


========================================
Contents of addons\virtual_joystick\test\player.gd:
========================================
  extends Sprite2D
  
  @export var speed : float = 100
  
  @export var joystick_left : VirtualJoystick
  
  @export var joystick_right : VirtualJoystick
  
  var move_vector := Vector2.ZERO
  
  func _process(delta: float) -> void:
  	## Movement using the joystick output:
  #	if joystick_left and joystick_left.is_pressed:
  #		position += joystick_left.output * speed * delta
  	
  	## Movement using Input functions:
  	move_vector = Vector2.ZERO
  	move_vector = Input.get_vector("ui_left","ui_right","ui_up","ui_down")
  	position += move_vector * speed * delta
  	
  	# Rotation:
  	if joystick_right and joystick_right.is_pressed:
  		rotation = joystick_right.output.angle()

========================================
Contents of addons\virtual_joystick\virtual_joystick.gd:
========================================
  class_name VirtualJoystick
  
  extends Control
  
  ## A simple virtual joystick for touchscreens, with useful options.
  ## Github: https://github.com/MarcoFazioRandom/Virtual-Joystick-Godot
  
  # EXPORTED VARIABLE
  
  ## The color of the button when the joystick is pressed.
  @export var pressed_color := Color.GRAY
  
  ## If the input is inside this range, the output is zero.
  @export_range(0, 200, 1) var deadzone_size : float = 10
  
  ## The max distance the tip can reach.
  @export_range(0, 500, 1) var clampzone_size : float = 75
  
  enum Joystick_mode {
  	FIXED, ## The joystick doesn't move.
  	DYNAMIC, ## Every time the joystick area is pressed, the joystick position is set on the touched position.
  	FOLLOWING ## When the finger moves outside the joystick area, the joystick will follow it.
  }
  
  ## If the joystick stays in the same position or appears on the touched position when touch is started
  @export var joystick_mode := Joystick_mode.FIXED
  
  enum Visibility_mode {
  	ALWAYS, ## Always visible
  	TOUCHSCREEN_ONLY, ## Visible on touch screens only
  	WHEN_TOUCHED ## Visible only when touched
  }
  
  ## If the joystick is always visible, or is shown only if there is a touchscreen
  @export var visibility_mode := Visibility_mode.ALWAYS
  
  ## If true, the joystick uses Input Actions (Project -> Project Settings -> Input Map)
  @export var use_input_actions := true
  
  @export var action_left := "ui_left"
  @export var action_right := "ui_right"
  @export var action_up := "ui_up"
  @export var action_down := "ui_down"
  
  # PUBLIC VARIABLES
  
  ## If the joystick is receiving inputs.
  var is_pressed := false
  
  # The joystick output.
  var output := Vector2.ZERO
  
  # PRIVATE VARIABLES
  
  var _touch_index : int = -1
  
  @onready var _base := $Base
  @onready var _tip := $Base/Tip
  
  @onready var _base_default_position : Vector2 = _base.position
  @onready var _tip_default_position : Vector2 = _tip.position
  
  @onready var _default_color : Color = _tip.modulate
  
  # FUNCTIONS
  
  func _ready() -> void:
  	if ProjectSettings.get_setting("input_devices/pointing/emulate_mouse_from_touch"):
  		printerr("The Project Setting 'emulate_mouse_from_touch' should be set to False")
  	if not ProjectSettings.get_setting("input_devices/pointing/emulate_touch_from_mouse"):
  		printerr("The Project Setting 'emulate_touch_from_mouse' should be set to True")
  	
  	if not DisplayServer.is_touchscreen_available() and visibility_mode == Visibility_mode.TOUCHSCREEN_ONLY :
  		hide()
  	
  	if visibility_mode == Visibility_mode.WHEN_TOUCHED:
  		hide()
  
  func _input(event: InputEvent) -> void:
  	if event is InputEventScreenTouch:
  		if event.pressed:
  			if _is_point_inside_joystick_area(event.position) and _touch_index == -1:
  				if joystick_mode == Joystick_mode.DYNAMIC or joystick_mode == Joystick_mode.FOLLOWING or (joystick_mode == Joystick_mode.FIXED and _is_point_inside_base(event.position)):
  					if joystick_mode == Joystick_mode.DYNAMIC or joystick_mode == Joystick_mode.FOLLOWING:
  						_move_base(event.position)
  					if visibility_mode == Visibility_mode.WHEN_TOUCHED:
  						show()
  					_touch_index = event.index
  					_tip.modulate = pressed_color
  					_update_joystick(event.position)
  					get_viewport().set_input_as_handled()
  		elif event.index == _touch_index:
  			_reset()
  			if visibility_mode == Visibility_mode.WHEN_TOUCHED:
  				hide()
  			get_viewport().set_input_as_handled()
  	elif event is InputEventScreenDrag:
  		if event.index == _touch_index:
  			_update_joystick(event.position)
  			get_viewport().set_input_as_handled()
  
  func _move_base(new_position: Vector2) -> void:
  	_base.global_position = new_position - _base.pivot_offset * get_global_transform_with_canvas().get_scale()
  
  func _move_tip(new_position: Vector2) -> void:
  	_tip.global_position = new_position - _tip.pivot_offset * _base.get_global_transform_with_canvas().get_scale()
  
  func _is_point_inside_joystick_area(point: Vector2) -> bool:
  	var x: bool = point.x >= global_position.x and point.x <= global_position.x + (size.x * get_global_transform_with_canvas().get_scale().x)
  	var y: bool = point.y >= global_position.y and point.y <= global_position.y + (size.y * get_global_transform_with_canvas().get_scale().y)
  	return x and y
  
  func _get_base_radius() -> Vector2:
  	return _base.size * _base.get_global_transform_with_canvas().get_scale() / 2
  
  func _is_point_inside_base(point: Vector2) -> bool:
  	var _base_radius = _get_base_radius()
  	var center : Vector2 = _base.global_position + _base_radius
  	var vector : Vector2 = point - center
  	if vector.length_squared() <= _base_radius.x * _base_radius.x:
  		return true
  	else:
  		return false
  
  func _update_joystick(touch_position: Vector2) -> void:
  	var _base_radius = _get_base_radius()
  	var center : Vector2 = _base.global_position + _base_radius
  	var vector : Vector2 = touch_position - center
  	vector = vector.limit_length(clampzone_size)
  	
  	if joystick_mode == Joystick_mode.FOLLOWING and touch_position.distance_to(center) > clampzone_size:
  		_move_base(touch_position - vector)
  	
  	_move_tip(center + vector)
  	
  	if vector.length_squared() > deadzone_size * deadzone_size:
  		is_pressed = true
  		output = (vector - (vector.normalized() * deadzone_size)) / (clampzone_size - deadzone_size)
  	else:
  		is_pressed = false
  		output = Vector2.ZERO
  	
  	if use_input_actions:
  		if output.x > 0:
  			Input.action_release(action_left)
  			Input.action_press(action_right, output.x)
  		else:
  			Input.action_release(action_right)
  			Input.action_press(action_left, -output.x)
  
  		if output.y > 0:
  			Input.action_release(action_up)
  			Input.action_press(action_down, output.y)
  		else:
  			Input.action_release(action_down)
  			Input.action_press(action_up, -output.y)
  
  func _reset():
  	is_pressed = false
  	output = Vector2.ZERO
  	_touch_index = -1
  	_tip.modulate = _default_color
  	_base.position = _base_default_position
  	_tip.position = _tip_default_position
  	if use_input_actions:
  		for action in [action_left, action_right, action_down, action_up]:
  			Input.action_release(action)

========================================
Contents of addons\virtual_joystick\virtual_joystick_instantiator.gd:
========================================
  @tool
  extends Control
  
  var scene
  
  func _enter_tree():
  	scene = preload("res://addons/virtual_joystick/virtual_joystick_scene.tscn").instantiate()
  	add_child(scene)
  	
  	if ProjectSettings.get_setting("input_devices/pointing/emulate_mouse_from_touch"):
  		printerr("The Project Setting 'emulate_mouse_from_touch' should be set to False")
  	if not ProjectSettings.get_setting("input_devices/pointing/emulate_touch_from_mouse"):
  		printerr("The Project Setting 'emulate_touch_from_mouse' should be set to True")
  
  
  func _exit_tree():
  	scene.free()

========================================
Contents of addons\virtual_joystick\virtual_joystick_plugin.gd:
========================================
  @tool
  extends EditorPlugin
  
  
  func _enter_tree():
  	add_custom_type("Virtual Joystick", "Control", preload("virtual_joystick_instantiator.gd"), preload("virtual_joystick_icon.png"))
  
  
  func _exit_tree():
  	remove_custom_type("Virtual Joystick")

========================================
Contents of project.godot:
========================================
  ; Engine configuration file.
  ; It's best edited using the editor UI and not directly,
  ; since the parameters that go here are not all obvious.
  ;
  ; Format:
  ;   [section] ; section goes between []
  ;   param=value ; assign values to parameters
  
  config_version=5
  
  [application]
  
  config/name="The Little Saint"
  run/main_scene="uid://dh7t0n4nj8w4o"
  config/features=PackedStringArray("4.4", "Mobile")
  
  [autoload]
  
  Constants="*res://scripts/autoload/constants.gd"
  AudioManager="*res://scripts/autoload/audio_manager.gd"
  SaveManager="*res://scripts/autoload/save_manager.gd"
  Global="*res://scripts/autoload/game_manager.gd"
  PopupManager="*res://scripts/ui/dialogs/popup_manager.gd"
  
  [display]
  
  window/size/viewport_width=1280
  window/size/viewport_height=720
  window/stretch/mode="canvas_items"
  window/stretch/aspect="expand"
  
  [input]
  
  right={
  "deadzone": 0.5,
  "events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":68,"key_label":0,"unicode":100,"location":0,"echo":false,"script":null)
  , Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194321,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
  ]
  }
  left={
  "deadzone": 0.5,
  "events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":65,"key_label":0,"unicode":97,"location":0,"echo":false,"script":null)
  , Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194319,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
  ]
  }
  up={
  "deadzone": 0.5,
  "events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":87,"key_label":0,"unicode":119,"location":0,"echo":false,"script":null)
  , Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194320,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
  ]
  }
  down={
  "deadzone": 0.5,
  "events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":83,"key_label":0,"unicode":115,"location":0,"echo":false,"script":null)
  , Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194322,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
  ]
  }
  attack={
  "deadzone": 0.5,
  "events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":85,"physical_keycode":0,"key_label":0,"unicode":117,"location":0,"echo":false,"script":null)
  ]
  }
  defend={
  "deadzone": 0.5,
  "events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":73,"physical_keycode":0,"key_label":0,"unicode":105,"location":0,"echo":false,"script":null)
  ]
  }
  Menu={
  "deadzone": 0.5,
  "events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194305,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
  ]
  }
  
  [input_devices]
  
  pointing/emulate_touch_from_mouse=true
  pointing/emulate_mouse_from_touch=false
  
  [layer_names]
  
  2d_physics/layer_1="player"
  2d_physics/layer_2="ports"
  2d_physics/layer_3="item"
  2d_physics/layer_4="enemy"
  
  [physics]
  
  2d/physics_engine="GodotPhysics2D"
  
  [rendering]
  
  textures/canvas_textures/default_texture_filter=0
  renderer/rendering_method="mobile"
  environment/defaults/default_clear_color=Color(0, 0, 0, 1)

========================================
Contents of scenes\levels\adventure_mode\main_map.gd:
========================================
  extends Node2D
  # Assuming this script is on your MainMap scene
  
  @onready var room1 = preload("res://scenes/levels/adventure_mode/enemy_room_1.tscn")
  @onready var room2 = preload("res://scenes/levels/adventure_mode/enemy_room_2.tscn")
  @onready var start_room = preload("res://scenes/levels/adventure_mode/Starting_Room.tscn")
  @onready var end_room = preload("res://scenes/levels/adventure_mode/End_Room.tscn")
  @onready var ExitBlock = preload("res://scenes/levels/adventure_mode/exit_block.tscn")
  
  # Constants for room dimensions and number of rooms
  const ROOM_WIDTH = 960  # Room width
  const ROOM_HEIGHT = 480  # Room height
  const NUM_ROOMS = 4  # Number of rooms
  const HIGH_EXIT_OFFSET = 320  # Vertical offset for high exit (move up)
  const LOW_EXIT_OFFSET = -320  # Vertical offset for low exit (move down)
  
  func _ready():
  	var previous_position = Vector2(960, 0)  # Starting position for the first room
  	var start_room_instance = start_room.instantiate()
  	add_child(start_room_instance)
  	var end = (NUM_ROOMS-1)
  	for i in range(NUM_ROOMS):
  		# Randomly choose room1 or room2
  		var room_instance
  		var room_instance2
  		var room_instance3 = ExitBlock.instantiate()
  		var room_instance4 = ExitBlock.instantiate()
  		var room_instance6 = ExitBlock.instantiate()
  		var room_instance5 = ExitBlock.instantiate()
  		var randRoom = randi() % 9  # Random int from 0 to 8
  		var rand1 = randi() % 2  # Random 0 or 1
  		print("  Random 0 or 1: ", rand1)
  		print("  Random 0 to 8: ", randRoom)
  		if i == end:
  				room_instance = end_room.instantiate()
  		else:
  			if randi() % 2 == 0:
  				room_instance = room1.instantiate()
  			else:
  				room_instance = room2.instantiate()
  			
  		# Set the position of the current room
  		room_instance.position = previous_position
  		add_child(room_instance)
  		print("Room ", i + 1, " placed at position: ", previous_position)
  		
  		previous_position.x += ROOM_WIDTH
  		# 50% chance to place vertically (upward or downward)
  		if randi() % 2 == 0:  # 50% chance to go upwards (high exit)
  			previous_position.y += HIGH_EXIT_OFFSET
  			var previous_position5 = previous_position + Vector2(0,-32)
  			room_instance5.position = previous_position5
  			add_child(room_instance5)
  			var rand_0_or_1 = randi() % 2  # Random 0 or 1
  			if rand_0_or_1 == 1:
  					var previous_position2 = previous_position + Vector2(0, -640)
  					var previous_position3 = previous_position2 + Vector2(0,-253)
  					var previous_position4 = previous_position2 + Vector2(928,-253)
  					var previous_position6 = previous_position2 + Vector2(928,67)
  					room_instance3.position = previous_position3
  					room_instance4.position = previous_position4
  					room_instance6.position = previous_position6
  					if randi() % 2 == 0:
  						room_instance2 = room1.instantiate()
  					else:
  						room_instance2 = room2.instantiate()
  					room_instance2.position = previous_position2
  					add_child(room_instance4)
  					add_child(room_instance3)
  					add_child(room_instance2)
  			else:
  					var previous_position3 = previous_position + Vector2(-32, -672)
  					room_instance3.position = previous_position3
  					add_child(room_instance3)
  		else:  # 50% chance to go downwards (low exit)
  			previous_position.y += LOW_EXIT_OFFSET
  			var previous_position5 = previous_position + Vector2(0,-352)
  			room_instance5.position = previous_position5
  			add_child(room_instance5)
  			var rand_0_or_1 = randi() % 2  # Random 0 or 1
  			if rand_0_or_1 == 1:
  					var previous_position2 = previous_position + Vector2(0, 640)
  					var previous_position3 = previous_position2 + Vector2(0, -32)
  					var previous_position4 = previous_position2 + Vector2(928, -32)
  					var previous_position6 = previous_position2 + Vector2(928, -352)
  					room_instance3.position = previous_position3
  					room_instance4.position = previous_position4
  					room_instance6.position = previous_position6
  					if randi() % 2 == 0:
  						room_instance2 = room1.instantiate()
  					else:
  						room_instance2 = room2.instantiate()
  					room_instance2.position = previous_position2
  					add_child(room_instance4)
  					add_child(room_instance3)
  					add_child(room_instance2)
  			else:
  					var previous_position3 = previous_position + Vector2(-32,288 )
  					room_instance3.position = previous_position3
  					add_child(room_instance3)

========================================
Contents of scripts\autoload\audio_manager.gd:
========================================
  extends Node
  
  ## Enhanced Audio Manager for managing all game audio
  ## Supports categories, multiple channels, and persistent settings
  
  # Audio bus names
  const MASTER_BUS = "Master"
  const MUSIC_BUS = "Music"
  const SFX_BUS = "SFX"
  const UI_BUS = "UI"
  const VOICE_BUS = "Voice"
  
  # Volume ranges
  const MIN_VOLUME_DB = -80.0
  const MAX_VOLUME_DB = 6.0
  
  # Fade durations
  const DEFAULT_FADE_DURATION = 1.0
  
  # Music properties
  @export var autoplay: bool = false
  @export var default_music_stream: AudioStream = null
  @export var default_music_volume: float = 0.0  # in dB
  @export var crossfade_duration: float = 1.0
  
  # Current audio tracks
  var current_music_track: AudioStream = null
  var current_music_player: AudioStreamPlayer = null
  var next_music_player: AudioStreamPlayer = null  # For crossfading
  
  # Audio player pools
  var music_players = []
  var sfx_players = {}
  var ui_players = []
  var voice_players = []
  
  # Audio stream cache
  var stream_cache = {}
  
  # Signals
  signal music_started(track_name)
  signal music_stopped()
  signal music_finished()
  signal music_faded(from_volume, to_volume)
  signal sfx_played(sfx_name)
  
  func _ready():
  	# Ensure we have all the audio buses we need
  	_setup_audio_buses()
  	
  	# Create initial audio players
  	_setup_audio_players()
  	
  	# Load settings
  	_load_audio_settings()
  	
  	# Autoplay if enabled
  	if autoplay and default_music_stream:
  		play_music(default_music_stream)
  
  func _setup_audio_buses():
  	# Create buses if they don't exist
  	var bus_names = [MASTER_BUS, MUSIC_BUS, SFX_BUS, UI_BUS, VOICE_BUS]
  	
  	for i in range(AudioServer.get_bus_count()):
  		var bus_name = AudioServer.get_bus_name(i)
  		bus_names.erase(bus_name)
  	
  	# Add any missing buses
  	for bus_name in bus_names:
  		if bus_name != MASTER_BUS:  # Master is always bus 0
  			var idx = AudioServer.bus_count
  			AudioServer.add_bus(idx)
  			AudioServer.set_bus_name(idx, bus_name)
  			
  			# Connect to Master
  			AudioServer.set_bus_send(idx, MASTER_BUS)
  
  func _setup_audio_players():
  	# Create music players for crossfading
  	for i in range(2):
  		var player = AudioStreamPlayer.new()
  		player.name = "MusicPlayer_" + str(i)
  		player.bus = MUSIC_BUS
  		player.volume_db = default_music_volume
  		add_child(player)
  		music_players.append(player)
  		player.finished.connect(_on_music_finished.bind(player))
  	
  	# Set current music player
  	current_music_player = music_players[0]
  
  # Music playback control
  func play_music(stream: AudioStream, fade_in: float = DEFAULT_FADE_DURATION, volume_db: float = default_music_volume, loop: bool = true):
  	if not stream:
  		push_error("Cannot play null music stream")
  		return
  	
  	# Check if this is the current track
  	if current_music_track == stream and current_music_player.playing:
  		return
  	
  	# Choose which player to use
  	var player
  	if current_music_player and current_music_player.playing:
  		# Crossfade
  		player = _get_unused_music_player()
  		next_music_player = player
  	else:
  		# No crossfade needed
  		player = current_music_player if current_music_player else music_players[0]
  	
  	# Set up the player
  	player.stream = stream
  	player.volume_db = MIN_VOLUME_DB if fade_in > 0 else volume_db
  	player.play()
  	
  	# Apply loop setting
  	if stream is AudioStreamMP3 or stream is AudioStreamOggVorbis:
  		stream.loop = loop
  	
  	# Store current track
  	current_music_track = stream
  	
  	# Handle fade in if needed
  	if fade_in > 0:
  		var tween = create_tween()
  		tween.tween_property(player, "volume_db", volume_db, fade_in)
  		
  		# If we're crossfading, fade out the old track
  		if current_music_player and current_music_player != player and current_music_player.playing:
  			var fade_out_tween = create_tween()
  			fade_out_tween.tween_property(current_music_player, "volume_db", MIN_VOLUME_DB, fade_in)
  			fade_out_tween.tween_callback(func(): current_music_player.stop())
  	
  	# Update current player reference
  	current_music_player = player
  	
  	var track_name = stream.resource_path.get_file()
  	emit_signal("music_started", track_name)
  
  func stop_music(fade_out: float = DEFAULT_FADE_DURATION):
  	if not current_music_player or not current_music_player.playing:
  		return
  	
  	if fade_out > 0:
  		var tween = create_tween()
  		tween.tween_property(current_music_player, "volume_db", MIN_VOLUME_DB, fade_out)
  		tween.tween_callback(func(): 
  			current_music_player.stop()
  			current_music_track = null
  			emit_signal("music_stopped")
  		)
  	else:
  		current_music_player.stop()
  		current_music_track = null
  		emit_signal("music_stopped")
  
  func pause_music():
  	if current_music_player and current_music_player.playing:
  		current_music_player.stream_paused = true
  
  func resume_music():
  	if current_music_player and current_music_player.stream_paused:
  		current_music_player.stream_paused = false
  
  func is_music_playing() -> bool:
  	return current_music_player != null and current_music_player.playing
  
  func fade_music(to_volume_db: float, duration: float = DEFAULT_FADE_DURATION):
  	if not current_music_player or not current_music_player.playing:
  		return
  	
  	var from_volume = current_music_player.volume_db
  	
  	var tween = create_tween()
  	tween.tween_property(current_music_player, "volume_db", to_volume_db, duration)
  	tween.tween_callback(func(): emit_signal("music_faded", from_volume, to_volume_db))
  
  # SFX playback
  func play_sfx(stream: AudioStream, volume_db: float = 0.0, pitch_scale: float = 1.0, bus: String = SFX_BUS) -> AudioStreamPlayer:
  	if not stream:
  		push_error("Cannot play null SFX stream")
  		return null
  	
  	# Get or create an available SFX player
  	var sfx_player = _get_available_sfx_player(bus)
  	
  	# Set up the player
  	sfx_player.stream = stream
  	sfx_player.volume_db = volume_db
  	sfx_player.pitch_scale = pitch_scale
  	sfx_player.play()
  	
  	var sfx_name = stream.resource_path.get_file()
  	emit_signal("sfx_played", sfx_name)
  	
  	return sfx_player
  
  func play_sfx_at_position(stream: AudioStream, position: Vector2, volume_db: float = 0.0, 
  						pitch_scale: float = 1.0, bus: String = SFX_BUS, 
  						falloff: float = 1.0, max_distance: float = 2000) -> AudioStreamPlayer2D:
  	if not stream:
  		push_error("Cannot play positional SFX with null stream")
  		return null
  	
  	# Create a temporary 2D audio player
  	var sfx_player = AudioStreamPlayer2D.new()
  	sfx_player.name = "TempSFX2D_" + str(randi())
  	sfx_player.stream = stream
  	sfx_player.volume_db = volume_db
  	sfx_player.pitch_scale = pitch_scale
  	sfx_player.bus = bus
  	sfx_player.position = position
  	sfx_player.max_distance = max_distance
  	sfx_player.attenuation = falloff
  	
  	# Add to tree temporarily
  	add_child(sfx_player)
  	sfx_player.play()
  	
  	# Connect to finished to auto-remove
  	sfx_player.finished.connect(func(): sfx_player.queue_free())
  	
  	var sfx_name = stream.resource_path.get_file()
  	emit_signal("sfx_played", sfx_name)
  	
  	return sfx_player
  
  func play_ui_sound(stream: AudioStream, volume_db: float = 0.0) -> AudioStreamPlayer:
  	return play_sfx(stream, volume_db, 1.0, UI_BUS)
  
  func play_voice(stream: AudioStream, volume_db: float = 0.0) -> AudioStreamPlayer:
  	return play_sfx(stream, volume_db, 1.0, VOICE_BUS)
  
  # Volume control
  func set_volume(bus_name: String, volume_db: float) -> bool:
  	var bus_idx = AudioServer.get_bus_index(bus_name)
  	if bus_idx < 0:
  		push_error("Audio bus not found: " + bus_name)
  		return false
  	
  	var clamped_volume = clamp(volume_db, MIN_VOLUME_DB, MAX_VOLUME_DB)
  	AudioServer.set_bus_volume_db(bus_idx, clamped_volume)
  	return true
  
  func get_volume(bus_name: String) -> float:
  	var bus_idx = AudioServer.get_bus_index(bus_name)
  	if bus_idx < 0:
  		push_error("Audio bus not found: " + bus_name)
  		return 0.0
  	
  	return AudioServer.get_bus_volume_db(bus_idx)
  
  func set_mute(bus_name: String, mute: bool) -> bool:
  	var bus_idx = AudioServer.get_bus_index(bus_name)
  	if bus_idx < 0:
  		push_error("Audio bus not found: " + bus_name)
  		return false
  	
  	AudioServer.set_bus_mute(bus_idx, mute)
  	return true
  
  func is_muted(bus_name: String) -> bool:
  	var bus_idx = AudioServer.get_bus_index(bus_name)
  	if bus_idx < 0:
  		push_error("Audio bus not found: " + bus_name)
  		return false
  	
  	return AudioServer.is_bus_mute(bus_idx)
  
  # Stream loading helper
  func load_stream(path: String) -> AudioStream:
  	# Check cache first
  	if stream_cache.has(path):
  		return stream_cache[path]
  	
  	# Load the stream
  	var stream = load(path)
  	if stream is AudioStream:
  		stream_cache[path] = stream
  		return stream
  	
  	push_error("Failed to load audio stream: " + path)
  	return null
  
  # Preload a collection of audio streams
  func preload_streams(paths: Array) -> void:
  	for path in paths:
  		load_stream(path)
  
  # Save and load audio settings
  func save_audio_settings() -> bool:
  	var config = ConfigFile.new()
  	
  	# Save volumes
  	for bus_name in [MASTER_BUS, MUSIC_BUS, SFX_BUS, UI_BUS, VOICE_BUS]:
  		var bus_idx = AudioServer.get_bus_index(bus_name)
  		if bus_idx >= 0:
  			config.set_value("volume", bus_name, AudioServer.get_bus_volume_db(bus_idx))
  			config.set_value("mute", bus_name, AudioServer.is_bus_mute(bus_idx))
  	
  	# Save the config
  	var err = config.save("user://audio_settings.cfg")
  	return err == OK
  
  func _load_audio_settings() -> bool:
  	var config = ConfigFile.new()
  	var err = config.load("user://audio_settings.cfg")
  	
  	if err != OK:
  		# Create default settings
  		for bus_name in [MASTER_BUS, MUSIC_BUS, SFX_BUS, UI_BUS, VOICE_BUS]:
  			set_volume(bus_name, 0.0)
  			set_mute(bus_name, false)
  		return false
  	
  	# Load volumes
  	for bus_name in [MASTER_BUS, MUSIC_BUS, SFX_BUS, UI_BUS, VOICE_BUS]:
  		var volume = config.get_value("volume", bus_name, 0.0)
  		var muted = config.get_value("mute", bus_name, false)
  		
  		set_volume(bus_name, volume)
  		set_mute(bus_name, muted)
  	
  	return true
  
  # Private utility functions
  func _get_unused_music_player() -> AudioStreamPlayer:
  	for player in music_players:
  		if player != current_music_player or not player.playing:
  			return player
  	
  	# All players are in use, create a new one
  	var player = AudioStreamPlayer.new()
  	player.name = "MusicPlayer_" + str(music_players.size())
  	player.bus = MUSIC_BUS
  	add_child(player)
  	music_players.append(player)
  	player.finished.connect(_on_music_finished.bind(player))
  	
  	return player
  
  func _get_available_sfx_player(bus: String = SFX_BUS) -> AudioStreamPlayer:
  	# Check for existing player in the bus category
  	if not sfx_players.has(bus):
  		sfx_players[bus] = []
  	
  	var bus_players = sfx_players[bus]
  	
  	# Look for an available player
  	for player in bus_players:
  		if not player.playing:
  			return player
  	
  	# Create a new player
  	var player = AudioStreamPlayer.new()
  	player.name = "SFXPlayer_" + bus + "_" + str(bus_players.size())
  	player.bus = bus
  	add_child(player)
  	bus_players.append(player)
  	
  	return player
  
  func _on_music_finished(player):
  	if player == current_music_player:
  		emit_signal("music_finished")
  		
  		# Check if we have a looping track
  		if current_music_track:
  			var is_looping = false
  			if current_music_track is AudioStreamMP3 or current_music_track is AudioStreamOggVorbis:
  				is_looping = current_music_track.loop
  			
  			if is_looping:
  				# Restart the track
  				player.play()
  
  # Legacy API for backward compatibility
  func play_track(audio_stream: AudioStream):
  	play_music(audio_stream)
  
  func stop_track():
  	stop_music()
  
  func is_playing() -> bool:
  	return is_music_playing()

========================================
Contents of scripts\autoload\constants.gd:
========================================
  extends Node
  
  ## Global constants for The Little Saint game
  
  # Game States
  enum GameState {
  	MENU,           # In main menu
  	PLAYING,        # Actively playing
  	PAUSED,         # Game paused
  	GAME_OVER,      # Player died or level failed
  	CUTSCENE,       # In a cutscene
  	DIALOGUE,       # In dialogue
  	LOADING         # Loading screen
  }
  
  # Player Movement
  const PLAYER_DEFAULT_SPEED: float = 200.0
  const PLAYER_DEFAULT_JUMP_VELOCITY: float = -250.0
  const PLAYER_DEFAULT_FLY_VELOCITY: float = -150.0
  const PLAYER_DEFAULT_GRAVITY: float = 300.0
  const PLAYER_MAX_JUMPS: int = 2
  
  # Player Status
  const PLAYER_DEFAULT_MAX_HEALTH: float = 3.0
  const PLAYER_INVULNERABILITY_TIME: float = 1.0
  const PLAYER_DEFAULT_FLY_TIME: float = 4.0
  
  # File Paths
  const SETTINGS_FILE_PATH: String = "user://settings.cfg"
  const SAVE_FILE_PATH: String = "user://save_data.tres"
  const OUTFIT_FILE_PATH: String = "user://outfits.tres"
  const FAVORITES_FILE_PATH: String = "user://favorites.cfg"
  
  # Config Sections
  const SECTION_SETTINGS: String = "settings"
  const SECTION_PLAYER: String = "player"
  const SECTION_OUTFITS: String = "outfits"
  const SECTION_FAVORITES: String = "favorites"
  
  # Physics
  const DEFAULT_GRAVITY: float = 980.0
  
  # Animation
  const ANIMATION_IDLE: String = "idle"
  const ANIMATION_WALKING: String = "walking"
  const ANIMATION_ATTACK: String = "walking6"  # Current attack animation
  const ANIMATION_HURT: String = "hurt"
  const ANIMATION_DEATH: String = "dead"
  const ANIMATION_JUMP: String = "animation4"  # May need to be updated
  
  # Layers
  enum Layer {
  	PLAYER = 1,
  	PORTS = 2,
  	ITEM = 3,
  	ENEMY = 4
  }
  
  # Input Action Names
  const INPUT_RIGHT: String = "right"
  const INPUT_LEFT: String = "left"
  const INPUT_UP: String = "up"
  const INPUT_DOWN: String = "down"
  const INPUT_ATTACK: String = "attack"
  const INPUT_DEFEND: String = "defend"
  const INPUT_MENU: String = "Menu"
  
  # Scene paths
  const MAIN_MENU_SCENE: String = "res://scenes/ui/main_menu/main_menu.tscn"
  const ADVENTURE_LEVEL_SCENE: String = "res://scenes/levels/adventure_mode/adventure_level.tscn"
  const SETTINGS_MENU_SCENE: String = "res://scenes/ui/settings/settings_menu.tscn"
  const CUSTOMIZER_SCENE: String = "res://scenes/ui/character_customizer/customizer.tscn"
  const AUDIO_SETTINGS_SCENE: String = "res://scenes/ui/settings/audio_settings.tscn"
  
  # Debug
  const DEBUG_ENABLED: bool = false

========================================
Contents of scripts\autoload\game_manager.gd:
========================================
  extends Node
  
  ## Game Manager handles game state, scene transitions, and global events
  ## Serves as the central controller for the game
  
  # Game state
  var current_state: Constants.GameState = Constants.GameState.MENU
  var previous_state: Constants.GameState = Constants.GameState.MENU
  
  # Player reference
  var player = null
  
  # Current level
  var current_level: String = ""
  var current_level_node = null
  var next_level: String = ""
  
  # Game progress
  var collected_coins: int = 0
  var unlocked_levels: Array = []
  var completed_quests: Array = []
  
  # Resource preloading
  var resource_preloader = null
  var is_preloading: bool = false
  var preload_progress: float = 0.0
  
  # Events
  signal state_changed(new_state, old_state)
  signal level_started(level_name)
  signal level_completed(level_name)
  signal player_died()
  signal coin_collected(total_coins)
  signal game_saved()
  signal game_loaded()
  signal resources_loading_progress(progress, total)
  signal resources_loaded()
  
  # Initialization
  func _ready():
  	process_mode = Node.PROCESS_MODE_ALWAYS # Game manager should run even when paused
  	print("Game Manager initialized")
  	
  	# Initialize the resource preloader
  	resource_preloader = GameResourcePreloader.new()
  	resource_preloader.name = "GameResourcePreloader"
  	add_child(resource_preloader)
  	
  	# Connect resource preloader signals
  	resource_preloader.loading_progress.connect(_on_loading_progress)
  	resource_preloader.all_resources_loaded.connect(_on_all_resources_loaded)
  
  # State management
  func change_state(new_state: Constants.GameState) -> void:
  	if new_state == current_state:
  		return
  
  	previous_state = current_state
  	current_state = new_state
  
  	match new_state:
  		Constants.GameState.PAUSED:
  			get_tree().paused = true
  		Constants.GameState.PLAYING, Constants.GameState.MENU:
  			get_tree().paused = false
  		Constants.GameState.LOADING:
  			# Loading state is handled by the loading screen
  			pass
  
  	emit_signal("state_changed", current_state, previous_state)
  	print("Game state changed to: ", Constants.GameState.keys()[current_state])
  
  func is_state(state: Constants.GameState) -> bool:
  	return current_state == state
  
  func resume_previous_state() -> void:
  	change_state(previous_state)
  
  # Resource preloading
  func preload_resources_for_level(level_name: String) -> void:
  	if is_preloading:
  		push_warning("Already preloading resources!")
  		return
  	
  	# Enter loading state
  	change_state(Constants.GameState.LOADING)
  	is_preloading = true
  	preload_progress = 0.0
  	
  	# Start preloading
  	var success = resource_preloader.preload_level_resources(level_name)
  	if success:
  		resource_preloader.load_queued_resources()
  	else:
  		# No specific resources to preload, just continue
  		is_preloading = false
  		_finish_level_change()
  
  func _on_loading_progress(loaded: int, total: int) -> void:
  	preload_progress = float(loaded) / max(total, 1)
  	emit_signal("resources_loading_progress", loaded, total)
  
  func _on_all_resources_loaded() -> void:
  	is_preloading = false
  	emit_signal("resources_loaded")
  	
  	# Continue with level change if we were changing levels
  	if next_level != "":
  		_finish_level_change()
  
  # Scene management with preloading
  func change_scene(scene_path: String) -> void:
  	# Store the next level path
  	next_level = scene_path
  	
  	# Clear any popups or overlays
  	if PopupManager:
  		PopupManager.close_all_dialogs()
  	
  	# Store reference to current level if it's a level scene
  	if scene_path.begins_with("res://scenes/levels/"):
  		current_level = scene_path
  		
  		# Extract level name for preloading
  		var level_name = scene_path.get_file().get_basename()
  		preload_resources_for_level(level_name)
  	else:
  		# If it's not a level, just preload based on the scene name
  		var scene_name = scene_path.get_file().get_basename()
  		preload_resources_for_level(scene_name)
  
  func _finish_level_change() -> void:
  	if next_level.is_empty():
  		return
  	
  	# Actual scene change
  	get_tree().change_scene_to_file(next_level)
  	
  	# After scene change, set appropriate state
  	if next_level == Constants.MAIN_MENU_SCENE:
  		change_state(Constants.GameState.MENU)
  	elif next_level.begins_with("res://scenes/levels/"):
  		change_state(Constants.GameState.PLAYING)
  		emit_signal("level_started", next_level)
  	
  	# Clear next level
  	var loaded_level = next_level
  	next_level = ""
  	
  	# Unload resources from previous level if not needed
  	if resource_preloader and loaded_level != Constants.MAIN_MENU_SCENE:
  		# Keep UI resources but unload previous level resources
  		resource_preloader.unload_unused_resources(["ui", "audio"])
  
  # Level management
  func restart_level() -> void:
  	if current_level:
  		change_scene(current_level)
  
  func go_to_main_menu() -> void:
  	change_scene(Constants.MAIN_MENU_SCENE)
  
  # Save and load through SaveManager
  func save_game() -> void:
  	if SaveManager:
  		SaveManager.save_game()
  		emit_signal("game_saved")
  
  func load_game() -> void:
  	if SaveManager:
  		SaveManager.load_game()
  		emit_signal("game_loaded")
  
  # Player-related functions
  func register_player(player_instance) -> void:
  	player = player_instance
  	print("Player registered with Game Manager")
  
  func collect_coin() -> void:
  	collected_coins += 1
  	emit_signal("coin_collected", collected_coins)
  
  func player_death() -> void:
  	change_state(Constants.GameState.GAME_OVER)
  	emit_signal("player_died")
  
  # Event handling
  func notify_level_completed() -> void:
  	if current_level and not unlocked_levels.has(current_level):
  		unlocked_levels.append(current_level)
  	emit_signal("level_completed", current_level)
  
  # Debug helpers
  func toggle_debug_mode() -> void:
  	get_node("/root").get_tree().get_root().set_debug_enabled(not get_node("/root").get_tree().get_root().is_debug_enabled())
  
  # Resource management helpers
  func get_resource(type: String, id: String) -> Resource:
  	if resource_preloader:
  		return resource_preloader.get_resource(type, id)
  	return null
  
  func has_resource(type: String, id: String) -> bool:
  	if resource_preloader:
  		return resource_preloader.has_resource(type, id)
  	return false
  
  func load_resource(path: String, type: String = "other", id: String = "") -> Resource:
  	if resource_preloader:
  		return resource_preloader.load_resource(path, type, id)
  	return ResourceLoader.load(path)
  
  # System functions
  func quit_game() -> void:
  	save_game()
  	get_tree().quit()
  
  # Input handling
  func _input(event: InputEvent) -> void:
  	if event.is_action_pressed(Constants.INPUT_MENU):
  		if current_state == Constants.GameState.PLAYING:
  			change_state(Constants.GameState.PAUSED)
  		elif current_state == Constants.GameState.PAUSED:
  			change_state(Constants.GameState.PLAYING)
  
  func _notification(what):
  	if what == NOTIFICATION_WM_CLOSE_REQUEST:
  		# Save game before allowing close
  		print("Game closing - saving data...")
  		SaveManager.save_game()
  		SaveManager.save_settings()
  		get_tree().quit()

========================================
Contents of scripts\autoload\save_manager.gd:
========================================
  extends Node
  
  ## SaveManager handles all game saving and loading operations
  ## It manages player data, settings, and outfit configurations
  ## Now with auto-save functionality
  
  # Current save data instance
  var current_save_data: SaveData = null
  
  # Auto-save settings
  var auto_save_enabled: bool = false
  var auto_save_interval: float = 300.0  # Default: save every 5 minutes
  var time_since_last_save: float = 0.0
  
  # Signals
  signal save_completed(success, message)
  signal load_completed(success, message)
  signal settings_saved(success)
  signal settings_loaded(success)
  signal outfit_saved(success, outfit_name)
  signal auto_save_performed(success)
  
  # Initialize on ready
  func _ready():
  	print("Save Manager initialized")
  	# Create default save data at startup
  	current_save_data = SaveData.new()
  	# Load settings immediately on startup
  	load_settings()
  	# Initialize auto-save
  	_init_auto_save()
  
  func _process(delta):
  	# Handle auto-save timer
  	if auto_save_enabled:
  		time_since_last_save += delta
  		
  		if time_since_last_save >= auto_save_interval:
  			perform_auto_save()
  
  # Initialize auto-save
  func _init_auto_save():
  	# Default is disabled
  	auto_save_enabled = false
  	time_since_last_save = 0.0
  	# Ensure process is called
  	set_process(true)
  
  # Toggle auto-save functionality
  func toggle_auto_save(enabled: bool) -> void:
  	auto_save_enabled = enabled
  	time_since_last_save = 0.0
  	print("Auto-save " + ("enabled" if enabled else "disabled"))
  
  # Set auto-save interval (in seconds)
  func set_auto_save_interval(interval: float) -> void:
  	if interval < 10.0:
  		push_warning("Auto-save interval set too low (< 10 seconds). Using 10 seconds.")
  		auto_save_interval = 10.0
  	else:
  		auto_save_interval = interval
  
  # Perform an auto-save operation
  func perform_auto_save() -> bool:
  	print("Performing auto-save...")
  	time_since_last_save = 0.0
  	
  	var success = save_game()
  	emit_signal("auto_save_performed", success)
  	return success
  
  # Save the full game state
  func save_game() -> bool:
  	if not current_save_data:
  		current_save_data = SaveData.new()
  
  	# Update data before saving
  	_update_save_data()
  
  	# Try to save the resource file
  	var dir = DirAccess.open("user://")
  	if not dir:
  		push_error("Failed to open user:// directory")
  		emit_signal("save_completed", false, "Failed to access save directory")
  		return false
  
  	var success = ResourceSaver.save(current_save_data, Constants.SAVE_FILE_PATH)
  
  	if success == OK:
  		print("Game saved successfully to: ", Constants.SAVE_FILE_PATH)
  		emit_signal("save_completed", true, "Game saved successfully")
  		return true
  	else:
  		push_error("Failed to save game. Error code: " + str(success))
  		emit_signal("save_completed", false, "Failed to save game")
  		return false
  
  # Load the full game state
  func load_game() -> bool:
  	if ResourceLoader.exists(Constants.SAVE_FILE_PATH):
  		var loaded_data = ResourceLoader.load(Constants.SAVE_FILE_PATH)
  
  		if loaded_data is SaveData:
  			current_save_data = loaded_data
  
  			# Apply loaded data to game state
  			_apply_save_data()
  
  			print("Game loaded successfully from: ", Constants.SAVE_FILE_PATH)
  			emit_signal("load_completed", true, "Game loaded successfully")
  			return true
  		else:
  			push_error("Loaded resource is not a SaveData resource")
  	else:
  		print("No save file found at: ", Constants.SAVE_FILE_PATH)
  
  	# If we get here, loading failed
  	emit_signal("load_completed", false, "No save data found or data corrupted")
  	return false
  
  # Update the save data with current game state
  func _update_save_data() -> void:
  	# Get player reference from GameManager
  	var player = null
  	if get_node_or_null("/root/Global") and get_node("/root/Global").player:
  		player = get_node("/root/Global").player
  
  	if player:
  		# Update player data
  		current_save_data.health = player.hud.lifes if player.hud else Constants.PLAYER_DEFAULT_MAX_HEALTH
  		current_save_data.coins = player.hud.coins if player.hud else 0
  		current_save_data.player_position = player.global_position
  		current_save_data.current_level = get_node("/root/Global").current_level
  
  		# Update player stats and settings - Use constants rather than hardcoded values
  		current_save_data.player_speed = player.SPEED
  		current_save_data.player_jump_velocity = player.JUMP_VELOCITY
  		current_save_data.player_fly_velocity = player.FLY_VELOCITY
  		current_save_data.player_gravity = player.GRAVITY
  		current_save_data.player_mode = player.mode
  		current_save_data.player_passed_fly_time = player.passed_fly_time
  		current_save_data.player_jump_counter = player.jump_counter
  		current_save_data.player_ready_for_jump = player.ready_for_jump
  		current_save_data.player_allowed_jumps = player.allowed_jumps
  
  		# Get outfit data - ensure we have a deep copy
  		if player.player_outfit:
  			current_save_data.player_outfit = player.player_outfit.duplicate(true)
  
  		# Update timestamp
  		current_save_data.save_date = Time.get_datetime_string_from_system(false, true)
  
  	# Add global game state
  	if get_node_or_null("/root/Global"):
  		current_save_data.collected_coins = get_node("/root/Global").collected_coins
  		current_save_data.unlocked_levels = get_node("/root/Global").unlocked_levels.duplicate()
  		current_save_data.completed_quests = get_node("/root/Global").completed_quests.duplicate()
  		
  	# Update playtime
  	current_save_data.playtime_seconds += 1  # Add at least 1 second each time
  
  # Apply loaded save data to the game
  func _apply_save_data() -> void:
  	# Update GameManager data
  	if get_node_or_null("/root/Global"):
  		get_node("/root/Global").collected_coins = current_save_data.collected_coins
  		get_node("/root/Global").unlocked_levels = current_save_data.unlocked_levels.duplicate()
  		get_node("/root/Global").completed_quests = current_save_data.completed_quests.duplicate()
  		get_node("/root/Global").current_level = current_save_data.current_level
  
  	# We will apply player-specific data when the player is instantiated
  	# or when we change to the appropriate scene
  
  # Apply save data to the player (called when player is instantiated)
  func apply_save_data_to_player(player) -> void:
  	if not current_save_data or not player:
  		return
  
  	# Set player stats from constants if they're not valid in save data
  	player.SPEED = current_save_data.player_speed if current_save_data.player_speed > 0 else Constants.PLAYER_DEFAULT_SPEED
  	player.JUMP_VELOCITY = current_save_data.player_jump_velocity if current_save_data.player_jump_velocity < 0 else Constants.PLAYER_DEFAULT_JUMP_VELOCITY
  	player.FLY_VELOCITY = current_save_data.player_fly_velocity if current_save_data.player_fly_velocity < 0 else Constants.PLAYER_DEFAULT_FLY_VELOCITY
  	player.GRAVITY = current_save_data.player_gravity if current_save_data.player_gravity > 0 else Constants.PLAYER_DEFAULT_GRAVITY
  	player.mode = current_save_data.player_mode
  	player.passed_fly_time = current_save_data.player_passed_fly_time
  	player.jump_counter = current_save_data.player_jump_counter
  	player.ready_for_jump = current_save_data.player_ready_for_jump
  	player.allowed_jumps = current_save_data.player_allowed_jumps
  
  	# Apply outfit if available
  	if current_save_data.player_outfit:
  		player.player_outfit = current_save_data.player_outfit.duplicate(true)
  
  		# If there's a resource-based outfit, update that too
  		if player.current_outfit:
  			player.current_outfit.from_dictionary(current_save_data.player_outfit)
  
  	# Set HUD data if available
  	if player.hud:
  		player.hud.lifes = current_save_data.health
  		player.hud.coins = current_save_data.coins
  		player.hud.load_hearts()
  		player.hud._update_coin_display()
  
  # Settings management - Using player defaults from Constants
  func save_settings() -> bool:
  	var config = ConfigFile.new()
  
  	# Get player for current settings
  	var player = null
  	if get_node_or_null("/root/Global") and get_node("/root/Global").player:
  		player = get_node("/root/Global").player
  
  	# Save constant values if player doesn't exist, otherwise save player values
  	if player:
  		# Save player settings
  		config.set_value(Constants.SECTION_SETTINGS, "speed", player.SPEED)
  		config.set_value(Constants.SECTION_SETTINGS, "jump_velocity", player.JUMP_VELOCITY)
  		config.set_value(Constants.SECTION_SETTINGS, "fly_velocity", player.FLY_VELOCITY)
  		config.set_value(Constants.SECTION_SETTINGS, "gravity", player.GRAVITY)
  		config.set_value(Constants.SECTION_SETTINGS, "mode", player.mode)
  		config.set_value(Constants.SECTION_SETTINGS, "passed_fly_time", player.passed_fly_time)
  		config.set_value(Constants.SECTION_SETTINGS, "jump_counter", player.jump_counter)
  		config.set_value(Constants.SECTION_SETTINGS, "ready_for_jump", player.ready_for_jump)
  		config.set_value(Constants.SECTION_SETTINGS, "allowed_jumps", player.allowed_jumps)
  
  		# Save outfit
  		if player.player_outfit:
  			config.set_value(Constants.SECTION_SETTINGS, "outfit", player.player_outfit)
  	else:
  		# If no player exists, use default constants or current save data
  		config.set_value(Constants.SECTION_SETTINGS, "speed", current_save_data.player_speed)
  		config.set_value(Constants.SECTION_SETTINGS, "jump_velocity", current_save_data.player_jump_velocity)
  		config.set_value(Constants.SECTION_SETTINGS, "fly_velocity", current_save_data.player_fly_velocity)
  		config.set_value(Constants.SECTION_SETTINGS, "gravity", current_save_data.player_gravity)
  		config.set_value(Constants.SECTION_SETTINGS, "mode", current_save_data.player_mode)
  		config.set_value(Constants.SECTION_SETTINGS, "passed_fly_time", current_save_data.player_passed_fly_time)
  		config.set_value(Constants.SECTION_SETTINGS, "jump_counter", current_save_data.player_jump_counter)
  		config.set_value(Constants.SECTION_SETTINGS, "ready_for_jump", current_save_data.player_ready_for_jump)
  		config.set_value(Constants.SECTION_SETTINGS, "allowed_jumps", current_save_data.player_allowed_jumps)
  
  		# Save outfit
  		if current_save_data.player_outfit:
  			config.set_value(Constants.SECTION_SETTINGS, "outfit", current_save_data.player_outfit)
  
  	# Save audio settings
  	var master_bus_idx = AudioServer.get_bus_index("Master")
  	config.set_value(Constants.SECTION_SETTINGS, "master_volume", AudioServer.get_bus_volume_db(master_bus_idx))
  	config.set_value(Constants.SECTION_SETTINGS, "master_mute", AudioServer.is_bus_mute(master_bus_idx))
  	
  	# Save auto-save settings
  	config.set_value(Constants.SECTION_SETTINGS, "auto_save_enabled", auto_save_enabled)
  	config.set_value(Constants.SECTION_SETTINGS, "auto_save_interval", auto_save_interval)
  
  	# Save the config
  	var err = config.save(Constants.SETTINGS_FILE_PATH)
  	var success = (err == OK)
  
  	if success:
  		print("Settings saved successfully to: ", Constants.SETTINGS_FILE_PATH)
  	else:
  		push_error("Failed to save settings. Error code: " + str(err))
  
  	emit_signal("settings_saved", success)
  	return success
  
  func load_settings() -> bool:
  	var config = ConfigFile.new()
  	var err = config.load(Constants.SETTINGS_FILE_PATH)
  
  	if err != OK:
  		print("No settings file found or error loading settings. Using defaults.")
  		emit_signal("settings_loaded", false)
  		return false
  
  	print("Loading settings from: ", Constants.SETTINGS_FILE_PATH)
  
  	# Create default save data if not already created
  	if not current_save_data:
  		current_save_data = SaveData.new()
  
  	# Load settings into current_save_data for future use
  	current_save_data.player_speed = config.get_value(Constants.SECTION_SETTINGS, "speed", Constants.PLAYER_DEFAULT_SPEED)
  	current_save_data.player_jump_velocity = config.get_value(Constants.SECTION_SETTINGS, "jump_velocity", Constants.PLAYER_DEFAULT_JUMP_VELOCITY)
  	current_save_data.player_fly_velocity = config.get_value(Constants.SECTION_SETTINGS, "fly_velocity", Constants.PLAYER_DEFAULT_FLY_VELOCITY)
  	current_save_data.player_gravity = config.get_value(Constants.SECTION_SETTINGS, "gravity", Constants.PLAYER_DEFAULT_GRAVITY)
  	current_save_data.player_mode = config.get_value(Constants.SECTION_SETTINGS, "mode", "normal")
  	current_save_data.player_passed_fly_time = config.get_value(Constants.SECTION_SETTINGS, "passed_fly_time", 0.0)
  	current_save_data.player_jump_counter = config.get_value(Constants.SECTION_SETTINGS, "jump_counter", 0)
  	current_save_data.player_ready_for_jump = config.get_value(Constants.SECTION_SETTINGS, "ready_for_jump", true)
  	current_save_data.player_allowed_jumps = config.get_value(Constants.SECTION_SETTINGS, "allowed_jumps", Constants.PLAYER_MAX_JUMPS)
  
  	# Load outfit
  	var saved_outfit = config.get_value(Constants.SECTION_SETTINGS, "outfit", null)
  	if saved_outfit:
  		current_save_data.player_outfit = saved_outfit.duplicate(true)
  
  	# Apply audio settings
  	var master_bus_idx = AudioServer.get_bus_index("Master")
  	var volume = config.get_value(Constants.SECTION_SETTINGS, "master_volume", 0.0)
  	var mute = config.get_value(Constants.SECTION_SETTINGS, "master_mute", false)
  
  	AudioServer.set_bus_volume_db(master_bus_idx, volume)
  	AudioServer.set_bus_mute(master_bus_idx, mute)
  	
  	# Load auto-save settings
  	auto_save_enabled = config.get_value(Constants.SECTION_SETTINGS, "auto_save_enabled", false)
  	auto_save_interval = config.get_value(Constants.SECTION_SETTINGS, "auto_save_interval", 300.0)
  
  	print("Settings loaded successfully")
  	emit_signal("settings_loaded", true)
  	return true
  
  # Outfit management
  func save_outfit(outfit_config: Dictionary, name: String = "") -> bool:
  	var favorites = load_favorite_outfits()
  
  	if name.is_empty():
  		name = "Outfit " + str(favorites.size() + 1)
  
  	favorites[name] = outfit_config
  
  	var config = ConfigFile.new()
  	config.set_value(Constants.SECTION_FAVORITES, "outfits", favorites)
  	var err = config.save(Constants.FAVORITES_FILE_PATH)
  	var success = (err == OK)
  
  	if success:
  		print("Outfit saved successfully: ", name)
  	else:
  		push_error("Failed to save outfit. Error code: " + str(err))
  
  	emit_signal("outfit_saved", success, name)
  	return success
  
  func load_favorite_outfits() -> Dictionary:
  	var config = ConfigFile.new()
  	var err = config.load(Constants.FAVORITES_FILE_PATH)
  
  	if err == OK:
  		return config.get_value(Constants.SECTION_FAVORITES, "outfits", {})
  	else:
  		return {}
  
  func delete_outfit(name: String) -> bool:
  	var favorites = load_favorite_outfits()
  
  	if not favorites.has(name):
  		return false
  
  	favorites.erase(name)
  
  	var config = ConfigFile.new()
  	config.set_value(Constants.SECTION_FAVORITES, "outfits", favorites)
  	var err = config.save(Constants.FAVORITES_FILE_PATH)
  
  	return (err == OK)
  
  # Helper functions
  func save_exists() -> bool:
  	return ResourceLoader.exists(Constants.SAVE_FILE_PATH)
  
  func clear_save_data() -> void:
  	var dir = DirAccess.open("user://")
  	if dir:
  		if dir.file_exists(Constants.SAVE_FILE_PATH):
  			dir.remove(Constants.SAVE_FILE_PATH)
  			print("Save data cleared")
  	current_save_data = SaveData.new()
  
  # Return a fresh instance of SaveData
  func create_new_save_data() -> SaveData:
  	return SaveData.new()
  
  # Helper method for other scripts to add callback function when save completes
  func connect_save_completed(target: Object, method: String, binds: Array = [], flags: int = 0) -> void:
  	if not is_connected("save_completed", Callable(target, method)):
  		connect("save_completed", Callable(target, method).bind(binds), flags)
  
  # Called when player instance is being initialized
  func _on_player_ready(player) -> void:
  	call_deferred("apply_save_data_to_player", player)

========================================
Contents of scripts\core\base_classes\base_enemy.gd:
========================================
  class_name BaseEnemy
  extends CharacterBody2D
  
  ## Base class for all enemies in the game
  
  # Enemy properties
  @export var max_health: float = 100.0
  @export var speed: float = 80.0
  @export var chase_speed: float = 100.0
  @export var attack_damage: float = 10.0
  @export var attack_cooldown: float = 1.0
  @export var detection_radius: float = 200.0
  @export var attack_radius: float = 75.0
  @export var patrol_distance: float = 100.0 # Added common patrol distance
  
  # Current state
  var current_health: float
  var is_dead: bool = false
  var is_chasing: bool = false
  var is_attacking: bool = false
  var can_attack: bool = true
  var target = null
  var is_invulnerable: bool = false # Added for more functionality
  
  # Nodes (to be assigned by extending classes)
  var animated_sprite: AnimatedSprite2D
  var collision_shape: CollisionShape2D
  var hud = null
  
  # Emitted when enemy dies
  signal enemy_died(enemy)
  # Emitted when enemy takes damage
  signal enemy_damaged(enemy, amount)
  # Added signal for attack completed
  signal attack_completed(enemy)
  
  func _ready():
  	# Initialize health
  	current_health = max_health
  	
  	# Set default animation
  	if animated_sprite:
  		animated_sprite.play("idle")
  	
  	# Get HUD reference (if needed)
  	hud = get_node_or_null("../../HUD")
  	
  	# Debug output to confirm initialization
  	print(name + " initialized with " + str(current_health) + " health")
  
  func _physics_process(delta):
  	# Apply gravity
  	if not is_on_floor():
  		velocity.y += calculate_gravity() * delta
  	
  	# Core movement
  	move_and_slide()
  
  func calculate_gravity():
  	# Can be overridden by child classes
  	return ProjectSettings.get_setting("physics/2d/default_gravity")
  
  # Make sure BaseEnemy has this crucial method:
  func take_damage(amount):
  	if is_dead or is_invulnerable:
  		return
  		
  	current_health -= amount
  	emit_signal("enemy_damaged", self, amount)
  	
  	print(name + " took " + str(amount) + " damage, health: " + str(current_health))
  	
  	if current_health <= 0:
  		die()
  	else:
  		play_animation("hurt")
  		# Try transitioning to Hurt state if there's a state machine
  		if has_node("StateMachine"):
  			$StateMachine.change_state("Hurt")
  			
  func die():
  	if is_dead:
  		return
  		
  	is_dead = true
  	is_chasing = false
  	is_attacking = false
  	
  	print(name + " died")
  	
  	# Disable collision
  	if collision_shape:
  		collision_shape.set_deferred("disabled", true)
  	
  	# Play death animation
  	play_animation("death")
  	
  	# Emit signal
  	emit_signal("enemy_died", self)
  	
  	# Wait for animation to finish before removing
  	if animated_sprite and animated_sprite.sprite_frames.has_animation("death"):
  		await animated_sprite.animation_finished
  	else:
  		await get_tree().create_timer(1.0).timeout
  	
  	queue_free()
  
  func play_animation(anim_name: String):
  	if animated_sprite and animated_sprite.sprite_frames and animated_sprite.sprite_frames.has_animation(anim_name):
  		animated_sprite.play(anim_name)
  	else:
  		# Fallback to idle if animation doesn't exist
  		if animated_sprite and animated_sprite.sprite_frames and animated_sprite.sprite_frames.has_animation("idle"):
  			animated_sprite.play("idle")
  			# Log missing animation for debugging
  			print("Animation not found for " + name + ": " + anim_name + ", using idle instead")
  
  func chase_target(target_node):
  	if is_dead or is_attacking:
  		return
  		
  	target = target_node
  	is_chasing = true
  	
  	var direction = (target.global_position - global_position).normalized()
  	
  	# Face the correct direction
  	if animated_sprite:
  		animated_sprite.flip_h = direction.x > 0
  	
  	# Set velocity
  	velocity.x = direction.x * (chase_speed if is_chasing else speed)
  	
  	# Play animation
  	play_animation("walk")
  
  func stop_chase():
  	is_chasing = false
  	velocity.x = 0
  	play_animation("idle")
  	target = null
  
  func attack():
  	if is_dead or not can_attack or not target:
  		return
  		
  	is_attacking = true
  	can_attack = false
  	velocity.x = 0
  	
  	play_animation("attack")
  	
  	# Wait for animation to finish
  	if animated_sprite:
  		await animated_sprite.animation_finished
  	else:
  		await get_tree().create_timer(attack_cooldown * 0.5).timeout
  	
  	is_attacking = false
  	emit_signal("attack_completed", self)
  	
  	# Start cooldown
  	await get_tree().create_timer(attack_cooldown).timeout
  	can_attack = true
  
  # Helper method to check if player is in attack range
  func is_target_in_attack_range() -> bool:
  	if not target:
  		return false
  	
  	var distance = global_position.distance_to(target.global_position)
  	return distance <= attack_radius
  
  # Helper method to check if player is in detection range
  func is_target_in_detection_range() -> bool:
  	if not target:
  		return false
  	
  	var distance = global_position.distance_to(target.global_position)
  	return distance <= detection_radius
  
  # Called when a player or other entity enters detection radius
  func _on_detection_radius_body_entered(body):
  	if body.name == "Player" and not is_dead:
  		chase_target(body)
  
  # Called when a player or other entity exits detection radius
  func _on_detection_radius_body_exited(body):
  	if body.name == "Player":
  		stop_chase()
  
  # Called when a player enters attack range
  func _on_attack_radius_body_entered(body):
  	if body.name == "Player" and not is_dead:
  		is_chasing = false
  		attack()
  
  # Called when a player exits attack range
  func _on_attack_radius_body_exited(body):
  	if body.name == "Player" and not is_dead:
  		is_chasing = true

========================================
Contents of scripts\core\base_classes\base_power_up.gd:
========================================
  class_name BasePowerUp
  extends Area2D
  
  ## Base class for all power-ups in the game
  
  # Power-up properties
  @export var power_up_name: String = "Power Up"
  @export var description: String = "A mysterious power-up"
  @export var icon_texture: Texture2D
  @export var effect_duration: float = 0.0  # 0 means permanent effect
  @export var play_animation: bool = true
  @export var destroy_on_pickup: bool = true
  
  # Animation
  @export var bounce_height: float = 5.0
  @export var bounce_speed: float = 2.0
  @export var rotation_speed: float = 0.0
  
  # Internal variables
  var original_position: Vector2
  var animation_time: float = 0.0
  var player_ref = null
  
  # Signals
  signal power_up_collected(power_up, player)
  signal power_up_effect_started(power_up, player)
  signal power_up_effect_ended(power_up, player)
  
  func _ready():
  	original_position = global_position
  	
  	# Set up collision
  	if not has_node("CollisionShape2D"):
  		push_error("Power-up " + name + " has no CollisionShape2D!")
  	
  	# Set up sprite/animation if enabled
  	if play_animation and has_node("Sprite2D"):
  		var sprite = get_node("Sprite2D")
  		if icon_texture:
  			sprite.texture = icon_texture
  	
  	# Connect signals
  	body_entered.connect(_on_power_up_body_entered)
  
  func _process(delta):
  	if play_animation:
  		animate_power_up(delta)
  
  func animate_power_up(delta):
  	animation_time += delta
  	
  	# Bouncing animation
  	if bounce_height > 0:
  		var bounce_offset = sin(animation_time * bounce_speed) * bounce_height
  		global_position.y = original_position.y + bounce_offset
  	
  	# Rotation animation
  	if rotation_speed > 0 and has_node("Sprite2D"):
  		var sprite = get_node("Sprite2D")
  		sprite.rotation += rotation_speed * delta
  
  func _on_power_up_body_entered(body):
  	if body.is_in_group("Player") or body.name == "Player":
  		collect_power_up(body)
  
  func collect_power_up(player):
  	# Store reference to player
  	player_ref = player
  	
  	# Disable collision
  	set_collision_mask_value(1, false)
  	
  	# Emit collected signal
  	emit_signal("power_up_collected", self, player)
  	
  	# Play collection animation if available
  	if has_node("AnimationPlayer"):
  		var anim_player = get_node("AnimationPlayer")
  		if anim_player.has_animation("collect"):
  			anim_player.play("collect")
  			await anim_player.animation_finished
  		
  	# Apply effect
  	apply_effect(player)
  	
  	# Destroy if set
  	if destroy_on_pickup:
  		queue_free()
  
  func apply_effect(player):
  	# Base implementation just emits signal
  	# Override in child classes to implement specific effects
  	emit_signal("power_up_effect_started", self, player)
  	
  	# If temporary effect, setup timer to end effect
  	if effect_duration > 0:
  		await get_tree().create_timer(effect_duration).timeout
  		remove_effect(player)
  
  func remove_effect(player):
  	# Override in child classes to implement specific effect removal
  	emit_signal("power_up_effect_ended", self, player)
  
  # Optional methods for child classes to implement
  func get_effect_description() -> String:
  	return description
  
  func get_icon() -> Texture2D:
  	return icon_texture

========================================
Contents of scripts\core\base_classes\base_projectile.gd:
========================================
  class_name BaseProjectile
  extends CharacterBody2D
  
  ## Verbesserte Basisklasse für alle Projektile im Spiel
  ## Unterstützt objekt-pooling, verschiedene Flugbahnen und Kollisionseffekte
  
  # Projektil-Eigenschaften
  @export var speed: float = 150.0
  @export var damage: float = 0.25  # Entspricht 25 vor Skalierung
  @export var lifetime: float = 5.0  # Zeit bis zur automatischen Zerstörung
  @export var gravity_affected: bool = false  # Ob das Projektil von der Schwerkraft beeinflusst wird
  @export var bounce: bool = false  # Ob das Projektil abprallen kann
  @export var bounce_factor: float = 0.5  # Wie viel Geschwindigkeit beim Abprallen erhalten bleibt
  @export var penetration: bool = false  # Ob das Projektil mehrere Ziele durchdringen kann
  @export var max_penetrations: int = 0  # Max. Anzahl an Durchdringungen (0 = keine Begrenzung)
  @export var hit_effect_scene: PackedScene  # Effekt bei Treffer
  @export var trail_effect: bool = false  # Ob ein Bewegungspfad angezeigt werden soll
  
  # Interne Variablen
  var direction: Vector2 = Vector2.ZERO
  var source_node = null  # Wer hat das Projektil abgefeuert
  var spawn_position: Vector2
  var spawn_rotation: float
  var time_alive: float = 0.0
  var has_hit: bool = false
  var is_from_pool: bool = false  # Ob dieses Projektil aus einem Pool stammt
  var penetration_count: int = 0  # Anzahl der durchdrungenen Ziele
  
  # Für Bewegungspfade/Partikel
  var trail: Line2D = null
  var particles: GPUParticles2D = null
  
  # Signale
  signal projectile_hit(projectile, target, hit_position)
  signal projectile_expired(projectile)
  signal projectile_bounce(projectile, collision_point, collision_normal)
  
  func _ready():
  	# Starte Lebenszeit-Timer
  	if lifetime > 0:
  		get_tree().create_timer(lifetime).timeout.connect(_on_lifetime_expired)
  	
  	# Richte Animation ein, falls vorhanden
  	var animated_sprite = get_node_or_null("AnimatedSprite2D")
  	if animated_sprite and animated_sprite.sprite_frames.has_animation("flying"):
  		animated_sprite.play("flying")
  	
  	# Erstelle Bewegungspfad, falls aktiviert
  	if trail_effect:
  		_setup_trail()
  
  func _physics_process(delta):
  	time_alive += delta
  	
  	# Schwerkraft anwenden, falls aktiviert
  	if gravity_affected:
  		velocity.y += ProjectSettings.get_setting("physics/2d/default_gravity") * delta
  	
  	# Bewege das Projektil
  	var collision = move_and_collide(velocity * delta)
  	
  	# Aktualisiere Trail, falls vorhanden
  	if trail:
  		trail.add_point(position)
  		# Begrenze Länge des Trails
  		while trail.get_point_count() > 20:
  			trail.remove_point(0)
  	
  	# Verarbeite Kollision
  	if collision and not has_hit:
  		_on_collision(collision)
  
  # Initialisiert das Projektil mit Richtung und Startposition
  func setup(dir: Vector2, spawn_pos: Vector2, spawn_rot: float = 0.0, source = null):
  	direction = dir.normalized()
  	spawn_position = spawn_pos
  	spawn_rotation = spawn_rot
  	source_node = source
  	
  	# Setze Startposition und -rotation
  	global_position = spawn_position
  	global_rotation = spawn_rotation
  	
  	# Setze Geschwindigkeit
  	velocity = direction * speed
  	
  	# Setze Status zurück
  	has_hit = false
  	time_alive = 0.0
  	penetration_count = 0
  	
  	return self  # Für Method-Chaining
  
  # Erstellt einen visuellen Trail für das Projektil
  func _setup_trail():
  	trail = Line2D.new()
  	trail.name = "Trail"
  	trail.width = 3.0
  	trail.default_color = Color(1, 0.7, 0.2, 0.5)  # Anpassen je nach Projektil
  	add_child(trail)
  
  # Verarbeitet Kollisionen
  func _on_collision(collision):
  	var collider = collision.get_collider()
  	
  	# Prüfe auf Abprallen
  	if bounce and not (collider.is_in_group("player") or collider.is_in_group("enemy")):
  		var reflection = collision.get_remainder().bounce(collision.get_normal())
  		velocity = velocity.bounce(collision.get_normal()) * bounce_factor
  		global_position += reflection
  		
  		emit_signal("projectile_bounce", self, collision.get_position(), collision.get_normal())
  		_spawn_bounce_effect(collision.get_position(), collision.get_normal())
  		return
  	
  	# Setze Trefferflag, wenn nicht durchdringend
  	if not penetration:
  		has_hit = true
  	else:
  		penetration_count += 1
  		if max_penetrations > 0 and penetration_count >= max_penetrations:
  			has_hit = true
  	
  	# Verarbeite verschiedene Kollisionstypen
  	if collider.is_in_group("player") and source_node != collider:
  		_on_hit_player(collider, collision.get_position())
  	elif collider.is_in_group("enemy") and source_node != collider:
  		_on_hit_enemy(collider, collision.get_position())
  	else:
  		_on_hit_environment(collider, collision.get_position())
  	
  	# Wenn wir nicht durchdringen oder das Limit erreicht ist, werden wir recycelt
  	if has_hit:
  		_recycle_or_free()
  
  # Bei Kollision mit Spieler
  func _on_hit_player(player, hit_position):
  	emit_signal("projectile_hit", self, player, hit_position)
  	
  	# Schaden anwenden basierend auf Damage System wenn verfügbar
  	var damage_system = get_node_or_null("/root/DamageSystem")
  	if damage_system and source_node:
  		damage_system.process_attack(source_node, player, damage * 100)  # Skalierung für DamageSystem
  	elif player.has_method("take_damage"):
  		player.take_damage(damage * 100)  # Skalierung für Player-Klasse
  	
  	# HUD aktualisieren, wenn verfügbar
  	var hud = get_node_or_null("../HUD") or get_tree().get_root().find_child("HUD", true, false)
  	if hud and hud.has_method("change_life"):
  		hud.change_life(-damage)  # Richtige Skalierung für HUD
  	
  	# Spawne Treffereffekt, wenn verfügbar
  	_spawn_hit_effect(hit_position)
  
  # Bei Kollision mit Feind
  func _on_hit_enemy(enemy, hit_position):
  	emit_signal("projectile_hit", self, enemy, hit_position)
  	
  	# Schaden anwenden
  	var damage_system = get_node_or_null("/root/DamageSystem")
  	if damage_system and source_node:
  		damage_system.process_attack(source_node, enemy, damage * 100)
  	elif enemy.has_method("take_damage"):
  		enemy.take_damage(damage * 100)
  	
  	# Spawne Treffereffekt, wenn verfügbar
  	_spawn_hit_effect(hit_position)
  
  # Bei Kollision mit Umgebung
  func _on_hit_environment(object, hit_position):
  	emit_signal("projectile_hit", self, object, hit_position)
  	
  	# Spawne Treffereffekt, wenn verfügbar
  	_spawn_hit_effect(hit_position)
  
  # Wenn die Lebenszeit abgelaufen ist
  func _on_lifetime_expired():
  	if not has_hit:
  		emit_signal("projectile_expired", self)
  		_recycle_or_free()
  
  # Spawnt den Treffereffekt
  func _spawn_hit_effect(hit_position):
  	if hit_effect_scene:
  		var effect = hit_effect_scene.instantiate()
  		effect.global_position = hit_position
  		get_tree().current_scene.add_child(effect)
  	else:
  		# Fallback, wenn keine Szene gesetzt ist
  		var sprite = get_node_or_null("AnimatedSprite2D")
  		if sprite and sprite.sprite_frames.has_animation("hit"):
  			# Physik-Prozess trennen
  			set_physics_process(false)
  			
  			# Bewegung stoppen
  			velocity = Vector2.ZERO
  			
  			# Hit-Animation abspielen
  			sprite.play("hit")
  			
  			# Warten auf Ende der Animation
  			await sprite.animation_finished
  
  # Spawnt einen Abpralleffekt
  func _spawn_bounce_effect(hit_position, normal):
  	# Vielleicht einfach ein paar kleine Partikel
  	var particles = CPUParticles2D.new()
  	particles.position = hit_position
  	particles.emitting = true
  	particles.one_shot = true
  	particles.amount = 5
  	particles.explosiveness = 1.0
  	particles.direction = Vector2(-normal.x, -normal.y)
  	particles.spread = 30.0
  	particles.initial_velocity_min = 20.0
  	particles.initial_velocity_max = 40.0
  	particles.lifetime = 0.3
  	get_tree().current_scene.add_child(particles)
  	
  	# Auto-Entfernung nach kurzer Zeit
  	await get_tree().create_timer(0.5).timeout
  	particles.queue_free()
  
  # Wenn von einem Object Pool gespawnt
  func _on_spawn_from_pool():
  	is_from_pool = true
  	visible = true
  	set_physics_process(true)
  	
  	# Status zurücksetzen
  	has_hit = false
  	time_alive = 0.0
  	penetration_count = 0
  	
  	# Trail zurücksetzen, falls vorhanden
  	if trail:
  		trail.clear_points()
  
  # Wenn zu einem Object Pool zurückgeführt
  func _on_recycle_to_pool():
  	# Status zurücksetzen
  	has_hit = false
  	time_alive = 0.0
  	velocity = Vector2.ZERO
  	source_node = null
  	penetration_count = 0
  	
  	# Trail zurücksetzen, falls vorhanden
  	if trail:
  		trail.clear_points()
  	
  	# Animation zurücksetzen, falls nötig
  	var sprite = get_node_or_null("AnimatedSprite2D")
  	if sprite and sprite.sprite_frames.has_animation("flying"):
  		sprite.play("flying")
  		sprite.frame = 0
  
  # Entweder zum Pool recyceln oder löschen basierend darauf, ob wir Pooling verwenden
  func _recycle_or_free():
  	if is_from_pool:
  		# Finde den Object Pool, der dieses Projektil besitzt
  		var pool = null
  		
  		# Zuerst prüfen, ob unsere Quelle einen Projektil-Pool hat
  		if source_node and source_node.has_node("ProjectilePool"):
  			pool = source_node.get_node("ProjectilePool")
  		
  		# Ansonsten im Scene-Root suchen
  		if not pool:
  			pool = get_tree().get_root().find_child("ProjectilePool", true, false)
  		
  		if pool and pool is ObjectPool:
  			# Zum Pool zurückgeben
  			pool.recycle(self)
  		else:
  			# Fallback zu queue_free
  			queue_free()
  	else:
  		# Nicht aus Pool, einfach löschen
  		queue_free()

========================================
Contents of scripts\core\base_classes\state_machine\state.gd:
========================================
  class_name State
  extends Node
  
  ## Base class for all states in a state machine
  
  # Reference to the state machine
  var state_machine: StateMachine = null
  
  # Reference to the owner node
  var owner_node: Node = null
  
  # State parameters (can be extended by child classes)
  var parameters: Dictionary = {}
  
  
  # Called when entering this state
  func enter():
  	pass
  
  # Called when exiting this state
  func exit():
  	pass
  
  # Called during _process
  func process(delta: float):
  	pass
  
  # Called during _physics_process
  func physics_process(delta: float):
  	pass
  
  # Called during _input
  func handle_input(event: InputEvent):
  	pass
  
  # Override this to determine the next state to transition to
  func get_next_state() -> String:
  	return ""
  
  # Utility functions that can be used by derived states
  
  # Check if a condition is true
  func condition_met(condition_name: String) -> bool:
  	if owner_node.has_method("check_condition"):
  		return owner_node.check_condition(condition_name)
  	return false
  
  # Get a value from the owner
  func get_owner_property(property_name: String):
  	if owner_node and property_name in owner_node:
  		return owner_node.get(property_name)
  	return null
  
  # Set a value on the owner
  func set_owner_property(property_name: String, value):
  	if owner_node and property_name in owner_node:
  		owner_node.set(property_name, value)
  
  # Helper to check if owner is on floor (for platformers)
  func is_on_floor() -> bool:
  	if owner_node.has_method("is_on_floor"):
  		return owner_node.is_on_floor()
  	return false
  
  # Helper to get owner velocity (for physics bodies)
  func get_velocity() -> Vector2:
  	if "velocity" in owner_node:
  		return owner_node.velocity
  	return Vector2.ZERO
  
  # Helper to set owner velocity (for physics bodies)
  func set_velocity(value: Vector2):
  	if "velocity" in owner_node:
  		owner_node.velocity = value
  
  # Helper to play animations
  func play_animation(anim_name: String):
  	if owner_node.has_method("play_animation"):
  		owner_node.play_animation(anim_name)
  	elif owner_node.has_node("AnimatedSprite2D"):
  		var sprite = owner_node.get_node("AnimatedSprite2D")
  		if sprite.sprite_frames.has_animation(anim_name):
  			sprite.play(anim_name)

========================================
Contents of scripts\core\base_classes\state_machine\state_machine.gd:
========================================
  class_name StateMachine
  extends Node
  
  ## A finite state machine implementation for Godot 4.x
  
  # Current active state
  var current_state: State = null
  
  # Dictionary of available states
  var states: Dictionary = {}
  
  # The owner node that this state machine controls
  var owner_node: Node = null
  
  # Debug mode flag
  @export var debug_mode: bool = true
  
  # Signal emitted when state changes
  signal state_changed(from_state, to_state)
  
  func _ready():
  	owner_node = get_parent()
  
  	# Register all child states
  	for child in get_children():
  		if child is State:
  			register_state(child)
  
  	# Initialize the first state
  	if states.size() > 0:
  		var initial_state = states.values()[0]
  		change_state(initial_state.name)
  
  func _process(delta):
  	if current_state != null:
  		# Call the current state's process method
  		current_state.process(delta)
  
  		# Check for state transitions
  		var next_state = current_state.get_next_state()
  		if next_state != null and next_state != "" and states.has(next_state):
  			change_state(next_state)
  
  func _physics_process(delta):
  	if current_state != null:
  		# Call the current state's physics_process method
  		current_state.physics_process(delta)
  
  func _input(event):
  	if current_state != null:
  		# Call the current state's input method
  		current_state.handle_input(event)
  
  func register_state(state: State):
  	# Add to states dictionary
  	states[state.name] = state
  
  	# Set the state machine reference
  	state.state_machine = self
  
  	# Set the owner reference
  	state.owner_node = owner_node
  	
  	# Specifically initialize player references for PlayerState instances
  	if state is PlayerState:
  		state.player = owner_node
  	
  	if debug_mode:
  		print("Registered state: ", state.name)
  
  func change_state(new_state_name: String):
  	if not states.has(new_state_name):
  		push_error("State '" + new_state_name + "' not found in state machine!")
  		return
  
  	var from_state = current_state.name if current_state else "None"
  
  	if current_state != null:
  		if debug_mode:
  			print("Exiting state: ", current_state.name)
  		current_state.exit()
  
  	var next_state = states[new_state_name]
  	current_state = next_state
  	
  	# Make sure the player reference is properly set before entering the state
  	if current_state is PlayerState and current_state.player == null:
  		current_state.player = owner_node
  
  	if debug_mode:
  		print("Entering state: ", current_state.name)
  
  	current_state.enter()
  
  	# Emit state change signal
  	emit_signal("state_changed", from_state, new_state_name)
  
  func get_current_state() -> String:
  	if current_state != null:
  		return current_state.name
  	return "None"
  
  # Add a new state at runtime
  func add_state(state: State):
  	register_state(state)
  
  # Remove a state at runtime
  func remove_state(state_name: String):
  	if states.has(state_name):
  		states.erase(state_name)
  	else:
  		push_error("Tried to remove non-existent state: " + state_name)

========================================
Contents of scripts\core\combat\damage_system.gd:
========================================
  class_name DamageSystem
  extends Node
  
  ## A centralized system for calculating and applying damage in the game
  
  # Damage types
  enum DamageType {
  	PHYSICAL,
  	MAGICAL,
  	TRUE      # Ignores defenses
  }
  
  # Hit types
  enum HitType {
  	NORMAL,
  	CRITICAL,
  	MISS
  }
  
  # Damage result structure
  class DamageResult:
  	var damage: float = 0
  	var hit_type: int = HitType.NORMAL
  	var damage_type: int = DamageType.PHYSICAL
  	var source = null
  	var target = null
  	
  	func _init(dmg: float, type: int = HitType.NORMAL, dmg_type: int = DamageType.PHYSICAL, src = null, tgt = null):
  		damage = dmg
  		hit_type = type
  		damage_type = dmg_type
  		source = src
  		target = tgt
  
  # Default critical hit modifier
  var critical_multiplier: float = 1.5
  # Base chance for a critical hit (0-1)
  var base_critical_chance: float = 0.1
  # Base chance to miss (0-1)
  var base_miss_chance: float = 0.05
  
  # Signal emitted when damage is calculated
  signal damage_calculated(result: DamageResult)
  # Signal emitted when damage is applied
  signal damage_applied(result: DamageResult)
  # Signal emitted when a lethal hit is dealt
  signal lethal_hit(target, source)
  
  ## Calculate raw damage based on attacker and defender stats
  func calculate_damage(attacker, defender, base_damage: float, damage_type: int = DamageType.PHYSICAL) -> DamageResult:
  	# Get attack power
  	var attack_power = base_damage
  	if attacker.has_method("get_attack_power"):
  		attack_power = attacker.get_attack_power()
  	elif "attack_damage" in attacker:
  		attack_power = attacker.attack_damage
  	
  	# Get defense
  	var defense = 0
  	if defender.has_method("get_defense"):
  		defense = defender.get_defense()
  	elif "defense" in defender:
  		defense = defender.defense
  	
  	# Determine hit type (miss, normal, critical)
  	var hit_type = HitType.NORMAL
  	var hit_chance = randf()
  	
  	# Check for miss
  	var miss_chance = base_miss_chance
  	if defender.has_method("get_dodge_chance"):
  		miss_chance += defender.get_dodge_chance()
  	
  	if hit_chance < miss_chance:
  		hit_type = HitType.MISS
  		attack_power = 0
  	else:
  		# Check for critical hit
  		var crit_chance = base_critical_chance
  		if attacker.has_method("get_critical_chance"):
  			crit_chance += attacker.get_critical_chance()
  			
  		if hit_chance > (1.0 - crit_chance):
  			hit_type = HitType.CRITICAL
  			attack_power *= critical_multiplier
  	
  	# Calculate damage based on type
  	var final_damage = attack_power
  	
  	match damage_type:
  		DamageType.PHYSICAL:
  			# Physical damage reduced by defense
  			final_damage = max(0, attack_power - defense)
  		DamageType.MAGICAL:
  			# Magical damage, different formula
  			var magic_defense = defense * 0.5  # Example: magic defense is half of physical
  			final_damage = max(0, attack_power - magic_defense)
  		DamageType.TRUE:
  			# True damage ignores defense
  			final_damage = attack_power
  	
  	# Create the damage result
  	var result = DamageResult.new(final_damage, hit_type, damage_type, attacker, defender)
  	
  	# Emit signal
  	emit_signal("damage_calculated", result)
  	
  	return result
  
  ## Apply calculated damage to the target
  func apply_damage(result: DamageResult) -> bool:
  	if result.hit_type == HitType.MISS:
  		# Missed attack
  		if result.target.has_method("on_damage_missed"):
  			result.target.on_damage_missed(result)
  		return false
  	
  	# Apply damage to the target
  	var was_lethal = false
  	
  	if result.target.has_method("take_damage"):
  		was_lethal = result.target.take_damage(result.damage)
  	elif "current_health" in result.target:
  		result.target.current_health -= result.damage
  		if result.target.current_health <= 0:
  			was_lethal = true
  	
  	# Emit the damage applied signal
  	emit_signal("damage_applied", result)
  	
  	# Handle lethal hit
  	if was_lethal:
  		emit_signal("lethal_hit", result.target, result.source)
  	
  	return was_lethal
  
  ## Process a direct attack from attacker to defender
  func process_attack(attacker, defender, base_damage: float, damage_type: int = DamageType.PHYSICAL) -> bool:
  	var result = calculate_damage(attacker, defender, base_damage, damage_type)
  	return apply_damage(result)
  
  ## Helper function to get the appropriate text for a hit type
  func get_hit_text(hit_type: int) -> String:
  	match hit_type:
  		HitType.MISS:
  			return "Miss"
  		HitType.CRITICAL:
  			return "Critical"
  		_:
  			return "Hit"

========================================
Contents of scripts\core\combat\hit_effect.gd:
========================================
  class_name HitEffect
  extends Node2D
  
  ## Visual and audio effects for combat hits
  ## Creates temporary visual effects at hit locations
  
  # Effect properties
  @export var lifetime: float = 0.5
  @export var scale_multiplier: float = 1.0
  @export var effect_color: Color = Color(1, 1, 1, 1)
  @export var hit_sound: AudioStream = null
  @export var hit_sound_volume: float = 0.0  # in dB
  
  # Effect type
  enum HitEffectType {
  	NORMAL,
  	CRITICAL,
  	BLOCK,
  	HEAL,
  	MAGIC
  }
  
  @export var effect_type: HitEffectType = HitEffectType.NORMAL
  
  # Animation properties
  @export var animation_speed: float = 1.0
  @export var sprite_frames: SpriteFrames = null
  
  # Animation node
  var animated_sprite: AnimatedSprite2D = null
  
  # Whether audio has been played
  var audio_played: bool = false
  
  # Signal when effect is finished
  signal effect_finished()
  
  # Initialize the hit effect
  func _ready():
  	# Create animated sprite if not already a child
  	if not has_node("AnimatedSprite2D"):
  		animated_sprite = AnimatedSprite2D.new()
  		animated_sprite.name = "AnimatedSprite2D"
  		add_child(animated_sprite)
  	else:
  		animated_sprite = $AnimatedSprite2D
  	
  	# Set up animation
  	if sprite_frames:
  		animated_sprite.sprite_frames = sprite_frames
  	
  	# Apply settings
  	animated_sprite.modulate = effect_color
  	scale = Vector2(scale_multiplier, scale_multiplier)
  	animated_sprite.speed_scale = animation_speed
  	
  	# Determine which animation to play
  	var anim_name = "normal" # Default animation
  	match effect_type:
  		HitEffectType.CRITICAL:
  			anim_name = "critical"
  		HitEffectType.BLOCK:
  			anim_name = "block"
  		HitEffectType.HEAL:
  			anim_name = "heal"
  		HitEffectType.MAGIC:
  			anim_name = "magic"
  	
  	# Check if animation exists
  	if animated_sprite.sprite_frames and animated_sprite.sprite_frames.has_animation(anim_name):
  		animated_sprite.play(anim_name)
  	else:
  		# Use first available animation
  		var animations = animated_sprite.sprite_frames.get_animation_names()
  		if animations.size() > 0:
  			animated_sprite.play(animations[0])
  	
  	# Play hit sound
  	if hit_sound and not audio_played:
  		var audio_player = AudioStreamPlayer.new()
  		audio_player.stream = hit_sound
  		audio_player.volume_db = hit_sound_volume
  		audio_player.name = "HitSound"
  		add_child(audio_player)
  		audio_player.play()
  		audio_player.finished.connect(func(): audio_player.queue_free())
  		audio_played = true
  	
  	# Connect to animation finished
  	animated_sprite.animation_finished.connect(_on_animation_finished)
  	
  	# Set up backup timeout
  	var timer = Timer.new()
  	timer.wait_time = lifetime
  	timer.one_shot = true
  	timer.name = "LifetimeTimer"
  	add_child(timer)
  	timer.timeout.connect(_on_timeout)
  	timer.start()
  
  # Process function for manual animation logic if needed
  func _process(delta):
  	# Add optional particle effects or additional animations
  	pass
  
  # Create and play a one-shot hit effect at a position
  static func create_hit_effect(
  	effect_scene: PackedScene,
  	position: Vector2,
  	type: HitEffectType = HitEffectType.NORMAL,
  	parent: Node = null
  ) -> HitEffect:
  	# Instance the effect
  	var effect_instance = effect_scene.instantiate()
  	
  	# Set effect properties
  	effect_instance.global_position = position
  	effect_instance.effect_type = type
  	
  	# Find parent to add to
  	var target_parent = parent
  	if not target_parent:
  		target_parent = Engine.get_main_loop().current_scene
  	
  	# Add to scene
  	target_parent.add_child(effect_instance)
  	
  	return effect_instance
  
  # Animation finished handler
  func _on_animation_finished():
  	queue_free()
  	emit_signal("effect_finished")
  
  # Backup timeout handler (in case animation doesn't finish)
  func _on_timeout():
  	queue_free()
  	emit_signal("effect_finished")
  
  # Apply a screen shake effect
  func apply_screen_shake(camera: Camera2D, intensity: float = 5.0, duration: float = 0.2) -> void:
  	if camera:
  		var original_offset = camera.offset
  		
  		# Create a tween for the shake
  		var tween = create_tween()
  		
  		# Add multiple shake steps
  		var shake_steps = 10
  		var time_per_step = duration / shake_steps
  		
  		for i in range(shake_steps):
  			var random_offset = Vector2(
  				randf_range(-intensity, intensity),
  				randf_range(-intensity, intensity)
  			)
  			
  			# Reduce intensity over time
  			random_offset *= 1.0 - (float(i) / shake_steps)
  			
  			tween.tween_property(camera, "offset", original_offset + random_offset, time_per_step)
  		
  		# Reset to original position
  		tween.tween_property(camera, "offset", original_offset, time_per_step)

========================================
Contents of scripts\core\enemies\ardit_enemy.gd:
========================================
  class_name ArditEnemy
  extends BaseEnemy
  
  ## Simple patrol enemy that walks back and forth
  
  @export var patrol_distance: float = 100.0
  @export var direction: int = 1  # 1 = right, -1 = left
  
  @onready var ray_cast_right: RayCast2D = $RayCastRight
  @onready var ray_cast_left: RayCast2D = $RayCastLeft
  
  var start_position: Vector2
  var is_patrolling: bool = true
  
  func _ready():
  	# Set base enemy properties
  	max_health = 50.0
  	speed = 60.0
  	chase_speed = 80.0
  	attack_damage = 15.0
  	attack_cooldown = 1.0
  	
  	# Set references
  	animated_sprite = $AnimatedSprite2D
  	collision_shape = $CollisionShape2D
  	
  	# Store starting position for patrol
  	start_position = global_position
  	
  	# Initialize raycasts if not already set
  	if not ray_cast_right:
  		ray_cast_right = $RayCastRight if has_node("RayCastRight") else null
  		
  	if not ray_cast_left:
  		ray_cast_left = $RayCastLeft if has_node("RayCastLeft") else null
  	
  	# Call parent ready method
  	super._ready()
  	
  	# Start patrol behavior
  	play_animation("walk")
  
  func _physics_process(delta):
  	# Call parent implementation for gravity and movement
  	super._physics_process(delta)
  	
  	# Handle patrol logic if not chasing or attacking
  	if is_patrolling and not is_chasing and not is_attacking and not is_dead:
  		patrol()
  
  func patrol():
  	# Check wall collisions
  	if ray_cast_right and ray_cast_right.is_colliding():
  		direction = -1
  		animated_sprite.flip_h = false
  	elif ray_cast_left and ray_cast_left.is_colliding():
  		direction = 1
  		animated_sprite.flip_h = true
  	
  	# Check patrol distance limits
  	if abs(global_position.x - start_position.x) > patrol_distance:
  		direction *= -1
  		animated_sprite.flip_h = direction > 0
  	
  	# Set movement velocity
  	velocity.x = direction * speed
  	
  	# Play walk animation
  	play_animation("walk")
  
  func chase_target(target_node):
  	# Stop patrolling when chasing
  	is_patrolling = false
  	
  	# Call parent implementation
  	super.chase_target(target_node)
  
  func stop_chase():
  	# Resume patrolling when chase ends
  	is_patrolling = true
  	
  	# Call parent implementation
  	super.stop_chase()
  
  # Overridden to properly handle player jumping on enemy
  func _on_top_checker_body_entered(body):
  	if body.name == "Player" and not is_dead:
  		# Player jumped on top, take damage
  		take_damage(current_health)  # Instant kill when jumped on
  		
  		# Give player an upward boost if it has the method
  		if body.has_method("bounce"):
  			body.bounce()
========================================
Contents of scripts\core\enemies\behaviors\attack_behavior.gd:
========================================
  class_name AttackBehavior
  extends Node
  
  ## A modular component for enemy attack behavior
  
  # Attack types
  enum AttackType {
  	MELEE,    # Close range attack
  	RANGED,   # Projectile attack
  	AREA      # Area of effect attack
  }
  
  # The type of attack
  @export var attack_type: AttackType = AttackType.MELEE
  # Base damage for the attack
  @export var base_damage: float = 10.0
  # Cooldown between attacks (seconds)
  @export var cooldown: float = 1.0
  # Range at which attack can be performed
  @export var attack_range: float = 50.0
  # For ranged attacks, the projectile scene
  @export var projectile_scene: PackedScene = null
  # For area attacks, the area shape
  @export var area_shape: Shape2D = null
  # For area attacks, the area size
  @export var area_size: Vector2 = Vector2(100, 100)
  # Animation to play when attacking
  @export var attack_animation: String = "attack"
  # Whether to face the target when attacking
  @export var face_target: bool = true
  # For ranged attacks, the spawn offset
  @export var projectile_spawn_offset: Vector2 = Vector2(0, 0)
  # Path to the animated sprite (if not direct child)
  @export var animated_sprite_path: String = "AnimatedSprite2D"
  # Whether this attack is currently available
  @export var can_attack: bool = true
  
  # Reference to the character this behavior belongs to
  var character = null
  # Current attack target
  var target = null
  # Current cooldown timer
  var cooldown_timer: float = 0.0
  # Reference to the damage system (optional)
  var damage_system = null
  
  # Signals
  signal attack_started(target)
  signal attack_finished(target, hit)
  signal attack_cooldown_started(time)
  signal attack_cooldown_finished()
  
  func _ready():
  	# Get the owner character (parent node)
  	character = get_parent()
  	
  	# Try to get damage system reference
  	damage_system = get_node_or_null("/root/DamageSystem")
  
  func _process(delta):
  	# Handle cooldown
  	if not can_attack:
  		cooldown_timer -= delta
  		if cooldown_timer <= 0:
  			can_attack = true
  			emit_signal("attack_cooldown_finished")
  
  ## Check if a target is in attack range
  func is_target_in_range(check_target) -> bool:
  	if not check_target:
  		return false
  	
  	var distance = character.global_position.distance_to(check_target.global_position)
  	return distance <= attack_range
  
  ## Set a new attack target
  func set_target(new_target):
  	target = new_target
  
  ## Perform an attack against the current target
  func attack() -> bool:
  	if not can_attack or not target:
  		return false
  	
  	if not is_target_in_range(target):
  		return false
  	
  	# Face the target if enabled
  	if face_target:
  		_face_target(target)
  	
  	# Play attack animation
  	if character.has_method("play_animation"):
  		character.play_animation(attack_animation)
  	elif character.has_node(animated_sprite_path):
  		var sprite = character.get_node(animated_sprite_path)
  		if sprite.has_method("play"):
  			sprite.play(attack_animation)
  	
  	emit_signal("attack_started", target)
  	
  	# Handle different attack types
  	var hit = false
  	
  	match attack_type:
  		AttackType.MELEE:
  			hit = _perform_melee_attack()
  		AttackType.RANGED:
  			hit = _perform_ranged_attack()
  		AttackType.AREA:
  			# This is a coroutine, so we need to use await
  			hit = await _perform_area_attack()
  	
  	# Start cooldown
  	can_attack = false
  	cooldown_timer = cooldown
  	emit_signal("attack_cooldown_started", cooldown)
  	
  	# Wait for animation to finish
  	if character.has_node(animated_sprite_path):
  		var sprite = character.get_node(animated_sprite_path)
  		await sprite.animation_finished
  	else:
  		await get_tree().create_timer(0.5).timeout
  	
  	emit_signal("attack_finished", target, hit)
  	return hit
  
  ## Perform a melee attack
  func _perform_melee_attack() -> bool:
  	# If we have a damage system, use it
  	if damage_system:
  		return damage_system.process_attack(character, target, base_damage)
  	
  	# Otherwise use direct damage application
  	if target.has_method("take_damage"):
  		target.take_damage(base_damage)
  		return true
  	elif "current_health" in target:
  		target.current_health -= base_damage
  		return true
  	
  	return false
  
  ## Perform a ranged attack by spawning a projectile
  func _perform_ranged_attack() -> bool:
  	if not projectile_scene:
  		push_error("Projectile scene is not set for ranged attack!")
  		return false
  	
  	# Get spawn position
  	var spawn_pos = character.global_position + projectile_spawn_offset
  	
  	# Get direction to target
  	var direction = (target.global_position - spawn_pos).normalized()
  	
  	# Check if we have an object pool
  	var projectile_pool = character.get_node_or_null("ProjectilePool")
  	
  	if projectile_pool and projectile_pool is ObjectPool:
  		# Get a projectile from the pool
  		var projectile = projectile_pool.get_object()
  		if projectile:
  			if projectile.has_method("setup"):
  				projectile.setup(direction, spawn_pos, character.global_rotation, character)
  			return true
  	else:
  		# Create a new projectile
  		var projectile = projectile_scene.instantiate()
  		get_tree().get_root().add_child(projectile)
  		
  		if projectile.has_method("setup"):
  			projectile.setup(direction, spawn_pos, character.global_rotation, character)
  		elif "direction" in projectile:
  			projectile.direction = direction
  			projectile.global_position = spawn_pos
  			projectile.source_node = character
  		
  		return true
  	
  	return false
  
  ## Perform an area attack affecting all targets in an area
  func _perform_area_attack() -> bool:
  	var hit_something = false
  	
  	# Create area for attack
  	var area = Area2D.new()
  	var collision_shape = CollisionShape2D.new()
  	
  	# Configure shape
  	if area_shape:
  		collision_shape.shape = area_shape
  	else:
  		# Default to rectangle
  		var rect_shape = RectangleShape2D.new()
  		rect_shape.size = area_size
  		collision_shape.shape = rect_shape
  	
  	area.add_child(collision_shape)
  	character.add_child(area)
  	
  	# Check for bodies in the area
  	await get_tree().process_frame
  	var bodies = area.get_overlapping_bodies()
  	
  	for body in bodies:
  		if body != character and body.is_in_group("damageable"):
  			# If we have a damage system, use it
  			if damage_system:
  				damage_system.process_attack(character, body, base_damage)
  			# Otherwise use direct damage application
  			elif body.has_method("take_damage"):
  				body.take_damage(base_damage)
  			elif "current_health" in body:
  				body.current_health -= base_damage
  			
  			hit_something = true
  	
  	# Clean up
  	area.queue_free()
  	return hit_something
  
  ## Face the character towards the target
  func _face_target(face_target):
  	if not face_target:
  		return
  	
  	var direction = (face_target.global_position - character.global_position).normalized()
  	
  	# Handle sprite flipping
  	var sprite = character.get_node_or_null(animated_sprite_path)
  	if sprite and "flip_h" in sprite:
  		sprite.flip_h = direction.x < 0

========================================
Contents of scripts\core\enemies\behaviors\chase_behavior.gd:
========================================
  class_name ChaseBehavior
  extends Node
  
  ## A modular component for enemy chase behavior
  
  # Reference to the character this behavior belongs to
  var character = null
  # The target being chased
  var target = null
  # Speed while chasing
  @export var chase_speed: float = 100.0
  # Maximum chase distance before giving up
  @export var max_chase_distance: float = 300.0
  # Minimum distance to maintain from target
  @export var min_distance: float = 10.0
  # Whether to use prediction for moving targets
  @export var use_prediction: bool = false
  # How far ahead to predict target movement (0-1)
  @export var prediction_factor: float = 0.5
  # Whether to check for line of sight
  @export var check_line_of_sight: bool = true
  # Collision layer to check for line of sight (walls, obstacles)
  @export_flags_2d_physics var line_of_sight_mask: int = 1
  # Animation to play while chasing
  @export var chase_animation: String = "walk"
  # Path to the animated sprite (if not direct child)
  @export var animated_sprite_path: String = "AnimatedSprite2D"
  # Whether the chase is currently active
  @export var is_active: bool = false
  
  # Last known position of the target
  var last_known_position: Vector2 = Vector2.ZERO
  # Direction to the target
  var chase_direction: Vector2 = Vector2.ZERO
  # Time spent chasing without line of sight
  var lost_sight_time: float = 0.0
  # Maximum time to chase without line of sight
  @export var max_lost_sight_time: float = 2.0
  
  # Signals
  signal chase_started(target)
  signal chase_ended()
  signal chase_target_reached(target)
  signal target_lost()
  signal line_of_sight_lost()
  signal line_of_sight_regained()
  
  func _ready():
  	# Get the owner character (parent node)
  	character = get_parent()
  
  func _physics_process(delta):
  	if not is_active or not target:
  		return
  	
  	if not is_instance_valid(target):
  		end_chase()
  		return
  	
  	# Get positions
  	var character_pos = character.global_position
  	var target_pos = target.global_position
  	
  	# Check max chase distance
  	var distance_to_target = character_pos.distance_to(target_pos)
  	if distance_to_target > max_chase_distance:
  		emit_signal("target_lost")
  		end_chase()
  		return
  	
  	# Check line of sight if needed
  	var has_line_of_sight = true
  	if check_line_of_sight:
  		has_line_of_sight = _check_line_of_sight(target)
  		
  		if not has_line_of_sight:
  			lost_sight_time += delta
  			if lost_sight_time > max_lost_sight_time:
  				emit_signal("target_lost")
  				end_chase()
  				return
  		else:
  			if lost_sight_time > 0:
  				emit_signal("line_of_sight_regained")
  			lost_sight_time = 0
  			last_known_position = target_pos
  	
  	# Calculate target position (with prediction if enabled)
  	var chase_target_pos = target_pos
  	if use_prediction and "velocity" in target and target.velocity.length() > 0:
  		chase_target_pos += target.velocity * prediction_factor
  	
  	# Calculate direction and distance
  	chase_direction = (chase_target_pos - character_pos).normalized()
  	
  	# Check if we've reached minimum distance
  	if distance_to_target <= min_distance:
  		emit_signal("chase_target_reached", target)
  		if "velocity" in character:
  			character.velocity.x = 0
  		return
  	
  	# Apply movement
  	if "velocity" in character:
  		character.velocity.x = chase_direction.x * chase_speed
  	
  	# Update animation and facing
  	_update_animation(chase_direction)
  
  ## Start chasing a target
  func start_chase(new_target) -> bool:
  	if not new_target:
  		return false
  	
  	target = new_target
  	is_active = true
  	lost_sight_time = 0
  	last_known_position = target.global_position
  	
  	emit_signal("chase_started", target)
  	return true
  
  ## End the current chase
  func end_chase():
  	if is_active:
  		emit_signal("chase_ended")
  	
  	is_active = false
  	target = null
  	lost_sight_time = 0
  	
  	# Stop movement
  	if "velocity" in character:
  		character.velocity.x = 0
  
  ## Check if the character has line of sight to the target
  func _check_line_of_sight(check_target) -> bool:
  	if not check_target:
  		return false
  	
  	var space_state = character.get_world_2d().direct_space_state
  	var params = PhysicsRayQueryParameters2D.new()
  	params.from = character.global_position
  	params.to = check_target.global_position
  	params.collision_mask = line_of_sight_mask
  	params.exclude = [character]
  	
  	var result = space_state.intersect_ray(params)
  	
  	if result and result.collider != check_target:
  		if lost_sight_time == 0:
  			emit_signal("line_of_sight_lost")
  		return false
  	return true
  
  ## Get the current distance to the target
  func get_distance_to_target() -> float:
  	if not target:
  		return INF
  	return character.global_position.distance_to(target.global_position)
  
  ## Update character animation and direction based on movement
  func _update_animation(direction: Vector2):
  	# Play chase animation
  	if character.has_method("play_animation"):
  		character.play_animation(chase_animation)
  	
  	# Handle sprite flipping
  	var sprite = character.get_node_or_null(animated_sprite_path)
  	if sprite and "flip_h" in sprite:
  		sprite.flip_h = direction.x < 0

========================================
Contents of scripts\core\enemies\behaviors\patrol_behavior.gd:
========================================
  class_name PatrolBehavior
  extends Node
  
  ## A modular component for enemy patrol behavior
  
  # Patrol modes
  enum PatrolMode {
  	BACK_AND_FORTH,  # Move between start and end points
  	LOOP,            # Move in a loop through all points
  	RANDOM           # Choose random points to patrol to
  }
  
  # Patrol points - Vector2 positions for the patrol path
  @export var patrol_points: Array[Vector2] = []
  # Current patrol mode
  @export var mode: PatrolMode = PatrolMode.BACK_AND_FORTH
  # Speed while patrolling
  @export var patrol_speed: float = 60.0
  # Wait time at each patrol point (seconds)
  @export var wait_time: float = 1.0
  # Whether to use global coordinates or local coordinates
  @export var use_global_coordinates: bool = true
  # Whether the enemy should flip when changing direction
  @export var flip_on_direction_change: bool = true
  # Flip method (sprite or node)
  @export var flip_method: String = "sprite" # "sprite" or "node"
  # Whether patrol is currently active
  @export var is_active: bool = true
  
  # Reference to the owner character
  var character = null
  # Current target patrol point index
  var current_point_index: int = 0
  # Direction of travel for back-and-forth mode (1 = forwards, -1 = backwards)
  var travel_direction: int = 1
  # Whether we're currently waiting at a patrol point
  var is_waiting: bool = false
  # Wait timer
  var wait_timer: float = 0.0
  # Path to the animated sprite (if not direct child)
  @export var animated_sprite_path: String = "AnimatedSprite2D"
  # Animation to play while patrolling
  @export var patrol_animation: String = "walk"
  
  # Signals
  signal point_reached(point_index)
  signal patrol_completed()
  signal direction_changed(new_direction)
  
  func _ready():
  	# Get the owner character (parent node)
  	character = get_parent()
  	
  	# Initialize with first patrol point if available
  	if patrol_points.size() > 0:
  		current_point_index = 0
  	else:
  		# Add the character's current position as the first patrol point
  		if use_global_coordinates:
  			patrol_points.append(character.global_position)
  		else:
  			patrol_points.append(character.position)
  
  func _physics_process(delta):
  	if not is_active or patrol_points.size() < 2:
  		return
  	
  	if is_waiting:
  		# Handle waiting at patrol points
  		wait_timer -= delta
  		if wait_timer <= 0:
  			is_waiting = false
  			_move_to_next_point()
  		return
  	
  	# Get current target point
  	var target_position = patrol_points[current_point_index]
  	if use_global_coordinates:
  		target_position = target_position
  	
  	# Get current position
  	var current_position = character.global_position if use_global_coordinates else character.position
  	
  	# Check if we've reached the target point
  	var distance_to_target = current_position.distance_to(target_position)
  	if distance_to_target < 10.0:  # Within 10 pixels considered as "reached"
  		_on_point_reached()
  		return
  	
  	# Move towards the target point
  	var direction = (target_position - current_position).normalized()
  	
  	# Apply movement
  	if "velocity" in character:
  		character.velocity.x = direction.x * patrol_speed
  	
  	# Handle animation and flipping
  	_update_animation(direction)
  
  ## Start patrolling
  func start():
  	is_active = true
  	is_waiting = false
  
  ## Stop patrolling
  func stop():
  	is_active = false
  	if "velocity" in character:
  		character.velocity.x = 0
  
  ## Add a new patrol point
  func add_patrol_point(point: Vector2):
  	patrol_points.append(point)
  
  ## Clear all patrol points
  func clear_patrol_points():
  	patrol_points.clear()
  	current_point_index = 0
  
  ## Set new patrol points
  func set_patrol_points(points: Array[Vector2]):
  	patrol_points = points
  	current_point_index = 0
  
  ## Set the patrol mode
  func set_patrol_mode(new_mode: PatrolMode):
  	mode = new_mode
  	
  ## Get the current patrol target position
  func get_current_target() -> Vector2:
  	if patrol_points.size() > current_point_index:
  		return patrol_points[current_point_index]
  	return Vector2.ZERO
  
  ## Called when a patrol point is reached
  func _on_point_reached():
  	emit_signal("point_reached", current_point_index)
  	
  	# Start waiting
  	is_waiting = true
  	wait_timer = wait_time
  	
  	# Stop horizontal movement
  	if "velocity" in character:
  		character.velocity.x = 0
  
  ## Move to the next patrol point based on the patrol mode
  func _move_to_next_point():
  	match mode:
  		PatrolMode.BACK_AND_FORTH:
  			# Change direction at endpoints
  			if current_point_index == patrol_points.size() - 1:
  				travel_direction = -1
  				emit_signal("direction_changed", travel_direction)
  			elif current_point_index == 0:
  				travel_direction = 1
  				emit_signal("direction_changed", travel_direction)
  			
  			current_point_index += travel_direction
  			
  		PatrolMode.LOOP:
  			# Move to next point, wrap around to beginning
  			current_point_index = (current_point_index + 1) % patrol_points.size()
  			
  			if current_point_index == 0:
  				emit_signal("patrol_completed")
  				
  		PatrolMode.RANDOM:
  			# Choose a random point different from the current one
  			var new_index = current_point_index
  			while new_index == current_point_index and patrol_points.size() > 1:
  				new_index = randi() % patrol_points.size()
  			current_point_index = new_index
  
  ## Update character animation and direction based on movement
  func _update_animation(direction: Vector2):
  	# Play patrol animation
  	if character.has_method("play_animation"):
  		character.play_animation(patrol_animation)
  	
  	# Handle flipping
  	if flip_on_direction_change:
  		var sprite = null
  		
  		if flip_method == "sprite":
  			sprite = character.get_node_or_null(animated_sprite_path)
  			if sprite and "flip_h" in sprite:
  				sprite.flip_h = direction.x < 0
  		elif flip_method == "node":
  			# Flip the entire character node
  			character.scale.x = abs(character.scale.x) * sign(direction.x)

========================================
Contents of scripts\core\enemies\enemy_state_machine\archer_states.gd:
========================================
  class_name ArcherState
  extends EnemyState
  
  ## Specialized states for Goblin Archer
  ## Handles ranged attacks, retreating, and reloading
  
  # Retreat State - Maintain distance from player
  class RetreatState extends EnemyState:
  	var retreat_timer: float = 0.0
  	var retreat_duration: float = 1.5
  	var optimal_distance: float = 150.0
  	
  	func enter():
  		super.enter()
  		play_animation("walk")
  		retreat_timer = 0.0
  		
  		# Get optimal distance from archer if available
  		var archer = enemy as GoblinArcher
  		if archer and "optimal_distance" in archer:
  			optimal_distance = archer.optimal_distance
  		
  		print(enemy.name + " entered retreat state")
  	
  	func physics_process(delta: float):
  		retreat_timer += delta
  		
  		# Update target reference
  		update_target()
  		
  		if not target:
  			return
  		
  		var distance = get_distance_to_target()
  		var direction = enemy.global_position.x - target.global_position.x
  		var normalized_dir = sign(direction)
  		
  		# If too close, move away
  		if distance < optimal_distance:
  			if "velocity" in enemy:
  				enemy.velocity.x = normalized_dir * enemy.speed
  			
  			if "animated_sprite" in enemy and enemy.animated_sprite:
  				enemy.animated_sprite.flip_h = normalized_dir < 0  # Face toward player
  		else:
  			if "velocity" in enemy:
  				enemy.velocity.x = 0
  			
  			# Turn toward player but don't move
  			var look_dir = target.global_position.x - enemy.global_position.x
  			if "animated_sprite" in enemy and enemy.animated_sprite:
  				enemy.animated_sprite.flip_h = look_dir > 0
  	
  	func get_next_state() -> String:
  		var next = super.get_next_state()
  		if next:
  			return next
  			
  		# Return to patrol if no target
  		if not target:
  			return "Patrol"
  		
  		# After retreat time, shoot
  		if retreat_timer >= retreat_duration:
  			# If good distance and has arrows, shoot
  			var distance = get_distance_to_target()
  			var archer = enemy as GoblinArcher
  			
  			if archer and distance >= optimal_distance and archer.arrows_remaining > 0:
  				return "Shoot"
  		
  		return ""
  
  # Shoot State - Fire arrows/rocks
  class ShootState extends EnemyState:
  	var aim_timer: float = 0.0
  	var aim_duration: float = 0.5
  	var shot_fired: bool = false
  	var shot_duration: float = 1.0
  	
  	func enter():
  		super.enter()
  		play_animation("attack")
  		
  		# Stop movement during shooting
  		if "velocity" in enemy:
  			enemy.velocity.x = 0
  			
  		aim_timer = 0.0
  		shot_fired = false
  		
  		# Face the target
  		if target:
  			var direction = target.global_position.x - enemy.global_position.x
  			if "animated_sprite" in enemy and enemy.animated_sprite:
  				enemy.animated_sprite.flip_h = direction > 0
  				
  		print(enemy.name + " entered shoot state")
  	
  	func physics_process(delta: float):
  		aim_timer += delta
  		
  		# Fire after aiming
  		if not shot_fired and aim_timer >= aim_duration:
  			fire_projectile()
  			shot_fired = true
  			
  			# Reduce arrows
  			var archer = enemy as GoblinArcher
  			if archer:
  				archer.arrows_remaining -= 1
  				print(enemy.name + " arrows remaining: " + str(archer.arrows_remaining))
  	
  	func fire_projectile():
  		if not target:
  			return
  		
  		var archer = enemy as GoblinArcher
  		if not archer:
  			return
  		
  		# Use the archer's shoot method
  		var success = archer.shoot()
  		
  		if success:
  			print(enemy.name + " fired a projectile at " + target.name)
  	
  	func get_next_state() -> String:
  		var next = super.get_next_state()
  		if next:
  			return next
  			
  		# After shot is complete
  		if shot_fired and aim_timer >= shot_duration:
  			var archer = enemy as GoblinArcher
  			if not archer:
  				return "Patrol"
  			
  			# Reload if out of arrows
  			if archer.arrows_remaining <= 0:
  				return "Reload"
  			
  			# Retreat if player too close
  			if get_distance_to_target() < 100:
  				return "Retreat"
  			
  			# Otherwise back to chase
  			return "Chase"
  		
  		return ""
  
  # Reload State - Reload arrows
  class ReloadState extends EnemyState:
  	var reload_timer: float = 0.0
  	var reload_time: float = 2.0
  	
  	func enter():
  		super.enter()
  		play_animation("idle")  # Use idle animation for reloading
  		
  		# Stop during reloading
  		if "velocity" in enemy:
  			enemy.velocity.x = 0
  			
  		reload_timer = 0.0
  		
  		# Begin reloading
  		var archer = enemy as GoblinArcher
  		if archer:
  			archer.start_reloading()
  			reload_time = archer.reload_time
  			
  		print(enemy.name + " entered reload state")
  	
  	func physics_process(delta: float):
  		reload_timer += delta
  		
  		# Update target for threat awareness
  		update_target()
  	
  	func get_next_state() -> String:
  		var next = super.get_next_state()
  		if next:
  			return next
  		
  		var archer = enemy as GoblinArcher
  		if not archer:
  			return "Patrol"
  		
  		# After reload completes
  		if reload_timer >= reload_time:
  			# Refill arrows
  			archer.arrows_remaining = archer.quiver_size
  			print(enemy.name + " finished reloading, arrows: " + str(archer.arrows_remaining))
  			
  			# Retreat if player is close
  			if target and get_distance_to_target() < 100:
  				return "Retreat"
  			
  			# Otherwise chase or patrol
  			if target:
  				return "Chase"
  			else:
  				return "Patrol"
  		
  		return ""

========================================
Contents of scripts\core\enemies\enemy_state_machine\enemy_state_machine.gd:
========================================
  class_name EnemyStateMachine
  extends StateMachine
  
  ## An improved state machine specifically for enemies
  ## Handles enemy target detection, state transitions, and combat
  
  # Signal emitted when an enemy detects a player
  signal player_detected(player)
  # Signal emitted when an enemy loses track of the player
  signal player_lost()
  # Signal emitted when an action is completed (e.g. attack)
  signal action_completed(action_name)
  # Signal emitted when the enemy takes damage
  signal took_damage(amount, attacker)
  # Signal emitted when the enemy dies
  signal died()
  
  # Enemy sensing properties
  var detection_range: float = 200.0
  var attack_range: float = 50.0
  var patrol_range: float = 100.0
  var can_see_through_walls: bool = false
  
  # Current target (usually the player)
  var target = null
  # Original position for patrols
  var initial_position: Vector2
  
  # Track the last state for debugger
  var previous_state_name: String = ""
  
  # Target tracking properties
  var target_visible_time: float = 0.0
  var target_lost_time: float = 0.0
  var minimum_detection_time: float = 0.1  # Time needed to confirm detection
  var maximum_lost_time: float = 0.5  # Time before target is considered lost
  
  func _ready():
  	super._ready()
  	
  	# Ensure the owner node is set
  	if not owner_node:
  		owner_node = get_parent()
  	
  	# Set initial position for patrol patterns
  	initial_position = owner_node.global_position
  	
  	# Connect signals if the owner has matching methods
  	if owner_node.has_signal("player_detected") and owner_node.has_method("_on_player_detected"):
  		player_detected.connect(owner_node._on_player_detected)
  	
  	if owner_node.has_signal("player_lost") and owner_node.has_method("_on_player_lost"):
  		player_lost.connect(owner_node._on_player_lost)
  	
  	if owner_node.has_signal("died") and owner_node.has_method("_on_died"):
  		died.connect(owner_node._on_died)
  	
  	# Enable debug mode in development builds
  	debug_mode = OS.is_debug_build()
  	print("EnemyStateMachine initialized for: " + owner_node.name + " with detection_range=" + str(detection_range))
  
  func _process(delta):
  	super._process(delta)
  	
  	# Debug state changes
  	if debug_mode and current_state:
  		if current_state.name != previous_state_name:
  			print("[EnemyStateMachine] State changed: ", previous_state_name, " -> ", current_state.name)
  			previous_state_name = current_state.name
  
  func _physics_process(delta):
  	super._physics_process(delta)
  	
  	# Check for target consistently
  	_update_target_detection(delta)
  
  # A more reliable target detection system
  func _update_target_detection(delta):
  	var player = _find_player()
  	var can_see_player = false
  	
  	if player:
  		# Check distance
  		var distance = owner_node.global_position.distance_to(player.global_position)
  		
  		if distance <= detection_range:
  			# Line of sight check
  			if can_see_through_walls or _has_line_of_sight(player):
  				can_see_player = true
  				
  				# Tracking for consistent detection
  				target_visible_time += delta
  				target_lost_time = 0
  				
  				# Confirm detection after minimum time
  				if target_visible_time >= minimum_detection_time:
  					if target != player:
  						print(owner_node.name + " detected player at distance " + str(distance))
  						set_target(player)
  			else:
  				can_see_player = false
  		else:
  			can_see_player = false
  	
  	# Handle losing sight of target
  	if !can_see_player and target:
  		target_visible_time = 0
  		target_lost_time += delta
  		
  		# Clear target after max lost time
  		if target_lost_time >= maximum_lost_time:
  			clear_target()
  
  # Find player in the scene
  func _find_player() -> Node:
  	# First check the Global singleton for player reference
  	if get_node_or_null("/root/Global") and get_node("/root/Global").player:
  		return get_node("/root/Global").player
  	
  	# Alternative: check for player in groups
  	var player = get_tree().get_first_node_in_group("player")
  	if not player:
  		# Last resort - search by name
  		player = get_tree().get_root().find_child("Player", true, false)
  	
  	return player
  
  # Check if there's a clear line of sight to the target
  func _has_line_of_sight(to_node: Node) -> bool:
  	if not is_instance_valid(to_node):
  		return false
  		
  	# Setup raycast
  	var space_state = owner_node.get_world_2d().direct_space_state
  	var query = PhysicsRayQueryParameters2D.create(
  		owner_node.global_position, 
  		to_node.global_position,
  		1, # Collision layer for obstacles 
  		[owner_node] # Exclude self from collision check
  	)
  	
  	var result = space_state.intersect_ray(query)
  	
  	# If nothing hit or hit the target, we have line of sight
  	return !result or result.collider == to_node
  
  # Set current target and notify owner
  func set_target(new_target):
  	if new_target == target:
  		return
  		
  	var had_no_target = (target == null)
  	target = new_target
  	
  	if new_target and had_no_target:
  		emit_signal("player_detected", new_target)
  		
  		# Force state change based on distance if in Patrol state
  		if current_state and current_state.name == "Patrol":
  			if is_target_in_attack_range():
  				change_state("Attack")
  			else:
  				change_state("Chase")
  
  # Clear current target
  func clear_target():
  	if target:
  		print(owner_node.name + " lost sight of player")
  		emit_signal("player_lost")
  		
  		# If we're chasing or attacking, return to patrol
  		if current_state and (current_state.name == "Chase" or current_state.name == "Attack"):
  			change_state("Patrol")
  	
  	target = null
  
  # Is target within attack range?
  func is_target_in_attack_range() -> bool:
  	if not target:
  		return false
  	
  	var distance = owner_node.global_position.distance_to(target.global_position)
  	var in_range = distance <= attack_range
  	
  	if debug_mode and in_range and current_state and current_state.name != "Attack":
  		print(owner_node.name + " target in attack range: " + str(distance) + " <= " + str(attack_range))
  	
  	return in_range
  
  # Direction to current target
  func get_direction_to_target() -> Vector2:
  	if not target:
  		return Vector2.ZERO
  	
  	return (target.global_position - owner_node.global_position).normalized()
  
  # Handle damage taken
  func take_damage(amount: float, attacker = null):
  	if owner_node.has_method("take_damage"):
  		owner_node.take_damage(amount)
  	
  	emit_signal("took_damage", amount, attacker)
  	
  	# Check for death
  	if _is_owner_dead():
  		change_state("Death")
  		emit_signal("died")
  
  # Check if owner is dead
  func _is_owner_dead() -> bool:
  	if owner_node.has_method("is_dead") and owner_node.is_dead():
  		return true
  	elif "is_dead" in owner_node and owner_node.is_dead:
  		return true
  	elif "current_health" in owner_node and owner_node.current_health <= 0:
  		return true
  	return false

========================================
Contents of scripts\core\enemies\enemy_state_machine\enemy_states.gd:
========================================
  class_name EnemyState
  extends State
  
  ## Base class for all enemy states
  ## Provides common functionality for enemy AI
  
  # Reference to enemy (type-safe)
  var enemy = null
  # Current target (usually player)
  var target = null
  
  func enter():
  	# Make sure the enemy reference is valid
  	enemy = owner_node
  	
  	if not enemy is CharacterBody2D:
  		push_error("Enemy state attached to non-CharacterBody2D object!")
  		return
  
  	# Get current target from state machine
  	var enemy_machine = get_enemy_state_machine()
  	if enemy_machine:
  		target = enemy_machine.target
  
  func exit():
  	pass
  
  func get_next_state() -> String:
  	# Check if enemy is dead first
  	if "is_dead" in enemy and enemy.is_dead:
  		return "Death"
  	
  	# Check health status
  	if "current_health" in enemy and enemy.current_health <= 0:
  		return "Death"
  	
  	# No transition by default
  	return ""
  
  # Common utility functions
  func play_animation(anim_name: String):
  	if "animated_sprite" in enemy and enemy.animated_sprite:
  		if enemy.animated_sprite.sprite_frames and enemy.animated_sprite.sprite_frames.has_animation(anim_name):
  			enemy.animated_sprite.play(anim_name)
  		else:
  			# Fall back to idle if animation not found
  			print("Animation not found: " + anim_name + " for enemy " + enemy.name + ", falling back to idle")
  			if enemy.animated_sprite.sprite_frames.has_animation("idle"):
  				enemy.animated_sprite.play("idle")
  
  func flip_to_target():
  	if not target:
  		return
  		
  	if "animated_sprite" in enemy and enemy.animated_sprite:
  		var direction = target.global_position.x - enemy.global_position.x
  		enemy.animated_sprite.flip_h = direction > 0
  
  # Type-safe getter for the state machine
  func get_enemy_state_machine() -> EnemyStateMachine:
  	return state_machine as EnemyStateMachine
  
  # Distance to current target
  func get_distance_to_target() -> float:
  	if not target:
  		return 9999.0
  	
  	return enemy.global_position.distance_to(target.global_position)
  
  # Is target in attack range?
  func is_target_in_attack_range() -> bool:
  	if "attack_radius" in enemy:
  		return get_distance_to_target() <= enemy.attack_radius
  	else:
  		return get_distance_to_target() <= 50.0  # Default if not defined
  
  # Is target in detection range?
  func is_target_in_detection_range() -> bool:
  	if "detection_radius" in enemy:
  		return get_distance_to_target() <= enemy.detection_radius
  	else:
  		return get_distance_to_target() <= 200.0  # Default if not defined
  
  # Update target reference
  func update_target():
  	var enemy_machine = get_enemy_state_machine()
  	if enemy_machine:
  		target = enemy_machine.target
  
  
  #
  # Concrete Enemy States
  # Each state handles specific behavior
  #
  
  # Patrol State - Walk between points
  class PatrolState extends EnemyState:
  	var patrol_timer: float = 0.0
  	var wait_time: float = 1.0
  	var is_waiting: bool = false
  	var direction: int = 1
  	var patrol_range: float = 100.0
  	var patrol_points: Array = []
  	
  	func enter():
  		super.enter()
  		play_animation("idle")
  		
  		# Get patrol_range from enemy if available
  		if "patrol_distance" in enemy:
  			patrol_range = enemy.patrol_distance
  		
  		# Create patrol points if needed
  		if patrol_points.size() == 0:
  			var start_pos = enemy.global_position
  			patrol_points = [
  				start_pos,
  				start_pos + Vector2(patrol_range, 0)
  			]
  		
  		patrol_timer = 0.0
  		is_waiting = false
  		print(enemy.name + " entered patrol state")
  		
  		# Get the machine initial position
  		var machine = get_enemy_state_machine()
  		if machine:
  			patrol_points = [
  				machine.initial_position,
  				machine.initial_position + Vector2(patrol_range, 0)
  			]
  	
  	func physics_process(delta: float):
  		patrol_timer += delta
  		
  		# Check for player
  		update_target()
  		
  		if is_waiting:
  			# Wait at patrol point
  			if patrol_timer >= wait_time:
  				is_waiting = false
  				patrol_timer = 0.0
  				# Reverse direction
  				direction *= -1
  				if "animated_sprite" in enemy and enemy.animated_sprite:
  					enemy.animated_sprite.flip_h = direction > 0
  			return
  		
  		# Apply patrol movement
  		if "velocity" in enemy:
  			enemy.velocity.x = enemy.speed * direction
  		
  		# Play walk animation
  		play_animation("walk")
  		
  		# Check if we've reached a boundary
  		if direction > 0 and enemy.global_position.x >= patrol_points[1].x:
  			enemy.global_position.x = patrol_points[1].x
  			handle_patrol_point_reached()
  		elif direction < 0 and enemy.global_position.x <= patrol_points[0].x:
  			enemy.global_position.x = patrol_points[0].x
  			handle_patrol_point_reached()
  	
  	func handle_patrol_point_reached():
  		if "velocity" in enemy:
  			enemy.velocity.x = 0
  		play_animation("idle")
  		is_waiting = true
  		patrol_timer = 0.0
  	
  	func get_next_state() -> String:
  		var next = super.get_next_state()
  		if next:
  			return next
  			
  		# Transition to chase if target detected
  		if target:
  			return "Chase"
  		
  		return ""
  
  # Chase State - Pursue the player
  class ChaseState extends EnemyState:
  	func enter():
  		super.enter()
  		play_animation("walk")
  		
  		# Set chase flag if present
  		if "is_chasing" in enemy:
  			enemy.is_chasing = true
  			
  		print(enemy.name + " entered chase state")
  	
  	func exit():
  		# Clear chase flag if present
  		if "is_chasing" in enemy:
  			enemy.is_chasing = false
  	
  	func physics_process(delta: float):
  		# Update target and check line of sight
  		update_target()
  		
  		if not target:
  			if "velocity" in enemy:
  				enemy.velocity.x = 0
  			return
  		
  		# Direction to player
  		var direction = target.global_position.x - enemy.global_position.x
  		var normalized_dir = sign(direction)
  		
  		# Set velocity
  		if "velocity" in enemy:
  			if "chase_speed" in enemy:
  				enemy.velocity.x = normalized_dir * enemy.chase_speed
  			else:
  				enemy.velocity.x = normalized_dir * enemy.speed * 1.2  # Default faster
  		
  		# Flip sprite
  		if "animated_sprite" in enemy and enemy.animated_sprite:
  			enemy.animated_sprite.flip_h = normalized_dir > 0
  	
  	func get_next_state() -> String:
  		var next = super.get_next_state()
  		if next:
  			return next
  			
  		# Return to patrol if no target
  		if not target:
  			return "Patrol"
  		
  		# Switch to attack if in range
  		if is_target_in_attack_range():
  			return "Attack"
  		
  		return ""
  
  # Attack State - Attack the player
  class AttackState extends EnemyState:
  	var attack_timer: float = 0.0
  	var attack_duration: float = 0.5
  	var has_dealt_damage: bool = false
  	
  	func enter():
  		super.enter()
  		play_animation("attack")
  		
  		# Update attacking flag
  		if "is_attacking" in enemy:
  			enemy.is_attacking = true
  			
  		attack_timer = 0.0
  		has_dealt_damage = false
  		
  		# Stop movement during attack
  		if "velocity" in enemy:
  			enemy.velocity.x = 0
  			
  		print(enemy.name + " entered attack state")
  	
  	func exit():
  		if "is_attacking" in enemy:
  			enemy.is_attacking = false
  	
  	func physics_process(delta: float):
  		attack_timer += delta
  		
  		# Deal damage in middle of animation
  		if not has_dealt_damage and attack_timer >= attack_duration * 0.5:
  			deal_damage()
  			has_dealt_damage = true
  	
  	func deal_damage():
  		if not target or not is_target_in_attack_range():
  			return
  			
  		# Use DamageSystem if available
  		var damage_system = get_node_or_null("/root/DamageSystem")
  		if damage_system:
  			damage_system.process_attack(enemy, target, enemy.attack_damage)
  		elif target.has_method("take_damage"):
  			target.take_damage(enemy.attack_damage)
  		
  		print(enemy.name + " dealt damage to " + target.name)
  	
  	func get_next_state() -> String:
  		var next = super.get_next_state()
  		if next:
  			return next
  			
  		# After attack is complete
  		if attack_timer >= attack_duration:
  			# If target out of range, chase
  			if not is_target_in_attack_range():
  				return "Chase"
  			# If target in range but can't attack yet
  			elif "can_attack" in enemy and not enemy.can_attack:
  				return "Chase"
  			# If target in range and we can attack, stay in attack state
  		
  		return ""
  
  # Hurt State - Enemy takes damage
  class HurtState extends EnemyState:
  	var hurt_timer: float = 0.0
  	var hurt_duration: float = 0.3
  	
  	func enter():
  		super.enter()
  		play_animation("hurt")
  		
  		# Stop movement
  		if "velocity" in enemy:
  			enemy.velocity.x = 0
  			
  		hurt_timer = 0.0
  		print(enemy.name + " entered hurt state")
  	
  	func physics_process(delta: float):
  		hurt_timer += delta
  	
  	func get_next_state() -> String:
  		var next = super.get_next_state()
  		if next:
  			return next
  			
  		# After hurt animation
  		if hurt_timer >= hurt_duration:
  			if target:
  				if is_target_in_attack_range() and "can_attack" in enemy and enemy.can_attack:
  					return "Attack"
  				else:
  					return "Chase"
  			else:
  				return "Patrol"
  		
  		return ""
  
  # Death State - Enemy dies
  class DeathState extends EnemyState:
  	var death_timer: float = 0.0
  	var death_duration: float = 1.0
  	
  	func enter():
  		super.enter()
  		play_animation("death")
  		
  		# Stop movement
  		if "velocity" in enemy:
  			enemy.velocity = Vector2.ZERO
  			
  		# Mark as dead
  		if "is_dead" in enemy:
  			enemy.is_dead = true
  		
  		# Disable collision
  		if "collision_shape" in enemy and enemy.collision_shape:
  			enemy.collision_shape.set_deferred("disabled", true)
  		
  		death_timer = 0.0
  		print(enemy.name + " entered death state")
  	
  	func physics_process(delta: float):
  		death_timer += delta
  		
  		# Emit died signal and remove entity
  		if death_timer >= death_duration:
  			var enemy_machine = get_enemy_state_machine()
  			if enemy_machine:
  				enemy_machine.emit_signal("died")
  			if is_instance_valid(enemy):
  				enemy.queue_free()
  	
  	func get_next_state() -> String:
  		# Never leave death state
  		return ""

========================================
Contents of scripts\core\enemies\enemy_state_machine\mage_states.gd:
========================================
  class_name MageState
  extends EnemyState
  
  ## Specialized states for Goblin Mage
  ## Handles magic attacks, teleportation, and shielding
  
  # Cast State - Cast magical spells
  class CastState extends EnemyState:
  	var cast_timer: float = 0.0
  	var cast_duration: float = 1.0
  	var spell_fired: bool = false
  	var mana_cost: float = 20.0
  	
  	func enter():
  		super.enter()
  		play_animation("attack")
  		
  		# Stop movement during casting
  		if "velocity" in enemy:
  			enemy.velocity.x = 0
  			
  		cast_timer = 0.0
  		spell_fired = false
  		
  		# Face target
  		if target:
  			var direction = target.global_position.x - enemy.global_position.x
  			if "animated_sprite" in enemy and enemy.animated_sprite:
  				enemy.animated_sprite.flip_h = direction > 0
  	
  	func physics_process(delta: float):
  		cast_timer += delta
  		
  		# Cast spell at halfway point
  		if not spell_fired and cast_timer >= cast_duration * 0.5:
  			cast_spell()
  			spell_fired = true
  			
  			# Reduce mana
  			var mage = enemy as GoblinMage
  			if mage:
  				mage.current_mana -= mana_cost
  	
  	func cast_spell():
  		if not target:
  			return
  		
  		var mage = enemy as GoblinMage
  		if not mage or not mage.projectile_scene:
  			print("Mage missing projectile scene!")
  			return
  		
  		print("Mage " + enemy.name + " casting spell at " + target.name)
  		
  		# Create magical projectile
  		var projectile = mage.projectile_scene.instantiate()
  		get_tree().current_scene.add_child(projectile)
  		
  		# Set position and direction
  		var spawn_pos = enemy.global_position
  		spawn_pos.y -= 10  # Slightly above the mage
  		
  		var direction = (target.global_position - spawn_pos).normalized()
  		
  		# Configure projectile
  		if projectile.has_method("setup"):
  			projectile.setup(direction, spawn_pos, 0, enemy)
  		else:
  			# Fallback if setup doesn't exist
  			projectile.global_position = spawn_pos
  			if "velocity" in projectile:
  				projectile.velocity = direction * projectile.speed
  			if "source_node" in projectile:
  				projectile.source_node = enemy
  		
  		# Play spell sound if available
  		if mage.has_node("SpellSound"):
  			mage.get_node("SpellSound").play()
  		
  		# Add visual effects
  		_spawn_magic_effect(spawn_pos)
  	
  	func _spawn_magic_effect(pos: Vector2):
  		# Create a simple particle effect
  		var particles = CPUParticles2D.new()
  		particles.emitting = true
  		particles.one_shot = true
  		particles.amount = 16
  		particles.explosiveness = 0.8
  		particles.lifetime = 0.5
  		particles.direction = Vector2(0, -1)
  		particles.spread = 60
  		particles.initial_velocity_min = 20
  		particles.initial_velocity_max = 40
  		particles.scale_amount = 2
  		particles.color = Color(0.5, 0.1, 0.9, 0.7)  # Purple magic color
  		
  		enemy.add_child(particles)
  		
  		# Auto-remove after animation
  		get_tree().create_timer(0.5).timeout.connect(func(): particles.queue_free())
  	
  	func get_next_state() -> String:
  		var next = super.get_next_state()
  		if next:
  			return next
  			
  		# After spell is cast
  		if spell_fired and cast_timer >= cast_duration:
  			var mage = enemy as GoblinMage
  			if not mage:
  				return "Patrol"
  			
  			# Teleport if low on mana
  			if mage.current_mana < mage.spell_mana_cost:
  				return "Teleport"
  			
  			# Teleport if player too close
  			if target and get_distance_to_target() < 50:
  				return "Teleport"
  			
  			# Otherwise back to chase
  			return "Chase"
  		
  		return ""
  
  # Teleport State - Teleport to a safer location
  class TeleportState extends EnemyState:
  	var teleport_timer: float = 0.0
  	var teleport_duration: float = 0.5
  	var teleport_positions: Array = []
  	var has_teleported: bool = false
  	
  	func enter():
  		super.enter()
  		play_animation("idle")  # Teleport animation if available, otherwise idle
  		
  		if "velocity" in enemy:
  			enemy.velocity = Vector2.ZERO
  			
  		teleport_timer = 0.0
  		has_teleported = false
  		
  		# Generate possible teleport positions
  		teleport_positions = _generate_teleport_positions()
  		
  		print(enemy.name + " entered teleport state")
  	
  	func _generate_teleport_positions() -> Array:
  		var positions = []
  		var current_pos = enemy.global_position
  		
  		# Generate positions at a safe distance
  		for i in range(4):
  			var angle = i * PI/2  # 0, 90, 180, 270 degrees
  			var distance = 150.0
  			var new_pos = current_pos + Vector2(cos(angle), sin(angle)) * distance
  			positions.append(new_pos)
  		
  		return positions
  	
  	func physics_process(delta: float):
  		teleport_timer += delta
  		
  		# Teleport halfway through state duration
  		if not has_teleported and teleport_timer >= teleport_duration * 0.5:
  			_perform_teleport()
  			has_teleported = true
  	
  	func _perform_teleport():
  		if teleport_positions.size() == 0:
  			return
  		
  		# Choose the best position
  		var best_pos = _get_best_teleport_position()
  		
  		# Fade-out effect
  		var tween = create_tween()
  		tween.tween_property(enemy, "modulate:a", 0.0, 0.1)
  		
  		# Teleport
  		await tween.finished
  		enemy.global_position = best_pos
  		
  		# Fade-in effect
  		tween = create_tween()
  		tween.tween_property(enemy, "modulate:a", 1.0, 0.1)
  		
  		# Update target after teleport
  		update_target()
  		
  		print(enemy.name + " teleported to " + str(best_pos))
  	
  	func _get_best_teleport_position() -> Vector2:
  		# Choose position farthest from player
  		var best_pos = enemy.global_position
  		var max_distance = 0.0
  		
  		if target:
  			for pos in teleport_positions:
  				var distance = pos.distance_to(target.global_position)
  				if distance > max_distance:
  					max_distance = distance
  					best_pos = pos
  		else:
  			# Without target, choose random position
  			best_pos = teleport_positions[randi() % teleport_positions.size()]
  		
  		return best_pos
  	
  	func get_next_state() -> String:
  		var next = super.get_next_state()
  		if next:
  			return next
  			
  		# After teleport is complete
  		if has_teleported and teleport_timer >= teleport_duration:
  			var mage = enemy as GoblinMage
  			if not mage:
  				return "Patrol"
  			
  			# Regenerate mana
  			mage.current_mana += 10.0
  			
  			# Return to appropriate state
  			if target:
  				# If enough mana to cast and in range, cast
  				if mage.current_mana >= mage.spell_mana_cost and get_distance_to_target() <= enemy.attack_radius:
  					return "Cast"
  				else:
  					return "Chase"
  			else:
  				return "Patrol"
  		
  		return ""
  
  # Shield State - Create a temporary magic shield
  class ShieldState extends EnemyState:
  	var shield_timer: float = 0.0
  	var shield_duration: float = 5.0
  	var shield_active: bool = false
  	var shield_node: Node2D = null
  	var mana_cost: float = 15.0
  	
  	func enter():
  		super.enter()
  		play_animation("idle")  # Shield animation if available, otherwise idle
  		shield_timer = 0.0
  		
  		var mage = enemy as GoblinMage
  		if mage and mage.current_mana >= mana_cost:
  			_activate_shield()
  			mage.current_mana -= mana_cost
  			
  		print(enemy.name + " entered shield state")
  	
  	func _activate_shield():
  		shield_active = true
  		
  		# Create shield visual
  		shield_node = Node2D.new()
  		shield_node.name = "MagicShield"
  		enemy.add_child(shield_node)
  		
  		# Create shield sprite - ideally with a proper shield graphic
  		var shield_sprite = Sprite2D.new()
  		shield_sprite.texture = load("res://icon.png")  # Replace with shield texture
  		shield_sprite.modulate = Color(0.2, 0.5, 1.0, 0.5)
  		shield_sprite.scale = Vector2(1.5, 1.5)
  		shield_node.add_child(shield_sprite)
  		
  		# Shield animation
  		var tween = create_tween().set_loops()
  		tween.tween_property(shield_sprite, "scale", Vector2(1.7, 1.7), 1.0)
  		tween.tween_property(shield_sprite, "scale", Vector2(1.5, 1.5), 1.0)
  		
  		# Activate invulnerability
  		enemy.is_invulnerable = true
  		
  		print(enemy.name + " activated shield")
  	
  	func _deactivate_shield():
  		if not shield_active:
  			return
  		
  		shield_active = false
  		
  		# Remove shield node
  		if shield_node:
  			shield_node.queue_free()
  		
  		# Deactivate invulnerability
  		enemy.is_invulnerable = false
  		
  		print(enemy.name + " deactivated shield")
  	
  	func exit():
  		_deactivate_shield()
  	
  	func physics_process(delta: float):
  		shield_timer += delta
  		
  		# Update target
  		update_target()
  		
  		if shield_active:
  			# Move slowly toward player
  			if target:
  				var direction = target.global_position.x - enemy.global_position.x
  				var normalized_dir = sign(direction)
  				if "velocity" in enemy:
  					enemy.velocity.x = normalized_dir * (enemy.speed * 0.5)  # Slower with shield
  				
  				if "animated_sprite" in enemy and enemy.animated_sprite:
  					enemy.animated_sprite.flip_h = normalized_dir > 0
  			else:
  				if "velocity" in enemy:
  					enemy.velocity.x = 0
  	
  	func get_next_state() -> String:
  		var next = super.get_next_state()
  		if next:
  			return next
  			
  		if shield_timer >= shield_duration:
  			var mage = enemy as GoblinMage
  			if not mage:
  				return "Patrol"
  			
  			# Cast if enough mana
  			if target and mage.current_mana >= mage.spell_mana_cost:
  				return "Cast"
  			
  			# Otherwise chase or patrol
  			if target:
  				return "Chase"
  			else:
  				return "Patrol"
  		
  		return ""

========================================
Contents of scripts\core\enemies\enemy_state_machine\melee_states.gd.gd:
========================================
  class_name MeleeState
  extends EnemyState
  
  ## Specialized states for Goblin Melee
  ## Handles enrage mechanics and aggressive attack patterns
  
  # RageMode State - Activated when health is low
  class RageState extends EnemyState:
  	var rage_timer: float = 0.0
  	var rage_duration: float = 0.8  # Shorter attack cooldown when enraged
  	var has_dealt_damage: bool = false
  	
  	func enter():
  		super.enter()
  		play_animation("attack")
  		
  		# Stop movement during attack
  		if "velocity" in enemy:
  			enemy.velocity.x = 0
  			
  		rage_timer = 0.0
  		has_dealt_damage = false
  		
  		# Apply rage visual effects
  		enemy.modulate = Color(1.3, 0.7, 0.7)  # Red tint
  		
  		# Play rage sound if available
  		if enemy.has_node("RageSound"):
  			enemy.get_node("RageSound").play()
  			
  		print(enemy.name + " entered rage state")
  	
  	func exit():
  		# Clean up any visual effects, but keep enraged status
  		pass
  	
  	func physics_process(delta: float):
  		rage_timer += delta
  		
  		# Deal damage faster than normal attack
  		if not has_dealt_damage and rage_timer >= rage_duration * 0.3:  # Quicker hit
  			deal_rage_damage()
  			has_dealt_damage = true
  	
  	func deal_rage_damage():
  		if not target or not is_target_in_attack_range():
  			return
  			
  		var melee = enemy as GoblinMelee
  		var damage_multiplier = melee.rage_damage_bonus if melee else 1.5
  		var base_damage = enemy.attack_damage
  		
  		# Apply increased damage
  		var rage_damage = base_damage * damage_multiplier
  		
  		# Use DamageSystem if available
  		var damage_system = get_node_or_null("/root/DamageSystem")
  		if damage_system:
  			damage_system.process_attack(enemy, target, rage_damage)
  		elif target.has_method("take_damage"):
  			target.take_damage(rage_damage)
  		
  		print(enemy.name + " dealt RAGE damage to " + target.name + ": " + str(rage_damage))
  	
  	func get_next_state() -> String:
  		var next = super.get_next_state()
  		if next:
  			return next
  			
  		# After attack is complete
  		if rage_timer >= rage_duration:
  			# If target out of range, chase at rage speed
  			if not is_target_in_attack_range():
  				return "RageChase"
  			# If target in range, continue attacking
  			# Rage attacks have shorter cooldown
  		
  		return ""
  
  # RageChase State - Faster chase when enraged
  class RageChaseState extends EnemyState:
  	func enter():
  		super.enter()
  		play_animation("walk")
  		
  		# Set chase flag if present
  		if "is_chasing" in enemy:
  			enemy.is_chasing = true
  			
  		print(enemy.name + " entered rage chase state")
  	
  	func exit():
  		# Clear chase flag if present
  		if "is_chasing" in enemy:
  			enemy.is_chasing = false
  	
  	func physics_process(delta: float):
  		# Update target
  		update_target()
  		
  		if not target:
  			if "velocity" in enemy:
  				enemy.velocity.x = 0
  			return
  		
  		# Direction to player
  		var direction = target.global_position.x - enemy.global_position.x
  		var normalized_dir = sign(direction)
  		
  		# Use enhanced rage speed
  		var melee = enemy as GoblinMelee
  		var speed_multiplier = melee.rage_speed_bonus if melee else 1.3
  		
  		# Set velocity with rage bonus
  		if "velocity" in enemy:
  			if "chase_speed" in enemy:
  				enemy.velocity.x = normalized_dir * enemy.chase_speed * speed_multiplier
  			else:
  				enemy.velocity.x = normalized_dir * enemy.speed * 1.2 * speed_multiplier
  		
  		# Flip sprite
  		if "animated_sprite" in enemy and enemy.animated_sprite:
  			enemy.animated_sprite.flip_h = normalized_dir > 0
  		
  		# Create rage particles if they don't exist
  		if not enemy.has_node("RageParticles"):
  			_create_rage_particles()
  	
  	func _create_rage_particles():
  		var particles = CPUParticles2D.new()
  		particles.name = "RageParticles"
  		particles.amount = 10
  		particles.lifetime = 0.5
  		particles.emission_shape = CPUParticles2D.EMISSION_SHAPE_SPHERE
  		particles.emission_sphere_radius = 10.0
  		particles.gravity = Vector2(0, -20)
  		particles.initial_velocity_min = 10.0
  		particles.initial_velocity_max = 20.0
  		particles.color = Color(1.0, 0.3, 0.1, 0.7)
  		enemy.add_child(particles)
  		particles.emitting = true
  	
  	func get_next_state() -> String:
  		var next = super.get_next_state()
  		if next:
  			return next
  			
  		# Return to patrol if no target
  		if not target:
  			return "Patrol"
  		
  		# Switch to rage attack if in range
  		if is_target_in_attack_range():
  			return "Rage"
  		
  		return ""
  
  # Charge State - Charges at the player with a burst of speed
  class ChargeState extends EnemyState:
  	var charge_timer: float = 0.0
  	var charge_duration: float = 0.75
  	var charge_cooldown: float = 3.0
  	var charge_speed_multiplier: float = 2.0
  	var can_charge: bool = true
  	var has_started_charge: bool = false
  	
  	func enter():
  		super.enter()
  		play_animation("walk")  # Ideally would have a charge animation
  		
  		charge_timer = 0.0
  		has_started_charge = false
  		
  		# Brief delay before charging
  		if "velocity" in enemy:
  			enemy.velocity.x = 0
  			
  		print(enemy.name + " entered charge state")
  	
  	func physics_process(delta: float):
  		charge_timer += delta
  		
  		# Brief preparation before charge
  		if not has_started_charge and charge_timer >= 0.2:
  			_start_charge()
  			has_started_charge = true
  		
  		# Update target during charge
  		update_target()
  	
  	func _start_charge():
  		if not target:
  			return
  			
  		# Get direction to player
  		var direction = target.global_position.x - enemy.global_position.x
  		var normalized_dir = sign(direction)
  		
  		# Apply charge velocity
  		if "velocity" in enemy:
  			enemy.velocity.x = normalized_dir * enemy.speed * charge_speed_multiplier
  		
  		# Face direction
  		if "animated_sprite" in enemy and enemy.animated_sprite:
  			enemy.animated_sprite.flip_h = normalized_dir > 0
  	
  	func get_next_state() -> String:
  		var next = super.get_next_state()
  		if next:
  			return next
  			
  		# End charge after duration
  		if charge_timer >= charge_duration:
  			# If in attack range, attack immediately
  			if is_target_in_attack_range():
  				# If enraged, use rage attack
  				if _is_enraged():
  					return "Rage"
  				else:
  					return "Attack"
  			else:
  				# Otherwise chase normally
  				if _is_enraged():
  					return "RageChase" 
  				else:
  					return "Chase"
  		
  		return ""
  	
  	func _is_enraged() -> bool:
  		var melee = enemy as GoblinMelee
  		if melee and "is_enraged" in melee:
  			return melee.is_enraged
  		return false
  
  # Helper function to use in enemy classes to set up the specialized melee states
  static func register_melee_states(state_machine: StateMachine, enemy: GoblinMelee):
  	# Create specialized melee states
  	var rage_state = RageState.new()
  	rage_state.name = "Rage"
  	state_machine.add_child(rage_state)
  	
  	var rage_chase_state = RageChaseState.new()
  	rage_chase_state.name = "RageChase"
  	state_machine.add_child(rage_chase_state)
  	
  	var charge_state = ChargeState.new()
  	charge_state.name = "Charge"
  	state_machine.add_child(charge_state)
  	
  	# Register with the state machine
  	state_machine.register_state(rage_state)
  	state_machine.register_state(rage_chase_state)
  	state_machine.register_state(charge_state)
  	
  	print("Registered specialized melee states for: " + enemy.name)

========================================
Contents of scripts\core\enemies\goblin_archer.gd:
========================================
  class_name GoblinArcher
  extends BaseEnemy
  
  ## Goblin Archer - Fernkämpfer, der Pfeile/Steine auf den Spieler schießt
  ## Hält Abstand und muss nach einer bestimmten Anzahl von Schüssen nachladen
  
  # Goblin Archer-spezifische Eigenschaften
  @export var projectile_scene: PackedScene = preload("res://scenes/core/projectiles/rock.tscn")
  @export var quiver_size: int = 5  # Anzahl der Pfeile, bevor er nachladen muss
  @export var reload_time: float = 2.0  # Zeit zum Nachladen in Sekunden
  @export var shooting_accuracy: float = 0.9  # 1.0 = perfekt, niedriger = ungenauer
  @export var optimal_distance: float = 150.0  # Optimaler Abstand zum Spieler
  
  # Status
  var arrows_remaining: int
  var is_reloading: bool = false
  var last_shot_time: float = 0.0
  
  # State Machine und States
  var state_machine: EnemyStateMachine
  
  # Objekt-Pool für Projektile
  var projectile_pool: ObjectPool
  
  # Signale
  signal arrow_shot
  signal quiver_empty
  signal reload_complete
  
  func _ready():
  	# Setze Basis-Feindwerte
  	max_health = 70.0
  	current_health = max_health
  	speed = 50.0
  	chase_speed = 60.0
  	attack_damage = 25.0  # Realistischer Wert für Projektile (0.25 nach Skalierung)
  	attack_cooldown = 1.0
  	detection_radius = 350.0  # Erhöht von 200.0
  	attack_radius = 300.0    # Erhöht von 180.0
  	
  	# Initialisiere Pfeile
  	arrows_remaining = quiver_size
  	
  	# Setze Komponentenreferenzen
  	animated_sprite = $AnimatedSprite2D
  	collision_shape = $CollisionShape2D
  	
  	# Make sure this node is in the enemy group
  	if not is_in_group("enemy"):
  		add_to_group("enemy")
  	
  	# Initialisiere den Objekt-Pool für Projektile
  	_setup_projectile_pool()
  	
  	# Stelle sicher, dass die State Machine initialisiert wird
  	_setup_state_machine()
  	
  	# Drucke Debug-Info
  	print("GoblinArcher initialized with:")
  	print("  - Gesundheit: ", max_health)
  	print("  - Geschwindigkeit: ", speed)
  	print("  - Angriffsschaden: ", attack_damage)
  	print("  - Erkennungsradius: ", detection_radius)
  	print("  - Pfeile: ", arrows_remaining, "/", quiver_size)
  	
  	# Rufe die Elternklasse auf
  	super._ready()
  
  func _physics_process(delta):
  	# Eltern-Physikprozess zuerst ausführen
  	super._physics_process(delta)
  	
  	# Update Nachladezeit
  	if is_reloading:
  		last_shot_time += delta
  		if last_shot_time >= reload_time:
  			_reload_complete()
  
  # Initialisiere den Objekt-Pool für Projektile
  func _setup_projectile_pool():
  	# Überprüfe, ob projectile_scene gültig ist
  	if projectile_scene == null:
  		push_error("GoblinArcher: projectile_scene ist null. Versuche direktes Laden...")
  		projectile_scene = load("res://scenes/core/projectiles/rock.tscn")
  		
  	if projectile_scene == null:
  		push_error("GoblinArcher: Konnte projectile_scene nicht laden. Pool wird nicht erstellt.")
  		return
  	
  	# Erstelle Project Pool für bessere Performance
  	projectile_pool = ObjectPool.new(projectile_scene, 10, true)
  	projectile_pool.name = "ProjectilePool"
  	add_child(projectile_pool)
  
  # Schieße ein Projektil
  # Enhanced shoot function for GoblinArcher in scripts\core\enemies\goblin_archer.gd
  func shoot():
  	print(name + " attempting to shoot with debugging")
  	
  	if is_dead or is_reloading or arrows_remaining <= 0:
  		print(name + " can't shoot: " + 
  			("is dead" if is_dead else 
  			"is reloading" if is_reloading else 
  			"no arrows left"))
  		emit_signal("quiver_empty")
  		return false
  	
  	# Finde das Ziel (über die State Machine)
  	var target = state_machine.target
  	if not target:
  		print(name + " can't shoot: no target")
  		return false
  	
  	print(name + " shooting at " + target.name + " with " + str(arrows_remaining) + " arrows left")
  	
  	# Ermittle Schussrichtung mit Genauigkeitsabweichung
  	var direction = (target.global_position - global_position).normalized()
  	if shooting_accuracy < 1.0:
  		# Füge zufällige Abweichung hinzu
  		var deviation = (1.0 - shooting_accuracy) * 0.2  # Max. 20% Abweichung
  		direction = direction.rotated(randf_range(-deviation, deviation))
  	
  	# Ermittle Startposition (leicht über dem Feind)
  	var spawn_pos = global_position
  	spawn_pos.y -= 5  # Leicht über dem Feind
  	
  	# Check if projectile_scene is valid
  	if projectile_scene == null:
  		print(name + " ERROR: projectile_scene is null! Trying to reload default scene.")
  		projectile_scene = load("res://scenes/core/projectiles/rock.tscn")
  		if projectile_scene == null:
  			print(name + " CRITICAL ERROR: Could not load projectile scene!")
  			return false
  	
  	# Beschaffe ein Projektil aus dem Pool oder erstelle neu
  	var projectile = null
  	if projectile_pool:
  		print(name + " getting projectile from pool")
  		projectile = projectile_pool.get_object()
  		if projectile == null:
  			print(name + " pool returned null projectile!")
  	else:
  		print(name + " projectile pool is null or not initialized!")
  		
  	# Wenn kein Pool vorhanden oder keine Objekte verfügbar, instanziiere neu
  	if not projectile and projectile_scene:
  		print(name + " instantiating new projectile directly")
  		projectile = projectile_scene.instantiate()
  		get_tree().current_scene.add_child(projectile)
  	
  	if projectile:
  		# Konfiguriere das Projektil
  		if projectile.has_method("setup"):
  			print(name + " configuring projectile with setup()")
  			projectile.setup(direction, spawn_pos, 0, self)
  		else:
  			# Fallback, falls setup nicht existiert
  			print(name + " using fallback projectile configuration")
  			projectile.global_position = spawn_pos
  			if "velocity" in projectile:
  				projectile.velocity = direction * projectile.speed
  			if "source_node" in projectile:
  				projectile.source_node = self
  		
  		# Reduziere Pfeile und emittiere Signal
  		arrows_remaining -= 1
  		emit_signal("arrow_shot")
  		
  		# Wenn keine Pfeile mehr, gehe in Nachlademodus
  		if arrows_remaining <= 0:
  			start_reloading()
  		
  		print(name + " successfully fired a projectile")
  		return true
  	
  	print(name + " FAILED to create projectile")
  	return false
  func start_reloading():
  	if is_reloading:
  		return
  		
  	is_reloading = true
  	last_shot_time = 0.0
  	
  	# Spiele Nachladeanimation, wenn vorhanden
  	if animated_sprite and animated_sprite.sprite_frames.has_animation("reload"):
  		animated_sprite.play("reload")
  	else:
  		animated_sprite.play("idle")
  	
  	# Emittiere Signal
  	emit_signal("quiver_empty")
  	print(name + " started reloading...")
  
  # Nachladevorgang abgeschlossen
  func _reload_complete():
  	is_reloading = false
  	arrows_remaining = quiver_size
  	
  	# Emittiere Signal
  	emit_signal("reload_complete")
  	print(name + " finished reloading, arrows: " + str(arrows_remaining))
  
  # Verhaltenssystem-Setup
  func _setup_state_machine():
  	state_machine = EnemyStateMachine.new()
  	state_machine.name = "StateMachine"
  	add_child(state_machine)
  	
  	# Registriere States
  	_register_states()
  	
  	# Konfiguiere die State Machine
  	state_machine.detection_range = detection_radius
  	state_machine.attack_range = attack_radius
  	state_machine.patrol_range = patrol_distance
  	state_machine.can_see_through_walls = false
  	
  	print(name + " state machine initialized with detection_range = " + str(state_machine.detection_range))
  
  # Registriere States bei der State Machine
  func _register_states():
  	# Patrouille-State
  	var patrol_state = EnemyState.PatrolState.new()
  	patrol_state.name = "Patrol"
  	state_machine.add_child(patrol_state)
  	
  	# Verfolgungs-State
  	var chase_state = EnemyState.ChaseState.new()
  	chase_state.name = "Chase"
  	state_machine.add_child(chase_state)
  	
  	# Rückzugs-State
  	var retreat_state = ArcherState.RetreatState.new()
  	retreat_state.name = "Retreat"
  	state_machine.add_child(retreat_state)
  	
  	# Schuss-State
  	var shoot_state = ArcherState.ShootState.new()
  	shoot_state.name = "Shoot"
  	state_machine.add_child(shoot_state)
  	
  	# Nachladen-State
  	var reload_state = ArcherState.ReloadState.new()
  	reload_state.name = "Reload"
  	state_machine.add_child(reload_state)
  	
  	# Verletzt-State
  	var hurt_state = EnemyState.HurtState.new()
  	hurt_state.name = "Hurt"
  	state_machine.add_child(hurt_state)
  	
  	# Tod-State
  	var death_state = EnemyState.DeathState.new()
  	death_state.name = "Death"
  	state_machine.add_child(death_state)
  
  # Signal-Handler
  func _on_player_detected(player):
  	if animated_sprite:
  		# Spieler entdeckt Animation (z.B. Ausrufezeichen)
  		var alert_sprite = $AlertSprite if has_node("AlertSprite") else null
  		if alert_sprite:
  			alert_sprite.visible = true
  			# Verstecke nach 1 Sekunde
  			get_tree().create_timer(1.0).timeout.connect(func(): 
  				alert_sprite.visible = false
  			)
  		print(name + " detected player: " + player.name)
  
  func _on_player_lost():
  	print(name + " lost sight of player")
  
  func _on_died():
  	# Lasse Item fallen bei Tod
  	_drop_loot()
  
  # Loot-Tabelle
  var loot_table = [
  	{"item": "res://scenes/core/items/coins.tscn", "chance": 0.8},
  	{"item": "res://scenes/core/items/power_jump.tscn", "chance": 0.2}
  ]
  
  # Lässt zufälliges Loot fallen
  func _drop_loot():
  	# Zufallsgenerator
  	randomize()
  	
  	# Wähle ein zufälliges Item
  	for loot in loot_table:
  		if randf() <= loot.chance:
  			var item_scene = load(loot.item)
  			if item_scene:
  				var item = item_scene.instantiate()
  				item.global_position = global_position
  				get_tree().current_scene.add_child(item)
  				break
  
  # Schadenshandler für spezifische Angriffe
  func _on_top_checker_body_entered(body):
  	if body.name == "Player" and not is_dead:
  		# Spieler ist von oben auf den Feind gesprungen
  		take_damage(50)  # Großer Schaden
  		
  		# Spieler erhält einen Sprungimpuls nach oben
  		if body.has_method("bounce"):
  			body.bounce()

========================================
Contents of scripts\core\enemies\goblin_mage.gd:
========================================
  class_name GoblinMage
  extends BaseEnemy
  
  ## Goblin Mage - Magier, der Zauber auf den Spieler wirft
  ## Kann sich teleportieren, einen Schild erzeugen und nutzt ein Mana-System
  
  # Goblin Mage-spezifische Eigenschaften
  @export var projectile_scene: PackedScene = preload("res://scenes/core/projectiles/mage_ball.tscn")
  @export var max_mana: float = 100.0
  @export var mana_regen_rate: float = 8.0  # Mana pro Sekunde
  @export var spell_mana_cost: float = 20.0  # Manakosten für einen Zauber
  @export var teleport_mana_cost: float = 30.0  # Manakosten für Teleportation
  @export var shield_mana_cost: float = 40.0  # Manakosten für Schild
  
  # Status
  var current_mana: float
  var is_teleporting: bool = false
  var is_shielding: bool = false
  var teleport_cooldown: float = 3.0
  var last_teleport_time: float = 0.0
  
  # State Machine und States
  var state_machine: EnemyStateMachine
  
  # Objekt-Pool für Projektile
  var projectile_pool: ObjectPool
  
  # Signale
  signal spell_cast(spell_name)
  signal mana_depleted
  signal teleported
  signal shield_activated
  signal shield_deactivated
  
  func _ready():
  	# Setze Basis-Feindwerte
  	max_health = 60.0
  	current_health = max_health
  	speed = 40.0
  	chase_speed = 50.0
  	attack_damage = 75.0  # Höherer Schaden für magische Angriffe (0.75 nach Skalierung)
  	attack_cooldown = 2.0
  	detection_radius = 350.0  # Erhöht von 180.0
  	attack_radius = 300.0    # Erhöht von 150.0
  	patrol_distance = 80.0
  	
  	# Initialisiere Mana
  	current_mana = max_mana
  	
  	# Setze Komponentenreferenzen
  	animated_sprite = $AnimatedSprite2D
  	collision_shape = $CollisionShape2D
  	
  	# Make sure this node is in the enemy group
  	if not is_in_group("enemy"):
  		add_to_group("enemy")
  	
  	# Initialisiere den Objekt-Pool für Projektile
  	_setup_projectile_pool()
  	
  	# Stelle sicher, dass die State Machine initialisiert wird
  	_setup_state_machine()
  	
  	# Debug-Ausgabe
  	print("GoblinMage initialized with:")
  	print("  - Gesundheit: ", max_health)
  	print("  - Mana: ", current_mana)
  	print("  - Geschwindigkeit: ", speed)
  	print("  - Angriffsschaden: ", attack_damage)
  	print("  - Erkennungsradius: ", detection_radius)
  	
  	# Rufe die Elternklasse auf
  	super._ready()
  
  func _physics_process(delta):
  	# Eltern-Physikprozess zuerst ausführen
  	super._physics_process(delta)
  	
  	# Mana-Regeneration
  	if current_mana < max_mana:
  		current_mana = min(current_mana + mana_regen_rate * delta, max_mana)
  	
  	# Teleport-Cooldown aktualisieren
  	if last_teleport_time > 0:
  		last_teleport_time -= delta
  
  # Initialisiere den Objekt-Pool für Projektile
  func _setup_projectile_pool():
  	# Überprüfe, ob projectile_scene gültig ist
  	if projectile_scene == null:
  		push_error("GoblinMage: projectile_scene ist null. Versuche direktes Laden...")
  		projectile_scene = load("res://scenes/core/projectiles/mage_ball.tscn")
  		
  	if projectile_scene == null:
  		push_error("GoblinMage: Konnte projectile_scene nicht laden. Pool wird nicht erstellt.")
  		return
  		
  	# Erstelle Project Pool für bessere Performance
  	projectile_pool = ObjectPool.new(projectile_scene, 8, true)
  	projectile_pool.name = "ProjectilePool"
  	add_child(projectile_pool)
  
  # Wirke einen Zauber
  func cast_spell(spell_name: String = "fireball") -> bool:
  	print(name + " attempting to cast " + spell_name)
  	
  	if is_dead or current_mana < spell_mana_cost:
  		print(name + " can't cast: " + 
  			("is dead" if is_dead else "not enough mana (" + str(current_mana) + "/" + str(spell_mana_cost) + ")"))
  		emit_signal("mana_depleted")
  		return false
  	
  	# Finde das Ziel (über die State Machine)
  	var target = state_machine.target
  	if not target:
  		print(name + " can't cast: no target")
  		return false
  	
  	print(name + " casting at " + target.name + " with " + str(current_mana) + " mana")
  	
  	# Ermittle Zielrichtung
  	var direction = (target.global_position - global_position).normalized()
  	
  	# Ermittle Startposition (leicht über dem Feind)
  	var spawn_pos = global_position
  	spawn_pos.y -= 8  # Leicht über dem Feind
  	
  	# Beschaffe ein Projektil aus dem Pool oder erstelle neu
  	var projectile = null
  	if projectile_pool:
  		projectile = projectile_pool.get_object()
  	
  	# Wenn kein Pool vorhanden oder keine Objekte verfügbar, instanziiere neu
  	if not projectile and projectile_scene:
  		projectile = projectile_scene.instantiate()
  		get_tree().current_scene.add_child(projectile)
  	
  	if projectile:
  		# Konfiguriere das Projektil
  		if projectile.has_method("setup"):
  			projectile.setup(direction, spawn_pos, 0, self)
  		else:
  			# Fallback, falls setup nicht existiert
  			projectile.global_position = spawn_pos
  			if "velocity" in projectile:
  				projectile.velocity = direction * projectile.speed
  			if "source_node" in projectile:
  				projectile.source_node = self
  		
  		# Reduziere Mana und emittiere Signal
  		current_mana -= spell_mana_cost
  		emit_signal("spell_cast", spell_name)
  		
  		# Zeige Zaubereffekt an
  		_show_cast_effect(spawn_pos)
  		
  		print(name + " successfully cast a spell, remaining mana: " + str(current_mana))
  		return true
  	
  	print(name + " failed to create spell projectile")
  	return false
  
  # Teleportieren zu einer neuen Position
  func teleport():
  	if is_dead or current_mana < teleport_mana_cost or last_teleport_time > 0:
  		print(name + " can't teleport: " + 
  			("is dead" if is_dead else 
  			"not enough mana" if current_mana < teleport_mana_cost else
  			"on cooldown"))
  		return false
  	
  	is_teleporting = true
  	
  	# Finde Zielposition
  	var teleport_pos = _find_teleport_position()
  	
  	# Fade-Out Effekt
  	var tween = create_tween()
  	tween.tween_property(self, "modulate:a", 0.0, 0.2)
  	
  	# Auf Tween-Ende warten
  	await tween.finished
  	
  	# Teleportiere
  	global_position = teleport_pos
  	
  	# Fade-In Effekt
  	tween = create_tween()
  	tween.tween_property(self, "modulate:a", 1.0, 0.2)
  	
  	# Reduziere Mana
  	current_mana -= teleport_mana_cost
  	
  	# Setze Cooldown
  	last_teleport_time = teleport_cooldown
  	
  	# Signal senden
  	emit_signal("teleported")
  	
  	is_teleporting = false
  	print(name + " teleported to " + str(teleport_pos))
  	return true
  
  # Finde eine gute Position zum Teleportieren
  func _find_teleport_position() -> Vector2:
  	var target = state_machine.target
  	var possible_positions = []
  	
  	# Wenn kein Ziel, teleportiere zufällig um die aktuelle Position
  	if not target:
  		for i in range(4):
  			var angle = randf() * 2 * PI
  			var distance = randf_range(80, 120)
  			possible_positions.append(global_position + Vector2(cos(angle), sin(angle)) * distance)
  	else:
  		# Teleportiere zu Positionen, die einen optimalen Abstand zum Spieler haben
  		for i in range(4):
  			var angle = randf() * 2 * PI
  			var distance = randf_range(100, 150)
  			possible_positions.append(target.global_position + Vector2(cos(angle), sin(angle)) * distance)
  	
  	# Wähle eine zufällige Position
  	return possible_positions[randi() % possible_positions.size()]
  
  # Aktiviere einen magischen Schild
  func activate_shield():
  	if is_dead or current_mana < shield_mana_cost or is_shielding:
  		print(name + " can't activate shield: " + 
  			("is dead" if is_dead else 
  			"not enough mana" if current_mana < shield_mana_cost else
  			"shield already active"))
  		return false
  	
  	is_shielding = true
  	
  	# Erstelle Schild-Effekt
  	var shield = Node2D.new()
  	shield.name = "MagicShield"
  	add_child(shield)
  	
  	# Erstelle Schild-Sprite
  	var shield_sprite = Sprite2D.new()
  	shield_sprite.texture = load("res://icon.png")  # Ersetze mit aktuellem Schild-Texture
  	shield_sprite.scale = Vector2(1.5, 1.5)
  	shield_sprite.modulate = Color(0.3, 0.7, 1.0, 0.5)
  	shield.add_child(shield_sprite)
  	
  	# Reduziere Mana
  	current_mana -= shield_mana_cost
  	
  	# Signal senden
  	emit_signal("shield_activated")
  	
  	# Mache den Feind vorübergehend unverwundbar
  	is_invulnerable = true
  	
  	print(name + " activated shield")
  	
  	# Deaktiviere Schild nach einer Zeit
  	get_tree().create_timer(5.0).timeout.connect(func():
  		if is_shielding:
  			deactivate_shield()
  	)
  	
  	return true
  
  # Deaktiviere den Schild
  func deactivate_shield():
  	if not is_shielding:
  		return
  	
  	is_shielding = false
  	
  	# Entferne Schild-Node
  	if has_node("MagicShield"):
  		$MagicShield.queue_free()
  	
  	# Deaktiviere Unverwundbarkeit
  	is_invulnerable = false
  	
  	# Signal senden
  	emit_signal("shield_deactivated")
  	print(name + " deactivated shield")
  
  # Zaubereffekt anzeigen
  func _show_cast_effect(position):
  	# Erstelle einen Zauberkreis-Effekt, wenn nicht im Pool
  	var effect = CPUParticles2D.new()
  	effect.position = position - global_position  # Relativ zur Mage-Position
  	effect.emitting = true
  	effect.one_shot = true
  	effect.explosiveness = 0.8
  	effect.amount = 16
  	effect.lifetime = 0.5
  	effect.emission_shape = CPUParticles2D.EMISSION_SHAPE_SPHERE
  	effect.emission_sphere_radius = 5.0
  	effect.color = Color(0.5, 0.1, 0.9, 0.8)
  	add_child(effect)
  	
  	# Entferne nach der Lebenszeit
  	get_tree().create_timer(effect.lifetime * 1.5).timeout.connect(func():
  		effect.queue_free()
  	)
  
  # Überschreibe die Schadensnahme-Funktion, um auf Schild zu prüfen
  func take_damage(amount):
  	# Wenn der Schild aktiv ist, teleportiere anstatt Schaden zu nehmen
  	if is_shielding:
  		teleport()
  		return
  	
  	# Sonst normal Schaden nehmen
  	super.take_damage(amount)
  	
  	# Bei niedrigem Leben, versuche zu teleportieren
  	if current_health < max_health * 0.3 and randf() < 0.5:
  		teleport()
  
  # Verhaltenssystem-Setup
  func _setup_state_machine():
  	state_machine = EnemyStateMachine.new()
  	state_machine.name = "StateMachine"
  	add_child(state_machine)
  	
  	# Registriere States
  	_register_states()
  	
  	# Konfiguiere die State Machine
  	state_machine.detection_range = detection_radius
  	state_machine.attack_range = attack_radius
  	state_machine.patrol_range = patrol_distance
  	state_machine.can_see_through_walls = false
  	
  	print(name + " state machine initialized with detection_range = " + str(state_machine.detection_range))
  
  # Registriere States bei der State Machine
  func _register_states():
  	# Patrouille-State
  	var patrol_state = EnemyState.PatrolState.new()
  	patrol_state.name = "Patrol"
  	state_machine.add_child(patrol_state)
  	
  	# Verfolgungs-State
  	var chase_state = EnemyState.ChaseState.new()
  	chase_state.name = "Chase"
  	state_machine.add_child(chase_state)
  	
  	# Zauber-State
  	var cast_state = MageState.CastState.new()
  	cast_state.name = "Cast"
  	state_machine.add_child(cast_state)
  	
  	# Teleport-State
  	var teleport_state = MageState.TeleportState.new()
  	teleport_state.name = "Teleport"
  	state_machine.add_child(teleport_state)
  	
  	# Shield-State
  	var shield_state = MageState.ShieldState.new()
  	shield_state.name = "Shield"
  	state_machine.add_child(shield_state)
  	
  	# Verletzt-State
  	var hurt_state = EnemyState.HurtState.new()
  	hurt_state.name = "Hurt"
  	state_machine.add_child(hurt_state)
  	
  	# Tod-State
  	var death_state = EnemyState.DeathState.new()
  	death_state.name = "Death"
  	state_machine.add_child(death_state)
  
  # Signal-Handler
  func _on_player_detected(player):
  	if animated_sprite:
  		# Spieler entdeckt Animation (z.B. Ausrufezeichen)
  		var alert_sprite = $AlertSprite if has_node("AlertSprite") else null
  		if alert_sprite:
  			alert_sprite.visible = true
  			# Verstecke nach 1 Sekunde
  			get_tree().create_timer(1.0).timeout.connect(func(): 
  				alert_sprite.visible = false
  			)
  		print(name + " detected player: " + player.name)
  
  func _on_player_lost():
  	print(name + " lost sight of player")
  
  func _on_died():
  	# Lasse Item fallen bei Tod
  	_drop_loot()
  	
  	# Eventuell einen Energieausbruch erzeugen
  	_create_death_explosion()
  
  # Energieausbruch bei Tod
  func _create_death_explosion():
  	# Erstelle Explosion mit Partikeln
  	var explosion = CPUParticles2D.new()
  	explosion.position = global_position
  	explosion.emitting = true
  	explosion.one_shot = true
  	explosion.explosiveness = 1.0
  	explosion.amount = 32
  	explosion.lifetime = 0.8
  	explosion.spread = 180.0
  	explosion.initial_velocity_min = 50.0
  	explosion.initial_velocity_max = 100.0
  	explosion.color = Color(0.8, 0.2, 0.9, 0.8)
  	get_tree().current_scene.add_child(explosion)
  	
  	# Entferne nach Animation
  	get_tree().create_timer(explosion.lifetime * 1.5).timeout.connect(func():
  		explosion.queue_free()
  	)
  
  # Loot-Tabelle
  var loot_table = [
  	{"item": "res://scenes/core/items/coins.tscn", "chance": 0.7},
  	{"item": "res://scenes/core/items/elixir.tscn", "chance": 0.3},
  	{"item": "res://scenes/core/items/power_fly.tscn", "chance": 0.1}
  ]
  
  # Lässt zufälliges Loot fallen
  func _drop_loot():
  	# Zufallsgenerator
  	randomize()
  	
  	# Wähle ein zufälliges Item
  	for loot in loot_table:
  		if randf() <= loot.chance:
  			var item_scene = load(loot.item)
  			if item_scene:
  				var item = item_scene.instantiate()
  				item.global_position = global_position
  				get_tree().current_scene.add_child(item)
  				break
  
  # Schadenshandler für spezifische Angriffe
  func _on_top_checker_body_entered(body):
  	if body.name == "Player" and not is_dead and not is_shielding:
  		# Spieler ist von oben auf den Feind gesprungen
  		take_damage(50)  # Großer Schaden
  		
  		# Spieler erhält einen Sprungimpuls nach oben
  		if body.has_method("bounce"):
  			body.bounce()
  		
  		# 50% Chance auf Teleport bei Sprung-Angriff
  		if randf() < 0.5:
  			teleport()

========================================
Contents of scripts\core\enemies\goblin_melee.gd:
========================================
  class_name GoblinMelee
  extends BaseEnemy
  
  ## Goblin Melee - Nahkämpfer, der aggressiv den Spieler verfolgt und angreift
  ## Wird wütend, wenn verwundet und erhält Kampfboni
  
  # Goblin Melee spezifische Eigenschaften
  @export var rage_threshold: float = 0.3  # Schwellenwert für Wut (0.3 = 30% Gesundheit)
  @export var rage_damage_bonus: float = 1.5  # 50% mehr Schaden im Wut-Modus
  @export var rage_speed_bonus: float = 1.3  # 30% mehr Geschwindigkeit im Wut-Modus
  # Rage Status
  var is_enraged: bool = false
  var base_speed: float
  var base_attack_damage: float
  
  # State Machine und States
  var state_machine: EnemyStateMachine
  
  # Signal bei Eintritt in Wut-Modus
  signal entered_rage_mode
  
  func _ready():
  	# Setze Basis-Feindwerte
  	max_health = 100.0
  	current_health = max_health
  	speed = 60.0
  	chase_speed = 80.0
  	attack_damage = 50.0  # Realistischerer Wert, entspricht 0.5 nach Skalierung (/100)
  	attack_cooldown = 1.5
  	detection_radius = 150.0
  	attack_radius = 40.0
  	patrol_distance = 120.0
  	
  	# Speichere Basiswerte für Wut-Modus
  	base_speed = speed
  	base_attack_damage = attack_damage
  	
  	# Setze Komponentenreferenzen
  	animated_sprite = $AnimatedSprite2D
  	collision_shape = $CollisionShape2D
  	
  	# Stelle sicher, dass die State Machine initialisiert wird
  	_setup_state_machine()
  	
  	# Drucke Debug-Info
  	print("GoblinMelee initialisiert mit folgenden Werten:")
  	print("  - Gesundheit: ", max_health)
  	print("  - Geschwindigkeit: ", speed)
  	print("  - Angriffsschaden: ", attack_damage)
  	print("  - Erkennungsradius: ", detection_radius)
  	
  	# Rufe die Elternklasse auf
  	super._ready()
  
  func _physics_process(delta):
  	# Eltern-Physikprozess zuerst ausführen
  	super._physics_process(delta)
  	
  	# Im Wut-Modus gibt es einen Partikeleffekt
  	if is_enraged and has_node("RageParticles") and not $RageParticles.emitting:
  		$RageParticles.emitting = true
  
  # Überschreibe die Schadensnahme-Funktion, um Wut-Modus zu prüfen
  func take_damage(amount):
  	super.take_damage(amount)
  	
  	# Prüfe, ob der Wut-Schwellenwert erreicht wurde
  	if not is_enraged and current_health <= max_health * rage_threshold:
  		enter_rage_mode()
  
  # Aktiviere den Wut-Modus
  func enter_rage_mode():
  	if is_enraged:
  		return
  		
  	is_enraged = true
  	
  	# Erhöhe Kampfwerte
  	speed = base_speed * rage_speed_bonus
  	chase_speed = speed * 1.2  # Verhältnis beibehalten
  	attack_damage = base_attack_damage * rage_damage_bonus
  	
  	# Visueller Effekt
  	modulate = Color(1.3, 0.7, 0.7)
  	
  	# Spiele einen Wutschrei ab
  	if has_node("RageSound"):
  		$RageSound.play()
  	
  	# Erstelle Partikeleffekt wenn noch nicht vorhanden
  	if not has_node("RageParticles"):
  		var particles = CPUParticles2D.new()
  		particles.name = "RageParticles"
  		particles.amount = 10
  		particles.lifetime = 0.5
  		particles.emission_shape = CPUParticles2D.EMISSION_SHAPE_SPHERE
  		particles.emission_sphere_radius = 10.0
  		particles.gravity = Vector2(0, -20)
  		particles.initial_velocity_min = 10.0
  		particles.initial_velocity_max = 20.0
  		particles.color = Color(1.0, 0.3, 0.1, 0.7)
  		add_child(particles)
  		particles.emitting = true
  	
  	# Signal senden
  	emit_signal("entered_rage_mode")
  	
  	# Wechsle zu Rage-State wenn verfügbar
  	if state_machine and state_machine.has_state("Rage"):
  		state_machine.change_state("Rage")
  	
  	print("Goblin ist in Wut-Modus!")
  
  # Registriere einen Treffer, der Wut erzeugen kann
  func register_hit(attacker):
  	if attacker and attacker.name == "Player":
  		# Erhöhe Chance auf Wut
  		if not is_enraged and current_health <= max_health * 0.5:
  			if randf() < 0.3:  # 30% Chance auf Wut bei <50% Gesundheit
  				enter_rage_mode()
  
  # Verhaltenssystem-Setup
  func _setup_state_machine():
  	state_machine = EnemyStateMachine.new()
  	state_machine.name = "StateMachine"
  	add_child(state_machine)
  	
  	# Registriere States
  	_register_states()
  	
  	# Konfiguiere die State Machine
  	state_machine.detection_range = detection_radius
  	state_machine.attack_range = attack_radius
  	state_machine.patrol_range = patrol_distance
  	state_machine.can_see_through_walls = false
  
  # Registriere States bei der State Machine
  func _register_states():
  	# Patrouille-State
  	var patrol_state = EnemyState.PatrolState.new()
  	patrol_state.name = "Patrol"
  	state_machine.add_child(patrol_state)
  	
  	# Verfolgungs-State
  	var chase_state = EnemyState.ChaseState.new()
  	chase_state.name = "Chase"
  	state_machine.add_child(chase_state)
  	
  	# Angriffs-State
  	var attack_state = EnemyState.AttackState.new()
  	attack_state.name = "Attack"
  	state_machine.add_child(attack_state)
  	
  	# Verletzt-State
  	var hurt_state = EnemyState.HurtState.new()
  	hurt_state.name = "Hurt"
  	state_machine.add_child(hurt_state)
  	
  	# Tod-State
  	var death_state = EnemyState.DeathState.new()
  	death_state.name = "Death"
  	state_machine.add_child(death_state)
  	
  	# Register the specialized melee states
  	MeleeState.register_melee_states(state_machine, self)
  
  # Signal-Handler
  func _on_player_detected(player):
  	if animated_sprite:
  		# Spieler entdeckt Animation (z.B. Ausrufezeichen)
  		var alert_sprite = $AlertSprite if has_node("AlertSprite") else null
  		if alert_sprite:
  			alert_sprite.visible = true
  			# Verstecke nach 1 Sekunde
  			get_tree().create_timer(1.0).timeout.connect(func(): 
  				alert_sprite.visible = false
  			)
  
  func _on_player_lost():
  	pass
  
  func _on_died():
  	# Lasse Item fallen bei Tod
  	_drop_loot()
  
  # Loot-Tabelle
  var loot_table = [
  	{"item": "res://scenes/core/items/coins.tscn", "chance": 0.7},
  	{"item": "res://scenes/core/items/elixir.tscn", "chance": 0.1},
  	{"item": "res://scenes/core/items/power_attack.tscn", "chance": 0.05}
  ]
  
  # Lässt zufälliges Loot fallen
  func _drop_loot():
  	# Zufallsgenerator
  	randomize()
  	
  	# Wähle ein zufälliges Item
  	for loot in loot_table:
  		if randf() <= loot.chance:
  			var item_scene = load(loot.item)
  			if item_scene:
  				var item = item_scene.instantiate()
  				item.global_position = global_position
  				get_tree().current_scene.add_child(item)
  				break
  
  # Schadenshandler für spezifische Angriffe
  func _on_top_checker_body_entered(body):
  	if body.name == "Player" and not is_dead:
  		# Spieler ist von oben auf den Feind gesprungen
  		take_damage(50)  # Großer Schaden
  		
  		# Spieler erhält einen Sprungimpuls nach oben
  		if body.has_method("bounce"):
  			body.bounce()

========================================
Contents of scripts\core\enemies\prince_enemy.gd:
========================================
  class_name PrinceEnemy
  extends BaseEnemy
  
  ## Simple patrol enemy that walks back and forth (used in prince levels)
  
  @export var direction: int = 1  # 1 = right, -1 = left
  @export var damage_on_touch: float = 10.0  # Damage dealt when touching player
  
  @onready var ray_cast_right: RayCast2D = $RayCastRight
  @onready var ray_cast_left: RayCast2D = $RayCastLeft
  
  var start_position: Vector2
  var is_patrolling: bool = true
  
  func _ready():
  	# Set base enemy properties
  	max_health = 40.0
  	speed = 60.0
  	chase_speed = speed  # Same as normal speed since this enemy doesn't chase
  	attack_damage = damage_on_touch
  	
  	# Set references
  	animated_sprite = $AnimatedSprite2D
  	collision_shape = $CollisionShape2D
  	
  	# Store starting position
  	start_position = global_position
  	
  	# Initialize raycasts if not already set
  	if not ray_cast_right:
  		ray_cast_right = $RayCastRight if has_node("RayCastRight") else null
  		
  	if not ray_cast_left:
  		ray_cast_left = $RayCastLeft if has_node("RayCastLeft") else null
  	
  	# Call parent ready method
  	super._ready()
  	
  	# Start patrol behavior
  	play_animation("walk")
  
  func _physics_process(delta):
  	# Call parent implementation for gravity and movement
  	super._physics_process(delta)
  	
  	# Handle patrol logic if not chasing or attacking
  	if is_patrolling and not is_dead:
  		patrol()
  
  func patrol():
  	# Check wall collisions
  	if ray_cast_right and ray_cast_right.is_colliding():
  		direction = -1
  		animated_sprite.flip_h = false
  	elif ray_cast_left and ray_cast_left.is_colliding():
  		direction = 1
  		animated_sprite.flip_h = true
  	
  	# Set movement velocity
  	velocity.x = direction * speed
  	
  	# Play walk animation
  	play_animation("walk")
  
  # Override to handle damage-on-touch behavior
  func _on_body_entered(body):
  	if body.name == "Player" and not is_dead:
  		# Deal damage to player
  		if body.has_method("take_damage"):
  			body.take_damage(damage_on_touch)
  		
  		# Update HUD
  		if hud and hud.has_method("change_life"):
  			hud.change_life(-damage_on_touch/100.0)  # Assuming health is on 0-1 scale for HUD
========================================
Contents of scripts\core\items\coins.gd:
========================================
  class_name Coins
  extends Area2D
  
  signal coin_collected
  
  
  
  func _on_coins_body_entered(body):
  	get_parent().get_node("HUD").coin_collected()
  	$AnimationPlayer.play("bounce")
  	set_collision_mask_value(1,false)
  
  
  func _on_animation_player_animation_finished(anim_name):
  	queue_free()

========================================
Contents of scripts\core\items\elixir.gd:
========================================
  class_name Elixir
  extends BasePowerUp
  
  ## Power-up that gives the player temporary flying ability via a magical elixir
  
  func _ready():
  	# Set power-up properties
  	power_up_name = "Magic Elixir"
  	description = "Grants temporary flying ability"
  	effect_duration = 20.0  # 20 seconds of flight
  	destroy_on_pickup = true
  	
  	# Set animation properties (optional: tweak to differentiate visually from Angel Wings)
  	bounce_height = 6.0
  	bounce_speed = 2.0
  	rotation_speed = 1.0
  	
  	# Call parent ready method
  	super._ready()
  
  func apply_effect(player):
  	# Call the parent implementation for signals
  	super.apply_effect(player)
  	
  	# Set the player's movement mode
  	if player.has_method("set_movement_mode"):
  		player.set_movement_mode("fly")
  	else:
  		player.mode = "fly"
  		
  	print("Player gained flight ability via Elixir")
  
  	# Update the Elixir fill in HUD
  	var hud = get_tree().get_root().find_child("HUD", true, false)
  	if hud:
  		hud.collect_softpower()  # This will add 25% elixir
  
  	# Show notification to player
  	var popup_manager = get_node_or_null("/root/PopupManager")
  	if popup_manager:
  		popup_manager.info("Elixir Power", "You've drunk the magic elixir! You can fly for " + str(effect_duration) + " seconds.")
  	
  	# Add a visible timer to the HUD if available
  	if hud and hud.has_method("show_ability_timer"):
  		hud.show_ability_timer("Flight", effect_duration)
  
  func remove_effect(player):
  	# Set the player's movement mode back to normal
  	if player.has_method("set_movement_mode"):
  		player.set_movement_mode("normal")
  	else:
  		player.mode = "normal"
  		
  	player.passed_fly_time = 0.0
  	
  	# Let the player know the effect has ended
  	var popup_manager = get_node_or_null("/root/PopupManager")
  	if popup_manager:
  		popup_manager.info("Elixir Expired", "The elixir's magic has worn off. You can't fly anymore.")
  	
  	super.remove_effect(player)

========================================
Contents of scripts\core\items\power_attack.gd:
========================================
  class_name PowerAttack
  extends BasePowerUp
  
  ## Power-up that gives the player an axe attack ability
  
  func _ready():
  	# Set power-up properties
  	power_up_name = "Battle Axe"
  	description = "Grants the ability to attack with a powerful axe"
  	destroy_on_pickup = true
  	
  	# Set animation properties
  	bounce_height = 5.0
  	bounce_speed = 2.0
  	rotation_speed = 1.0
  	
  	# Call parent ready method
  	super._ready()
  
  func apply_effect(player):
  	# Call the parent implementation for signals
  	super.apply_effect(player)
  	
  	# Set the player's attack animation
  	if player.has_method("set_attack_animation"):
  		player.set_attack_animation("walking6")
  	else:
  		# Fallback for current implementation
  		player.attack_animation = "walking6"
  		
  	# Enable attack ability if player has the method
  	if player.has_method("enable_attack"):
  		player.enable_attack(true)
  	
  	print("Player gained axe attack ability")
  	
  	# Show notification to player
  	var popup_manager = get_node_or_null("/root/PopupManager")
  	if popup_manager:
  		popup_manager.info("New Ability", "You've acquired a battle axe! Press the attack button to use it.")

========================================
Contents of scripts\core\items\power_fly.gd:
========================================
  class_name PowerFly
  extends BasePowerUp
  
  ## Power-up that gives the player temporary flying ability
  
  func _ready():
  	# Set power-up properties
  	power_up_name = "Angel Wings"
  	description = "Grants temporary flying ability"
  	effect_duration = 20.0  # 20 seconds of flight
  	destroy_on_pickup = true
  	
  	# Set animation properties
  	bounce_height = 8.0
  	bounce_speed = 1.5
  	rotation_speed = 0.5
  	
  	# Call parent ready method
  	super._ready()
  
  func apply_effect(player):
  	# Call the parent implementation for signals
  	super.apply_effect(player)
  	
  	# Set the player's movement mode
  	if player.has_method("set_movement_mode"):
  		player.set_movement_mode("fly")
  	else:
  		# Fallback for current implementation
  		player.mode = "fly"
  		
  	print("Player gained flight ability")
  	
  	# Show notification to player
  	var popup_manager = get_node_or_null("/root/PopupManager")
  	if popup_manager:
  		popup_manager.info("New Ability", "You've acquired angel wings! You can now fly for " + str(effect_duration) + " seconds.")
  	
  	# Add a visible timer to the HUD if available
  	var hud = get_node_or_null("../../HUD")
  	if hud and hud.has_method("show_ability_timer"):
  		hud.show_ability_timer("Flight", effect_duration)
  
  func remove_effect(player):
  	# Set the player's movement mode back to normal
  	if player.has_method("set_movement_mode"):
  		player.set_movement_mode("normal")
  	else:
  		# Fallback for current implementation
  		player.mode = "normal"
  		
  	# Reset player's flight timer
  	player.passed_fly_time = 0.0
  	
  	# Let the player know the effect has ended
  	var popup_manager = get_node_or_null("/root/PopupManager")
  	if popup_manager:
  		popup_manager.info("Ability Expired", "Your angel wings have disappeared.")
  	
  	# Call the parent implementation for signals
  	super.remove_effect(player)

========================================
Contents of scripts\core\items\power_jump.gd:
========================================
  class_name PowerJump
  extends BasePowerUp
  
  ## Power-up that gives the player double jump ability
  
  @export var extra_jumps: int = 1  # How many extra jumps to grant
  
  func _ready():
  	# Set power-up properties
  	power_up_name = "Feather Boots"
  	description = "Grants the ability to double jump"
  	destroy_on_pickup = true
  	
  	# Set animation properties
  	bounce_height = 10.0
  	bounce_speed = 3.0
  	rotation_speed = 0.0
  	
  	# Call parent ready method
  	super._ready()
  
  func apply_effect(player):
  	# Call the parent implementation for signals
  	super.apply_effect(player)
  	
  	# Increase player's allowed jumps
  	if player.has_method("add_extra_jumps"):
  		player.add_extra_jumps(extra_jumps)
  	else:
  		# Fallback for current implementation
  		player.allowed_jumps += extra_jumps
  		
  	# Set the player's movement mode to normal (in case they were flying)
  	if player.has_method("set_movement_mode"):
  		player.set_movement_mode("normal")
  	else:
  		# Fallback for current implementation
  		player.mode = "normal"
  	
  	print("Player gained double jump ability")
  	
  	# Show notification to player
  	var popup_manager = get_node_or_null("/root/PopupManager")
  	if popup_manager:
  		if extra_jumps == 1:
  			popup_manager.info("New Ability", "You've acquired Feather Boots! You can now double jump in mid-air.")
  		else:
  			popup_manager.info("New Ability", "You've acquired Feather Boots! You can now perform " + str(extra_jumps + 1) + " jumps in a row.")
========================================
Contents of scripts\core\player\character_sprites.gd:
========================================
  class_name CharacterSprites
  extends Node2D
  
  var animation_frames = {
  	"idle": [0, 1, 2, 3, 4, 5, 6, 7],
  	"animation1": [8, 9, 10, 11, 12, 13, 14, 15],
  	"animation2": [16, 17, 18, 19, 20, 21, 22, 23],
  	"walking": [24, 25, 26, 27, 28, 29, 30, 31],
  	"animation4": [32, 33, 34, 35, 36],
  	"animation5": [40, 41, 42, 43, 44],
  	"animation6": [48, 49, 50, 51, 52],
  	"animation7": [56, 57, 58, 59, 60],
  	"animation8": [64, 65, 66, 67, 68],
  	"animation9": [72, 73, 74, 75, 76],
  	"animation10": [80, 81, 82, 83, 84],
  	"animation11": [88, 89, 90, 91, 92],
  	"animation12": [96, 97, 98, 99, 100, 101, 102, 103],
  	"animation13": [104, 105, 106, 107, 108, 109, 110, 111],
  	"animation14": [112, 113, 114, 115, 116, 117, 118, 119],
  	"animation15": [120, 121, 122, 123, 124, 125, 126, 127],
  	"animation16": [128, 129, 130, 131],
  	"animation17": [136, 137, 138, 139],
  	"animation18": [144, 145, 146, 147], #attack knife
  	"animation19": [152, 153, 154, 155],
  	"animation20": [160],
  	"animation21": [168],
  	"animation22": [176],
  	"animation23": [184],
  	"animation24": [192],
  	"animation25": [200],
  	"animation26": [208],
  	"animation27": [216],
  	"dead": [224, 225],
  	"animation29": [232, 233, 234, 235, 236],
  	"walking0": [240, 241, 242, 243, 244],
  	"walking1": [248, 249, 250, 251, 252],
  	"walking2": [256, 257, 258, 259, 260],
  	"walking3": [264, 265, 266, 267, 268],
  	"walking4": [272, 273, 274, 275, 276],
  	"walking5": [280, 281, 282, 283, 284], #attack axe right
  	"walking6": [288, 289, 290, 291, 292], #attack axe left
  	"walking7": [296, 297],
  	"walking8": [304, 305],
  	"walking9": [312, 313],
  	"animation40": [320, 321],
  	"animation41": [328, 329, 330, 331, 332],
  	"animation42": [336, 337, 338, 339, 340],
  	"animation43": [344, 345, 346, 347, 348],
  	"animation44": [352, 353, 354, 355, 356],
  	"animation45": [360, 361, 362, 363, 364],
  	"animation46": [368, 369, 370, 371, 372],
  	"animation47": [376, 377, 378, 379, 380],
  	"animation48": [384, 385, 386, 387, 388],
  	"hurt":        [25*8, 27*8],
  }
  
  var default_outfit = {
  	"beard": 1,
  	"lipstick": 1,
  	"eyes": 1,
  	"shoes": 1,
  	"earrings": 1,
  	"hats": 1,
  	"glasses": 1,
  	"clothes_down": 1,
  	"clothes_up": 1,
  	"clothes_complete": 1,
  	"bodies": 1,
  	"hair": 1
  }

========================================
Contents of scripts\core\player\player.gd:
========================================
  class_name Player
  extends CharacterBody2D
  
  @export var joystick_right: VirtualJoystick
  @export var debug_mode: bool = false
  
  # Environment variables - use constants from Constants singleton
  var SPEED = Constants.PLAYER_DEFAULT_SPEED
  var JUMP_VELOCITY = Constants.PLAYER_DEFAULT_JUMP_VELOCITY
  var FLY_VELOCITY = Constants.PLAYER_DEFAULT_FLY_VELOCITY
  var GRAVITY = Constants.PLAYER_DEFAULT_GRAVITY
  
  # Character mode variables
  var mode = "normal"
  var passed_fly_time = 0.0
  var jump_counter = 0
  var ready_for_jump = true
  var allowed_jumps = Constants.PLAYER_MAX_JUMPS
  
  # Character health reference
  var hud
  
  # Character design variables
  var player_animations
  var current_animation = Constants.ANIMATION_IDLE
  var player_outfit
  var play_attack_animation = false
  var attack_animation = Constants.ANIMATION_ATTACK
  
  # Resource-based outfit system
  var current_outfit: PlayerOutfitResource = null
  
  # Reference to the state machine
  @onready var state_machine = $StateMachine
  
  func _ready() -> void:
  	# Initialize your global variables here
  	hud = get_node_or_null("../../HUD")
  	player_animations = get_node("character_sprites").animation_frames
  
  	# Initialize outfit with defaults
  	var default_player_outfit = get_node("character_sprites").default_outfit
  	get_node("character_sprites/masks").visible = false
  	player_outfit = default_player_outfit.duplicate(true)
  
  	# Create outfit resource
  	current_outfit = PlayerOutfitResource.new()
  
  	# Register with GameManager
  	if get_node_or_null("/root/Global"):
  		Global.register_player(self)
  
  	# Connect to SaveManager signals
  	if get_node_or_null("/root/SaveManager"):
  		SaveManager.connect("load_completed", Callable(self, "_on_save_loaded"))
  		SaveManager.connect("settings_loaded", Callable(self, "_on_settings_loaded"))
  		
  		# Load settings from SaveManager
  		if SaveManager.current_save_data:
  			update_from_save_data()
  	
  	_setup_state_machine()
  	
  	if debug_mode:
  		print("Player ready, State Machine initialized")
  		print("Initial player stats: Speed=", SPEED, ", Jump=", JUMP_VELOCITY,
  			  ", Fly=", FLY_VELOCITY, ", Gravity=", GRAVITY)
  
  # Setup the state machine and initialize all player states
  func _setup_state_machine():
  	# Check if StateMachine node exists
  	if not has_node("StateMachine"):
  		var sm = StateMachine.new()
  		sm.name = "StateMachine"
  		add_child(sm)
  		state_machine = sm
  	
  	# Set owner reference for StateMachine
  	state_machine.owner_node = self
  	
  	# Set debug mode
  	state_machine.debug_mode = debug_mode
  	
  	# Add all player states as children
  	_add_player_states()
  
  # Add all player states to the state machine
  func _add_player_states():
  	# If states already exist, don't add them again
  	if state_machine.get_child_count() > 0:
  		return
  	
  	# Define state classes to use (imported from player_states)
  	var state_classes = {
  		"PlayerIdleState": PlayerIdleState,
  		"PlayerWalkState": PlayerWalkState,
  		"PlayerJumpState": PlayerJumpState,
  		"PlayerFallState": PlayerFallState,
  		"PlayerAttackState": PlayerAttackState,
  		"PlayerFlyState": PlayerFlyState,
  		"PlayerHurtState": PlayerHurtState,
  		"PlayerDeathState": PlayerDeathState
  	}
  	
  	# Add each state as a child node
  	for state_name in state_classes:
  		var state = state_classes[state_name].new()
  		state.name = state_name
  		state_machine.add_child(state)
  		
  		# Register the state with the state machine
  		state_machine.register_state(state)
  	
  	# Set initial state to Idle
  	state_machine.change_state("PlayerIdleState")
  	
  	if debug_mode:
  		print("Player states added to StateMachine:", state_machine.states.keys())
  
  # Save current player settings
  func save_settings():
  	if get_node_or_null("/root/SaveManager"):
  		SaveManager.save_settings()
  
  # New methods for SaveManager integration
  func _on_save_loaded(success, message):
  	if success:
  		update_from_save_data()
  
  func _on_settings_loaded(success):
  	if success:
  		update_from_save_data()
  
  func update_from_save_data():
  	if not get_node_or_null("/root/SaveManager") or not SaveManager.current_save_data:
  		print("No save data available to update from")
  		return
  
  	var save_data = SaveManager.current_save_data
  	
  	# Update movement parameters
  	SPEED = save_data.player_speed
  	JUMP_VELOCITY = save_data.player_jump_velocity
  	FLY_VELOCITY = save_data.player_fly_velocity
  	GRAVITY = save_data.player_gravity
  	
  	# Update state
  	mode = save_data.player_mode
  	passed_fly_time = save_data.player_passed_fly_time
  	jump_counter = save_data.player_jump_counter
  	ready_for_jump = save_data.player_ready_for_jump
  	allowed_jumps = save_data.player_allowed_jumps
  
  	# Apply outfit if available
  	if save_data.player_outfit and not save_data.player_outfit.is_empty():
  		# Update resource and dictionary
  		if current_outfit:
  			current_outfit.from_dictionary(save_data.player_outfit)
  		else:
  			current_outfit = PlayerOutfitResource.new().from_dictionary(save_data.player_outfit)
  
  		# Apply current outfit to character
  		player_outfit = save_data.player_outfit.duplicate(true)
  		_update_outfit_visuals()
  		
  	if debug_mode:
  		print("Updated player from save data: Speed=", SPEED, ", Jump=", JUMP_VELOCITY)
  		print("Outfit loaded:", player_outfit)
  
  # Update outfit sprite visibility and animations
  func _update_outfit_visuals():
  	for category in player_outfit:
  		if has_node("character_sprites/" + category):
  			var sprite = get_node("character_sprites/" + category)
  			var value = str(player_outfit[category])
  			
  			if value == "none":
  				sprite.visible = false
  			else:
  				sprite.visible = true
  				sprite.animation = value
  				sprite.frame = 1
  
  # Helper method to play animations
  func play_animation(anim_name: String):
  	current_animation = anim_name
  
  # Return gravity as a Vector2 to avoid conflicts with PhysicsBody2D
  func calculate_gravity() -> Vector2:
  	return Vector2(0, GRAVITY)
  
  # Keep portal handlers and other methods
  func _on_test_portal_entered(_body):
  	if get_node_or_null("/root/Global"):
  		Global.change_scene(Constants.MAIN_MENU_SCENE)
  	mode = "fly"
  	save_settings()
  
  func _on_elias_portal_entered(_body):
  	print("Elias")
  	save_settings()
  
  func _on_ardit_portal_entered(_body):
  	if get_node_or_null("/root/Global"):
  		Global.change_scene("res://Arrogance.tscn")
  	save_settings()
  
  func _on_sebastian_portal_entered(_body):
  	mode = "normal"
  	if get_node_or_null("/root/Global"):
  		Global.change_scene("res://scenes/levels/sebastian_levels/level_1.tscn")
  	save_settings()
  
  func _on_prince_portal_entered(_body):
  	if get_node_or_null("/root/Global"):
  		Global.change_scene("res://scenes/levels/prince_levels/platform.tscn")
  	save_settings()
  
  func _on_fallzone_body_entered(_body):
  	if get_node_or_null("/root/Global"):
  		Global.change_scene("res://scenes/levels/ardit_levels/arrogance.tscn")
  
  func _on_life_up_body_entered(_body):
  	if hud:
  		hud.change_life(0.25)
  
  func _on_life_down_body_entered(_body):
  	if hud:
  		hud.change_life(-0.25)
  
  func death():
  	$CollisionShape2D.disabled = true
  	current_animation = "dead"
  
  	# Notify GameManager of player death
  	if get_node_or_null("/root/Global"):
  		Global.player_death()
  
  	self.queue_free()
  	
  	if get_node_or_null("/root/Global"):
  		Global.go_to_main_menu()
  
  func _on_test_portal_body_entered(_body):
  	if get_node_or_null("/root/Global"):
  		Global.change_scene("res://scenes/levels/adventure_mode/MainMap.tscn")
  
  # New methods for gameplay enhancement
  func set_movement_mode(new_mode: String) -> void:
  	mode = new_mode
  
  	if new_mode == "fly":
  		passed_fly_time = 0.0
  
  	if debug_mode:
  		print("Movement mode changed to: ", new_mode)
  
  func enable_attack(enable: bool) -> void:
  	play_attack_animation = enable
  
  func set_attack_animation(anim_name: String) -> void:
  	attack_animation = anim_name
  
  func add_extra_jumps(extra_jumps: int) -> void:
  	allowed_jumps += extra_jumps
  
  func take_damage(amount: float) -> void:
  	if hud:
  		hud.change_life(-amount / 100.0)
  
  func bounce() -> void:
  	velocity.y = JUMP_VELOCITY * 0.7 # Less powerful than a regular jump

========================================
Contents of scripts\core\player\player_camera.gd:
========================================
  class_name PlayerCamera
  extends Camera2D
  
  
  # Called when the node enters the scene tree for the first time.
  func _ready():
  	pass # Replace with function body.
  
  
  # Called every frame. 'delta' is the elapsed time since the previous frame.
  func _process(delta):
  	pass

========================================
Contents of scripts\core\player\player_states\player_attack_state.gd:
========================================
  class_name PlayerAttackState
  extends PlayerState
  
  var attack_timer: float = 0.0
  var attack_duration: float = 0.5  # Duration of the attack animation
  
  func enter():
  	player.current_animation = player.attack_animation
  	player.play_attack_animation = true
  	attack_timer = 0.0
  	
  	# Optionally play attack sound
  	# if player.has_node("AttackSound"):
  	#     player.get_node("AttackSound").play()
  
  func physics_process(delta: float):
  	# Apply gravity
  	var velocity = get_velocity()
  	velocity.y += player.GRAVITY * delta
  	
  	# Reduce movement during attack (optional)
  	velocity.x = move_toward(velocity.x, 0, 20)
  	
  	set_velocity(velocity)
  	
  	# Handle movement for character body
  	player.move_and_slide()
  	
  	# Update attack timer
  	attack_timer += delta
  	
  	# Update outfit
  	update_outfit()
  
  func get_next_state() -> String:
  	# Check state transitions
  	var life_state = check_life()
  	if life_state:
  		return life_state
  	
  	# Return to appropriate state after attack finishes
  	if attack_timer >= attack_duration:
  		player.play_attack_animation = false
  		
  		if player.is_on_floor():
  			var x_input = Input.get_axis("left", "right")
  			if x_input != 0:
  				return "PlayerWalkState"
  			else:
  				return "PlayerIdleState"
  		else:
  			return "PlayerFallState"
  	
  	# Stay in attack state
  	return ""
  	
  func handle_input(event: InputEvent):
  	check_menu_input(event)

========================================
Contents of scripts\core\player\player_states\player_base_state.gd:
========================================
  class_name PlayerState
  extends State
  
  # Base functions shared by all player states
  var player: Player
  
  func _ready():
  	# Set player reference during initialization
  	player = owner_node as Player
  
  # Function to update the outfit based on the current state
  func update_outfit():
  	var player_outfit = player.player_outfit
  	var player_animations = player.player_animations
  	var current_animation = player.current_animation
  
  	for outfit in player_outfit:
  		var animated_sprite = player.get_node("character_sprites/" + outfit)
  		var selected_outfit = player_outfit[outfit]
  
  		if str(selected_outfit) == "none":
  			animated_sprite.visible = false
  		else:
  			animated_sprite.visible = true
  			animated_sprite.play(str(selected_outfit))
  			animated_sprite.speed_scale = 2.0
  
  			# Set direction based on movement
  			var x_input = Input.get_axis("left", "right")
  			if x_input != 0:
  				animated_sprite.flip_h = x_input > 0
  
  			# Frame management
  			if current_animation in player_animations:
  				if animated_sprite.frame < player_animations[current_animation][0] or animated_sprite.frame >= player_animations[current_animation][-1]:
  					animated_sprite.frame = player_animations[current_animation][0]
  
  # Function to check life and handle death
  func check_life():
  	# Check for player health in the HUD
  	if player.hud:
  		var health_value = 0
  		
  		# Try to get health using the current API or the legacy API
  		if "current_health" in player.hud:
  			health_value = player.hud.current_health
  		elif "lifes" in player.hud:
  			health_value = player.hud.lifes
  			
  		if health_value <= 0:
  			return "PlayerDeathState"
  	
  	return ""
  
  # Function to check menu input
  func check_menu_input(event):
  	if event is InputEvent and event.is_action_pressed("Menu"):
  		get_tree().change_scene_to_file("res://scenes/ui/main_menu/main_menu.tscn")
  		if player.has_method("save_settings"):
  			player.save_settings()

========================================
Contents of scripts\core\player\player_states\player_death_state.gd:
========================================
  class_name PlayerDeathState
  extends PlayerState
  
  var death_timer: float = 0.0
  var death_duration: float = 1.5  # Duration before scene transition
  
  func enter():
      player.current_animation = "death"
      player.get_node("CollisionShape2D").disabled = true
      death_timer = 0.0
  
  func physics_process(delta: float):
      # Update death animation timer
      death_timer += delta
      
      # Update outfit
      update_outfit()
  
  func get_next_state() -> String:
      # Scene transition after death animation
      if death_timer >= death_duration:
          player.queue_free()
          get_tree().change_scene_to_file("res://scenes/ui/main_menu/main_menu.tscn")
      
      # Stay in death state
      return ""
========================================
Contents of scripts\core\player\player_states\player_fall_state.gd:
========================================
  class_name PlayerFallState
  extends PlayerState
  
  func enter():
  	# player.current_animation = "idle"  # You may want a falling animation
  	
  	# Mark as not ready for jump
  	if player.jump_counter == 0:
  		player.ready_for_jump = false
  		
  func physics_process(delta: float):
  	# Apply gravity
  	var velocity = get_velocity()
  	velocity.y += player.GRAVITY * delta
  	
  	# Read the input
  	var x_input = Input.get_axis("left", "right")
  	var y_input = Input.get_axis("down", "up")
  	
  	# Apply horizontal movement
  	if x_input != 0:
  		velocity.x = x_input * player.SPEED
  		player.current_animation = "walking"
  	else:
  		velocity.x = move_toward(velocity.x, 0, 30)
  	
  	# Check for double jump if allowed
  	if y_input > 0.4 && player.jump_counter < player.allowed_jumps && player.ready_for_jump:
  		velocity.y = player.JUMP_VELOCITY * y_input
  		player.jump_counter += 1
  		player.ready_for_jump = false
  	elif y_input < 0.4:
  		player.ready_for_jump = true
  		
  	set_velocity(velocity)
  	
  	# Handle movement for character body
  	player.move_and_slide()
  	
  	# Update outfit
  	update_outfit()
  
  func get_next_state() -> String:
  	# Check state transitions
  	var life_state = check_life()
  	if life_state:
  		return life_state
  		
  	# Check for attack input
  	if Input.is_action_just_pressed("attack"):
  		return "PlayerAttackState"
  		
  	# Check for fly mode
  	if player.mode == "fly":
  		return "PlayerFlyState"
  	
  	# Landing transition
  	if player.is_on_floor():
  		player.jump_counter = 0
  		player.ready_for_jump = true
  		player.passed_fly_time = 0.0
  		
  		# Check if still moving
  		var x_input = Input.get_axis("left", "right")
  		if x_input != 0:
  			return "PlayerWalkState"
  		else:
  			return "PlayerIdleState"
  			
  	# Double jump transition
  	var y_input = Input.get_axis("down", "up")
  	if y_input > 0.4 && player.jump_counter < player.allowed_jumps && player.ready_for_jump:
  		return "PlayerJumpState"
  	
  	# Stay in fall state
  	return ""
  	
  func handle_input(event: InputEvent):
  	check_menu_input(event)

========================================
Contents of scripts\core\player\player_states\player_fly_state.gd:
========================================
  class_name PlayerFlyState
  extends PlayerState
  
  var elixir_drain_timer: float = 0.0
  var drain_interval: float = 3.0  # Drain every 5 seconds
  var drain_amount: float = 0.25   # Drain 25% each time
  
  func enter():
  	player.current_animation = "idle"  # You may want a specific fly animation
  	elixir_drain_timer = 0.0  # Reset timer on state entry
  
  func physics_process(delta: float):
  	# Apply gravity
  	var velocity = get_velocity()
  	velocity.y += player.GRAVITY * delta
  	
  	# Read inputs
  	var x_input = Input.get_axis("left", "right")
  	var y_input = Input.get_axis("down", "up")
  	
  	# Apply horizontal movement
  	if x_input != 0:
  		velocity.x = x_input * player.SPEED
  	else:
  		velocity.x = move_toward(velocity.x, 0, 30)
  		
  	# Update fly time counter
  	if player.passed_fly_time < 4:
  		player.passed_fly_time += delta
  		if y_input != 0:
  			velocity.y = player.FLY_VELOCITY * y_input
  	
  	# Handle elixir drain
  	elixir_drain_timer += delta
  	if elixir_drain_timer >= drain_interval:
  		elixir_drain_timer = 0.0  # Reset timer
  		player.hud.use_softpower()
  	
  	if player.hud.elixir_fill_level <= 0:
  		player.mode = "normal"
  		
  	
  	
  	set_velocity(velocity)
  	
  	# Handle movement for character body
  	player.move_and_slide()
  	
  	# Update outfit
  	update_outfit()
  
  func get_next_state() -> String:
  	# Check state transitions
  	var life_state = check_life()
  	if life_state:
  		return life_state
  		
  	# Check for attack input
  	if Input.is_action_just_pressed("attack"):
  		return "PlayerAttackState"
  	
  	# Check elixir level - transition to fall if empty
  	if player.hud.elixir_fill_level <= 0:
  		player.passed_fly_time = 0.0  # Reset fly time
  		return "PlayerFallState"
  	
  	# Landing transition
  	if player.is_on_floor():
  		player.jump_counter = 0
  		player.ready_for_jump = true
  		player.passed_fly_time = 0.0
  		
  		# Check movement direction after landing
  		var x_input = Input.get_axis("left", "right")
  		if x_input != 0:
  			return "PlayerWalkState"
  		else:
  			return "PlayerIdleState"
  	
  	# Time limit check
  	if player.passed_fly_time >= 4:
  		return "PlayerFallState"
  	
  	# Stay in fly state
  	return ""
  	
  func handle_input(event: InputEvent):
  	check_menu_input(event)

========================================
Contents of scripts\core\player\player_states\player_hurt_state.gd:
========================================
  class_name PlayerHurtState
  extends PlayerState

========================================
Contents of scripts\core\player\player_states\player_idle_state.gd:
========================================
  class_name PlayerIdleState
  extends PlayerState
  
  func enter():
  	player.current_animation = "idle"
  	# Reset horizontal velocity
  	var velocity = get_velocity()
  	velocity.x = 0
  	set_velocity(velocity)
  	
  	if player.debug_mode:
  		print("Entered Idle State")
  
  func physics_process(delta: float):
  	# Apply gravity
  	var velocity = get_velocity()
  	velocity.y += player.GRAVITY * delta
  	set_velocity(velocity)
  	
  	# Handle movement for character body
  	player.move_and_slide()
  	
  	# Update outfit
  	update_outfit()
  
  func get_next_state() -> String:
  	# Check for death
  	var life_state = check_life()
  	if life_state != "":
  		return life_state
  	
  	# Check input for state transitions
  	var x_input = Input.get_axis("left", "right")
  	var y_input = Input.get_axis("down", "up")
  	
  	# Check for attack
  	if Input.is_action_just_pressed("attack"):
  		return "PlayerAttackState"
  	
  	# Check for movement
  	if x_input != 0:
  		return "PlayerWalkState"
  	
  	# Check for jumping
  	if y_input > 0.4 and player.is_on_floor():
  		return "PlayerJumpState"
  	
  	# Check for falling
  	if !player.is_on_floor():
  		return "PlayerFallState"
  	
  	# No transition
  	return ""
  
  func handle_input(event: InputEvent):
  	check_menu_input(event)

========================================
Contents of scripts\core\player\player_states\player_jump_state.gd:
========================================
  # Fix for player_jump_state.gd - Correct class name
  class_name PlayerJumpState
  extends PlayerState
  
  func enter():
  	# player.current_animation = "idle"  # You may want to use a jump animation
  
  	# Apply initial jump velocity
  	var velocity = get_velocity()
  	var y_input = Input.get_axis("down", "up")
  	velocity.y = player.JUMP_VELOCITY * y_input
  	set_velocity(velocity)
  
  	# Update jump counter
  	player.jump_counter += 1
  	player.ready_for_jump = false
  	
  	if player.debug_mode:
  		print("Entered Jump State")
  
  func physics_process(delta: float):
  	# Apply gravity
  	var velocity = get_velocity()
  	velocity.y += player.GRAVITY * delta
  
  	# Read horizontal input
  	var x_input = Input.get_axis("left", "right")
  
  	# Apply horizontal movement
  	if x_input != 0:
  		velocity.x = x_input * player.SPEED
  		player.current_animation = "walking"
  	else:
  		velocity.x = move_toward(velocity.x, 0, 30)
  
  	set_velocity(velocity)
  
  	# Handle movement for character body
  	player.move_and_slide()
  
  	# Reset jump readiness when input is released
  	var y_input = Input.get_axis("down", "up")
  	if y_input < 0.4:
  		player.ready_for_jump = true
  
  	# Update outfit
  	update_outfit()
  
  func get_next_state() -> String:
  	# Check state transitions
  	var life_state = check_life()
  	if life_state:
  		return life_state
  
  	# Check for attack input
  	if Input.is_action_just_pressed("attack"):
  		return "PlayerAttackState"
  
  	# Fly state transition
  	if player.mode == "fly":
  		return "PlayerFlyState"
  
  	# Landing transition
  	if player.is_on_floor():
  		player.jump_counter = 0
  		player.ready_for_jump = true
  
  		# Check if still moving
  		var x_input = Input.get_axis("left", "right")
  		if x_input != 0:
  			return "PlayerWalkState"
  		else:
  			return "PlayerIdleState"
  
  	# Falling transition
  	if get_velocity().y > 0:
  		return "PlayerFallState"
  
  	# Stay in jump state
  	return ""
  
  func handle_input(event: InputEvent):
  	check_menu_input(event)

========================================
Contents of scripts\core\player\player_states\player_state.gd:
========================================
  class_name PlayerState
  extends State
  
  # Base functions shared by all player states
  var player: Player
  
  func _ready():
  	# Set player reference during initialization
  	player = owner_node as Player
  
  # Function to update the outfit based on the current state
  func update_outfit():
  	var player_outfit = player.player_outfit
  	var player_animations = player.player_animations
  	var current_animation = player.current_animation
  
  	for outfit in player_outfit:
  		var animated_sprite = player.get_node("character_sprites/" + outfit)
  		var selected_outfit = player_outfit[outfit]
  
  		if str(selected_outfit) == "none":
  			animated_sprite.visible = false
  		else:
  			animated_sprite.visible = true
  			animated_sprite.play(str(selected_outfit))
  			animated_sprite.speed_scale = 2.0
  
  			# Set direction based on movement
  			var x_input = Input.get_axis("left", "right")
  			if x_input != 0:
  				animated_sprite.flip_h = x_input > 0
  
  			# Frame management
  			if current_animation in player_animations:
  				if animated_sprite.frame < player_animations[current_animation][0] or animated_sprite.frame >= player_animations[current_animation][-1]:
  					animated_sprite.frame = player_animations[current_animation][0]
  
  # Function to check life and handle death
  func check_life():
  	# Check for player health in the HUD
  	if player.hud:
  		var health_value = 0
  		
  		# Try to get health using the current API or the legacy API
  		if "current_health" in player.hud:
  			health_value = player.hud.current_health
  		elif "lifes" in player.hud:
  			health_value = player.hud.lifes
  			
  		if health_value <= 0:
  			return "PlayerDeathState"
  	
  	return ""
  
  # Function to check menu input
  func check_menu_input(event):
  	if event is InputEvent and event.is_action_pressed("Menu"):
  		get_tree().change_scene_to_file("res://scenes/ui/main_menu/main_menu.tscn")
  		if player.has_method("save_settings"):
  			player.save_settings()

========================================
Contents of scripts\core\player\player_states\player_walk_state.gd:
========================================
  class_name PlayerWalkState
  extends PlayerState
  
  func enter():
  	player.current_animation = "walking"  # Walk animation
  	
  	if player.debug_mode:
  		print("Entered Walk State")
  
  func physics_process(delta: float):
  	# Apply gravity
  	var velocity = get_velocity()
  	velocity.y += player.GRAVITY * delta
  	
  	# Read the input
  	var x_input = Input.get_axis("left", "right")
  	
  	# Apply horizontal movement
  	if x_input != 0:
  		velocity.x = x_input * player.SPEED
  	else:
  		velocity.x = move_toward(velocity.x, 0, 30)
  		
  	set_velocity(velocity)
  	
  	# Handle movement for character body
  	player.move_and_slide()
  	
  	# Update outfit
  	update_outfit()
  
  func get_next_state() -> String:
  	# Check for death
  	var life_state = check_life()
  	if life_state != "":
  		return life_state
  		
  	# Check for attack
  	if Input.is_action_just_pressed("attack"):
  		return "PlayerAttackState"
  	
  	# Read inputs
  	var x_input = Input.get_axis("left", "right")
  	var y_input = Input.get_axis("down", "up")
  	
  	# Stop walking
  	if x_input == 0:
  		return "PlayerIdleState"
  	
  	# Jump while moving
  	if y_input > 0.4 and player.is_on_floor():
  		return "PlayerJumpState"
  		
  	# Fall transition
  	if !player.is_on_floor():
  		return "PlayerFallState"
  	
  	# Stay in walk state
  	return ""
  	
  func handle_input(event: InputEvent):
  	check_menu_input(event)

========================================
Contents of scripts\core\projectiles\mage_ball.gd:
========================================
  class_name MageBall
  extends BaseProjectile
  
  ## Magisches Projektil verwendet von Goblin Mages
  ## Enthält Partikeleffekte und hat spezielle Treffereffekte
  
  # Zusätzliche Mage Ball-spezifische Eigenschaften
  @export var magic_color: Color = Color(0.5, 0.2, 0.9, 0.7)  # Lila Magie-Farbe
  @export var homing_strength: float = 0.0  # Optional: Stärke des Zielsuchens (0 = aus)
  @export var emit_particles: bool = true   # Partikel während des Flugs
  @export var magic_sound: AudioStream     # Soundeffekt für Magie
  
  # Tracking für Partikelsysteme
  var current_particles = []
  
  func _ready():
  	# Setze Standardeigenschaften
  	speed = 80.0
  	damage = 0.25  # 0.25 Leben (der Spieler hat 3 Leben)
  	lifetime = 6.0
  	gravity_affected = false
  	bounce = false
  	trail_effect = true
  	
  	# Magischen Trail-Effekt erstellen
  	if trail_effect:
  		_setup_magical_trail()
  	
  	# Animation abspielen
  	if has_node("AnimatedSprite2D"):
  		$AnimatedSprite2D.play("flying")
  		# Magische Farbe anwenden
  		$AnimatedSprite2D.modulate = magic_color
  	
  	# Lichteffekt hinzufügen, wenn nicht schon vorhanden
  	if not has_node("PointLight2D"):
  		var light = PointLight2D.new()
  		light.color = magic_color
  		light.energy = 0.7
  		light.texture = load("res://icon.png")  # Ersetze mit besserem Licht-Texture
  		light.texture_scale = 0.5
  		add_child(light)
  	
  	# Aura-Sprite hinzufügen
  	if not has_node("AuraSprite"):
  		var aura = Sprite2D.new()
  		aura.name = "AuraSprite"
  		aura.texture = load("res://icon.png")  # Ersetze mit Aura-Texture
  		aura.modulate = magic_color.lightened(0.3)
  		aura.modulate.a = 0.4
  		aura.scale = Vector2(1.5, 1.5)
  		add_child(aura)
  		
  		# Aura-Animation
  		var tween = create_tween().set_loops()
  		tween.tween_property(aura, "scale", Vector2(1.7, 1.7), 0.6)
  		tween.tween_property(aura, "scale", Vector2(1.5, 1.5), 0.6)
  	
  	super._ready()
  
  func _physics_process(delta):
  	# Magische Heimsuche, wenn aktiviert
  	if homing_strength > 0 and is_instance_valid(source_node) and source_node.state_machine and source_node.state_machine.target:
  		var target = source_node.state_machine.target
  		if is_instance_valid(target):
  			var direction_to_target = (target.global_position - global_position).normalized()
  			velocity = velocity.lerp(direction_to_target * speed, homing_strength * delta)
  	
  	# Partikel emittieren während des Flugs
  	if emit_particles and randf() < 0.2:  # 20% Chance pro Frame
  		_emit_magic_particle()
  	
  	# Standard-Physik
  	super._physics_process(delta)
  
  # Erstelle einen magischen Trail
  func _setup_magical_trail():
  	if trail:
  		trail.default_color = magic_color
  		trail.width = 4.0
  		
  		# Farbverlauf hinzufügen
  		trail.gradient = Gradient.new()
  		trail.gradient.add_point(0.0, magic_color.darkened(0.2))
  		trail.gradient.add_point(1.0, magic_color.lightened(0.3))
  
  # Emittiere einen einzelnen magischen Partikel
  func _emit_magic_particle():
  	var particle = CPUParticles2D.new()
  	particle.emitting = true
  	particle.amount = 3
  	particle.lifetime = 0.4
  	particle.explosiveness = 0.7
  	particle.direction = Vector2(0, 0)
  	particle.spread = 180
  	particle.gravity = Vector2.ZERO
  	particle.initial_velocity_min = 10
  	particle.initial_velocity_max = 20
  	particle.scale_amount = 2.0
  	particle.color = magic_color
  	
  	# Füge zum Hauptbaum hinzu (damit sie beim Recycling nicht verschwinden)
  	get_tree().current_scene.add_child(particle)
  	particle.global_position = global_position
  	
  	# Tracking für Cleanup
  	current_particles.append(particle)
  	
  	# Auto-Entfernung nach Lebenszeit
  	await get_tree().create_timer(particle.lifetime * 1.5).timeout
  	if is_instance_valid(particle):
  		current_particles.erase(particle)
  		particle.queue_free()
  
  # Überschreibe die Treffereffektsmethode für magischen Effekt
  func _spawn_hit_effect(hit_position):
  	# Magic-Explosion-Effekt
  	var explosion = CPUParticles2D.new()
  	explosion.emitting = true
  	explosion.one_shot = true
  	explosion.amount = 20
  	explosion.lifetime = 0.5
  	explosion.explosiveness = 1.0
  	explosion.direction = Vector2(0, -1)
  	explosion.spread = 180
  	explosion.gravity = Vector2(0, 0)
  	explosion.initial_velocity_min = 30
  	explosion.initial_velocity_max = 70
  	explosion.scale_amount = 2.0
  	explosion.color = magic_color
  	
  	get_tree().current_scene.add_child(explosion)
  	explosion.global_position = hit_position
  	
  	# Spiele magischen Sound ab, wenn verfügbar
  	if magic_sound:
  		var audio_player = AudioStreamPlayer2D.new()
  		audio_player.stream = magic_sound
  		audio_player.volume_db = -5
  		audio_player.max_distance = 300
  		audio_player.position = hit_position
  		get_tree().current_scene.add_child(audio_player)
  		audio_player.play()
  		
  		# Entferne Audio nach dem Abspielen
  		audio_player.finished.connect(func(): audio_player.queue_free())
  	
  	# Magisches Leuchten (wird mit Zeit schwächer)
  	var light = PointLight2D.new()
  	light.color = magic_color
  	light.energy = 1.0
  	light.texture = load("res://icon.png")  # Ersetze mit besserem Licht-Texture
  	light.texture_scale = 2.0
  	light.position = hit_position
  	get_tree().current_scene.add_child(light)
  	
  	# Ausblenden mit Tween
  	var tween = create_tween()
  	tween.tween_property(light, "energy", 0.0, 0.5)
  	tween.tween_callback(func(): light.queue_free())
  	
  	# Entferne Explosion nach der Lebenszeit
  	await get_tree().create_timer(explosion.lifetime * 1.5).timeout
  	if is_instance_valid(explosion):
  		explosion.queue_free()
  
  # Überschreibe die Recycling-Methode
  func _on_recycle_to_pool():
  	super._on_recycle_to_pool()
  	
  	# Bereinige alle noch aktiven Partikel
  	for particle in current_particles:
  		if is_instance_valid(particle):
  			particle.queue_free()
  	current_particles.clear()

========================================
Contents of scripts\core\projectiles\rock.gd:
========================================
  class_name Rock
  extends BaseProjectile
  
  ## Stein-Projektil abgeschossen von Goblin Archers
  ## Ist von der Schwerkraft beeinflusst und kann abprallen
  
  # Rock-spezifische Eigenschaften
  @export var max_bounces: int = 2  # Maximale Anzahl an Abprallvorgängen
  @export var impact_sound: AudioStream  # Sound beim Aufprall
  @export var size_variation: float = 0.2  # Zufällige Größenvariation
  @export var dust_on_bounce: bool = true  # Staubeffekt beim Abprallen
  @export var rotation_speed: float = 5.0  # Wie schnell der Stein rotiert
  
  # Tracking-Variablen
  var bounces_remaining: int = 0
  var current_dust_particles = []
  
  func _ready():
  	# Setze Standardeigenschaften
  	speed = 200.0
  	damage = 0.1  # 0.1 Leben (weniger Schaden als Magie)
  	lifetime = 4.0
  	gravity_affected = true
  	bounce = true
  	bounce_factor = 0.6  # Verliert 40% Energie beim Abprallen
  	
  	# Setze Abprallzähler
  	bounces_remaining = max_bounces
  	
  	# Animation abspielen
  	if has_node("AnimatedSprite2D"):
  		$AnimatedSprite2D.play("flying")
  		
  		# Zufällige Größenvariation für mehr Natürlichkeit
  		var size_factor = 1.0 + randf_range(-size_variation, size_variation)
  		$AnimatedSprite2D.scale = Vector2(size_factor, size_factor)
  		
  		# Zufällige Anfangsrotation
  		$AnimatedSprite2D.rotation = randf() * TAU
  	
  	# Zufällige Variation in der Geschwindigkeit
  	speed = speed * (1.0 + randf_range(-0.1, 0.1))
  	
  	super._ready()
  
  func _physics_process(delta):
  	# Drehe den Sprite basierend auf der Bewegungsrichtung
  	var sprite = get_node_or_null("AnimatedSprite2D")
  	if sprite:
  		sprite.rotation += rotation_speed * delta
  	
  	# Standard-Physik
  	super._physics_process(delta)
  
  # Überschriebene Kollisionsmethode für verbesserte Abprall-Logik
  func _on_collision(collision):
  	var collider = collision.get_collider()
  	
  	# Prüfe auf Abprallen für Umgebungsobjekte
  	if bounce and bounces_remaining > 0 and not (collider.is_in_group("player") or collider.is_in_group("enemy")):
  		var reflection = collision.get_remainder().bounce(collision.get_normal())
  		velocity = velocity.bounce(collision.get_normal()) * bounce_factor
  		global_position += reflection
  		
  		# Reduziere verbleibende Abprallvorgänge
  		bounces_remaining -= 1
  		
  		# Spiele Abprallsound ab
  		_play_bounce_sound(collision.get_position())
  		
  		# Erzeuge Staubeffekt
  		if dust_on_bounce:
  			_spawn_dust_effect(collision.get_position(), collision.get_normal())
  		
  		# Sende Abprall-Signal
  		emit_signal("projectile_bounce", self, collision.get_position(), collision.get_normal())
  		
  		# Wenn keine Abprallvorgänge mehr übrig, markiere als getroffen bei nächster Kollision
  		if bounces_remaining <= 0:
  			bounce = false
  		
  		return
  	
  	# Standard-Kollision für alles andere
  	has_hit = true
  	
  	# Verarbeite verschiedene Kollisionstypen
  	if collider.is_in_group("player") and source_node != collider:
  		_on_hit_player(collider, collision.get_position())
  	elif collider.is_in_group("enemy") and source_node != collider:
  		_on_hit_enemy(collider, collision.get_position())
  	else:
  		_on_hit_environment(collider, collision.get_position())
  	
  	_recycle_or_free()
  
  # Spiele Abprallsound ab
  func _play_bounce_sound(position):
  	if impact_sound:
  		var audio_player = AudioStreamPlayer2D.new()
  		audio_player.stream = impact_sound
  		audio_player.volume_db = -10
  		audio_player.max_distance = 200
  		audio_player.position = position
  		get_tree().current_scene.add_child(audio_player)
  		audio_player.play()
  		
  		# Entferne Audio nach dem Abspielen
  		audio_player.finished.connect(func(): audio_player.queue_free())
  	else:
  		# Standardsound wenn keiner definiert ist
  		var audio_player = AudioStreamPlayer2D.new()
  		var sound_index = randi() % 3 + 1  # Zufällig zwischen 1-3
  		var sound_path = "res://assets/audio/sfx/rock_impact" + str(sound_index) + ".wav"
  		var sound = load(sound_path) if ResourceLoader.exists(sound_path) else null
  		
  		if sound:
  			audio_player.stream = sound
  			audio_player.volume_db = -15
  			audio_player.position = position
  			get_tree().current_scene.add_child(audio_player)
  			audio_player.play()
  			audio_player.finished.connect(func(): audio_player.queue_free())
  
  # Erzeuge Staubeffekt beim Abprallen
  func _spawn_dust_effect(position, normal):
  	var dust = CPUParticles2D.new()
  	dust.emitting = true
  	dust.one_shot = true
  	dust.explosiveness = 0.8
  	dust.amount = 8
  	dust.lifetime = 0.5
  	dust.direction = Vector2(-normal.x, -normal.y)
  	dust.spread = 45
  	dust.gravity = Vector2(0, 20)
  	dust.initial_velocity_min = 10
  	dust.initial_velocity_max = 30
  	dust.scale_amount = 1.5
  	dust.color = Color(0.7, 0.7, 0.5, 0.7)  # Staubfarbe
  	
  	get_tree().current_scene.add_child(dust)
  	dust.global_position = position
  	
  	# Tracking für Cleanup
  	current_dust_particles.append(dust)
  	
  	# Auto-Entfernung nach Lebenszeit
  	await get_tree().create_timer(dust.lifetime * 1.5).timeout
  	if is_instance_valid(dust):
  		current_dust_particles.erase(dust)
  		dust.queue_free()
  
  # Überschreibe die Treffereffektsmethode für Steineffekt
  func _spawn_hit_effect(hit_position):
  	# Steinimpakt-Effekt mit Steinsplittern
  	var impact = CPUParticles2D.new()
  	impact.emitting = true
  	impact.one_shot = true
  	impact.amount = 10
  	impact.lifetime = 0.7
  	impact.explosiveness = 1.0
  	impact.spread = 180
  	impact.gravity = Vector2(0, 98)
  	impact.initial_velocity_min = 20
  	impact.initial_velocity_max = 50
  	impact.scale_amount = 2.0
  	impact.color = Color(0.6, 0.5, 0.4)  # Steinfarbe
  	
  	get_tree().current_scene.add_child(impact)
  	impact.global_position = hit_position
  	
  	# Spiele Aufprallsound ab
  	_play_bounce_sound(hit_position)
  	
  	# Entferne Impact nach der Lebenszeit
  	await get_tree().create_timer(impact.lifetime * 1.5).timeout
  	if is_instance_valid(impact):
  		impact.queue_free()
  
  # Setup-Methode überschreiben um Abprallzähler zurückzusetzen
  func setup(dir: Vector2, spawn_pos: Vector2, spawn_rot: float = 0.0, source = null):
  	# Normal-Setup durchführen
  	super.setup(dir, spawn_pos, spawn_rot, source)
  	
  	# Abprallzähler zurücksetzen
  	bounces_remaining = max_bounces
  	bounce = true
  	
  	return self
  
  # Überschreibe die Recycling-Methode
  func _on_recycle_to_pool():
  	super._on_recycle_to_pool()
  	
  	# Abprallzähler zurücksetzen
  	bounces_remaining = max_bounces
  	bounce = true
  	
  	# Bereinige alle noch aktiven Partikel
  	for particle in current_dust_particles:
  		if is_instance_valid(particle):
  			particle.queue_free()
  	current_dust_particles.clear()

========================================
Contents of scripts\levels\base_level.gd:
========================================
  class_name BaseLevel
  extends Node2D
  
  var boss_music = load("res://assets/audio/music/Tracks/the-epic-2-by-rafael-krux(chosic.com).mp3")
  # Called when the node enters the scene tree for the first time.
  func _ready():
  	AudioManager.play_track(boss_music)
  
  # Called every frame. 'delta' is the elapsed time since the previous frame.
  func _process(_delta):
  	pass

========================================
Contents of scripts\resources\player_outfit_resource.gd:
========================================
  class_name PlayerOutfitResource
  extends Resource
  
  ## Resource-based outfit system for The Little Saint
  ## Provides structured way to store and manage player appearance
  
  # Outfit components
  @export var beard: String = "none"
  @export var lipstick: String = "none"
  @export var eyes: String = "1"
  @export var shoes: String = "1"
  @export var earrings: String = "none"
  @export var hat: String = "none"
  @export var glasses: String = "none"
  @export var clothes_down: String = "1"
  @export var clothes_up: String = "1"
  @export var clothes_complete: String = "none"
  @export var body: String = "1"
  @export var hair: String = "1"
  
  # Outfit metadata
  @export var outfit_name: String = "Default Outfit"
  @export var is_favorite: bool = false
  @export var creation_date: String = ""
  
  # Initialize with default values
  func _init():
  	creation_date = Time.get_datetime_string_from_system(false, true)
  
  # Convert to dictionary format (for backwards compatibility)
  func to_dictionary() -> Dictionary:
  	return {
  		"beard": beard,
  		"lipstick": lipstick,
  		"eyes": eyes,
  		"shoes": shoes,
  		"earrings": earrings,
  		"hats": hat,
  		"glasses": glasses,
  		"clothes_down": clothes_down,
  		"clothes_up": clothes_up,
  		"clothes_complete": clothes_complete,
  		"bodies": body,
  		"hair": hair
  	}
  
  # Create from dictionary (for backwards compatibility)
  func from_dictionary(dict: Dictionary) -> PlayerOutfitResource:
  	beard = str(dict.get("beard", "none"))
  	lipstick = str(dict.get("lipstick", "none"))
  	eyes = str(dict.get("eyes", "1"))
  	shoes = str(dict.get("shoes", "1"))
  	earrings = str(dict.get("earrings", "none"))
  	hat = str(dict.get("hats", "none"))
  	glasses = str(dict.get("glasses", "none"))
  	clothes_down = str(dict.get("clothes_down", "1"))
  	clothes_up = str(dict.get("clothes_up", "1"))
  	clothes_complete = str(dict.get("clothes_complete", "none"))
  	body = str(dict.get("bodies", "1"))
  	hair = str(dict.get("hair", "1"))
  	return self
  
  # Check if a component is visible
  func is_visible(component: String) -> bool:
  	match component:
  		"beard", "lipstick", "earrings", "hat", "glasses", "clothes_complete":
  			return get(component) != "none"
  		_:
  			return true
  
  # Check if this is a complete outfit (has all required elements)
  func is_complete() -> bool:
  	return body != "none" and eyes != "none"
  
  # Reset to default values
  func reset() -> void:
  	beard = "none"
  	lipstick = "none"
  	eyes = "1"
  	shoes = "1"
  	earrings = "none"
  	hat = "none"
  	glasses = "none"
  	clothes_down = "1"
  	clothes_up = "1"
  	clothes_complete = "none"
  	body = "1"
  	hair = "1"
  	outfit_name = "Default Outfit"
  	is_favorite = false
  	creation_date = Time.get_datetime_string_from_system(false, true)
  
  # Create a randomized outfit
  func randomize_outfit() -> PlayerOutfitResource:
  	# Use true randomization
  	randomize()
  	
  	# Always set essential parts
  	body = str(randi_range(1, 10))  # Assuming there are 10 body options
  	eyes = str(randi_range(1, 14))  # Assuming there are 14 eye options
  	
  	# Randomly decide for all other parts
  	beard = _random_part(["none", "1", "2", "3"], 0.7)  # 70% chance for none
  	lipstick = _random_part(["none", "1", "2", "3"], 0.8)  # 80% chance for none
  	shoes = str(randi_range(1, 10))  # Assuming there are 10 shoe options
  	earrings = _random_part(["none", "1", "2", "3"], 0.8)  # 80% chance for none
  	hat = _random_part(["none", "1", "2", "3", "4"], 0.6)  # 60% chance for none
  	glasses = _random_part(["none", "1", "2"], 0.9)  # 90% chance for none
  	
  	# Either use separate top/bottom or complete outfit
  	if randf() > 0.3:  # 70% chance for separate clothes
  		clothes_down = str(randi_range(1, 10))
  		clothes_up = str(randi_range(1, 10))
  		clothes_complete = "none"
  	else:  # 30% chance for complete outfit
  		clothes_down = "none"
  		clothes_up = "none"
  		clothes_complete = str(randi_range(1, 5))  # Assuming there are 5 complete outfit options
  	
  	# Hair is important for character look
  	hair = str(randi_range(1, 14))  # Assuming there are 14 hair options
  	
  	outfit_name = "Random Outfit"
  	creation_date = Time.get_datetime_string_from_system(false, true)
  	
  	return self
  
  # Helper for randomizing parts with "none" option
  func _random_part(options: Array, none_chance: float) -> String:
  	if randf() < none_chance:
  		return "none"
  	
  	var valid_options = options.duplicate()
  	valid_options.erase("none")
  	return valid_options[randi() % valid_options.size()]
  
  # Create a duplicate of this outfit
  func duplicate_outfit() -> PlayerOutfitResource:
  	var new_outfit = PlayerOutfitResource.new()
  	new_outfit.beard = beard
  	new_outfit.lipstick = lipstick
  	new_outfit.eyes = eyes
  	new_outfit.shoes = shoes
  	new_outfit.earrings = earrings
  	new_outfit.hat = hat
  	new_outfit.glasses = glasses
  	new_outfit.clothes_down = clothes_down
  	new_outfit.clothes_up = clothes_up
  	new_outfit.clothes_complete = clothes_complete
  	new_outfit.body = body
  	new_outfit.hair = hair
  	new_outfit.outfit_name = outfit_name + " (Copy)"
  	new_outfit.is_favorite = is_favorite
  	new_outfit.creation_date = Time.get_datetime_string_from_system(false, true)
  	return new_outfit
  
  # Create a new default outfit resource
  static func create_default() -> PlayerOutfitResource:
  	return PlayerOutfitResource.new()
  
  # Check for equality with another outfit
  func equals(other: PlayerOutfitResource) -> bool:
  	return (
  		beard == other.beard and
  		lipstick == other.lipstick and
  		eyes == other.eyes and
  		shoes == other.shoes and
  		earrings == other.earrings and
  		hat == other.hat and
  		glasses == other.glasses and
  		clothes_down == other.clothes_down and
  		clothes_up == other.clothes_up and
  		clothes_complete == other.clothes_complete and
  		body == other.body and
  		hair == other.hair
  	)
  
  # Apply this outfit to character sprites
  func apply_to_sprites(character_sprites: Node2D) -> void:
  	var outfit_dict = to_dictionary()
  	
  	for category in outfit_dict:
  		if character_sprites.has_node(category):
  			var sprite = character_sprites.get_node(category)
  			var value = outfit_dict[category]
  			
  			if value == "none":
  				sprite.visible = false
  			else:
  				sprite.visible = true
  				sprite.animation = value
  				sprite.frame = 1

========================================
Contents of scripts\ui\character_customizer\customizer_controller.gd:
========================================
  class_name CustomizerController
  # UI.gd
  extends Control
  
  # Spieler-Outfit-Eigenschaften
  var body
  var player_outfit
  var selected_outfit_category = ""
  var player_animations
  var options_per_category = {}
  var has_unsaved_changes = false  # Neue Variable für ungespeicherte Änderungen
  
  # Resource-basiertes Outfit System
  var current_outfit_resource: PlayerOutfitResource = null
  
  # Signal für Debugging
  signal debug_message(message)
  
  func _ready():
  	randomize() # Initialisiere den Zufallsgenerator
  	get_node("character_sprites/masks").visible = false
  	player_outfit = get_node("character_sprites").default_outfit
  	player_animations = get_node("character_sprites").animation_frames
  	
  	# Create outfit resource
  	current_outfit_resource = PlayerOutfitResource.new()
  	
  	# Connect to PopupManager
  	PopupManager.dialog_confirmed.connect(_on_dialog_confirmed)
  
  	# UI-Elemente für jede Outfit-Kategorie erstellen
  	setup_outfit_categories()
  
  	# Versuche, gespeicherte Outfits zu laden
  	load_saved_outfit()
  
  	# Bei Programmstart gibt es keine ungespeicherten Änderungen
  	has_unsaved_changes = false
  
  # Erstellt UI-Elemente für alle Outfit-Kategorien
  func setup_outfit_categories():
  	for category in player_outfit:
  		var category_button = Button.new()
  		var items_container = ScrollContainer.new()
  		var item_container_grid = GridContainer.new()
  
  		# Kategorie-Button einrichten
  		category_button.text = category
  		category_button.pressed.connect(_on_category_button_pressed.bind(category))
  		$Outfit_Category_Picker/GridContainer.add_child(category_button)
  
  		# Container für Items einrichten
  		items_container.size = Vector2(620, 400)
  		items_container.position = Vector2(600, 200)
  		items_container.add_child(item_container_grid)
  		items_container.name = category
  		add_child(items_container)
  		items_container.hide()
  
  		# Grid für Items einrichten
  		item_container_grid.columns = 6
  		var current_item = 0
  		var button_size = Vector2(100, 100)
  
  		# Leeren Button für optionale Kategorien hinzufügen
  		if category != "bodies":
  			var empty_button = Button.new()
  			empty_button.custom_minimum_size = button_size
  			empty_button.pressed.connect(_on_item_button_pressed.bind("none"))
  			item_container_grid.add_child(empty_button)
  
  			var animated_sprite = get_node("character_sprites/" + category)
  			animated_sprite.visible = false
  			player_outfit[category] = "none"
  
  		# Alle verfügbaren Items für diese Kategorie hinzufügen
  		while true:
  			current_item += 1
  			var texture = get_node("character_sprites/"+category).sprite_frames.get_frame_texture(str(current_item), 1)
  			if texture == null:
  				break
  
  			var item_texture = TextureRect.new()
  			item_texture.texture = texture
  			item_texture.custom_minimum_size = button_size
  			item_texture.stretch_mode = TextureRect.STRETCH_KEEP_ASPECT_CENTERED
  
  			var item_button = Button.new()
  			item_button.custom_minimum_size = button_size
  			item_button.add_child(item_texture)
  			item_button.pressed.connect(_on_item_button_pressed.bind(str(current_item)))
  			item_container_grid.add_child(item_button)
  
  		options_per_category[category] = current_item - 1
  
  # Aktualisiert die Animations-Frames basierend auf dem gewählten Outfit
  func _process(_delta):
  	for outfit in player_outfit:
  		var animated_sprite = get_node("character_sprites/" + outfit)
  		animated_sprite.animation = player_outfit[outfit]
  		animated_sprite.frame = 1
  
  # Wird aufgerufen, wenn ein Item ausgewählt wird
  func _on_item_button_pressed(item):
  	var animated_sprite = get_node("character_sprites/" + selected_outfit_category)
  	var old_value = player_outfit[selected_outfit_category]
  	var new_value = str(item)
  
  	if new_value == "none":
  		animated_sprite.visible = false
  	else:
  		animated_sprite.visible = true
  
  	# Setze has_unsaved_changes nur, wenn sich etwas geändert hat
  	if old_value != new_value:
  		player_outfit[selected_outfit_category] = new_value
  		has_unsaved_changes = true
  		
  		# Update outfit resource
  		if selected_outfit_category == "bodies":
  			current_outfit_resource.body = new_value
  		elif selected_outfit_category == "hats":
  			current_outfit_resource.hat = new_value
  		elif current_outfit_resource.get(selected_outfit_category) != null:
  			current_outfit_resource.set(selected_outfit_category, new_value)
  	else:
  		player_outfit[selected_outfit_category] = new_value
  
  # Wird aufgerufen, wenn eine Kategorie ausgewählt wird
  func _on_category_button_pressed(category):
  	if selected_outfit_category:
  		get_node(selected_outfit_category).hide()
  	get_node(category).show()
  	selected_outfit_category = category
  
  # Generiert ein zufälliges Outfit
  func _random_button_pressed():
  	current_outfit_resource.randomize_outfit()
  	var outfit_dict = current_outfit_resource.to_dictionary()
  	var had_changes = false
  	
  	# Update the player_outfit from the resource
  	for category in outfit_dict:
  		if player_outfit.has(category):
  			var new_value = outfit_dict[category]
  			if player_outfit[category] != new_value:
  				player_outfit[category] = new_value
  				had_changes = true
  			
  			# Update sprite visibility
  			var animated_sprite = get_node("character_sprites/" + category)
  			if new_value == "none":
  				animated_sprite.visible = false
  			else:
  				animated_sprite.visible = true
  
  	if had_changes:
  		has_unsaved_changes = true
  
  # Speichert das aktuelle Outfit
  func _save_button_pressed():
  	# Update the outfit resource
  	current_outfit_resource.from_dictionary(player_outfit)
  	current_outfit_resource.outfit_name = "Last Saved Outfit"
  
  	# Save to both the favorites and the player's current outfit
  	SaveManager.save_outfit(player_outfit, "Last Saved Outfit")
  	
  	# Ensure the current save data has the outfit
  	if SaveManager.current_save_data:
  		SaveManager.current_save_data.player_outfit = player_outfit.duplicate(true)
  	
  	# Save both settings and game data
  	SaveManager.save_settings()
  	SaveManager.save_game()  # Add this line to ensure full game save
  	
  	has_unsaved_changes = false
  	show_message("Outfit erfolgreich gespeichert!", Color(0.3, 1, 0.3, 1))
  
  # Setzt alle optionalen Teile des Outfits zurück
  func _reset_button_pressed():
  	# Use the resource method to reset
  	current_outfit_resource.reset()
  	var outfit_dict = current_outfit_resource.to_dictionary()
  	var had_changes = false
  	
  	# Apply the reset to player_outfit
  	for category in outfit_dict:
  		if player_outfit.has(category) and category != "bodies":
  			var animated_sprite = get_node("character_sprites/" + category)
  			animated_sprite.visible = false
  			
  			if player_outfit[category] != "none":
  				player_outfit[category] = "none"
  				had_changes = true
  
  	if had_changes:
  		has_unsaved_changes = true
  
  	show_message("Outfit zurückgesetzt!", Color(0.3, 0.7, 1, 1))
  
  # Hilfsfunktion zum Anzeigen von Nachrichten
  func show_message(text, color = Color(1, 1, 1, 1)):
  	if has_node("save_feedback"):
  		var label = get_node("save_feedback")
  		label.text = text
  		label.modulate = color
  
  		# Timer zum Ausblenden nach 2 Sekunden
  		get_tree().create_timer(2.0).timeout.connect(func():
  			if has_node("save_feedback"):
  				get_node("save_feedback").text = ""
  		)
  
  # Lädt das gespeicherte Outfit, falls vorhanden
  func load_saved_outfit():
  	# First try to load from current save data
  	if SaveManager.current_save_data and SaveManager.current_save_data.player_outfit:
  		var saved_outfit = SaveManager.current_save_data.player_outfit
  		
  		# Log for debugging
  		print("Loading outfit from save data: ", saved_outfit)
  		
  		# Update the outfit resource
  		current_outfit_resource.from_dictionary(saved_outfit)
  		
  		# Update the UI
  		for category in saved_outfit:
  			if player_outfit.has(category):
  				var outfit_value = str(saved_outfit[category])
  				player_outfit[category] = outfit_value
  				
  				# Update visibility
  				var animated_sprite = get_node("character_sprites/" + category)
  				if outfit_value == "none":
  					animated_sprite.visible = false
  				else:
  					animated_sprite.visible = true
  		
  		print("Outfit loaded successfully")
  	else:
  		print("No saved outfit found in save data")
  
  
  func _on_back_pressed() -> void:
  	if has_unsaved_changes:
  		PopupManager.confirm(
  			"Nicht gespeicherte Änderungen",
  			"Du hast nicht gespeicherte Änderungen. Möchtest du wirklich ohne Speichern zurückkehren?",
  			"Abbrechen",
  			"Zurück",
  			"back_confirmation"
  		)
  	else:
  		get_tree().change_scene_to_file("res://scenes/ui/settings/settings_menu.tscn")
  
  func _on_dialog_confirmed(dialog_id):
  	if dialog_id == "back_confirmation":
  		get_tree().change_scene_to_file("res://scenes/ui/settings/settings_menu.tscn")

========================================
Contents of scripts\ui\character_customizer\outfit_showcase.gd:
========================================
  class_name OutfitShowcase
  # outfit_showcase.gd
  extends Control
  
  var current_outfits = {}
  var preview_container
  var outfit_grid
  var back_button
  var outfit_name_field
  var save_button
  var delete_button
  var preview_helper
  
  func _ready():
  	preview_helper = load("res://scripts/ui/character_customizer/preview_helper.gd").new()
  	add_child(preview_helper)
  	
  	# UI erstellen
  	setup_ui()
  	
  	# Gespeicherte Outfits laden
  	load_saved_outfits()
  
  func setup_ui():
  	# Container für die Vorschau
  	preview_container = ScrollContainer.new()
  	preview_container.position = Vector2(50, 50)
  	preview_container.size = Vector2(900, 400)
  	add_child(preview_container)
  	
  	# Grid für Outfit-Vorschaubilder
  	outfit_grid = GridContainer.new()
  	outfit_grid.columns = 4
  	preview_container.add_child(outfit_grid)
  	
  	# Textfeld für Outfit-Namen
  	var name_label = Label.new()
  	name_label.text = "Outfit-Name:"
  	name_label.position = Vector2(50, 470)
  	add_child(name_label)
  	
  	outfit_name_field = LineEdit.new()
  	outfit_name_field.position = Vector2(150, 470)
  	outfit_name_field.size = Vector2(300, 30)
  	outfit_name_field.placeholder_text = "Mein cooles Outfit"
  	add_child(outfit_name_field)
  	
  	# Save-Button
  	save_button = Button.new()
  	save_button.text = "Speichern"
  	save_button.position = Vector2(470, 470)
  	save_button.size = Vector2(120, 30)
  	save_button.pressed.connect(_on_save_pressed)
  	add_child(save_button)
  	
  	# Delete-Button
  	delete_button = Button.new()
  	delete_button.text = "Löschen"
  	delete_button.position = Vector2(600, 470)
  	delete_button.size = Vector2(120, 30)
  	delete_button.pressed.connect(_on_delete_pressed)
  	add_child(delete_button)
  	
  	# Back-Button
  	back_button = Button.new()
  	back_button.text = "Zurück"
  	back_button.position = Vector2(400, 550)
  	back_button.size = Vector2(200, 40)
  	back_button.pressed.connect(_on_back_pressed)
  	add_child(back_button)
  
  # Lädt alle gespeicherten Outfits und zeigt sie an
  func load_saved_outfits():
  	current_outfits = preview_helper.load_favorites()
  	
  	# UI aktualisieren
  	update_showcase()
  
  # Aktualisiert die Anzeige der Outfits
  func update_showcase():
  	# Alle vorherigen Kinder entfernen
  	for child in outfit_grid.get_children():
  		outfit_grid.remove_child(child)
  		child.queue_free()
  	
  	# Aktuelle Outfit-Liste durchgehen
  	for outfit_name in current_outfits:
  		var outfit_config = current_outfits[outfit_name]
  		
  		# Container für jedes Outfit
  		var outfit_container = VBoxContainer.new()
  		outfit_grid.add_child(outfit_container)
  		
  		# Vorschaubild generieren
  		var preview_image = await preview_helper.generate_outfit_preview(
  			get_node("/root/Main/character_sprites"), 
  			outfit_config
  		)
  		
  		# TextureRect für das Vorschaubild
  		var preview_rect = TextureRect.new()
  		var image_texture = ImageTexture.create_from_image(preview_image)
  		preview_rect.texture = image_texture
  		preview_rect.custom_minimum_size = Vector2(200, 200)
  		preview_rect.stretch_mode = TextureRect.STRETCH_KEEP_ASPECT_CENTERED
  		outfit_container.add_child(preview_rect)
  		
  		# Label für den Namen
  		var name_label = Label.new()
  		name_label.text = outfit_name
  		name_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
  		outfit_container.add_child(name_label)
  		
  		# Button zum Laden dieses Outfits
  		var load_button = Button.new()
  		load_button.text = "Laden"
  		load_button.pressed.connect(_on_load_outfit_pressed.bind(outfit_name))
  		outfit_container.add_child(load_button)
  
  # Event-Handler
  
  func _on_save_pressed():
  	var current_outfit = get_node("/root/Main").get_current_outfit()
  	var name = outfit_name_field.text
  	
  	if name.empty():
  		name = "Outfit " + str(current_outfits.size() + 1)
  	
  	# Outfit zu Favoriten hinzufügen
  	preview_helper.save_to_favorites(current_outfit, name)
  	
  	# Liste aktualisieren
  	load_saved_outfits()
  
  func _on_delete_pressed():
  	var name = outfit_name_field.text
  	if current_outfits.has(name):
  		current_outfits.erase(name)
  		
  		# Aktualisierte Liste speichern
  		var config = ConfigFile.new()
  		config.set_value("favorites", "outfits", current_outfits)
  		config.save("user://favorites.cfg")
  		
  		# UI aktualisieren
  		update_showcase()
  
  func _on_load_outfit_pressed(outfit_name):
  	var outfit_config = current_outfits[outfit_name]
  	get_node("/root/Main").apply_outfit(outfit_config)
  	
  	# Eingabefeld aktualisieren
  	outfit_name_field.text = outfit_name
  
  func _on_back_pressed():
  	get_tree().change_scene_to_file("res://scenes/ui/character_customizer/customizer.tscn")

========================================
Contents of scripts\ui\character_customizer\preview_helper.gd:
========================================
  class_name PreviewHelper
  # preview_helper.gd
  # Diese Datei enthält Hilfsfunktionen für die Vorschau im Character-Customizer
  
  extends Node
  
  # Cache für Outfit-Vorschaubilder
  var preview_cache = {}
  
  # Generiert ein Vorschaubild für ein komplettes Outfit
  # Kann verwendet werden, um mehrere Outfits nebeneinander anzuzeigen
  func generate_outfit_preview(character_sprites, outfit_config):
  	var viewport = SubViewport.new()
  	viewport.size = Vector2i(128, 128)
  	viewport.transparent_bg = true
  	viewport.render_target_update_mode = SubViewport.UPDATE_ONCE
  	
  	var sprites_instance = character_sprites.duplicate()
  	viewport.add_child(sprites_instance)
  	
  	# Positioniere die Sprites in der Mitte des Viewports
  	sprites_instance.position = Vector2(64, 64)
  	sprites_instance.scale = Vector2(4, 4)
  	
  	# Setze das Outfit gemäß der Konfiguration
  	for category in outfit_config:
  		if sprites_instance.has_node(category):
  			var sprite = sprites_instance.get_node(category)
  			if str(outfit_config[category]) == "none":
  				sprite.visible = false
  			else:
  				sprite.visible = true
  				sprite.animation = str(outfit_config[category])
  				sprite.frame = 1
  	
  	# Rendern und Vorschaubild zurückgeben
  	await get_tree().process_frame
  	await get_tree().process_frame
  	
  	var texture = viewport.get_texture()
  	var image = texture.get_image()
  	
  	# Viewport und Duplikat aufräumen
  	viewport.remove_child(sprites_instance)
  	sprites_instance.queue_free()
  	viewport.queue_free()
  	
  	return image
  
  # Speichert ein Outfit in einem gesonderten Bereich für Favoriten
  func save_to_favorites(outfit_config, name = ""):
  	var favorites = load_favorites()
  	
  	if name.empty():
  		name = "Outfit " + str(favorites.size() + 1)
  	
  	favorites[name] = outfit_config
  	
  	var config = ConfigFile.new()
  	config.set_value("favorites", "outfits", favorites)
  	var err = config.save("user://favorites.cfg")
  	
  	return err == OK
  
  # Lädt alle gespeicherten Favoriten
  func load_favorites():
  	var config = ConfigFile.new()
  	var err = config.load("user://favorites.cfg")
  	
  	if err == OK:
  		return config.get_value("favorites", "outfits", {})
  	else:
  		return {}
  
  # Konvertiert ein Outfit in ein exportierbares Format (z.B. JSON)
  func export_outfit_to_json(outfit_config):
  	return JSON.stringify(outfit_config)
  
  # Importiert ein Outfit aus einem exportierten Format
  func import_outfit_from_json(json_string):
  	var json = JSON.new()
  	var error = json.parse(json_string)
  	if error == OK:
  		return json.get_data()
  	else:
  		return null

========================================
Contents of scripts\ui\controls\attack_button.gd:
========================================
  class_name AttackButton
  extends Button
  
  
  @onready var attack = $"."
  
  func _ready():
  	attack.modulate = Color(2, 2, 2, 0.5) 
  
  
  func _on_button_up():
  	attack.modulate = Color(2, 2, 2, 0.5) 
  	Input.action_release("attack")
  
  
  func _on_button_down():
  	attack.modulate = Color(1.0, 1.0, 1.0, 0.5) 
  	Input.action_press("attack")

========================================
Contents of scripts\ui\controls\defend_button.gd:
========================================
  class_name DefendButton
  extends Button
  
  
  @onready var defend = $"."
  
  func _ready():
  	defend.modulate = Color(2, 2, 2, 0.5) 
  
  
  func _on_button_up():
  	defend.modulate = Color(2, 2, 2, 0.5) 
  	Input.action_release("defend")
  
  func _on_button_down():
  	defend.modulate = Color(1.0, 1.0, 1.0, 0.5) 
  	Input.action_press("defend")
  	

========================================
Contents of scripts\ui\dialogs\popup_dialog.gd:
========================================
  class_name PopupDialog
  extends CanvasLayer
  
  # Signal, wenn der primäre (rechte) Button gedrückt wird
  signal confirmed
  # Signal, wenn der sekundäre (linke) Button gedrückt wird
  signal canceled
  
  # UI-Elemente
  var dimmer
  var dialog_panel
  var title_label
  var message_label
  var button_container
  var cancel_button
  var confirm_button
  
  # Standardwerte
  var _title_text = "Bestätigung"
  var _message_text = "Möchtest du fortfahren?"
  var _cancel_text = "Abbrechen"
  var _confirm_text = "Bestätigen"
  var _confirm_color = Color(0.7, 0.2, 0.2, 1)  # Rot
  var _auto_hide = true
  
  func _init():
  	# Erstelle alle UI-Elemente programmatisch
  	_create_ui()
  
  func _ready():
  	# Bei Start nicht anzeigen
  	hide()
  	
  	# Verbinde Button-Signale
  	cancel_button.pressed.connect(_on_cancel_pressed)
  	confirm_button.pressed.connect(_on_confirm_pressed)
  
  # Erstellt die komplette UI-Struktur
  func _create_ui():
  	# Dimmer (Hintergrund-Verdunkelung)
  	dimmer = ColorRect.new()
  	dimmer.name = "Dimmer"
  	dimmer.color = Color(0, 0, 0, 0.6)  # Halbtransparentes Schwarz
  	add_child(dimmer)
  	
  	# DialogPanel
  	dialog_panel = Panel.new()
  	dialog_panel.name = "DialogPanel"
  	
  	# Panel-Design
  	var panel_style = StyleBoxFlat.new()
  	panel_style.bg_color = Color(0.12, 0.12, 0.15, 1.0)
  	panel_style.border_width_left = 2
  	panel_style.border_width_top = 2
  	panel_style.border_width_right = 2
  	panel_style.border_width_bottom = 2
  	panel_style.border_color = Color(0.6, 0.6, 1.0, 0.7)
  	panel_style.corner_radius_top_left = 15
  	panel_style.corner_radius_top_right = 15
  	panel_style.corner_radius_bottom_left = 15
  	panel_style.corner_radius_bottom_right = 15
  	panel_style.shadow_color = Color(0, 0, 0, 0.3)
  	panel_style.shadow_size = 8
  	dialog_panel.add_theme_stylebox_override("panel", panel_style)
  	dimmer.add_child(dialog_panel)
  	
  	# Titel
  	title_label = Label.new()
  	title_label.name = "Title"
  	title_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
  	title_label.add_theme_font_size_override("font_size", 24)
  	title_label.add_theme_color_override("font_color", Color(1, 1, 1, 1))
  	dialog_panel.add_child(title_label)
  	
  	# Nachricht
  	message_label = Label.new()
  	message_label.name = "Message"
  	message_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
  	message_label.autowrap_mode = TextServer.AUTOWRAP_WORD_SMART
  	message_label.add_theme_font_size_override("font_size", 18)
  	message_label.add_theme_color_override("font_color", Color(0.9, 0.9, 0.9, 1))
  	dialog_panel.add_child(message_label)
  	
  	# Buttons-Container
  	button_container = HBoxContainer.new()
  	button_container.name = "ButtonContainer"
  	button_container.alignment = BoxContainer.ALIGNMENT_CENTER
  	button_container.add_theme_constant_override("separation", 20)
  	dialog_panel.add_child(button_container)
  	
  	# Button-Style vorbereiten
  	var button_style_normal = StyleBoxFlat.new()
  	button_style_normal.bg_color = Color(0.2, 0.2, 0.25, 1)
  	button_style_normal.border_width_left = 0
  	button_style_normal.border_width_top = 0
  	button_style_normal.border_width_right = 0
  	button_style_normal.border_width_bottom = 0
  	button_style_normal.corner_radius_top_left = 8
  	button_style_normal.corner_radius_top_right = 8
  	button_style_normal.corner_radius_bottom_left = 8
  	button_style_normal.corner_radius_bottom_right = 8
  	
  	var button_style_hover = StyleBoxFlat.new()
  	button_style_hover.bg_color = Color(0.25, 0.25, 0.3, 1)
  	button_style_hover.border_width_left = 0
  	button_style_hover.border_width_top = 0
  	button_style_hover.border_width_right = 0
  	button_style_hover.border_width_bottom = 0
  	button_style_hover.corner_radius_top_left = 8
  	button_style_hover.corner_radius_top_right = 8
  	button_style_hover.corner_radius_bottom_left = 8
  	button_style_hover.corner_radius_bottom_right = 8
  	
  	var button_style_pressed = StyleBoxFlat.new()
  	button_style_pressed.bg_color = Color(0.15, 0.15, 0.2, 1)
  	button_style_pressed.border_width_left = 0
  	button_style_pressed.border_width_top = 0
  	button_style_pressed.border_width_right = 0
  	button_style_pressed.border_width_bottom = 0
  	button_style_pressed.corner_radius_top_left = 8
  	button_style_pressed.corner_radius_top_right = 8
  	button_style_pressed.corner_radius_bottom_left = 8
  	button_style_pressed.corner_radius_bottom_right = 8
  	
  	# Abbrechen-Button
  	cancel_button = Button.new()
  	cancel_button.name = "CancelButton"
  	cancel_button.add_theme_font_size_override("font_size", 18)
  	cancel_button.add_theme_stylebox_override("normal", button_style_normal.duplicate())
  	cancel_button.add_theme_stylebox_override("hover", button_style_hover.duplicate())
  	cancel_button.add_theme_stylebox_override("pressed", button_style_pressed.duplicate())
  	button_container.add_child(cancel_button)
  	
  	# Bestätigen-Button
  	confirm_button = Button.new()
  	confirm_button.name = "ConfirmButton"
  	confirm_button.add_theme_font_size_override("font_size", 18)
  	
  	# Rote Button-Stile
  	var confirm_style_normal = button_style_normal.duplicate()
  	confirm_style_normal.bg_color = Color(0.7, 0.2, 0.2, 1)
  	var confirm_style_hover = button_style_hover.duplicate()
  	confirm_style_hover.bg_color = Color(0.8, 0.3, 0.3, 1)
  	var confirm_style_pressed = button_style_pressed.duplicate()
  	confirm_style_pressed.bg_color = Color(0.6, 0.15, 0.15, 1)
  	
  	confirm_button.add_theme_stylebox_override("normal", confirm_style_normal)
  	confirm_button.add_theme_stylebox_override("hover", confirm_style_hover)
  	confirm_button.add_theme_stylebox_override("pressed", confirm_style_pressed)
  	button_container.add_child(confirm_button)
  
  # Setzt Text-Inhalte und Farben
  func setup(title: String = "", message: String = "", 
  		   cancel_text: String = "", confirm_text: String = "",
  		   confirm_button_color: Color = Color(0.7, 0.2, 0.2, 1)):
  	
  	# Setze nur nicht-leere Werte
  	if title:
  		_title_text = title
  	if message:
  		_message_text = message
  	if cancel_text:
  		_cancel_text = cancel_text
  	if confirm_text:
  		_confirm_text = confirm_text
  		
  	_confirm_color = confirm_button_color
  	
  	return self  # Für Methoden-Verkettung
  
  # Einstellen, ob das Popup sich automatisch schließen soll
  func set_auto_hide(value: bool):
  	_auto_hide = value
  	return self  # Für Methoden-Verkettung
  
  # Zeigt den Dialog an
  func popup():
  	# Fenstergröße aktualisieren
  	var viewport_size = get_viewport().get_visible_rect().size
  	dimmer.size = viewport_size
  	
  	var dialog_width = min(500, viewport_size.x * 0.8)
  	var dialog_height = 230
  	dialog_panel.size = Vector2(dialog_width, dialog_height)
  	dialog_panel.position = (viewport_size - dialog_panel.size) / 2
  	dialog_panel.pivot_offset = dialog_panel.size / 2
  	
  	# Layout aktualisieren
  	title_label.position = Vector2(0, 20)
  	title_label.size = Vector2(dialog_width, 30)
  	
  	message_label.position = Vector2(20, 60)
  	message_label.size = Vector2(dialog_width - 40, 60)
  	
  	button_container.position = Vector2(20, dialog_height - 80)
  	button_container.size = Vector2(dialog_width - 40, 60)
  	
  	cancel_button.custom_minimum_size = Vector2(dialog_width * 0.35, 60)
  	confirm_button.custom_minimum_size = Vector2(dialog_width * 0.35, 60)
  	
  	# Aktualisiere UI
  	title_label.text = _title_text
  	message_label.text = _message_text
  	cancel_button.text = _cancel_text
  	confirm_button.text = _confirm_text
  	
  	# Setze Button-Farbe
  	var normal_style = confirm_button.get_theme_stylebox("normal").duplicate()
  	var hover_style = confirm_button.get_theme_stylebox("hover").duplicate()
  	var pressed_style = confirm_button.get_theme_stylebox("pressed").duplicate()
  	
  	normal_style.bg_color = _confirm_color
  	hover_style.bg_color = _confirm_color.lightened(0.1)
  	pressed_style.bg_color = _confirm_color.darkened(0.1)
  	
  	confirm_button.add_theme_stylebox_override("normal", normal_style)
  	confirm_button.add_theme_stylebox_override("hover", hover_style)
  	confirm_button.add_theme_stylebox_override("pressed", pressed_style)
  	
  	# Dialog anzeigen mit Animation
  	show()
  	dimmer.modulate = Color(1, 1, 1, 0)
  	
  	var tween = create_tween()
  	tween.tween_property(dimmer, "modulate", Color(1, 1, 1, 1), 0.3).set_ease(Tween.EASE_OUT)
  	
  	# Dialog-Panel Animation (Skalierung)
  	dialog_panel.scale = Vector2(0.9, 0.9)
  	tween.parallel().tween_property(dialog_panel, "scale", Vector2(1, 1), 0.3).set_ease(Tween.EASE_OUT)
  	
  	return self  # Für Methoden-Verkettung
  
  # Schließt den Dialog
  func close():
  	var tween = create_tween()
  	tween.tween_property(dimmer, "modulate", Color(1, 1, 1, 0), 0.2).set_ease(Tween.EASE_IN)
  	tween.parallel().tween_property(dialog_panel, "scale", Vector2(0.9, 0.9), 0.2).set_ease(Tween.EASE_IN)
  	
  	# Warte auf das Ende der Animation
  	await tween.finished
  	hide()
  
  # Button-Handling
  func _on_cancel_pressed():
  	emit_signal("canceled")
  	if _auto_hide:
  		close()
  
  func _on_confirm_pressed():
  	emit_signal("confirmed")
  	if _auto_hide:
  		close()

========================================
Contents of scripts\ui\dialogs\popup_manager.gd:
========================================
  extends Node
  
  # Signal, dass ein zuvor erstellter Dialog bestätigt wurde
  signal dialog_confirmed(dialog_id: String)
  # Signal, dass ein zuvor erstellter Dialog abgebrochen wurde
  signal dialog_canceled(dialog_id: String)
  
  # Speichert alle aktiven Popups
  var _active_popups = {}
  
  # Zeigt eine einfache Bestätigungsabfrage
  func confirm(title: String, message: String, 
  			 cancel_text: String = "Abbrechen", confirm_text: String = "Bestätigen",
  			 dialog_id: String = "") -> String:
  				
  	# Generiere eine eindeutige ID, falls keine angegeben wurde
  	var id = dialog_id if dialog_id else _generate_id()
  	
  	# Erstelle und zeige das Popup an
  	var popup = _create_popup()
  	popup.setup(title, message, cancel_text, confirm_text)
  	
  	# Verbinde Signale, um weiterzuleiten
  	popup.confirmed.connect(func(): 
  		emit_signal("dialog_confirmed", id)
  		_active_popups.erase(id)
  	)
  	popup.canceled.connect(func(): 
  		emit_signal("dialog_canceled", id)
  		_active_popups.erase(id)
  	)
  	
  	# Speichere das Popup für spätere Referenz
  	_active_popups[id] = popup
  	
  	# Zeige das Popup an
  	popup.popup()
  	
  	return id
  
  # Zeigt einen Warnungs-Dialog
  func warning(title: String, message: String, button_text: String = "OK") -> String:
  	var id = _generate_id()
  	var popup = _create_popup()
  	
  	# Stelle Warnungs-Dialog ein
  	popup.setup(
  		title, 
  		message, 
  		"", # Kein Abbrechen-Button
  		button_text,
  		Color(0.9, 0.6, 0.1, 1) # Orange für Warnungen
  	)
  	
  	# Verbinde Signale
  	popup.confirmed.connect(func():
  		emit_signal("dialog_confirmed", id)
  		_active_popups.erase(id)
  	)
  	
  	# Verstecke den Abbrechen-Button
  	popup.cancel_button.visible = false
  	
  	# Speichere und zeige an
  	_active_popups[id] = popup
  	popup.popup()
  	
  	return id
  
  # Zeigt einen Fehler-Dialog
  func error(title: String, message: String, button_text: String = "OK") -> String:
  	var id = _generate_id()
  	var popup = _create_popup()
  	
  	# Stelle Fehler-Dialog ein
  	popup.setup(
  		title, 
  		message, 
  		"", # Kein Abbrechen-Button
  		button_text,
  		Color(0.8, 0.1, 0.1, 1) # Rot für Fehler
  	)
  	
  	# Verbinde Signale
  	popup.confirmed.connect(func():
  		emit_signal("dialog_confirmed", id)
  		_active_popups.erase(id)
  	)
  	
  	# Verstecke den Abbrechen-Button
  	popup.cancel_button.visible = false
  	
  	# Speichere und zeige an
  	_active_popups[id] = popup
  	popup.popup()
  	
  	return id
  
  # Zeigt eine Info-Nachricht
  func info(title: String, message: String, button_text: String = "OK") -> String:
  	var id = _generate_id()
  	var popup = _create_popup()
  	
  	# Stelle Info-Dialog ein
  	popup.setup(
  		title, 
  		message, 
  		"", # Kein Abbrechen-Button
  		button_text,
  		Color(0.2, 0.6, 0.8, 1) # Blau für Info
  	)
  	
  	# Verbinde Signale
  	popup.confirmed.connect(func():
  		emit_signal("dialog_confirmed", id)
  		_active_popups.erase(id)
  	)
  	
  	# Verstecke den Abbrechen-Button
  	popup.cancel_button.visible = false
  	
  	# Speichere und zeige an
  	_active_popups[id] = popup
  	popup.popup()
  	
  	return id
  
  # Schließt einen bestimmten Dialog
  func close_dialog(dialog_id: String) -> bool:
  	if _active_popups.has(dialog_id):
  		_active_popups[dialog_id].close()
  		_active_popups.erase(dialog_id)
  		return true
  	return false
  
  # Schließt alle aktiven Dialoge
  func close_all_dialogs():
  	for id in _active_popups:
  		_active_popups[id].close()
  	_active_popups.clear()
  
  # Erstellt eine neue Popup-Instanz
  func _create_popup():
  	var popup_script = load("res://scripts/ui/dialogs/popup_dialog.gd")
  	# Hier ist die Korrektur: Wir erstellen einen CanvasLayer statt eines Node
  	var popup_instance = CanvasLayer.new()
  	popup_instance.set_script(popup_script)
  	add_child(popup_instance)
  	return popup_instance
  
  # Generiert eine eindeutige ID für Dialoge
  func _generate_id() -> String:
  	return "dialog_" + str(randi())

========================================
Contents of scripts\ui\hud\hud_controller.gd:
========================================
  class_name HUDController
  extends CanvasLayer
  
  ## A modular HUD manager that handles in-game UI elements
  ## Supports various gameplay elements like health, coins, and power-ups
  
  # Health system variables
  @export var max_health: float = 3.0
  @export var initial_health: float = 3.0
  var current_health: float = 3.0
  
  # Legacy properties and accessor methods
  func get_lifes() -> float:
  	return current_health
  	
  func set_lifes(value: float) -> void:
  	current_health = value
  	_update_health_display()
  
  # Make sure legacy code can access lifes directly
  var lifes: float:
  	get: return get_lifes()
  	set(value): set_lifes(value)
  
  # Currency/Collectible tracking
  var coins: int = 0
  
  # Power-up and ability tracking
  var elixir_fill_level: float = 0.0
  var active_power_ups: Array = []
  var power_up_timers: Dictionary = {}
  
  # HUD Components reference
  @onready var health_display = $HeartsFull
  @onready var coins_label = $LabelCoinSum
  @onready var elixir_container = $bottle
  @onready var elixir_fill = $elixir
  
  # Optional components
  @onready var objective_display = $ObjectiveTracker if has_node("ObjectiveTracker") else null
  @onready var ability_timer_display = $AbilityTimer if has_node("AbilityTimer") else null
  
  # Notification components
  @onready var notification_container = $NotificationContainer if has_node("NotificationContainer") else null
  
  # UI Theme reference
  var ui_theme = null
  
  # Signals
  signal health_changed(new_health, max_health)
  signal coins_changed(new_amount)
  signal elixir_changed(new_level)
  signal power_up_activated(power_up_name, duration)
  signal power_up_deactivated(power_up_name)
  signal objective_updated(objective_id, progress, total)
  signal notification_shown(message, type)
  
  func _ready():
  	# Initialize health display
  	current_health = initial_health
  	lifes = current_health  # Update legacy property
  	
  	if health_display:
  		_update_health_display()
  	
  	# Initialize coins display
  	if coins_label:
  		coins_label.text = str(coins)
  	
  	# Initialize elixir display
  	if elixir_container and elixir_fill:
  		set_elixir_fill(elixir_fill_level)
  	
  	# Get UI theme if available
  	ui_theme = get_node_or_null("/root/UITheme")
  	if ui_theme:
  		_apply_theme()
  		ui_theme.theme_changed.connect(_on_theme_changed)
  	
  	# Connect to game manager if available
  	var game_manager = get_node_or_null("/root/Global")
  	if game_manager:
  		game_manager.coin_collected.connect(_on_global_coin_collected)
  		game_manager.state_changed.connect(_on_game_state_changed)
  
  func _process(delta):
  	# Update power-up timers
  	for power_up_name in power_up_timers.keys():
  		var timer_data = power_up_timers[power_up_name]
  		timer_data.time_remaining -= delta
  		
  		# Update UI timer if available
  		if ability_timer_display:
  			ability_timer_display.update_timer(power_up_name, timer_data.time_remaining, timer_data.duration)
  		
  		# Check if power-up has expired
  		if timer_data.time_remaining <= 0:
  			_on_power_up_expired(power_up_name)
  
  # Health Management
  func set_max_health(new_max: float) -> void:
  	max_health = max(1.0, new_max)
  	current_health = min(current_health, max_health)
  	_update_health_display()
  	emit_signal("health_changed", current_health, max_health)
  
  func change_health(amount: float) -> void:
  	var old_health = current_health
  	current_health = clamp(current_health + amount, 0, max_health)
  	
  	if current_health != old_health:
  		_update_health_display()
  		emit_signal("health_changed", current_health, max_health)
  		
  		# Handle death
  		if current_health <= 0:
  			_on_player_death()
  		# Handle healing effects
  		elif amount > 0:
  			_show_healing_effect()
  		# Handle damage effects
  		elif amount < 0:
  			_show_damage_effect()
  
  func _update_health_display() -> void:
  	if health_display:
  		# Scale heart display based on current health
  		health_display.size.x = (current_health / max_health) * health_display.texture.get_width()
  
  # Coin Management
  func add_coins(amount: int = 1) -> void:
  	coins += amount
  	if coins_label:
  		coins_label.text = str(coins)
  	emit_signal("coins_changed", coins)
  	
  	# Show collection effect
  	if amount > 0:
  		_show_coin_collect_effect()
  
  func set_coins(amount: int) -> void:
  	coins = max(0, amount)
  	if coins_label:
  		coins_label.text = str(coins)
  	emit_signal("coins_changed", coins)
  
  # Elixir/Power Meter Management
  func set_elixir_fill(fill_level: float) -> void:
  	elixir_fill_level = clamp(fill_level, 0.0, 1.0)
  	
  	if elixir_fill and elixir_container:
  		# Update the visual representation
  		_update_elixir_display()
  	
  	emit_signal("elixir_changed", elixir_fill_level)
  
  func update_elixir_fill(amount: float) -> void:
  	set_elixir_fill(elixir_fill_level + amount)
  
  func collect_softpower(amount: float = 0.25) -> void:
  	update_elixir_fill(amount)
  	# Show collection effect
  	_show_elixir_collect_effect()
  
  func use_softpower(amount: float = 0.25) -> bool:
  	if elixir_fill_level >= amount:
  		update_elixir_fill(-amount)
  		return true
  	return false
  
  func _update_elixir_display() -> void:
  	var elixir = elixir_fill
  	var bottle = elixir_container
  	
  	# Enable region clipping for partial display
  	elixir.region_enabled = true
  	
  	# Get texture size (unscaled)
  	var tex_size = elixir.texture.get_size()
  	
  	# Calculate visible height based on fill level
  	var visible_height = tex_size.y * elixir_fill_level
  	
  	# Set the region rect (clip from bottom)
  	elixir.region_rect = Rect2(
  		Vector2(0, tex_size.y - visible_height),
  		Vector2(tex_size.x, visible_height)
  	)
  	
  	# Position the fill inside the bottle
  	var bottle_texture_size = bottle.texture.get_size()
  	var elixir_texture_size = elixir.texture.get_size()
  	
  	var bottle_scale = bottle.scale
  	var elixir_scale = elixir.scale
  	
  	var bottle_size = bottle_texture_size.y * bottle_scale.y
  	var elixir_size = visible_height * elixir_scale.y
  	
  	# Center the elixir horizontally and position it at the bottom of bottle
  	elixir.position.x = bottle.position.x
  	elixir.position.y = bottle.position.y + ((bottle_size - elixir_size) / 2)
  
  # Power-up Management
  func activate_power_up(name: String, duration: float = 0.0) -> void:
  	# Add to active power-ups
  	if not active_power_ups.has(name):
  		active_power_ups.append(name)
  	
  	# Set up timer if it has a duration
  	if duration > 0:
  		power_up_timers[name] = {
  			"duration": duration,
  			"time_remaining": duration
  		}
  		
  		# Show timer UI if available
  		if ability_timer_display:
  			ability_timer_display.show_timer(name, duration)
  	
  	emit_signal("power_up_activated", name, duration)
  	
  	# Show activation effect
  	_show_power_up_effect(name)
  
  func deactivate_power_up(name: String) -> void:
  	if active_power_ups.has(name):
  		active_power_ups.erase(name)
  	
  	if power_up_timers.has(name):
  		power_up_timers.erase(name)
  		
  		# Hide timer UI if available
  		if ability_timer_display:
  			ability_timer_display.hide_timer(name)
  	
  	emit_signal("power_up_deactivated", name)
  
  func has_power_up(name: String) -> bool:
  	return active_power_ups.has(name)
  
  func get_power_up_remaining_time(name: String) -> float:
  	if power_up_timers.has(name):
  		return power_up_timers[name].time_remaining
  	return 0.0
  
  func _on_power_up_expired(name: String) -> void:
  	deactivate_power_up(name)
  	_show_power_up_expiry_effect(name)
  
  # Objective System
  func update_objective(objective_id: String, progress: int, total: int, description: String = "") -> void:
  	if objective_display:
  		objective_display.update_objective(objective_id, progress, total, description)
  	
  	emit_signal("objective_updated", objective_id, progress, total)
  
  func complete_objective(objective_id: String) -> void:
  	if objective_display:
  		objective_display.complete_objective(objective_id)
  	
  	emit_signal("objective_updated", objective_id, 1, 1)
  	
  	# Show completion effect
  	_show_objective_complete_effect()
  
  func add_objective(objective_id: String, description: String, total: int = 1) -> void:
  	if objective_display:
  		objective_display.add_objective(objective_id, description, total)
  	
  	emit_signal("objective_updated", objective_id, 0, total)
  	
  	# Show new objective effect
  	_show_new_objective_effect()
  
  # Notification System
  func show_notification(message: String, type: String = "info", duration: float = 3.0) -> void:
  	if notification_container:
  		notification_container.show_notification(message, type, duration)
  	
  	emit_signal("notification_shown", message, type)
  
  # Visual Effects
  func _show_damage_effect() -> void:
  	# Simple screen flash for now
  	var canvas_modulate = get_node_or_null("DamageEffect")
  	if canvas_modulate:
  		var tween = create_tween()
  		canvas_modulate.color = Color(1, 0, 0, 0.3)
  		canvas_modulate.visible = true
  		tween.tween_property(canvas_modulate, "color:a", 0.0, 0.5)
  		tween.tween_callback(func(): canvas_modulate.visible = false)
  
  func _show_healing_effect() -> void:
  	# Simple green flash for healing
  	var canvas_modulate = get_node_or_null("HealEffect")
  	if canvas_modulate:
  		var tween = create_tween()
  		canvas_modulate.color = Color(0, 1, 0, 0.3)
  		canvas_modulate.visible = true
  		tween.tween_property(canvas_modulate, "color:a", 0.0, 0.5)
  		tween.tween_callback(func(): canvas_modulate.visible = false)
  
  func _show_coin_collect_effect() -> void:
  	# Animate the coin counter
  	if coins_label:
  		var tween = create_tween()
  		tween.tween_property(coins_label, "modulate", Color(1, 1, 0, 1), 0.1)
  		tween.tween_property(coins_label, "modulate", Color(1, 1, 1, 1), 0.2)
  
  func _show_elixir_collect_effect() -> void:
  	# Flash the elixir
  	if elixir_fill:
  		var tween = create_tween()
  		tween.tween_property(elixir_fill, "modulate", Color(1.5, 1.5, 1.5, 1), 0.1)
  		tween.tween_property(elixir_fill, "modulate", Color(1, 1, 1, 1), 0.2)
  
  func _show_power_up_effect(power_up_name: String) -> void:
  	# This could be customized per power-up
  	show_notification("Power-up activated: " + power_up_name, "power_up")
  
  func _show_power_up_expiry_effect(power_up_name: String) -> void:
  	show_notification("Power-up expired: " + power_up_name, "warning")
  
  func _show_objective_complete_effect() -> void:
  	show_notification("Objective completed!", "success")
  
  func _show_new_objective_effect() -> void:
  	show_notification("New objective added", "info")
  
  # Theme management
  func _apply_theme() -> void:
  	if ui_theme:
  		# Apply theme to various HUD elements
  		if coins_label:
  			coins_label.add_theme_color_override("font_color", ui_theme.get_color("accent"))
  		
  		# Add more theme customizations as needed
  		pass
  
  func _on_theme_changed(theme_name: String) -> void:
  	_apply_theme()
  
  # Event handlers
  func _on_player_death() -> void:
  	var game_manager = get_node_or_null("/root/Global")
  	if game_manager:
  		game_manager.player_death()
  
  func _on_global_coin_collected(_total_coins) -> void:
  	# Update HUD to match global state
  	set_coins(get_node("/root/Global").collected_coins)
  
  func _on_game_state_changed(new_state, _old_state) -> void:
  	# Adjust HUD visibility based on game state
  	if new_state == Constants.GameState.PAUSED:
  		# Find the container to adjust visibility
  		var container = get_node_or_null("Container")
  		if container:
  			container.modulate.a = 0.5
  	else:
  		var container = get_node_or_null("Container")
  		if container:
  			container.modulate.a = 1.0
  
  # Legacy API for backward compatibility
  func change_life(amount: float) -> void:
  	change_health(amount)
  
  func load_hearts() -> void:
  	_update_health_display()
  
  func coin_collected() -> void:
  	add_coins(1)
  
  func _update_coin_display() -> void:
  	if coins_label:
  		coins_label.text = str(coins)

========================================
Contents of scripts\ui\main_menu\camera.gd:
========================================
  class_name Camera
  extends Camera2D
  
  
  # Called when the node enters the scene tree for the first time.
  func _ready():
  	pass # Replace with function body.
  
  
  # Called every frame. 'delta' is the elapsed time since the previous frame.
  func _process(delta):
  	pass

========================================
Contents of scripts\ui\main_menu\customizer_button.gd:
========================================
  class_name CustomizerButton
  extends Button
  
  
  # Called when the node enters the scene tree for the first time.
  func _ready():
  	pass # Replace with function body.
  
  
  # Called every frame. 'delta' is the elapsed time since the previous frame.
  func _process(delta):
  	pass

========================================
Contents of scripts\ui\main_menu\main_menu.gd:
========================================
  class_name MainMenu
  extends Node2D
  
  
  func _on_exit_button_pressed():
  	get_tree().quit()
  
  
  func _on_settings_button_pressed():
  	get_tree().change_scene_to_file("res://scenes/ui/settings/settings_menu.tscn")
  
  
  func _on_start_button_pressed():
  	get_tree().change_scene_to_file("res://scenes/levels/adventure_mode/base_level.tscn")

========================================
Contents of scripts\ui\main_menu\menu_buttons.gd:
========================================
  class_name MenuButtons
  extends Button
  
  
  # Called when the node enters the scene tree for the first time.
  func _ready():
  	pass # Replace with function body.
  
  
  # Called every frame. 'delta' is the elapsed time since the previous frame.
  func _process(_delta):
  	pass

========================================
Contents of scripts\ui\main_menu\start_background.gd:
========================================
  class_name StartBackground
  extends ParallaxBackground
  
  var scrolling_speed = 50
  # Called every frame. 'delta' is the elapsed time since the previous frame.
  func _process(delta):
  	scroll_offset.x -= scrolling_speed * delta

========================================
Contents of scripts\ui\objective_tracker.gd:
========================================
  class_name ObjectiveTracker
  extends Control
  
  ## A UI component for tracking and displaying game objectives
  ## Supports multiple objectives with progress tracking
  
  # UI components
  @onready var objectives_container = $ObjectivesContainer
  @onready var objective_template = $ObjectiveTemplate
  
  # Data structure for tracking objectives
  var objectives = {}
  
  # Optional theme reference
  var ui_theme = null
  
  # Signals
  signal objective_added(objective_id, description, total)
  signal objective_updated(objective_id, progress, total)
  signal objective_completed(objective_id)
  signal all_objectives_completed()
  
  func _ready():
  	# Hide the template
  	if objective_template:
  		objective_template.visible = false
  	
  	# Try to get UI theme
  	ui_theme = get_node_or_null("/root/UITheme")
  	if ui_theme:
  		ui_theme.theme_changed.connect(_on_theme_changed)
  		_apply_theme()
  
  # Add a new objective to track
  func add_objective(objective_id: String, description: String, total: int = 1) -> bool:
  	if objectives.has(objective_id):
  		push_warning("Objective already exists: " + objective_id)
  		return false
  	
  	# Create new objective data
  	objectives[objective_id] = {
  		"description": description,
  		"progress": 0,
  		"total": total,
  		"completed": false,
  		"ui_element": null
  	}
  	
  	# Create UI element
  	_create_objective_ui(objective_id)
  	
  	emit_signal("objective_added", objective_id, description, total)
  	return true
  
  # Update an objective's progress
  func update_objective(objective_id: String, progress: int, total: int = -1, description: String = "") -> bool:
  	if not objectives.has(objective_id):
  		push_warning("Cannot update non-existent objective: " + objective_id)
  		return false
  	
  	var objective = objectives[objective_id]
  	
  	# Update the progress
  	objective.progress = progress
  	
  	# Update total if specified
  	if total > 0:
  		objective.total = total
  		
  	# Update description if provided
  	if description != "":
  		objective.description = description
  	
  	# Check if newly completed
  	var newly_completed = false
  	if progress >= objective.total and not objective.completed:
  		objective.completed = true
  		newly_completed = true
  	
  	# Update UI
  	_update_objective_ui(objective_id)
  	
  	# Handle completion
  	if newly_completed:
  		emit_signal("objective_completed", objective_id)
  		_check_all_objectives_completed()
  	else:
  		emit_signal("objective_updated", objective_id, progress, objective.total)
  	
  	return true
  
  # Mark an objective as complete
  func complete_objective(objective_id: String) -> bool:
  	if not objectives.has(objective_id):
  		push_warning("Cannot complete non-existent objective: " + objective_id)
  		return false
  	
  	var objective = objectives[objective_id]
  	
  	# Check if already completed
  	if objective.completed:
  		return true
  	
  	# Set as completed
  	objective.progress = objective.total
  	objective.completed = true
  	
  	# Update UI
  	_update_objective_ui(objective_id)
  	
  	emit_signal("objective_completed", objective_id)
  	_check_all_objectives_completed()
  	
  	return true
  
  # Remove an objective
  func remove_objective(objective_id: String) -> bool:
  	if not objectives.has(objective_id):
  		push_warning("Cannot remove non-existent objective: " + objective_id)
  		return false
  	
  	var objective = objectives[objective_id]
  	
  	# Remove UI element if it exists
  	if objective.ui_element and is_instance_valid(objective.ui_element):
  		objective.ui_element.queue_free()
  	
  	# Remove from tracking
  	objectives.erase(objective_id)
  	
  	return true
  
  # Clear all objectives
  func clear_all_objectives() -> void:
  	# Remove all UI elements
  	for objective_id in objectives:
  		var objective = objectives[objective_id]
  		if objective.ui_element and is_instance_valid(objective.ui_element):
  			objective.ui_element.queue_free()
  	
  	# Clear the tracking dictionary
  	objectives.clear()
  
  # Check if all objectives are completed
  func are_all_objectives_completed() -> bool:
  	if objectives.size() == 0:
  		return false
  	
  	for objective_id in objectives:
  		if not objectives[objective_id].completed:
  			return false
  	
  	return true
  
  # Check if a specific objective exists
  func has_objective(objective_id: String) -> bool:
  	return objectives.has(objective_id)
  
  # Check if a specific objective is completed
  func is_objective_completed(objective_id: String) -> bool:
  	if not objectives.has(objective_id):
  		return false
  	return objectives[objective_id].completed
  
  # Get objective progress
  func get_objective_progress(objective_id: String) -> Dictionary:
  	if not objectives.has(objective_id):
  		return {}
  	
  	var objective = objectives[objective_id]
  	return {
  		"progress": objective.progress,
  		"total": objective.total,
  		"completed": objective.completed
  	}
  
  # Create UI for a new objective
  func _create_objective_ui(objective_id: String) -> void:
  	if not objective_template or not objectives_container:
  		push_error("Objective tracker UI components not found")
  		return
  	
  	var objective = objectives[objective_id]
  	
  	# Create from template
  	var new_objective_ui = objective_template.duplicate()
  	new_objective_ui.name = "Objective_" + objective_id
  	new_objective_ui.visible = true
  	objectives_container.add_child(new_objective_ui)
  	
  	# Set initial content
  	var description_label = new_objective_ui.get_node_or_null("Description")
  	var progress_label = new_objective_ui.get_node_or_null("Progress")
  	var progress_bar = new_objective_ui.get_node_or_null("ProgressBar")
  	
  	if description_label:
  		description_label.text = objective.description
  	
  	if progress_label:
  		if objective.total > 1:
  			progress_label.text = str(objective.progress) + " / " + str(objective.total)
  		else:
  			progress_label.visible = false
  	
  	if progress_bar:
  		if objective.total > 1:
  			progress_bar.max_value = objective.total
  			progress_bar.value = objective.progress
  		else:
  			progress_bar.visible = false
  	
  	# Store the UI reference
  	objective.ui_element = new_objective_ui
  	
  	# Apply theme
  	if ui_theme:
  		_apply_theme_to_objective(new_objective_ui, objective.completed)
  
  # Update UI for an existing objective
  func _update_objective_ui(objective_id: String) -> void:
  	if not objectives.has(objective_id):
  		return
  	
  	var objective = objectives[objective_id]
  	var ui_element = objective.ui_element
  	
  	if not ui_element or not is_instance_valid(ui_element):
  		return
  	
  	# Update content
  	var description_label = ui_element.get_node_or_null("Description")
  	var progress_label = ui_element.get_node_or_null("Progress")
  	var progress_bar = ui_element.get_node_or_null("ProgressBar")
  	var completed_icon = ui_element.get_node_or_null("CompletedIcon")
  	
  	if description_label:
  		description_label.text = objective.description
  	
  	if progress_label:
  		if objective.total > 1:
  			progress_label.text = str(objective.progress) + " / " + str(objective.total)
  			progress_label.visible = true
  		else:
  			progress_label.visible = false
  	
  	if progress_bar:
  		if objective.total > 1:
  			progress_bar.max_value = objective.total
  			progress_bar.value = objective.progress
  			progress_bar.visible = true
  		else:
  			progress_bar.visible = false
  	
  	if completed_icon:
  		completed_icon.visible = objective.completed
  	
  	# Apply theme with completion state
  	if ui_theme:
  		_apply_theme_to_objective(ui_element, objective.completed)
  	
  	# Apply completed styling
  	if objective.completed:
  		# Visual indication of completion
  		if description_label:
  			description_label.modulate = Color(0.7, 1.0, 0.7)  # Slight green tint
  		
  		# Add completion animation if needed
  		if not ui_element.has_meta("completion_animated"):
  			var tween = create_tween()
  			tween.tween_property(ui_element, "modulate", Color(1.5, 1.5, 1.5), 0.2)
  			tween.tween_property(ui_element, "modulate", Color(1, 1, 1), 0.3)
  			ui_element.set_meta("completion_animated", true)
  
  # Check if all objectives are completed and emit signal if so
  func _check_all_objectives_completed() -> void:
  	if are_all_objectives_completed():
  		emit_signal("all_objectives_completed")
  
  # Apply theme to the entire tracker
  func _apply_theme() -> void:
  	if not ui_theme:
  		return
  	
  	# Apply to container background if needed
  	var panel = get_node_or_null("Background")
  	if panel and panel is Panel:
  		var style = ui_theme.create_panel_style("background", "", "small", 0)
  		panel.add_theme_stylebox_override("panel", style)
  	
  	# Apply to all objective UI elements
  	for objective_id in objectives:
  		var objective = objectives[objective_id]
  		if objective.ui_element and is_instance_valid(objective.ui_element):
  			_apply_theme_to_objective(objective.ui_element, objective.completed)
  
  # Apply theme to a specific objective UI element
  func _apply_theme_to_objective(ui_element: Control, is_completed: bool) -> void:
  	if not ui_theme:
  		return
  	
  	var description_label = ui_element.get_node_or_null("Description")
  	var progress_label = ui_element.get_node_or_null("Progress")
  	var progress_bar = ui_element.get_node_or_null("ProgressBar")
  	
  	if description_label:
  		var color = ui_theme.get_color("success") if is_completed else ui_theme.get_color("foreground")
  		description_label.add_theme_color_override("font_color", color)
  	
  	if progress_label:
  		progress_label.add_theme_color_override("font_color", ui_theme.get_color("secondary"))
  	
  	if progress_bar:
  		# Style the progress bar
  		var fg_stylebox = StyleBoxFlat.new()
  		fg_stylebox.bg_color = ui_theme.get_color("primary")
  		fg_stylebox.corner_radius_top_left = ui_theme.get_corner_radius("small")
  		fg_stylebox.corner_radius_top_right = ui_theme.get_corner_radius("small")
  		fg_stylebox.corner_radius_bottom_left = ui_theme.get_corner_radius("small")
  		fg_stylebox.corner_radius_bottom_right = ui_theme.get_corner_radius("small")
  		
  		var bg_stylebox = fg_stylebox.duplicate()
  		bg_stylebox.bg_color = ui_theme.get_color("background").lightened(0.1)
  		
  		progress_bar.add_theme_stylebox_override("fill", fg_stylebox)
  		progress_bar.add_theme_stylebox_override("background", bg_stylebox)
  
  # Handle theme changes
  func _on_theme_changed(_theme_name) -> void:
  	_apply_theme()

========================================
Contents of scripts\ui\settings\audio_settings.gd:
========================================
  class_name AudioSettings
  extends Node2D
  
  
  # Called when the node enters the scene tree for the first time.
  func _ready():
  	pass # Replace with function body.
  
  
  # Called every frame. 'delta' is the elapsed time since the previous frame.
  func _process(delta):
  	pass
  
  
  func _on_back_button_pressed():
  	get_tree().change_scene_to_file("res://scenes/ui/settings/settings_menu.tscn")
  	
  var master_bus = AudioServer.get_bus_index("Master")
  
  
  func _on_h_slider_value_changed(value):
  	AudioServer.set_bus_volume_db(master_bus, value)
  	
  	if value == -30:
  		AudioServer.set_bus_mute(master_bus, true)
  	else:
  		AudioServer.set_bus_mute(master_bus, false)

========================================
Contents of scripts\ui\settings\settings_menu.gd:
========================================
  class_name SettingsMenu
  extends Node2D
  
  "res://scripts/ui/settings/settings_menu.gd"
  # Called when the node enters the scene tree for the first time.
  func _ready():
  	pass # Replace with function body.
  
  
  # Called every frame. 'delta' is the elapsed time since the previous frame.
  func _process(delta):
  	pass
  
  
  func _on_back_button_pressed():
  	get_tree().change_scene_to_file("res://scenes/ui/main_menu/main_menu.tscn")
  
  
  func _on_audio_button_pressed():
  	get_tree().change_scene_to_file("res://scenes/ui/settings/audio_settings.tscn")
  
  
  func _on_customizer_button_pressed():
  	get_tree().change_scene_to_file("res://scenes/ui/character_customizer/customizer.tscn")

========================================
Contents of scripts\utils\game_resource_preloader.gd:
========================================
  class_name GameResourcePreloader
  extends Node
  
  ## A utility class for preloading and managing game resources
  ## Helps improve loading times by caching frequently used resources
  
  # Resource cache organized by type and ID
  var _cache = {
  	"scenes": {},
  	"textures": {},
  	"audio": {},
  	"fonts": {},
  	"materials": {},
  	"animations": {},
  	"other": {}
  }
  
  # Signal emitted when a resource is loaded
  signal resource_loaded(type, id, resource)
  # Signal emitted when all queued resources are loaded
  signal all_resources_loaded()
  # Signal emitted on loading progress update
  signal loading_progress(progress, total)
  
  # Queue of resources to load
  var _load_queue = []
  # Count of loaded resources
  var _loaded_count = 0
  # Whether we're currently loading resources
  var _is_loading = false
  # Progress interval for emitting loading_progress signals
  var _progress_interval = 0.1
  var _last_progress_time = 0
  
  ## Initialize with default resources to preload
  func _ready():
  	# Nothing to preload by default
  	pass
  
  ## Add a resource to the preload queue
  func queue_resource(path: String, type: String = "other", id: String = ""):
  	if id == "":
  		id = path.get_file().get_basename()
  
  	# Check if already in cache
  	if has_resource(type, id):
  		return true
  
  	# Add to queue
  	_load_queue.append({
  		"path": path,
  		"type": type,
  		"id": id
  	})
  	
  	return true
  
  ## Start loading all queued resources
  func load_queued_resources(use_thread: bool = true):
  	if _is_loading:
  		return false
  	
  	if _load_queue.size() == 0:
  		emit_signal("all_resources_loaded")
  		return true
  	
  	_is_loading = true
  	_loaded_count = 0
  	_last_progress_time = Time.get_ticks_msec() / 1000.0
  	
  	if use_thread:
  		_start_threaded_loading()
  	else:
  		_start_immediate_loading()
  	
  	return true
  
  ## Load a single resource immediately
  func load_resource(path: String, type: String = "other", id: String = "") -> Resource:
  	if id == "":
  		id = path.get_file().get_basename()
  	
  	# Check if already in cache
  	if has_resource(type, id):
  		return get_resource(type, id)
  	
  	# Load and cache
  	var resource = ResourceLoader.load(path)
  	if resource:
  		_cache_resource(resource, type, id)
  		emit_signal("resource_loaded", type, id, resource)
  		return resource
  	
  	push_error("Failed to load resource: " + path)
  	return null
  
  ## Check if a resource is in the cache
  func has_resource(type: String, id: String) -> bool:
  	if not _cache.has(type):
  		return false
  	return _cache[type].has(id)
  
  ## Get a resource from the cache
  func get_resource(type: String, id: String) -> Resource:
  	if not has_resource(type, id):
  		push_error("Resource not found in cache: " + type + "/" + id)
  		return null
  	
  	return _cache[type][id]
  
  ## Clear the cache for a specific type
  func clear_cache(type: String = ""):
  	if type == "":
  		# Clear all caches
  		for t in _cache:
  			_cache[t].clear()
  	elif _cache.has(type):
  		_cache[type].clear()
  
  ## Clear the load queue
  func clear_queue():
  	_load_queue.clear()
  	_loaded_count = 0
  	_is_loading = false
  
  ## Get cache statistics
  func get_cache_stats() -> Dictionary:
  	var stats = {}
  	
  	for type in _cache:
  		stats[type] = _cache[type].size()
  	
  	stats["total"] = 0
  	for type in stats:
  		stats["total"] += stats[type]
  	
  	return stats
  
  ## Process loading queue in the main thread (immediate)
  func _start_immediate_loading():
  	for resource_info in _load_queue:
  		var resource = ResourceLoader.load(resource_info.path)
  		if resource:
  			_cache_resource(resource, resource_info.type, resource_info.id)
  			_loaded_count += 1
  			
  			# Emit progress signal at intervals
  			var current_time = Time.get_ticks_msec() / 1000.0
  			if current_time - _last_progress_time >= _progress_interval:
  				_last_progress_time = current_time
  				emit_signal("loading_progress", _loaded_count, _load_queue.size())
  			
  			emit_signal("resource_loaded", resource_info.type, resource_info.id, resource)
  		else:
  			push_error("Failed to load resource: " + resource_info.path)
  	
  	_load_queue.clear()
  	_is_loading = false
  	emit_signal("loading_progress", _loaded_count, _loaded_count)
  	emit_signal("all_resources_loaded")
  
  ## Process loading queue in a background thread
  func _start_threaded_loading():
  	# Create a new thread for loading
  	var thread = Thread.new()
  	thread.start(Callable(self, "_threaded_loading"))
  	
  	# Thread cleanup will happen in _threaded_loading
  
  ## Thread function for background loading
  func _threaded_loading():
  	var total = _load_queue.size()
  	
  	for resource_info in _load_queue:
  		var path = resource_info.path
  		var type = resource_info.type
  		var id = resource_info.id
  		
  		# Use ResourceLoader.load_threaded_request to start loading
  		ResourceLoader.load_threaded_request(path)
  		
  		# Poll until loading completes
  		var status = ResourceLoader.load_threaded_get_status(path)
  		while status == ResourceLoader.THREAD_LOAD_IN_PROGRESS:
  			OS.delay_msec(10) # Small delay to prevent high CPU usage
  			status = ResourceLoader.load_threaded_get_status(path)
  		
  		# Process the result
  		if status == ResourceLoader.THREAD_LOAD_LOADED:
  			var resource = ResourceLoader.load_threaded_get(path)
  			if resource:
  				# Use call_deferred to update the cache on the main thread
  				call_deferred("_cache_resource", resource, type, id)
  				_loaded_count += 1
  				
  				# Emit signals on the main thread
  				var progress_data = {"count": _loaded_count, "total": total}
  				call_deferred("_emit_loading_progress", progress_data)
  				call_deferred("_emit_resource_loaded", type, id, resource)
  			else:
  				push_error("Failed to load threaded resource: " + path)
  		else:
  			push_error("Failed to load threaded resource: " + path + ", status: " + str(status))
  	
  	# Clear queue and emit completion on the main thread
  	call_deferred("_finish_loading")
  	
  	# Thread cleanup happens automatically in Godot 4.x
  
  ## Safely emit loading progress signal from thread
  func _emit_loading_progress(data: Dictionary):
  	var current_time = Time.get_ticks_msec() / 1000.0
  	if current_time - _last_progress_time >= _progress_interval:
  		_last_progress_time = current_time
  		emit_signal("loading_progress", data.count, data.total)
  
  ## Safely emit resource loaded signal from thread
  func _emit_resource_loaded(type: String, id: String, resource: Resource):
  	emit_signal("resource_loaded", type, id, resource)
  
  ## Finish loading process
  func _finish_loading():
  	_load_queue.clear()
  	_is_loading = false
  	emit_signal("loading_progress", _loaded_count, _loaded_count)
  	emit_signal("all_resources_loaded")
  
  ## Add a resource to the cache
  func _cache_resource(resource: Resource, type: String, id: String):
  	# Create the type category if it doesn't exist
  	if not _cache.has(type):
  		_cache[type] = {}
  	
  	# Cache the resource
  	_cache[type][id] = resource
  
  ## Preload common resources for a specific level or scene
  func preload_level_resources(level_name: String) -> bool:
  	# This method should be customized per game to preload
  	# appropriate resources for each level
  	match level_name:
  		"main_menu":
  			queue_resource("res://scenes/ui/main_menu/main_menu.tscn", "scenes", "main_menu")
  			# Add UI elements, backgrounds, etc.
  			return true
  			
  		"adventure_level":
  			queue_resource("res://scenes/levels/adventure_mode/adventure_level.tscn", "scenes", "adventure_level")
  			# Add player, enemies, items, etc.
  			return true
  			
  		_:
  			push_warning("No preload configuration for level: " + level_name)
  			return false
  	
  	return false
  
  ## Unload resources that are not needed for the current scene
  func unload_unused_resources(keep_types: Array = []):
  	var stats_before = get_cache_stats()
  	
  	# Keep all resources of specified types
  	for type in _cache:
  		if type in keep_types:
  			continue
  		
  		# Clear this type of resources
  		_cache[type].clear()
  	
  	var stats_after = get_cache_stats()
  	print("Unloaded resources - Before: ", stats_before.total, ", After: ", stats_after.total)
  	
  	# Force garbage collection
  	ResourceLoader.load_threaded_request("res://")
  	ResourceLoader.load_threaded_get_status("res://")

========================================
Contents of scripts\utils\killzone.gd:
========================================
  class_name Killzone
  extends Area2D
  
  @onready var timer = $Timer
  
  func _on_body_entered(body):
  	print("you died!")
  	Engine.time_scale = 0.5
  	body.get_node("CollisionShape2D").queue_free()
  	timer.start()
  	
  
  
  func _on_timer_timeout():
  	Engine.time_scale = 1.0
  	get_tree().reload_current_scene()

========================================
Contents of scripts\utils\object_pool.gd:
========================================
  class_name ObjectPool
  extends Node
  
  ## A generic object pooling system for reusing objects instead of creating and destroying them
  
  # The scene to create objects from
  var scene: PackedScene
  # Maximum number of objects to keep in the pool (0 = unlimited)
  var max_size: int = 0
  # Container for inactive objects
  var inactive_objects: Array = []
  # Container to track all spawned objects (both active and inactive)
  var all_objects: Array = []
  # Whether to automatically resize the pool as needed
  var auto_resize: bool = true
  # Parent node for spawned objects
  var parent_node: Node = null
  
  # Signal emitted when an object is taken from the pool
  signal object_spawned(object)
  # Signal emitted when an object is returned to the pool
  signal object_recycled(object)
  
  ## Create a new object pool with the specified scene
  func _init(object_scene: PackedScene, pool_size: int = 10, auto_resize_pool: bool = true):
  	scene = object_scene
  	max_size = pool_size
  	auto_resize = auto_resize_pool
  	
  	# Check if scene is valid before pre-populating
  	if scene == null:
  		push_error("ObjectPool: Cannot initialize with null scene")
  		return
  	
  	# Pre-populate the pool with objects
  	for i in range(pool_size):
  		var obj = _create_object()
  		if obj != null:
  			inactive_objects.append(obj)
  			all_objects.append(obj)
  
  ## Set the parent node for all pooled objects
  func set_parent(parent: Node):
  	parent_node = parent
  	
  	# Reparent existing objects
  	for obj in all_objects:
  		if obj.get_parent():
  			obj.get_parent().remove_child(obj)
  		parent_node.add_child(obj)
  
  ## Get an object from the pool, or create a new one if the pool is empty
  func get_object() -> Node:
  	# First check if the scene is valid
  	if scene == null:
  		push_error("ObjectPool: Cannot get object from pool with null scene")
  		return null
  		
  	var obj = null
  	
  	if inactive_objects.size() > 0:
  		# Take an object from the inactive pool
  		obj = inactive_objects.pop_back()
  	elif auto_resize:
  		# Create a new object if we're allowed to resize the pool
  		obj = _create_object()
  		if obj != null:
  			all_objects.append(obj)
  	else:
  		push_error("Object pool is empty and auto-resize is disabled!")
  		return null
  	
  	if obj != null:
  		if obj.has_method("_on_spawn_from_pool"):
  			obj._on_spawn_from_pool()
  		
  		# Ensure the object is visible and active
  		obj.visible = true
  		obj.process_mode = Node.PROCESS_MODE_INHERIT
  		
  		emit_signal("object_spawned", obj)
  	
  	return obj
  
  ## Return an object to the pool for reuse
  func recycle(obj: Node) -> void:
  	if not all_objects.has(obj):
  		push_error("Attempted to recycle an object that wasn't created by this pool!")
  		return
  	
  	# Make sure it's not already in the inactive pool
  	if inactive_objects.has(obj):
  		return
  	
  	# Prepare the object for recycling
  	if obj.has_method("_on_recycle_to_pool"):
  		obj._on_recycle_to_pool()
  	
  	# Hide and disable the object
  	obj.visible = false
  	obj.process_mode = Node.PROCESS_MODE_DISABLED
  	
  	# Add to inactive pool, respecting max size
  	if max_size <= 0 or inactive_objects.size() < max_size:
  		inactive_objects.append(obj)
  	else:
  		# If the pool is full, destroy the object
  		all_objects.erase(obj)
  		obj.queue_free()
  	
  	emit_signal("object_recycled", obj)
  
  ## Clear the entire pool, freeing all objects
  func clear_pool() -> void:
  	for obj in all_objects:
  		obj.queue_free()
  	
  	inactive_objects.clear()
  	all_objects.clear()
  
  ## Resize the pool to the specified size
  func resize(new_size: int) -> void:
  	if new_size < 0:
  		push_error("Cannot resize pool to negative size!")
  		return
  	
  	if new_size < inactive_objects.size():
  		# Need to shrink the pool
  		while inactive_objects.size() > new_size:
  			var obj = inactive_objects.pop_back()
  			all_objects.erase(obj)
  			obj.queue_free()
  	else:
  		# Need to grow the pool
  		for i in range(new_size - inactive_objects.size()):
  			var obj = _create_object()
  			if obj != null:
  				inactive_objects.append(obj)
  				all_objects.append(obj)
  	
  	max_size = new_size
  
  ## Get the current number of active objects
  func active_count() -> int:
  	return all_objects.size() - inactive_objects.size()
  
  ## Get the current number of inactive objects
  func inactive_count() -> int:
  	return inactive_objects.size()
  
  ## Get the total number of objects managed by this pool
  func total_count() -> int:
  	return all_objects.size()
  
  ## Create a new object and set it up for the pool
  func _create_object() -> Node:
  	if scene == null:
  		push_error("ObjectPool: Cannot instantiate from null scene")
  		return null
  
  	var obj = scene.instantiate()
  	
  	# Set up parent if specified
  	if parent_node:
  		parent_node.add_child(obj)
  	
  	# Hide and disable by default
  	obj.visible = false
  	obj.process_mode = Node.PROCESS_MODE_DISABLED
  	
  	return obj

========================================
Contents of scripts\utils\save_data.gd:
========================================
  class_name SaveData
  extends Resource
  
  ## Data structure for saved games in The Little Saint
  ## Stores player stats, game progress, and settings
  
  # Version for compatibility checks
  @export var save_version: int = 1
  
  # Save metadata
  @export var save_date: String = ""
  @export var playtime_seconds: int = 0
  
  # Player position and level
  @export var player_position: Vector2 = Vector2.ZERO
  @export var current_level: String = ""
  
  # Player stats
  @export var health: float = 3.0
  @export var coins: int = 0
  @export var player_speed: float = Constants.PLAYER_DEFAULT_SPEED
  @export var player_jump_velocity: float = Constants.PLAYER_DEFAULT_JUMP_VELOCITY
  @export var player_fly_velocity: float = Constants.PLAYER_DEFAULT_FLY_VELOCITY
  @export var player_gravity: float = Constants.PLAYER_DEFAULT_GRAVITY
  
  # Player state
  @export var player_mode: String = "normal"
  @export var player_passed_fly_time: float = 0.0
  @export var player_jump_counter: int = 0
  @export var player_ready_for_jump: bool = true
  @export var player_allowed_jumps: int = 1
  
  # Player appearance
  @export var player_outfit: Dictionary = {}
  
  # Game progress
  @export var collected_coins: int = 0
  @export var unlocked_levels: Array = []
  @export var completed_quests: Array = []
  
  # Initialize with default values
  func _init():
  	save_date = Time.get_datetime_string_from_system(false, true)
  	
  	# Set default player outfit if none exists
  	if player_outfit.is_empty():
  		# Create a default outfit
  		player_outfit = {
  			"beard": "none",
  			"lipstick": "none",
  			"eyes": "1",
  			"shoes": "1",
  			"earrings": "none",
  			"hats": "none",
  			"glasses": "none",
  			"clothes_down": "1",
  			"clothes_up": "1",
  			"clothes_complete": "none",
  			"bodies": "1",
  			"hair": "1"
  		}
  
  # Validate the save data to ensure it's not corrupted
  func validate() -> bool:
  	# Basic validation to ensure critical fields are present
  	if player_speed <= 0 or player_gravity <= 0:
  		return false
  	
  	# Check that outfit dictionary has expected keys
  	var required_outfit_keys = [
  		"beard", "lipstick", "eyes", "shoes", "earrings", 
  		"hats", "glasses", "clothes_down", "clothes_up", 
  		"clothes_complete", "bodies", "hair"
  	]
  	
  	for key in required_outfit_keys:
  		if not player_outfit.has(key):
  			return false
  	
  	return true
  
  # Create a dictionary representation of the save data for debug purposes
  func to_dict() -> Dictionary:
  	return {
  		"save_version": save_version,
  		"save_date": save_date,
  		"playtime_seconds": playtime_seconds,
  		"player_position": {"x": player_position.x, "y": player_position.y},
  		"current_level": current_level,
  		"health": health,
  		"coins": coins,
  		"player_speed": player_speed,
  		"player_jump_velocity": player_jump_velocity,
  		"player_fly_velocity": player_fly_velocity,
  		"player_gravity": player_gravity,
  		"player_mode": player_mode,
  		"player_passed_fly_time": player_passed_fly_time,
  		"player_jump_counter": player_jump_counter,
  		"player_ready_for_jump": player_ready_for_jump,
  		"player_allowed_jumps": player_allowed_jumps,
  		"player_outfit": player_outfit,
  		"collected_coins": collected_coins,
  		"unlocked_levels": unlocked_levels,
  		"completed_quests": completed_quests
  	}
  
  # Return a string representation for debugging
  func _to_string() -> String:
  	return JSON.stringify(to_dict(), "\t")
  
  # Update playtime
  func update_playtime(seconds_to_add: int) -> void:
  	playtime_seconds += seconds_to_add
  
  # Get formatted playtime as string
  func get_playtime_string() -> String:
  	var hours = playtime_seconds / 3600
  	var minutes = (playtime_seconds % 3600) / 60
  	var seconds = playtime_seconds % 60
  	
  	return "%02d:%02d:%02d" % [hours, minutes, seconds]
  
  # Create a deep copy of this save data
  func duplicate_data() -> SaveData:
  	var new_data = SaveData.new()
  	
  	new_data.save_version = save_version
  	new_data.save_date = save_date
  	new_data.playtime_seconds = playtime_seconds
  	new_data.player_position = player_position
  	new_data.current_level = current_level
  	new_data.health = health
  	new_data.coins = coins
  	new_data.player_speed = player_speed
  	new_data.player_jump_velocity = player_jump_velocity
  	new_data.player_fly_velocity = player_fly_velocity
  	new_data.player_gravity = player_gravity
  	new_data.player_mode = player_mode
  	new_data.player_passed_fly_time = player_passed_fly_time
  	new_data.player_jump_counter = player_jump_counter
  	new_data.player_ready_for_jump = player_ready_for_jump
  	new_data.player_allowed_jumps = player_allowed_jumps
  	new_data.player_outfit = player_outfit.duplicate(true)
  	new_data.collected_coins = collected_coins
  	new_data.unlocked_levels = unlocked_levels.duplicate()
  	new_data.completed_quests = completed_quests.duplicate()
  	
  	return new_data
  
  # Create a new save with default values
  static func create_new_save() -> SaveData:
  	var save = SaveData.new()
  	save.save_date = Time.get_datetime_string_from_system(false, true)
  	return save

========================================
Contents of scripts\utils\ui_theme.gd:
========================================
  class_name UITheme
  extends Node
  
  ## A central manager for UI themes and styling across the game
  ## Handles theme properties, color palettes, and consistent UI elements
  
  # Current theme name
  var current_theme: String = "default"
  
  # Available themes
  var available_themes: Array = ["default", "dark", "light", "custom"]
  
  # Color palettes for each theme
  var theme_colors = {
  	"default": {
  		"background": Color("#1f1f1f"),
  		"foreground": Color("#ffffff"),
  		"primary": Color("#e7896a"),      # Clay/terracotta color from your game
  		"secondary": Color("#4aa8d8"),    # Blue accent
  		"accent": Color("#a8d84a"),       # Green accent
  		"error": Color("#d84a4a"),        # Red for errors/warnings
  		"success": Color("#4ad84a"),      # Green for success
  		"warning": Color("#d8d84a"),      # Yellow for warnings
  		"disabled": Color("#7f7f7f"),     # Gray for disabled elements
  		"transparent": Color(0, 0, 0, 0)  # Fully transparent
  	},
  	"dark": {
  		"background": Color("#121212"),
  		"foreground": Color("#f0f0f0"),
  		"primary": Color("#d87a5f"),      # Darker clay color
  		"secondary": Color("#3a8ab8"),    # Darker blue
  		"accent": Color("#8ab83a"),       # Darker green
  		"error": Color("#b83a3a"),        # Darker red
  		"success": Color("#3ab83a"),      # Darker green
  		"warning": Color("#b8b83a"),      # Darker yellow
  		"disabled": Color("#5f5f5f"),     # Darker gray
  		"transparent": Color(0, 0, 0, 0)
  	},
  	"light": {
  		"background": Color("#f5f5f5"),
  		"foreground": Color("#202020"),
  		"primary": Color("#ff9478"),      # Lighter clay color
  		"secondary": Color("#78c4ff"),    # Lighter blue
  		"accent": Color("#c4ff78"),       # Lighter green
  		"error": Color("#ff7878"),        # Lighter red
  		"success": Color("#78ff78"),      # Lighter green
  		"warning": Color("#ffff78"),      # Lighter yellow
  		"disabled": Color("#a0a0a0"),     # Lighter gray
  		"transparent": Color(0, 0, 0, 0)
  	},
  	"custom": {
  		# Will be populated from user settings
  	}
  }
  
  # Font sizes for different UI elements
  var font_sizes = {
  	"small": 12,
  	"regular": 16,
  	"large": 20,
  	"title": 24,
  	"heading": 32
  }
  
  # Margin and padding sizes
  var spacing = {
  	"tiny": 2,
  	"small": 4,
  	"regular": 8,
  	"large": 16,
  	"xlarge": 24
  }
  
  # Corner radius for UI elements
  var corner_radius = {
  	"none": 0,
  	"small": 4,
  	"regular": 8,
  	"large": 16,
  	"pill": 9999  # Very large value for pill shape
  }
  
  # Animation durations
  var animation_durations = {
  	"fast": 0.1,
  	"regular": 0.3,
  	"slow": 0.5
  }
  
  # Default fonts
  var fonts = {
  	"regular": null,
  	"bold": null,
  	"title": null,
  	"monospace": null
  }
  
  # Signal emitted when theme changes
  signal theme_changed(theme_name)
  
  # Initialize the theme system
  func _ready():
  	# Load fonts
  	_load_fonts()
  	
  	# Try to load user theme preferences
  	_load_theme_preferences()
  	
  	print("UI Theme Manager initialized with theme: ", current_theme)
  
  # Set the active theme
  func set_theme(theme_name: String) -> bool:
  	if theme_name in available_themes:
  		current_theme = theme_name
  		emit_signal("theme_changed", theme_name)
  		return true
  	return false
  
  # Get a color from the current theme
  func get_color(color_name: String) -> Color:
  	if theme_colors.has(current_theme) and theme_colors[current_theme].has(color_name):
  		return theme_colors[current_theme][color_name]
  	
  	# Fallback to default theme
  	if theme_colors["default"].has(color_name):
  		return theme_colors["default"][color_name]
  	
  	# Ultimate fallback
  	push_warning("Color not found: " + color_name)
  	return Color.WHITE
  
  # Get a font size
  func get_font_size(size_name: String) -> int:
  	if font_sizes.has(size_name):
  		return font_sizes[size_name]
  	
  	push_warning("Font size not found: " + size_name)
  	return font_sizes["regular"]
  
  # Get spacing value
  func get_spacing(spacing_name: String) -> int:
  	if spacing.has(spacing_name):
  		return spacing[spacing_name]
  	
  	push_warning("Spacing not found: " + spacing_name)
  	return spacing["regular"]
  
  # Get corner radius
  func get_corner_radius(radius_name: String) -> int:
  	if corner_radius.has(radius_name):
  		return corner_radius[radius_name]
  	
  	push_warning("Corner radius not found: " + radius_name)
  	return corner_radius["regular"]
  
  # Get animation duration
  func get_animation_duration(duration_name: String) -> float:
  	if animation_durations.has(duration_name):
  		return animation_durations[duration_name]
  	
  	push_warning("Animation duration not found: " + duration_name)
  	return animation_durations["regular"]
  
  # Get a font
  func get_font(font_name: String) -> Font:
  	if fonts.has(font_name) and fonts[font_name] != null:
  		return fonts[font_name]
  	
  	push_warning("Font not found: " + font_name)
  	return fonts["regular"] if fonts["regular"] != null else null
  
  # Create a panel style with theme colors
  func create_panel_style(
  	bg_color_name: String = "background",
  	border_color_name: String = "",
  	radius_name: String = "regular",
  	border_width: int = 0
  ) -> StyleBoxFlat:
  	var style = StyleBoxFlat.new()
  	
  	# Set background color
  	style.bg_color = get_color(bg_color_name)
  	
  	# Set corner radius
  	var radius = get_corner_radius(radius_name)
  	style.corner_radius_top_left = radius
  	style.corner_radius_top_right = radius
  	style.corner_radius_bottom_left = radius
  	style.corner_radius_bottom_right = radius
  	
  	# Set border if requested
  	if border_color_name != "" and border_width > 0:
  		style.border_width_left = border_width
  		style.border_width_top = border_width
  		style.border_width_right = border_width
  		style.border_width_bottom = border_width
  		style.border_color = get_color(border_color_name)
  	
  	return style
  
  # Create a button style with normal, hover, pressed states
  func create_button_style(
  	normal_color_name: String = "primary",
  	hover_color_name: String = "",
  	pressed_color_name: String = "",
  	disabled_color_name: String = "disabled",
  	radius_name: String = "regular",
  	border_width: int = 0
  ) -> Dictionary:
  	# Get the normal color
  	var normal_color = get_color(normal_color_name)
  	
  	# Calculate derived colors or get specified colors
  	var hover_color: Color
  	var pressed_color: Color
  	
  	if hover_color_name == "":
  		hover_color = normal_color.lightened(0.1)
  	else:
  		hover_color = get_color(hover_color_name)
  	
  	if pressed_color_name == "":
  		pressed_color = normal_color.darkened(0.1)
  	else:
  		pressed_color = get_color(pressed_color_name)
  	
  	# Create styles for each state
  	var normal_style = create_panel_style(normal_color_name, "", radius_name, border_width)
  	
  	var hover_style = normal_style.duplicate()
  	hover_style.bg_color = hover_color
  	
  	var pressed_style = normal_style.duplicate()
  	pressed_style.bg_color = pressed_color
  	
  	var disabled_style = normal_style.duplicate()
  	disabled_style.bg_color = get_color(disabled_color_name)
  	
  	return {
  		"normal": normal_style,
  		"hover": hover_style,
  		"pressed": pressed_style,
  		"disabled": disabled_style
  	}
  
  # Apply theme to a control
  func apply_theme_to_control(control: Control, theme_preset: String = "default") -> void:
  	match theme_preset:
  		"default":
  			_apply_default_theme(control)
  		"button":
  			_apply_button_theme(control)
  		"panel":
  			_apply_panel_theme(control)
  		"label":
  			_apply_label_theme(control)
  		_:
  			push_warning("Unknown theme preset: " + theme_preset)
  			_apply_default_theme(control)
  
  # Set custom theme colors
  func set_custom_colors(colors: Dictionary) -> void:
  	for color_name in colors:
  		if color_name in theme_colors["custom"]:
  			theme_colors["custom"][color_name] = colors[color_name]
  	
  	# Ensure all colors are defined
  	for color_name in theme_colors["default"]:
  		if not theme_colors["custom"].has(color_name):
  			theme_colors["custom"][color_name] = theme_colors["default"][color_name]
  	
  	# If custom theme is current, notify of change
  	if current_theme == "custom":
  		emit_signal("theme_changed", current_theme)
  
  # Save theme preferences
  func save_theme_preferences() -> bool:
  	var config = ConfigFile.new()
  	
  	# Store current theme
  	config.set_value("theme", "current_theme", current_theme)
  	
  	# Store custom theme colors
  	config.set_value("theme", "custom_colors", theme_colors["custom"])
  	
  	# Store font sizes
  	config.set_value("theme", "font_sizes", font_sizes)
  	
  	# Save the config
  	var err = config.save("user://theme_settings.cfg")
  	return err == OK
  
  # Load the fonts
  func _load_fonts() -> void:
  	var default_font = load("res://assets/fonts/general/default_font.tres") if ResourceLoader.exists("res://assets/fonts/general/default_font.tres") else null
  	
  	fonts["regular"] = default_font
  	fonts["bold"] = load("res://assets/fonts/general/default_font_bold.tres") if ResourceLoader.exists("res://assets/fonts/general/default_font_bold.tres") else default_font
  	fonts["title"] = load("res://assets/fonts/special/copyduck/Copyduck.ttf") if ResourceLoader.exists("res://assets/fonts/special/copyduck/Copyduck.ttf") else default_font
  	fonts["monospace"] = load("res://assets/fonts/general/default_mono.tres") if ResourceLoader.exists("res://assets/fonts/general/default_mono.tres") else default_font
  
  # Load theme preferences from config
  func _load_theme_preferences() -> void:
  	var config = ConfigFile.new()
  	var err = config.load("user://theme_settings.cfg")
  	
  	if err == OK:
  		# Load current theme
  		var saved_theme = config.get_value("theme", "current_theme", "default")
  		if saved_theme in available_themes:
  			current_theme = saved_theme
  		
  		# Load custom colors
  		var saved_colors = config.get_value("theme", "custom_colors", {})
  		for color_name in saved_colors:
  			theme_colors["custom"][color_name] = saved_colors[color_name]
  		
  		# Load font sizes
  		var saved_font_sizes = config.get_value("theme", "font_sizes", {})
  		for size_name in saved_font_sizes:
  			font_sizes[size_name] = saved_font_sizes[size_name]
  	else:
  		# If no config exists, initialize custom theme with default colors
  		theme_colors["custom"] = theme_colors["default"].duplicate()
  
  # Apply default theme to a control
  func _apply_default_theme(control: Control) -> void:
  	var theme_override = Theme.new()
  	
  	# Set default font
  	if fonts["regular"]:
  		theme_override.default_font = fonts["regular"]
  		theme_override.default_font_size = get_font_size("regular")
  	
  	# Set default colors
  	theme_override.set_color("font_color", "Label", get_color("foreground"))
  	theme_override.set_color("font_focus_color", "Label", get_color("primary"))
  	
  	control.theme = theme_override
  
  # Apply button theme
  func _apply_button_theme(button: Control) -> void:
  	if not button is Button:
  		push_warning("Cannot apply button theme to non-Button control")
  		return
  	
  	# Apply default theme first
  	_apply_default_theme(button)
  	
  	# Create button styles
  	var styles = create_button_style()
  	
  	# Apply button styles
  	button.add_theme_stylebox_override("normal", styles["normal"])
  	button.add_theme_stylebox_override("hover", styles["hover"])
  	button.add_theme_stylebox_override("pressed", styles["pressed"])
  	button.add_theme_stylebox_override("disabled", styles["disabled"])
  	
  	# Set colors
  	button.add_theme_color_override("font_color", get_color("foreground"))
  	button.add_theme_color_override("font_focus_color", get_color("foreground"))
  	button.add_theme_color_override("font_disabled_color", get_color("disabled"))
  	
  	# Set font
  	if fonts["bold"]:
  		button.add_theme_font_override("font", fonts["bold"])
  
  # Apply panel theme
  func _apply_panel_theme(panel: Control) -> void:
  	if not panel is Panel:
  		push_warning("Cannot apply panel theme to non-Panel control")
  		return
  	
  	# Apply default theme first
  	_apply_default_theme(panel)
  	
  	# Create panel style
  	var style = create_panel_style("background", "foreground", "regular", 1)
  	
  	# Apply panel style
  	panel.add_theme_stylebox_override("panel", style)
  
  # Apply label theme
  func _apply_label_theme(label: Control) -> void:
  	if not label is Label:
  		push_warning("Cannot apply label theme to non-Label control")
  		return
  	
  	# Apply default theme first
  	_apply_default_theme(label)
  	
  	# Set colors
  	label.add_theme_color_override("font_color", get_color("foreground"))
  	label.add_theme_color_override("font_shadow_color", get_color("background"))
  	
  	# Set font
  	label.add_theme_font_override("font", fonts["regular"])
  	label.add_theme_font_size_override("font_size", get_font_size("regular"))

==================================================
Scan completed at 2025-04-11 23:30:54
