PROJECT STRUCTURE SCAN
==================================================
Directory: C:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint
Date: 2025-04-12 14:47:03
Filter mode: include
Included file types: .gd, .godot

Document Support Status:
- PDF: Enabled (Available)
- Word: Enabled (Not available - install python-docx)
- Excel: Enabled (Not available - install openpyxl)
- PowerPoint: Enabled (Available)
==================================================
DIRECTORY STRUCTURE
------------------

[DIR] .git (excluded)
[DIR] .godot (excluded)
[DIR] .vscode (excluded)
[DIR] Artefakte
[DIR] addons
  [DIR] virtual_joystick
    [DIR] previews
    [DIR] test
      - player.gd
    [DIR] textures
    - virtual_joystick.gd
    - virtual_joystick_instantiator.gd
    - virtual_joystick_plugin.gd
[DIR] assets
  [DIR] audio
    [DIR] music
      [DIR] Tracks
    [DIR] sfx
  [DIR] fonts
    [DIR] general
    [DIR] special
      [DIR] copyduck
  [DIR] sprites
    [DIR] WasserTileset
      [DIR] RPGMAKER-100
      [DIR] RPGMAKERMV
      [DIR] RPGMAKERVX
    [DIR] characters
      [DIR] acc
      [DIR] characters
      [DIR] clothes
      [DIR] eyes
      [DIR] greyscale
        [DIR] acc
          [DIR] acc
          [DIR] modular
        [DIR] character
          [DIR] without
        [DIR] clothes
          [DIR] clothes
          [DIR] modular
        [DIR] eyes
        [DIR] hair
        [DIR] tools
      [DIR] hair
      [DIR] separate
        [DIR] axe
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
          [DIR] tool
          [DIR] without
        [DIR] block
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
          [DIR] tool
          [DIR] without
        [DIR] carry
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
        [DIR] die
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
        [DIR] fish
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
          [DIR] tool
          [DIR] without
        [DIR] hoe
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
          [DIR] tool
          [DIR] without
        [DIR] hurt
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
        [DIR] jump
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
        [DIR] pickaxe
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
          [DIR] tool
          [DIR] without
        [DIR] pickup
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
        [DIR] sword
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
          [DIR] tool
          [DIR] without
        [DIR] walk
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
        [DIR] water
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
          [DIR] tool
          [DIR] without
    [DIR] enemies
      [DIR] 1 Bat
      [DIR] 2 Goblin_Mage
      [DIR] 3 Goblin_Melee
      [DIR] 4 Goblin_Range
      [DIR] 5 Small_Mushroom
      [DIR] 6 Big_Mushroom
    [DIR] environment
      [DIR] Industrial
      [DIR] craftpix-896753-village-pixel-art-environment-assets-pack
        [DIR] PNG
          [DIR] Objects
          [DIR] Tiles
      [DIR] craftpix-net-352322-nature-pixel-art-environment-free-assets-pack
        [DIR] PNG
          [DIR] Objects
          [DIR] Tiles
      [DIR] craftpix-net-481981-free-summer-pixel-art-backgrounds
        [DIR] PNG
          [DIR] summer 1
          [DIR] summer 2
          [DIR] summer 3
          [DIR] summer 4
          [DIR] summer5
          [DIR] summer6
          [DIR] summer7
          [DIR] summer8
      [DIR] craftpix-net-965049-free-industrial-zone-tileset-pixel-art
        [DIR] 1 Tiles
        [DIR] 2 Background
        [DIR] 3 Objects
        [DIR] 4 Animated objects
      [DIR] peasant's_house
        [DIR] Peasant's_House
          [DIR] Door_Animation
            [DIR] Door_Animation-FrameByFrame
          [DIR] House_in_the_middle
            [DIR] Door_Animation
            [DIR] Window_Animation
          [DIR] Peasant's_House-NoAnimation
          [DIR] Window_Animation
            [DIR] Window_Animation-FrameByFrame
      [DIR] sunny-land-files
        [DIR] Sunny-land-files
          [DIR] Graphical Assets
            [DIR] environment
              [DIR] Background
              [DIR] Props
            [DIR] sprites
              [DIR] cherry
              [DIR] eagle
              [DIR] enemy-death
              [DIR] frog
                [DIR] idle
                [DIR] jump
              [DIR] gem
              [DIR] item-feedback
              [DIR] opossum
              [DIR] player
                [DIR] climb
                [DIR] crouch
                [DIR] hurt
                [DIR] idle
                [DIR] jump
                [DIR] run
            [DIR] spritesheets
    [DIR] items
    [DIR] ui
    [DIR] unsorted
      [DIR] Audio
        [DIR] Tracks
      [DIR] Bushes
      [DIR] Character v.2
        [DIR] acc
        [DIR] characters
        [DIR] clothes
        [DIR] eyes
        [DIR] greyscale
          [DIR] acc
            [DIR] acc
            [DIR] modular
          [DIR] character
            [DIR] without
          [DIR] clothes
            [DIR] clothes
            [DIR] modular
          [DIR] eyes
          [DIR] hair
          [DIR] tools
        [DIR] hair
        [DIR] separate
          [DIR] axe
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
            [DIR] tool
            [DIR] without
          [DIR] block
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
            [DIR] tool
            [DIR] without
          [DIR] carry
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
          [DIR] die
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
          [DIR] fish
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
            [DIR] tool
            [DIR] without
          [DIR] hoe
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
            [DIR] tool
            [DIR] without
          [DIR] hurt
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
          [DIR] jump
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
          [DIR] pickaxe
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
            [DIR] tool
            [DIR] without
          [DIR] pickup
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
          [DIR] sword
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
            [DIR] tool
            [DIR] without
          [DIR] walk
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
          [DIR] water
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
            [DIR] tool
            [DIR] without
      [DIR] Font
      [DIR] Fonts
        [DIR] copyduck
      [DIR] Monsters
        [DIR] 1 Bat
        [DIR] 2 Goblin_Mage
        [DIR] 3 Goblin_Melee
        [DIR] 4 Goblin_Range
        [DIR] 5 Small_Mushroom
        [DIR] 6 Big_Mushroom
        [DIR] PSD
      [DIR] Peasant's_House
        [DIR] Peasant's_House
          [DIR] Door_Animation
            [DIR] Door_Animation-FrameByFrame
          [DIR] House_in_the_middle
            [DIR] Door_Animation
            [DIR] Window_Animation
          [DIR] Peasant's_House-NoAnimation
          [DIR] Window_Animation
            [DIR] Window_Animation-FrameByFrame
      [DIR] Sunny-land-files
        [DIR] Sunny-land-files
          [DIR] Graphical Assets
            [DIR] Aseprite
            [DIR] GIF Previews
              [DIR] FX
              [DIR] eagle
              [DIR] frog
              [DIR] items
              [DIR] opossum
              [DIR] player
            [DIR] PSD
              [DIR] MISC
              [DIR] environment
              [DIR] sprites
                [DIR] FX
                [DIR] eagle
                [DIR] frog
                [DIR] items
                [DIR] opossum
                [DIR] player
            [DIR] environment
              [DIR] Background
              [DIR] Props
            [DIR] sprites
              [DIR] cherry
              [DIR] eagle
              [DIR] enemy-death
              [DIR] frog
                [DIR] idle
                [DIR] jump
              [DIR] gem
              [DIR] item-feedback
              [DIR] opossum
              [DIR] player
                [DIR] climb
                [DIR] crouch
                [DIR] hurt
                [DIR] idle
                [DIR] jump
                [DIR] run
            [DIR] spritesheets
      [DIR] craftpix-896753-village-pixel-art-environment-assets-pack
        [DIR] PNG
          [DIR] Objects
          [DIR] Tiles
        [DIR] Village_PixelArt_Environment.unitypackage
      [DIR] craftpix-net-352322-nature-pixel-art-environment-free-assets-pack
        [DIR] PNG
          [DIR] Objects
          [DIR] Tiles
      [DIR] craftpix-net-481981-free-summer-pixel-art-backgrounds
        [DIR] PNG
          [DIR] summer 1
          [DIR] summer 2
          [DIR] summer 3
          [DIR] summer 4
          [DIR] summer5
          [DIR] summer6
          [DIR] summer7
          [DIR] summer8
        [DIR] PSD
      [DIR] craftpix-net-965049-free-industrial-zone-tileset-pixel-art
        [DIR] 1 Tiles
        [DIR] 2 Background
        [DIR] 3 Objects
        [DIR] 4 Animated objects
        [DIR] PSD
      [DIR] princefotos
  [DIR] tilemaps
[DIR] config
[DIR] docs
- project.godot
[DIR] scenes
  [DIR] common
    [DIR] enemies
    [DIR] items
  [DIR] core
    [DIR] character
    [DIR] enemies
    [DIR] items
    [DIR] projectiles
  [DIR] levels
    [DIR] adventure_mode
      - main_map.gd
    [DIR] ardit_levels
      [DIR] Egypt
      [DIR] Free
        [DIR] Background
        [DIR] Items
          [DIR] Boxes
            [DIR] Box1
            [DIR] Box2
            [DIR] Box3
          [DIR] Checkpoints
            [DIR] Checkpoint
            [DIR] End
            [DIR] Start
          [DIR] Fruits
        [DIR] Main Characters
          [DIR] Mask Dude
          [DIR] Ninja Frog
          [DIR] Pink Man
          [DIR] Virtual Guy
        [DIR] Menu
          [DIR] Buttons
          [DIR] Levels
          [DIR] Text
        [DIR] Other
        [DIR] Terrain
        [DIR] Traps
          [DIR] Arrow
          [DIR] Blocks
          [DIR] Falling Platforms
          [DIR] Fan
          [DIR] Fire
          [DIR] Platforms
          [DIR] Rock Head
          [DIR] Sand Mud Ice
          [DIR] Saw
          [DIR] Spike Head
          [DIR] Spiked Ball
          [DIR] Spikes
          [DIR] Trampoline
      [DIR] Free Version
        [DIR] Tiles
      [DIR] [Free-Version] The Lost Tomb - [24x24] Dungeon Asset pack
      [DIR] egyptian-game-ui-frames-assets
      [DIR] enemy1
    [DIR] prince_levels
      [DIR] Scriptprince
      [DIR] Tiles
        [DIR] fourSeasonsPlatformer
          [DIR] background_
          [DIR] foreground_
          [DIR] midground_
          [DIR] objects_
    [DIR] sebastian_levels
  [DIR] managers
  [DIR] ui
    [DIR] character_customizer
    [DIR] controls
    [DIR] dialogs
    [DIR] hud
    [DIR] loading_screen
    [DIR] main_menu
    [DIR] settings
[DIR] scripts
  [DIR] autoload
    - audio_manager.gd
    - constants.gd
    - game_manager.gd
    - global_hud.gd
    - save_manager.gd
  [DIR] core
    [DIR] base_classes
      - base_enemy.gd
      - base_power_up.gd
      - base_projectile.gd
      [DIR] state_machine
        - state.gd
        - state_machine.gd
    [DIR] combat
      - damage_system.gd
      - hit_effect.gd
    [DIR] enemies
      [DIR] behaviors
        - attack_behavior.gd
        - chase_behavior.gd
        - patrol_behavior.gd
      - enemy_state_machine.gd
      - goblin_archer.gd
      - goblin_mage.gd
      - goblin_melee.gd
      [DIR] states
        [DIR] archer
          - archer_state.gd
          - positioning_state.gd
          - reload_state.gd
          - retreat_state.gd
          - shoot_state.gd
        [DIR] common
          - attack_state.gd
          - chase_state.gd
          - death_state.gd
          - enemy_state.gd
          - hurt_state.gd
          - patrol_state.gd
        [DIR] mage
          - cast_state.gd
          - mage_state.gd
          - positioning_state.gd
          - shield_state.gd
          - teleport_state.gd
        [DIR] melee
          - charge_state.gd
          - melee_state.gd
          - rage_chase_state.gd
          - rage_state.gd
    [DIR] items
      - coins.gd
      - elixir.gd
      - power_attack.gd
      - power_fly.gd
      - power_jump.gd
    [DIR] player
      - character_sprites.gd
      - player.gd
      - player_camera.gd
      [DIR] player_states
        - player_attack_state.gd
        - player_base_state.gd
        - player_death_state.gd
        - player_fall_state.gd
        - player_fly_state.gd
        - player_hurt_state.gd
        - player_idle_state.gd
        - player_jump_state.gd
        - player_state.gd
        - player_walk_state.gd
    [DIR] projectiles
      - mage_ball.gd
      - rock.gd
  [DIR] examples
  [DIR] levels
    - base_level.gd
  [DIR] resources
    - player_outfit_resource.gd
  [DIR] ui
    [DIR] character_customizer
      - customizer_controller.gd
      - outfit_showcase.gd
      - preview_helper.gd
    [DIR] controls
      - attack_button.gd
      - defend_button.gd
    [DIR] dialogs
      - popup_dialog.gd
      - popup_manager.gd
    [DIR] hud
      - hud_controller.gd
    [DIR] main_menu
      - camera.gd
      - customizer_button.gd
      - main_menu.gd
      - menu_buttons.gd
      - start_background.gd
    - objective_tracker.gd
    [DIR] settings
      - audio_settings.gd
      - settings_menu.gd
  [DIR] utils
    - game_resource_preloader.gd
    - killzone.gd
    - object_pool.gd
    - save_data.gd
    - ui_theme.gd

FILE CONTENTS
-------------


========================================
Contents of addons\virtual_joystick\test\player.gd:
========================================
  extends Sprite2D
  
  @export var speed : float = 100
  
  @export var joystick_left : VirtualJoystick
  
  @export var joystick_right : VirtualJoystick
  
  var move_vector := Vector2.ZERO
  
  func _process(delta: float) -> void:
  	## Movement using the joystick output:
  #	if joystick_left and joystick_left.is_pressed:
  #		position += joystick_left.output * speed * delta
  	
  	## Movement using Input functions:
  	move_vector = Vector2.ZERO
  	move_vector = Input.get_vector("ui_left","ui_right","ui_up","ui_down")
  	position += move_vector * speed * delta
  	
  	# Rotation:
  	if joystick_right and joystick_right.is_pressed:
  		rotation = joystick_right.output.angle()

========================================
Contents of addons\virtual_joystick\virtual_joystick.gd:
========================================
  class_name VirtualJoystick
  
  extends Control
  
  ## A simple virtual joystick for touchscreens, with useful options.
  ## Github: https://github.com/MarcoFazioRandom/Virtual-Joystick-Godot
  
  # EXPORTED VARIABLE
  
  ## The color of the button when the joystick is pressed.
  @export var pressed_color := Color.GRAY
  
  ## If the input is inside this range, the output is zero.
  @export_range(0, 200, 1) var deadzone_size : float = 10
  
  ## The max distance the tip can reach.
  @export_range(0, 500, 1) var clampzone_size : float = 75
  
  enum Joystick_mode {
  	FIXED, ## The joystick doesn't move.
  	DYNAMIC, ## Every time the joystick area is pressed, the joystick position is set on the touched position.
  	FOLLOWING ## When the finger moves outside the joystick area, the joystick will follow it.
  }
  
  ## If the joystick stays in the same position or appears on the touched position when touch is started
  @export var joystick_mode := Joystick_mode.FIXED
  
  enum Visibility_mode {
  	ALWAYS, ## Always visible
  	TOUCHSCREEN_ONLY, ## Visible on touch screens only
  	WHEN_TOUCHED ## Visible only when touched
  }
  
  ## If the joystick is always visible, or is shown only if there is a touchscreen
  @export var visibility_mode := Visibility_mode.ALWAYS
  
  ## If true, the joystick uses Input Actions (Project -> Project Settings -> Input Map)
  @export var use_input_actions := true
  
  @export var action_left := "ui_left"
  @export var action_right := "ui_right"
  @export var action_up := "ui_up"
  @export var action_down := "ui_down"
  
  # PUBLIC VARIABLES
  
  ## If the joystick is receiving inputs.
  var is_pressed := false
  
  # The joystick output.
  var output := Vector2.ZERO
  
  # PRIVATE VARIABLES
  
  var _touch_index : int = -1
  
  @onready var _base := $Base
  @onready var _tip := $Base/Tip
  
  @onready var _base_default_position : Vector2 = _base.position
  @onready var _tip_default_position : Vector2 = _tip.position
  
  @onready var _default_color : Color = _tip.modulate
  
  # FUNCTIONS
  
  func _ready() -> void:
  	if ProjectSettings.get_setting("input_devices/pointing/emulate_mouse_from_touch"):
  		printerr("The Project Setting 'emulate_mouse_from_touch' should be set to False")
  	if not ProjectSettings.get_setting("input_devices/pointing/emulate_touch_from_mouse"):
  		printerr("The Project Setting 'emulate_touch_from_mouse' should be set to True")
  	
  	if not DisplayServer.is_touchscreen_available() and visibility_mode == Visibility_mode.TOUCHSCREEN_ONLY :
  		hide()
  	
  	if visibility_mode == Visibility_mode.WHEN_TOUCHED:
  		hide()
  
  func _input(event: InputEvent) -> void:
  	if event is InputEventScreenTouch:
  		if event.pressed:
  			if _is_point_inside_joystick_area(event.position) and _touch_index == -1:
  				if joystick_mode == Joystick_mode.DYNAMIC or joystick_mode == Joystick_mode.FOLLOWING or (joystick_mode == Joystick_mode.FIXED and _is_point_inside_base(event.position)):
  					if joystick_mode == Joystick_mode.DYNAMIC or joystick_mode == Joystick_mode.FOLLOWING:
  						_move_base(event.position)
  					if visibility_mode == Visibility_mode.WHEN_TOUCHED:
  						show()
  					_touch_index = event.index
  					_tip.modulate = pressed_color
  					_update_joystick(event.position)
  					get_viewport().set_input_as_handled()
  		elif event.index == _touch_index:
  			_reset()
  			if visibility_mode == Visibility_mode.WHEN_TOUCHED:
  				hide()
  			get_viewport().set_input_as_handled()
  	elif event is InputEventScreenDrag:
  		if event.index == _touch_index:
  			_update_joystick(event.position)
  			get_viewport().set_input_as_handled()
  
  func _move_base(new_position: Vector2) -> void:
  	_base.global_position = new_position - _base.pivot_offset * get_global_transform_with_canvas().get_scale()
  
  func _move_tip(new_position: Vector2) -> void:
  	_tip.global_position = new_position - _tip.pivot_offset * _base.get_global_transform_with_canvas().get_scale()
  
  func _is_point_inside_joystick_area(point: Vector2) -> bool:
  	var x: bool = point.x >= global_position.x and point.x <= global_position.x + (size.x * get_global_transform_with_canvas().get_scale().x)
  	var y: bool = point.y >= global_position.y and point.y <= global_position.y + (size.y * get_global_transform_with_canvas().get_scale().y)
  	return x and y
  
  func _get_base_radius() -> Vector2:
  	return _base.size * _base.get_global_transform_with_canvas().get_scale() / 2
  
  func _is_point_inside_base(point: Vector2) -> bool:
  	var _base_radius = _get_base_radius()
  	var center : Vector2 = _base.global_position + _base_radius
  	var vector : Vector2 = point - center
  	if vector.length_squared() <= _base_radius.x * _base_radius.x:
  		return true
  	else:
  		return false
  
  func _update_joystick(touch_position: Vector2) -> void:
  	var _base_radius = _get_base_radius()
  	var center : Vector2 = _base.global_position + _base_radius
  	var vector : Vector2 = touch_position - center
  	vector = vector.limit_length(clampzone_size)
  	
  	if joystick_mode == Joystick_mode.FOLLOWING and touch_position.distance_to(center) > clampzone_size:
  		_move_base(touch_position - vector)
  	
  	_move_tip(center + vector)
  	
  	if vector.length_squared() > deadzone_size * deadzone_size:
  		is_pressed = true
  		output = (vector - (vector.normalized() * deadzone_size)) / (clampzone_size - deadzone_size)
  	else:
  		is_pressed = false
  		output = Vector2.ZERO
  	
  	if use_input_actions:
  		if output.x > 0:
  			Input.action_release(action_left)
  			Input.action_press(action_right, output.x)
  		else:
  			Input.action_release(action_right)
  			Input.action_press(action_left, -output.x)
  
  		if output.y > 0:
  			Input.action_release(action_up)
  			Input.action_press(action_down, output.y)
  		else:
  			Input.action_release(action_down)
  			Input.action_press(action_up, -output.y)
  
  func _reset():
  	is_pressed = false
  	output = Vector2.ZERO
  	_touch_index = -1
  	_tip.modulate = _default_color
  	_base.position = _base_default_position
  	_tip.position = _tip_default_position
  	if use_input_actions:
  		for action in [action_left, action_right, action_down, action_up]:
  			Input.action_release(action)

========================================
Contents of addons\virtual_joystick\virtual_joystick_instantiator.gd:
========================================
  @tool
  extends Control
  
  var scene
  
  func _enter_tree():
  	scene = preload("res://addons/virtual_joystick/virtual_joystick_scene.tscn").instantiate()
  	add_child(scene)
  	
  	if ProjectSettings.get_setting("input_devices/pointing/emulate_mouse_from_touch"):
  		printerr("The Project Setting 'emulate_mouse_from_touch' should be set to False")
  	if not ProjectSettings.get_setting("input_devices/pointing/emulate_touch_from_mouse"):
  		printerr("The Project Setting 'emulate_touch_from_mouse' should be set to True")
  
  
  func _exit_tree():
  	scene.free()

========================================
Contents of addons\virtual_joystick\virtual_joystick_plugin.gd:
========================================
  @tool
  extends EditorPlugin
  
  
  func _enter_tree():
  	add_custom_type("Virtual Joystick", "Control", preload("virtual_joystick_instantiator.gd"), preload("virtual_joystick_icon.png"))
  
  
  func _exit_tree():
  	remove_custom_type("Virtual Joystick")

========================================
Contents of project.godot:
========================================
  ; Engine configuration file.
  ; It's best edited using the editor UI and not directly,
  ; since the parameters that go here are not all obvious.
  ;
  ; Format:
  ;   [section] ; section goes between []
  ;   param=value ; assign values to parameters
  
  config_version=5
  
  [application]
  
  config/name="The Little Saint"
  run/main_scene="uid://dh7t0n4nj8w4o"
  config/features=PackedStringArray("4.4", "Mobile")
  
  [autoload]
  
  Constants="*res://scripts/autoload/constants.gd"
  AudioManager="*res://scripts/autoload/audio_manager.gd"
  SaveManager="*res://scripts/autoload/save_manager.gd"
  Global="*res://scripts/autoload/game_manager.gd"
  PopupManager="*res://scripts/ui/dialogs/popup_manager.gd"
  GlobalHUD="*res://scripts/autoload/global_hud.gd"
  
  [display]
  
  window/size/viewport_width=1280
  window/size/viewport_height=720
  window/stretch/mode="canvas_items"
  window/stretch/aspect="expand"
  
  [input]
  
  right={
  "deadzone": 0.5,
  "events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":68,"key_label":0,"unicode":100,"location":0,"echo":false,"script":null)
  , Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194321,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
  ]
  }
  left={
  "deadzone": 0.5,
  "events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":65,"key_label":0,"unicode":97,"location":0,"echo":false,"script":null)
  , Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194319,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
  ]
  }
  up={
  "deadzone": 0.5,
  "events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":87,"key_label":0,"unicode":119,"location":0,"echo":false,"script":null)
  , Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194320,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
  ]
  }
  down={
  "deadzone": 0.5,
  "events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":83,"key_label":0,"unicode":115,"location":0,"echo":false,"script":null)
  , Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194322,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
  ]
  }
  attack={
  "deadzone": 0.5,
  "events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":85,"physical_keycode":0,"key_label":0,"unicode":117,"location":0,"echo":false,"script":null)
  ]
  }
  defend={
  "deadzone": 0.5,
  "events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":73,"physical_keycode":0,"key_label":0,"unicode":105,"location":0,"echo":false,"script":null)
  ]
  }
  Menu={
  "deadzone": 0.5,
  "events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194305,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
  ]
  }
  
  [input_devices]
  
  pointing/emulate_touch_from_mouse=true
  pointing/emulate_mouse_from_touch=false
  
  [layer_names]
  
  2d_physics/layer_1="player"
  2d_physics/layer_2="ports"
  2d_physics/layer_3="item"
  2d_physics/layer_4="enemy"
  
  [physics]
  
  2d/physics_engine="GodotPhysics2D"
  
  [rendering]
  
  textures/canvas_textures/default_texture_filter=0
  renderer/rendering_method="mobile"
  environment/defaults/default_clear_color=Color(0, 0, 0, 1)

========================================
Contents of scenes\levels\adventure_mode\main_map.gd:
========================================
  extends Node2D
  # Assuming this script is on your MainMap scene
  
  @onready var room1 = preload("res://scenes/levels/adventure_mode/enemy_room_1.tscn")
  @onready var room2 = preload("res://scenes/levels/adventure_mode/enemy_room_2.tscn")
  @onready var start_room = preload("res://scenes/levels/adventure_mode/Starting_Room.tscn")
  @onready var end_room = preload("res://scenes/levels/adventure_mode/End_Room.tscn")
  @onready var ExitBlock = preload("res://scenes/levels/adventure_mode/exit_block.tscn")
  
  # Constants for room dimensions and number of rooms
  const ROOM_WIDTH = 960  # Room width
  const ROOM_HEIGHT = 480  # Room height
  const NUM_ROOMS = 4  # Number of rooms
  const HIGH_EXIT_OFFSET = 320  # Vertical offset for high exit (move up)
  const LOW_EXIT_OFFSET = -320  # Vertical offset for low exit (move down)
  
  func _ready():
  	var previous_position = Vector2(960, 0)  # Starting position for the first room
  	var start_room_instance = start_room.instantiate()
  	add_child(start_room_instance)
  	var end = (NUM_ROOMS-1)
  	for i in range(NUM_ROOMS):
  		# Randomly choose room1 or room2
  		var room_instance
  		var room_instance2
  		var room_instance3 = ExitBlock.instantiate()
  		var room_instance4 = ExitBlock.instantiate()
  		var room_instance6 = ExitBlock.instantiate()
  		var room_instance5 = ExitBlock.instantiate()
  		var randRoom = randi() % 9  # Random int from 0 to 8
  		var rand1 = randi() % 2  # Random 0 or 1
  		print("  Random 0 or 1: ", rand1)
  		print("  Random 0 to 8: ", randRoom)
  		if i == end:
  				room_instance = end_room.instantiate()
  		else:
  			if randi() % 2 == 0:
  				room_instance = room1.instantiate()
  			else:
  				room_instance = room2.instantiate()
  			
  		# Set the position of the current room
  		room_instance.position = previous_position
  		add_child(room_instance)
  		print("Room ", i + 1, " placed at position: ", previous_position)
  		
  		previous_position.x += ROOM_WIDTH
  		# 50% chance to place vertically (upward or downward)
  		if randi() % 2 == 0:  # 50% chance to go upwards (high exit)
  			previous_position.y += HIGH_EXIT_OFFSET
  			var previous_position5 = previous_position + Vector2(0,-32)
  			room_instance5.position = previous_position5
  			add_child(room_instance5)
  			var rand_0_or_1 = randi() % 2  # Random 0 or 1
  			if rand_0_or_1 == 1:
  					var previous_position2 = previous_position + Vector2(0, -640)
  					var previous_position3 = previous_position2 + Vector2(0,-253)
  					var previous_position4 = previous_position2 + Vector2(928,-253)
  					var previous_position6 = previous_position2 + Vector2(928,67)
  					room_instance3.position = previous_position3
  					room_instance4.position = previous_position4
  					room_instance6.position = previous_position6
  					if randi() % 2 == 0:
  						room_instance2 = room1.instantiate()
  					else:
  						room_instance2 = room2.instantiate()
  					room_instance2.position = previous_position2
  					add_child(room_instance4)
  					add_child(room_instance3)
  					add_child(room_instance2)
  			else:
  					var previous_position3 = previous_position + Vector2(-32, -672)
  					room_instance3.position = previous_position3
  					add_child(room_instance3)
  		else:  # 50% chance to go downwards (low exit)
  			previous_position.y += LOW_EXIT_OFFSET
  			var previous_position5 = previous_position + Vector2(0,-352)
  			room_instance5.position = previous_position5
  			add_child(room_instance5)
  			var rand_0_or_1 = randi() % 2  # Random 0 or 1
  			if rand_0_or_1 == 1:
  					var previous_position2 = previous_position + Vector2(0, 640)
  					var previous_position3 = previous_position2 + Vector2(0, -32)
  					var previous_position4 = previous_position2 + Vector2(928, -32)
  					var previous_position6 = previous_position2 + Vector2(928, -352)
  					room_instance3.position = previous_position3
  					room_instance4.position = previous_position4
  					room_instance6.position = previous_position6
  					if randi() % 2 == 0:
  						room_instance2 = room1.instantiate()
  					else:
  						room_instance2 = room2.instantiate()
  					room_instance2.position = previous_position2
  					add_child(room_instance4)
  					add_child(room_instance3)
  					add_child(room_instance2)
  			else:
  					var previous_position3 = previous_position + Vector2(-32,288 )
  					room_instance3.position = previous_position3
  					add_child(room_instance3)

========================================
Contents of scripts\autoload\audio_manager.gd:
========================================
  extends Node
  
  ## Enhanced Audio Manager for managing all game audio
  ## Supports categories, multiple channels, and persistent settings
  
  # Audio bus names
  const MASTER_BUS = "Master"
  const MUSIC_BUS = "Music"
  const SFX_BUS = "SFX"
  const UI_BUS = "UI"
  const VOICE_BUS = "Voice"
  
  # Volume ranges
  const MIN_VOLUME_DB = -80.0
  const MAX_VOLUME_DB = 6.0
  
  # Fade durations
  const DEFAULT_FADE_DURATION = 1.0
  
  # Music properties
  @export var autoplay: bool = false
  @export var default_music_stream: AudioStream = null
  @export var default_music_volume: float = 0.0  # in dB
  @export var crossfade_duration: float = 1.0
  
  # Current audio tracks
  var current_music_track: AudioStream = null
  var current_music_player: AudioStreamPlayer = null
  var next_music_player: AudioStreamPlayer = null  # For crossfading
  
  # Audio player pools
  var music_players = []
  var sfx_players = {}
  var ui_players = []
  var voice_players = []
  
  # Audio stream cache
  var stream_cache = {}
  
  # Signals
  signal music_started(track_name)
  signal music_stopped()
  signal music_finished()
  signal music_faded(from_volume, to_volume)
  signal sfx_played(sfx_name)
  
  func _ready():
  	# Ensure we have all the audio buses we need
  	_setup_audio_buses()
  	
  	# Create initial audio players
  	_setup_audio_players()
  	
  	# Load settings
  	_load_audio_settings()
  	
  	# Autoplay if enabled
  	if autoplay and default_music_stream:
  		play_music(default_music_stream)
  
  func _setup_audio_buses():
  	# Create buses if they don't exist
  	var bus_names = [MASTER_BUS, MUSIC_BUS, SFX_BUS, UI_BUS, VOICE_BUS]
  	
  	for i in range(AudioServer.get_bus_count()):
  		var bus_name = AudioServer.get_bus_name(i)
  		bus_names.erase(bus_name)
  	
  	# Add any missing buses
  	for bus_name in bus_names:
  		if bus_name != MASTER_BUS:  # Master is always bus 0
  			var idx = AudioServer.bus_count
  			AudioServer.add_bus(idx)
  			AudioServer.set_bus_name(idx, bus_name)
  			
  			# Connect to Master
  			AudioServer.set_bus_send(idx, MASTER_BUS)
  
  func _setup_audio_players():
  	# Create music players for crossfading
  	for i in range(2):
  		var player = AudioStreamPlayer.new()
  		player.name = "MusicPlayer_" + str(i)
  		player.bus = MUSIC_BUS
  		player.volume_db = default_music_volume
  		add_child(player)
  		music_players.append(player)
  		player.finished.connect(_on_music_finished.bind(player))
  	
  	# Set current music player
  	current_music_player = music_players[0]
  
  # Music playback control
  func play_music(stream: AudioStream, fade_in: float = DEFAULT_FADE_DURATION, volume_db: float = default_music_volume, loop: bool = true):
  	if not stream:
  		push_error("Cannot play null music stream")
  		return
  	
  	# Check if this is the current track
  	if current_music_track == stream and current_music_player.playing:
  		return
  	
  	# Choose which player to use
  	var player
  	if current_music_player and current_music_player.playing:
  		# Crossfade
  		player = _get_unused_music_player()
  		next_music_player = player
  	else:
  		# No crossfade needed
  		player = current_music_player if current_music_player else music_players[0]
  	
  	# Set up the player
  	player.stream = stream
  	player.volume_db = MIN_VOLUME_DB if fade_in > 0 else volume_db
  	player.play()
  	
  	# Apply loop setting
  	if stream is AudioStreamMP3 or stream is AudioStreamOggVorbis:
  		stream.loop = loop
  	
  	# Store current track
  	current_music_track = stream
  	
  	# Handle fade in if needed
  	if fade_in > 0:
  		var tween = create_tween()
  		tween.tween_property(player, "volume_db", volume_db, fade_in)
  		
  		# If we're crossfading, fade out the old track
  		if current_music_player and current_music_player != player and current_music_player.playing:
  			var fade_out_tween = create_tween()
  			fade_out_tween.tween_property(current_music_player, "volume_db", MIN_VOLUME_DB, fade_in)
  			fade_out_tween.tween_callback(func(): current_music_player.stop())
  	
  	# Update current player reference
  	current_music_player = player
  	
  	var track_name = stream.resource_path.get_file()
  	emit_signal("music_started", track_name)
  
  func stop_music(fade_out: float = DEFAULT_FADE_DURATION):
  	if not current_music_player or not current_music_player.playing:
  		return
  	
  	if fade_out > 0:
  		var tween = create_tween()
  		tween.tween_property(current_music_player, "volume_db", MIN_VOLUME_DB, fade_out)
  		tween.tween_callback(func(): 
  			current_music_player.stop()
  			current_music_track = null
  			emit_signal("music_stopped")
  		)
  	else:
  		current_music_player.stop()
  		current_music_track = null
  		emit_signal("music_stopped")
  
  func pause_music():
  	if current_music_player and current_music_player.playing:
  		current_music_player.stream_paused = true
  
  func resume_music():
  	if current_music_player and current_music_player.stream_paused:
  		current_music_player.stream_paused = false
  
  func is_music_playing() -> bool:
  	return current_music_player != null and current_music_player.playing
  
  func fade_music(to_volume_db: float, duration: float = DEFAULT_FADE_DURATION):
  	if not current_music_player or not current_music_player.playing:
  		return
  	
  	var from_volume = current_music_player.volume_db
  	
  	var tween = create_tween()
  	tween.tween_property(current_music_player, "volume_db", to_volume_db, duration)
  	tween.tween_callback(func(): emit_signal("music_faded", from_volume, to_volume_db))
  
  # SFX playback
  func play_sfx(stream: AudioStream, volume_db: float = 0.0, pitch_scale: float = 1.0, bus: String = SFX_BUS) -> AudioStreamPlayer:
  	if not stream:
  		push_error("Cannot play null SFX stream")
  		return null
  	
  	# Get or create an available SFX player
  	var sfx_player = _get_available_sfx_player(bus)
  	
  	# Set up the player
  	sfx_player.stream = stream
  	sfx_player.volume_db = volume_db
  	sfx_player.pitch_scale = pitch_scale
  	sfx_player.play()
  	
  	var sfx_name = stream.resource_path.get_file()
  	emit_signal("sfx_played", sfx_name)
  	
  	return sfx_player
  
  func play_sfx_at_position(stream: AudioStream, position: Vector2, volume_db: float = 0.0, 
  						pitch_scale: float = 1.0, bus: String = SFX_BUS, 
  						falloff: float = 1.0, max_distance: float = 2000) -> AudioStreamPlayer2D:
  	if not stream:
  		push_error("Cannot play positional SFX with null stream")
  		return null
  	
  	# Create a temporary 2D audio player
  	var sfx_player = AudioStreamPlayer2D.new()
  	sfx_player.name = "TempSFX2D_" + str(randi())
  	sfx_player.stream = stream
  	sfx_player.volume_db = volume_db
  	sfx_player.pitch_scale = pitch_scale
  	sfx_player.bus = bus
  	sfx_player.position = position
  	sfx_player.max_distance = max_distance
  	sfx_player.attenuation = falloff
  	
  	# Add to tree temporarily
  	add_child(sfx_player)
  	sfx_player.play()
  	
  	# Connect to finished to auto-remove
  	sfx_player.finished.connect(func(): sfx_player.queue_free())
  	
  	var sfx_name = stream.resource_path.get_file()
  	emit_signal("sfx_played", sfx_name)
  	
  	return sfx_player
  
  func play_ui_sound(stream: AudioStream, volume_db: float = 0.0) -> AudioStreamPlayer:
  	return play_sfx(stream, volume_db, 1.0, UI_BUS)
  
  func play_voice(stream: AudioStream, volume_db: float = 0.0) -> AudioStreamPlayer:
  	return play_sfx(stream, volume_db, 1.0, VOICE_BUS)
  
  # Volume control
  func set_volume(bus_name: String, volume_db: float) -> bool:
  	var bus_idx = AudioServer.get_bus_index(bus_name)
  	if bus_idx < 0:
  		push_error("Audio bus not found: " + bus_name)
  		return false
  	
  	var clamped_volume = clamp(volume_db, MIN_VOLUME_DB, MAX_VOLUME_DB)
  	AudioServer.set_bus_volume_db(bus_idx, clamped_volume)
  	return true
  
  func get_volume(bus_name: String) -> float:
  	var bus_idx = AudioServer.get_bus_index(bus_name)
  	if bus_idx < 0:
  		push_error("Audio bus not found: " + bus_name)
  		return 0.0
  	
  	return AudioServer.get_bus_volume_db(bus_idx)
  
  func set_mute(bus_name: String, mute: bool) -> bool:
  	var bus_idx = AudioServer.get_bus_index(bus_name)
  	if bus_idx < 0:
  		push_error("Audio bus not found: " + bus_name)
  		return false
  	
  	AudioServer.set_bus_mute(bus_idx, mute)
  	return true
  
  func is_muted(bus_name: String) -> bool:
  	var bus_idx = AudioServer.get_bus_index(bus_name)
  	if bus_idx < 0:
  		push_error("Audio bus not found: " + bus_name)
  		return false
  	
  	return AudioServer.is_bus_mute(bus_idx)
  
  # Stream loading helper
  func load_stream(path: String) -> AudioStream:
  	# Check cache first
  	if stream_cache.has(path):
  		return stream_cache[path]
  	
  	# Load the stream
  	var stream = load(path)
  	if stream is AudioStream:
  		stream_cache[path] = stream
  		return stream
  	
  	push_error("Failed to load audio stream: " + path)
  	return null
  
  # Preload a collection of audio streams
  func preload_streams(paths: Array) -> void:
  	for path in paths:
  		load_stream(path)
  
  # Save and load audio settings
  func save_audio_settings() -> bool:
  	var config = ConfigFile.new()
  	
  	# Save volumes
  	for bus_name in [MASTER_BUS, MUSIC_BUS, SFX_BUS, UI_BUS, VOICE_BUS]:
  		var bus_idx = AudioServer.get_bus_index(bus_name)
  		if bus_idx >= 0:
  			config.set_value("volume", bus_name, AudioServer.get_bus_volume_db(bus_idx))
  			config.set_value("mute", bus_name, AudioServer.is_bus_mute(bus_idx))
  	
  	# Save the config
  	var err = config.save("user://audio_settings.cfg")
  	return err == OK
  
  func _load_audio_settings() -> bool:
  	var config = ConfigFile.new()
  	var err = config.load("user://audio_settings.cfg")
  	
  	if err != OK:
  		# Create default settings
  		for bus_name in [MASTER_BUS, MUSIC_BUS, SFX_BUS, UI_BUS, VOICE_BUS]:
  			set_volume(bus_name, 0.0)
  			set_mute(bus_name, false)
  		return false
  	
  	# Load volumes
  	for bus_name in [MASTER_BUS, MUSIC_BUS, SFX_BUS, UI_BUS, VOICE_BUS]:
  		var volume = config.get_value("volume", bus_name, 0.0)
  		var muted = config.get_value("mute", bus_name, false)
  		
  		set_volume(bus_name, volume)
  		set_mute(bus_name, muted)
  	
  	return true
  
  # Private utility functions
  func _get_unused_music_player() -> AudioStreamPlayer:
  	for player in music_players:
  		if player != current_music_player or not player.playing:
  			return player
  	
  	# All players are in use, create a new one
  	var player = AudioStreamPlayer.new()
  	player.name = "MusicPlayer_" + str(music_players.size())
  	player.bus = MUSIC_BUS
  	add_child(player)
  	music_players.append(player)
  	player.finished.connect(_on_music_finished.bind(player))
  	
  	return player
  
  func _get_available_sfx_player(bus: String = SFX_BUS) -> AudioStreamPlayer:
  	# Check for existing player in the bus category
  	if not sfx_players.has(bus):
  		sfx_players[bus] = []
  	
  	var bus_players = sfx_players[bus]
  	
  	# Look for an available player
  	for player in bus_players:
  		if not player.playing:
  			return player
  	
  	# Create a new player
  	var player = AudioStreamPlayer.new()
  	player.name = "SFXPlayer_" + bus + "_" + str(bus_players.size())
  	player.bus = bus
  	add_child(player)
  	bus_players.append(player)
  	
  	return player
  
  func _on_music_finished(player):
  	if player == current_music_player:
  		emit_signal("music_finished")
  		
  		# Check if we have a looping track
  		if current_music_track:
  			var is_looping = false
  			if current_music_track is AudioStreamMP3 or current_music_track is AudioStreamOggVorbis:
  				is_looping = current_music_track.loop
  			
  			if is_looping:
  				# Restart the track
  				player.play()
  
  # Legacy API for backward compatibility
  func play_track(audio_stream: AudioStream):
  	play_music(audio_stream)
  
  func stop_track():
  	stop_music()
  
  func is_playing() -> bool:
  	return is_music_playing()

========================================
Contents of scripts\autoload\constants.gd:
========================================
  extends Node
  
  ## Global constants for The Little Saint game
  
  # Game States
  enum GameState {
  	MENU,           # In main menu
  	PLAYING,        # Actively playing
  	PAUSED,         # Game paused
  	GAME_OVER,      # Player died or level failed
  	CUTSCENE,       # In a cutscene
  	DIALOGUE,       # In dialogue
  	LOADING         # Loading screen
  }
  
  # Player Movement
  const PLAYER_DEFAULT_SPEED: float = 200.0
  const PLAYER_DEFAULT_JUMP_VELOCITY: float = -250.0
  const PLAYER_DEFAULT_FLY_VELOCITY: float = -150.0
  const PLAYER_DEFAULT_GRAVITY: float = 300.0
  const PLAYER_MAX_JUMPS: int = 2
  
  # Player Status
  const PLAYER_DEFAULT_MAX_HEALTH: float = 3.0
  const PLAYER_INVULNERABILITY_TIME: float = 1.0
  const PLAYER_DEFAULT_FLY_TIME: float = 4.0
  
  # File Paths
  const SETTINGS_FILE_PATH: String = "user://settings.cfg"
  const SAVE_FILE_PATH: String = "user://save_data.tres"
  const OUTFIT_FILE_PATH: String = "user://outfits.tres"
  const FAVORITES_FILE_PATH: String = "user://favorites.cfg"
  
  # Config Sections
  const SECTION_SETTINGS: String = "settings"
  const SECTION_PLAYER: String = "player"
  const SECTION_OUTFITS: String = "outfits"
  const SECTION_FAVORITES: String = "favorites"
  
  # Physics
  const DEFAULT_GRAVITY: float = 980.0
  
  # Animation
  const ANIMATION_IDLE: String = "idle"
  const ANIMATION_WALKING: String = "walking"
  const ANIMATION_ATTACK: String = "walking6"  # Current attack animation
  const ANIMATION_HURT: String = "hurt"
  const ANIMATION_DEATH: String = "dead"
  const ANIMATION_JUMP: String = "animation4"  # May need to be updated
  
  # Layers
  enum Layer {
  	PLAYER = 1,
  	PORTS = 2,
  	ITEM = 3,
  	ENEMY = 4
  }
  
  # Input Action Names
  const INPUT_RIGHT: String = "right"
  const INPUT_LEFT: String = "left"
  const INPUT_UP: String = "up"
  const INPUT_DOWN: String = "down"
  const INPUT_ATTACK: String = "attack"
  const INPUT_DEFEND: String = "defend"
  const INPUT_MENU: String = "Menu"
  
  # Scene paths
  const MAIN_MENU_SCENE: String = "res://scenes/ui/main_menu/main_menu.tscn"
  const ADVENTURE_LEVEL_SCENE: String = "res://scenes/levels/adventure_mode/adventure_level.tscn"
  const SETTINGS_MENU_SCENE: String = "res://scenes/ui/settings/settings_menu.tscn"
  const CUSTOMIZER_SCENE: String = "res://scenes/ui/character_customizer/customizer.tscn"
  const AUDIO_SETTINGS_SCENE: String = "res://scenes/ui/settings/audio_settings.tscn"
  
  # Debug
  const DEBUG_ENABLED: bool = false

========================================
Contents of scripts\autoload\game_manager.gd:
========================================
  extends Node
  
  ## Game Manager handles game state, scene transitions, and global events
  ## Serves as the central controller for the game
  
  # Game state
  var current_state: Constants.GameState = Constants.GameState.MENU
  var previous_state: Constants.GameState = Constants.GameState.MENU
  
  # Player reference
  var player = null
  
  # Current level
  var current_level: String = ""
  var current_level_node = null
  var next_level: String = ""
  
  # Game progress
  var collected_coins: int = 0
  var unlocked_levels: Array = []
  var completed_quests: Array = []
  
  # Resource preloading
  var resource_preloader = null
  var is_preloading: bool = false
  var preload_progress: float = 0.0
  
  # Events
  signal state_changed(new_state, old_state)
  signal level_started(level_name)
  signal level_completed(level_name)
  signal player_died()
  signal coin_collected(total_coins)
  signal game_saved()
  signal game_loaded()
  signal resources_loading_progress(progress, total)
  signal resources_loaded()
  
  # Initialization
  func _ready():
  	process_mode = Node.PROCESS_MODE_ALWAYS # Game manager should run even when paused
  	print("Game Manager initialized")
  	
  	# Initialize the resource preloader
  	resource_preloader = GameResourcePreloader.new()
  	resource_preloader.name = "GameResourcePreloader"
  	add_child(resource_preloader)
  	
  	# Connect resource preloader signals
  	resource_preloader.loading_progress.connect(_on_loading_progress)
  	resource_preloader.all_resources_loaded.connect(_on_all_resources_loaded)
  
  # State management
  func change_state(new_state: Constants.GameState) -> void:
  	if new_state == current_state:
  		return
  
  	previous_state = current_state
  	current_state = new_state
  
  	match new_state:
  		Constants.GameState.PAUSED:
  			get_tree().paused = true
  		Constants.GameState.PLAYING, Constants.GameState.MENU:
  			get_tree().paused = false
  		Constants.GameState.LOADING:
  			# Loading state is handled by the loading screen
  			pass
  
  	emit_signal("state_changed", current_state, previous_state)
  	print("Game state changed to: ", Constants.GameState.keys()[current_state])
  
  func is_state(state: Constants.GameState) -> bool:
  	return current_state == state
  
  func resume_previous_state() -> void:
  	change_state(previous_state)
  
  # Resource preloading
  func preload_resources_for_level(level_name: String) -> void:
  	if is_preloading:
  		push_warning("Already preloading resources!")
  		return
  	
  	# Enter loading state
  	change_state(Constants.GameState.LOADING)
  	is_preloading = true
  	preload_progress = 0.0
  	
  	# Start preloading
  	var success = resource_preloader.preload_level_resources(level_name)
  	if success:
  		resource_preloader.load_queued_resources()
  	else:
  		# No specific resources to preload, just continue
  		is_preloading = false
  		_finish_level_change()
  
  func _on_loading_progress(loaded: int, total: int) -> void:
  	preload_progress = float(loaded) / max(total, 1)
  	emit_signal("resources_loading_progress", loaded, total)
  
  func _on_all_resources_loaded() -> void:
  	is_preloading = false
  	emit_signal("resources_loaded")
  	
  	# Continue with level change if we were changing levels
  	if next_level != "":
  		_finish_level_change()
  
  # Scene management with preloading
  func change_scene(scene_path: String) -> void:
  	# Store the next level path
  	next_level = scene_path
  	
  	# Clear any popups or overlays
  	if PopupManager:
  		PopupManager.close_all_dialogs()
  	
  	# Store reference to current level if it's a level scene
  	if scene_path.begins_with("res://scenes/levels/"):
  		current_level = scene_path
  		
  		# Extract level name for preloading
  		var level_name = scene_path.get_file().get_basename()
  		preload_resources_for_level(level_name)
  	else:
  		# If it's not a level, just preload based on the scene name
  		var scene_name = scene_path.get_file().get_basename()
  		preload_resources_for_level(scene_name)
  
  func _finish_level_change() -> void:
  	if next_level.is_empty():
  		return
  	
  	# Actual scene change
  	get_tree().change_scene_to_file(next_level)
  	
  	# After scene change, set appropriate state
  	if next_level == Constants.MAIN_MENU_SCENE:
  		change_state(Constants.GameState.MENU)
  	elif next_level.begins_with("res://scenes/levels/"):
  		change_state(Constants.GameState.PLAYING)
  		emit_signal("level_started", next_level)
  	
  	# Clear next level
  	var loaded_level = next_level
  	next_level = ""
  	
  	# Unload resources from previous level if not needed
  	if resource_preloader and loaded_level != Constants.MAIN_MENU_SCENE:
  		# Keep UI resources but unload previous level resources
  		resource_preloader.unload_unused_resources(["ui", "audio"])
  
  # Level management
  func restart_level() -> void:
  	if current_level:
  		change_scene(current_level)
  
  func go_to_main_menu() -> void:
  	change_scene(Constants.MAIN_MENU_SCENE)
  
  # Save and load through SaveManager
  func save_game() -> void:
  	if SaveManager:
  		SaveManager.save_game()
  		emit_signal("game_saved")
  
  func load_game() -> void:
  	if SaveManager:
  		SaveManager.load_game()
  		emit_signal("game_loaded")
  
  # Player-related functions
  func register_player(player_instance) -> void:
  	player = player_instance
  	print("Player registered with Game Manager")
  
  func collect_coin() -> void:
  	collected_coins += 1
  	emit_signal("coin_collected", collected_coins)
  
  func player_death() -> void:
  	change_state(Constants.GameState.GAME_OVER)
  	emit_signal("player_died")
  
  # Event handling
  func notify_level_completed() -> void:
  	if current_level and not unlocked_levels.has(current_level):
  		unlocked_levels.append(current_level)
  	emit_signal("level_completed", current_level)
  
  # Debug helpers
  func toggle_debug_mode() -> void:
  	get_node("/root").get_tree().get_root().set_debug_enabled(not get_node("/root").get_tree().get_root().is_debug_enabled())
  
  # Resource management helpers
  func get_resource(type: String, id: String) -> Resource:
  	if resource_preloader:
  		return resource_preloader.get_resource(type, id)
  	return null
  
  func has_resource(type: String, id: String) -> bool:
  	if resource_preloader:
  		return resource_preloader.has_resource(type, id)
  	return false
  
  func load_resource(path: String, type: String = "other", id: String = "") -> Resource:
  	if resource_preloader:
  		return resource_preloader.load_resource(path, type, id)
  	return ResourceLoader.load(path)
  
  # System functions
  func quit_game() -> void:
  	save_game()
  	get_tree().quit()
  
  # Input handling
  func _input(event: InputEvent) -> void:
  	if event.is_action_pressed(Constants.INPUT_MENU):
  		if current_state == Constants.GameState.PLAYING:
  			change_state(Constants.GameState.PAUSED)
  		elif current_state == Constants.GameState.PAUSED:
  			change_state(Constants.GameState.PLAYING)
  
  func _notification(what):
  	if what == NOTIFICATION_WM_CLOSE_REQUEST:
  		# Save game before allowing close
  		print("Game closing - saving data...")
  		SaveManager.save_game()
  		SaveManager.save_settings()
  		get_tree().quit()

========================================
Contents of scripts\autoload\global_hud.gd:
========================================
  extends Node
  
  # Core player stats - THE single source of truth
  var max_health: float = 3.0
  var current_health: float = 3.0
  var coins: int = 0
  var elixir_fill_level: float = 0.0
  
  # Power-up tracking
  var active_power_ups: Array = []
  var power_up_timers: Dictionary = {}
  
  # Reference to the actual HUD scene instance
  var hud_instance = null
  
  # Signals
  signal health_changed(new_health, max_health)
  signal coins_changed(new_amount)
  signal elixir_changed(new_level)
  signal power_up_activated(power_up_name, duration)
  signal power_up_deactivated(power_up_name)
  
  func _ready():
  	# Initialize with default values
  	reset_to_defaults()
  	
  	# Connect to player death signal from GameManager
  	if get_node_or_null("/root/Global"):
  		Global.player_died.connect(_on_player_died)
  
  # Register the actual HUD scene
  func register_hud(hud):
  	hud_instance = hud
  	notify_hud_of_all_values()
  
  # Notify HUD of all current values
  func notify_hud_of_all_values():
  	if not hud_instance:
  		return
  		
  	# Tell the HUD to update its visuals with our values
  	hud_instance.update_health_display(current_health, max_health)
  	hud_instance.update_coins_display(coins)
  	hud_instance.update_elixir_display(elixir_fill_level)
  	
  	# Sync power-ups if needed
  	for power_up in active_power_ups:
  		if power_up_timers.has(power_up):
  			hud_instance.update_power_up_display(power_up, power_up_timers[power_up].duration)
  
  # Reset HUD to default values
  func reset_to_defaults():
  	current_health = max_health
  	coins = 0
  	elixir_fill_level = 0.0
  	active_power_ups.clear()
  	power_up_timers.clear()
  	
  	if hud_instance:
  		notify_hud_of_all_values()
  
  # --- Core state modification methods ---
  
  # Health
  func change_health(amount: float):
  	var old_health = current_health
  	current_health = clamp(current_health + amount, 0, max_health)
  	
  	if current_health != old_health:
  		emit_signal("health_changed", current_health, max_health)
  		
  		if hud_instance:
  			hud_instance.update_health_display(current_health, max_health)
  			
  			if amount < 0:
  				hud_instance.play_damage_effect()
  			elif amount > 0:
  				hud_instance.play_healing_effect()
  		
  		# Check for death
  		if current_health <= 0 and get_node_or_null("/root/Global"):
  			Global.player_death()
  			
  		# Save state after health changes
  		save_state()
  
  # Coins
  func add_coins(amount: int = 1):
  	coins += amount
  	
  	if hud_instance:
  		hud_instance.update_coins_display(coins)
  		hud_instance.play_coin_effect()
  		
  	emit_signal("coins_changed", coins)
  	save_state()
  
  func set_coins(amount: int):
  	coins = max(0, amount)
  	
  	if hud_instance:
  		hud_instance.update_coins_display(coins)
  		
  	emit_signal("coins_changed", coins)
  	save_state()
  
  # Elixir
  func update_elixir_fill(amount: float):
  	elixir_fill_level = clamp(elixir_fill_level + amount, 0.0, 1.0)
  	
  	if hud_instance:
  		hud_instance.update_elixir_display(elixir_fill_level)
  		
  	emit_signal("elixir_changed", elixir_fill_level)
  	save_state()
  
  # Power-ups
  func activate_power_up(name: String, duration: float = 0.0):
  	# Add to active power-ups
  	if not active_power_ups.has(name):
  		active_power_ups.append(name)
  	
  	# Set up timer if it has a duration
  	if duration > 0:
  		power_up_timers[name] = {
  			"duration": duration,
  			"time_remaining": duration
  		}
  	
  	emit_signal("power_up_activated", name, duration)
  	
  	# Notify HUD
  	if hud_instance:
  		hud_instance.update_power_up_display(name, duration)
  
  # Handle player death
  func _on_player_died():
  	#reset_to_defaults()
  	save_state()
  
  # Save current HUD state to SaveManager
  func save_state():
  	if get_node_or_null("/root/SaveManager") and SaveManager.current_save_data:
  		SaveManager.current_save_data.health = current_health
  		SaveManager.current_save_data.coins = coins
  		# Any other HUD state to save
  
  # Load state from SaveManager
  func load_state():
  	if get_node_or_null("/root/SaveManager") and SaveManager.current_save_data:
  		current_health = SaveManager.current_save_data.health
  		coins = SaveManager.current_save_data.coins
  		# Any other HUD state to load
  		
  		if hud_instance:
  			notify_hud_of_all_values()
  
  # --- Convenience methods ---
  
  # Legacy API compatibility
  func change_life(amount: float):
  	change_health(amount)
  
  func coin_collected():
  	add_coins(1)
  
  func collect_softpower(amount: float = 0.25):
  	update_elixir_fill(amount)
  
  func use_softpower(amount: float = 0.25) -> bool:
  	if elixir_fill_level >= amount:
  		update_elixir_fill(-amount)
  		return true
  	return false
  
  # ProcessMode allows updating power-up timers
  func _process(delta):
  	# Update power-up timers
  	for power_up_name in power_up_timers.keys():
  		var timer_data = power_up_timers[power_up_name]
  		timer_data.time_remaining -= delta
  		
  		# Check if power-up has expired
  		if timer_data.time_remaining <= 0:
  			power_up_timers.erase(power_up_name)
  			active_power_ups.erase(power_up_name)
  			emit_signal("power_up_deactivated", power_up_name)
  			
  			# Notify HUD
  			if hud_instance:
  				hud_instance.hide_power_up_display(power_up_name)

========================================
Contents of scripts\autoload\save_manager.gd:
========================================
  extends Node
  
  ## SaveManager handles all game saving and loading operations
  ## It manages player data, settings, and outfit configurations
  ## Now with auto-save functionality
  
  # Current save data instance
  var current_save_data: SaveData = null
  
  # Auto-save settings
  var auto_save_enabled: bool = false
  var auto_save_interval: float = 300.0  # Default: save every 5 minutes
  var time_since_last_save: float = 0.0
  
  # Signals
  signal save_completed(success, message)
  signal load_completed(success, message)
  signal settings_saved(success)
  signal settings_loaded(success)
  signal outfit_saved(success, outfit_name)
  signal auto_save_performed(success)
  
  # Initialize on ready
  func _ready():
  	print("Save Manager initialized")
  	# Create default save data at startup
  	current_save_data = SaveData.new()
  	# Load settings immediately on startup
  	load_settings()
  	# Initialize auto-save
  	_init_auto_save()
  
  func _process(delta):
  	# Handle auto-save timer
  	if auto_save_enabled:
  		time_since_last_save += delta
  		
  		if time_since_last_save >= auto_save_interval:
  			perform_auto_save()
  
  # Initialize auto-save
  func _init_auto_save():
  	# Default is disabled
  	auto_save_enabled = false
  	time_since_last_save = 0.0
  	# Ensure process is called
  	set_process(true)
  
  # Toggle auto-save functionality
  func toggle_auto_save(enabled: bool) -> void:
  	auto_save_enabled = enabled
  	time_since_last_save = 0.0
  	print("Auto-save " + ("enabled" if enabled else "disabled"))
  
  # Set auto-save interval (in seconds)
  func set_auto_save_interval(interval: float) -> void:
  	if interval < 10.0:
  		push_warning("Auto-save interval set too low (< 10 seconds). Using 10 seconds.")
  		auto_save_interval = 10.0
  	else:
  		auto_save_interval = interval
  
  # Perform an auto-save operation
  func perform_auto_save() -> bool:
  	print("Performing auto-save...")
  	time_since_last_save = 0.0
  	
  	var success = save_game()
  	emit_signal("auto_save_performed", success)
  	return success
  
  # Save the full game state
  func save_game() -> bool:
  	if not current_save_data:
  		current_save_data = SaveData.new()
  
  	# Update data before saving
  	_update_save_data()
  
  	# Try to save the resource file
  	var dir = DirAccess.open("user://")
  	if not dir:
  		push_error("Failed to open user:// directory")
  		emit_signal("save_completed", false, "Failed to access save directory")
  		return false
  
  	var success = ResourceSaver.save(current_save_data, Constants.SAVE_FILE_PATH)
  
  	if success == OK:
  		print("Game saved successfully to: ", Constants.SAVE_FILE_PATH)
  		emit_signal("save_completed", true, "Game saved successfully")
  		return true
  	else:
  		push_error("Failed to save game. Error code: " + str(success))
  		emit_signal("save_completed", false, "Failed to save game")
  		return false
  
  # Load the full game state
  func load_game() -> bool:
  	if ResourceLoader.exists(Constants.SAVE_FILE_PATH):
  		var loaded_data = ResourceLoader.load(Constants.SAVE_FILE_PATH)
  
  		if loaded_data is SaveData:
  			current_save_data = loaded_data
  
  			# Apply loaded data to game state
  			_apply_save_data()
  
  			print("Game loaded successfully from: ", Constants.SAVE_FILE_PATH)
  			emit_signal("load_completed", true, "Game loaded successfully")
  			return true
  		else:
  			push_error("Loaded resource is not a SaveData resource")
  	else:
  		print("No save file found at: ", Constants.SAVE_FILE_PATH)
  
  	# If we get here, loading failed
  	emit_signal("load_completed", false, "No save data found or data corrupted")
  	return false
  
  func _update_save_data() -> void:
  	# Get player reference from GameManager
  	var player = null
  	if get_node_or_null("/root/Global") and get_node("/root/Global").player:
  		player = get_node("/root/Global").player
  
  	# Check if GlobalHUD exists
  	var global_hud = get_node_or_null("/root/GlobalHUD")
  
  	if player:
  		# Update player data
  		if global_hud:
  			# Use GlobalHUD for health and coins
  			current_save_data.health = global_hud.current_health
  			current_save_data.coins = global_hud.coins
  		else:
  			# Fallback to player's HUD
  			current_save_data.health = GlobalHUD.lifes if GlobalHUD else Constants.PLAYER_DEFAULT_MAX_HEALTH
  			current_save_data.coins = GlobalHUD.coins if GlobalHUD else 0
  			
  		current_save_data.player_position = player.global_position
  		current_save_data.current_level = get_node("/root/Global").current_level
  
  		# Update player stats and settings
  		current_save_data.player_speed = player.SPEED
  		current_save_data.player_jump_velocity = player.JUMP_VELOCITY
  		current_save_data.player_fly_velocity = player.FLY_VELOCITY
  		current_save_data.player_gravity = player.GRAVITY
  		current_save_data.player_mode = player.mode
  		current_save_data.player_passed_fly_time = player.passed_fly_time
  		current_save_data.player_jump_counter = player.jump_counter
  		current_save_data.player_ready_for_jump = player.ready_for_jump
  		current_save_data.player_allowed_jumps = player.allowed_jumps
  
  		# Get outfit data - ensure we have a deep copy
  		if player.player_outfit:
  			current_save_data.player_outfit = player.player_outfit.duplicate(true)
  
  		# Update timestamp
  		current_save_data.save_date = Time.get_datetime_string_from_system(false, true)
  
  	# Add global game state
  	if get_node_or_null("/root/Global"):
  		current_save_data.collected_coins = get_node("/root/Global").collected_coins
  		current_save_data.unlocked_levels = get_node("/root/Global").unlocked_levels.duplicate()
  		current_save_data.completed_quests = get_node("/root/Global").completed_quests.duplicate()
  		
  	# Update playtime
  	current_save_data.playtime_seconds += 1  # Add at least 1 second each time
  
  # Update to SaveManager._apply_save_data method
  func _apply_save_data() -> void:
  	if not current_save_data:
  		return
  		
  	# Update GameManager data
  	if get_node_or_null("/root/Global"):
  		get_node("/root/Global").collected_coins = current_save_data.collected_coins
  		get_node("/root/Global").unlocked_levels = current_save_data.unlocked_levels.duplicate()
  		get_node("/root/Global").completed_quests = current_save_data.completed_quests.duplicate()
  		get_node("/root/Global").current_level = current_save_data.current_level
  
  	# Update GlobalHUD if available
  	var global_hud = get_node_or_null("/root/GlobalHUD")
  	if global_hud:
  		global_hud.current_health = current_save_data.health
  		global_hud.coins = current_save_data.coins
  		global_hud.sync_hud_with_global()
  		
  # Apply save data to the player (called when player is instantiated)
  func apply_save_data_to_player(player) -> void:
  	if not current_save_data or not player:
  		return
  
  	# Set player stats from constants if they're not valid in save data
  	player.SPEED = current_save_data.player_speed if current_save_data.player_speed > 0 else Constants.PLAYER_DEFAULT_SPEED
  	player.JUMP_VELOCITY = current_save_data.player_jump_velocity if current_save_data.player_jump_velocity < 0 else Constants.PLAYER_DEFAULT_JUMP_VELOCITY
  	player.FLY_VELOCITY = current_save_data.player_fly_velocity if current_save_data.player_fly_velocity < 0 else Constants.PLAYER_DEFAULT_FLY_VELOCITY
  	player.GRAVITY = current_save_data.player_gravity if current_save_data.player_gravity > 0 else Constants.PLAYER_DEFAULT_GRAVITY
  	player.mode = current_save_data.player_mode
  	player.passed_fly_time = current_save_data.player_passed_fly_time
  	player.jump_counter = current_save_data.player_jump_counter
  	player.ready_for_jump = current_save_data.player_ready_for_jump
  	player.allowed_jumps = current_save_data.player_allowed_jumps
  
  	# Apply outfit if available
  	if current_save_data.player_outfit:
  		player.player_outfit = current_save_data.player_outfit.duplicate(true)
  
  		# If there's a resource-based outfit, update that too
  		if player.current_outfit:
  			player.current_outfit.from_dictionary(current_save_data.player_outfit)
  
  	# Set HUD data if available
  	if GlobalHUD:
  		GlobalHUD.lifes = current_save_data.health
  		GlobalHUD.coins = current_save_data.coins
  		GlobalHUD.load_hearts()
  		GlobalHUD._update_coin_display()
  
  # Settings management - Using player defaults from Constants
  func save_settings() -> bool:
  	var config = ConfigFile.new()
  
  	# Get player for current settings
  	var player = null
  	if get_node_or_null("/root/Global") and get_node("/root/Global").player:
  		player = get_node("/root/Global").player
  
  	# Save constant values if player doesn't exist, otherwise save player values
  	if player:
  		# Save player settings
  		config.set_value(Constants.SECTION_SETTINGS, "speed", player.SPEED)
  		config.set_value(Constants.SECTION_SETTINGS, "jump_velocity", player.JUMP_VELOCITY)
  		config.set_value(Constants.SECTION_SETTINGS, "fly_velocity", player.FLY_VELOCITY)
  		config.set_value(Constants.SECTION_SETTINGS, "gravity", player.GRAVITY)
  		config.set_value(Constants.SECTION_SETTINGS, "mode", player.mode)
  		config.set_value(Constants.SECTION_SETTINGS, "passed_fly_time", player.passed_fly_time)
  		config.set_value(Constants.SECTION_SETTINGS, "jump_counter", player.jump_counter)
  		config.set_value(Constants.SECTION_SETTINGS, "ready_for_jump", player.ready_for_jump)
  		config.set_value(Constants.SECTION_SETTINGS, "allowed_jumps", player.allowed_jumps)
  
  		# Save outfit
  		if player.player_outfit:
  			config.set_value(Constants.SECTION_SETTINGS, "outfit", player.player_outfit)
  	else:
  		# If no player exists, use default constants or current save data
  		config.set_value(Constants.SECTION_SETTINGS, "speed", current_save_data.player_speed)
  		config.set_value(Constants.SECTION_SETTINGS, "jump_velocity", current_save_data.player_jump_velocity)
  		config.set_value(Constants.SECTION_SETTINGS, "fly_velocity", current_save_data.player_fly_velocity)
  		config.set_value(Constants.SECTION_SETTINGS, "gravity", current_save_data.player_gravity)
  		config.set_value(Constants.SECTION_SETTINGS, "mode", current_save_data.player_mode)
  		config.set_value(Constants.SECTION_SETTINGS, "passed_fly_time", current_save_data.player_passed_fly_time)
  		config.set_value(Constants.SECTION_SETTINGS, "jump_counter", current_save_data.player_jump_counter)
  		config.set_value(Constants.SECTION_SETTINGS, "ready_for_jump", current_save_data.player_ready_for_jump)
  		config.set_value(Constants.SECTION_SETTINGS, "allowed_jumps", current_save_data.player_allowed_jumps)
  
  		# Save outfit
  		if current_save_data.player_outfit:
  			config.set_value(Constants.SECTION_SETTINGS, "outfit", current_save_data.player_outfit)
  
  	# Save audio settings
  	var master_bus_idx = AudioServer.get_bus_index("Master")
  	config.set_value(Constants.SECTION_SETTINGS, "master_volume", AudioServer.get_bus_volume_db(master_bus_idx))
  	config.set_value(Constants.SECTION_SETTINGS, "master_mute", AudioServer.is_bus_mute(master_bus_idx))
  	
  	# Save auto-save settings
  	config.set_value(Constants.SECTION_SETTINGS, "auto_save_enabled", auto_save_enabled)
  	config.set_value(Constants.SECTION_SETTINGS, "auto_save_interval", auto_save_interval)
  
  	# Save the config
  	var err = config.save(Constants.SETTINGS_FILE_PATH)
  	var success = (err == OK)
  
  	if success:
  		print("Settings saved successfully to: ", Constants.SETTINGS_FILE_PATH)
  	else:
  		push_error("Failed to save settings. Error code: " + str(err))
  
  	emit_signal("settings_saved", success)
  	return success
  
  func load_settings() -> bool:
  	var config = ConfigFile.new()
  	var err = config.load(Constants.SETTINGS_FILE_PATH)
  
  	if err != OK:
  		print("No settings file found or error loading settings. Using defaults.")
  		emit_signal("settings_loaded", false)
  		return false
  
  	print("Loading settings from: ", Constants.SETTINGS_FILE_PATH)
  
  	# Create default save data if not already created
  	if not current_save_data:
  		current_save_data = SaveData.new()
  
  	# Load settings into current_save_data for future use
  	current_save_data.player_speed = config.get_value(Constants.SECTION_SETTINGS, "speed", Constants.PLAYER_DEFAULT_SPEED)
  	current_save_data.player_jump_velocity = config.get_value(Constants.SECTION_SETTINGS, "jump_velocity", Constants.PLAYER_DEFAULT_JUMP_VELOCITY)
  	current_save_data.player_fly_velocity = config.get_value(Constants.SECTION_SETTINGS, "fly_velocity", Constants.PLAYER_DEFAULT_FLY_VELOCITY)
  	current_save_data.player_gravity = config.get_value(Constants.SECTION_SETTINGS, "gravity", Constants.PLAYER_DEFAULT_GRAVITY)
  	current_save_data.player_mode = config.get_value(Constants.SECTION_SETTINGS, "mode", "normal")
  	current_save_data.player_passed_fly_time = config.get_value(Constants.SECTION_SETTINGS, "passed_fly_time", 0.0)
  	current_save_data.player_jump_counter = config.get_value(Constants.SECTION_SETTINGS, "jump_counter", 0)
  	current_save_data.player_ready_for_jump = config.get_value(Constants.SECTION_SETTINGS, "ready_for_jump", true)
  	current_save_data.player_allowed_jumps = config.get_value(Constants.SECTION_SETTINGS, "allowed_jumps", Constants.PLAYER_MAX_JUMPS)
  
  	# Load outfit
  	var saved_outfit = config.get_value(Constants.SECTION_SETTINGS, "outfit", null)
  	if saved_outfit:
  		current_save_data.player_outfit = saved_outfit.duplicate(true)
  
  	# Apply audio settings
  	var master_bus_idx = AudioServer.get_bus_index("Master")
  	var volume = config.get_value(Constants.SECTION_SETTINGS, "master_volume", 0.0)
  	var mute = config.get_value(Constants.SECTION_SETTINGS, "master_mute", false)
  
  	AudioServer.set_bus_volume_db(master_bus_idx, volume)
  	AudioServer.set_bus_mute(master_bus_idx, mute)
  	
  	# Load auto-save settings
  	auto_save_enabled = config.get_value(Constants.SECTION_SETTINGS, "auto_save_enabled", false)
  	auto_save_interval = config.get_value(Constants.SECTION_SETTINGS, "auto_save_interval", 300.0)
  
  	print("Settings loaded successfully")
  	emit_signal("settings_loaded", true)
  	return true
  
  # Outfit management
  func save_outfit(outfit_config: Dictionary, name: String = "") -> bool:
  	var favorites = load_favorite_outfits()
  
  	if name.is_empty():
  		name = "Outfit " + str(favorites.size() + 1)
  
  	favorites[name] = outfit_config
  
  	var config = ConfigFile.new()
  	config.set_value(Constants.SECTION_FAVORITES, "outfits", favorites)
  	var err = config.save(Constants.FAVORITES_FILE_PATH)
  	var success = (err == OK)
  
  	if success:
  		print("Outfit saved successfully: ", name)
  	else:
  		push_error("Failed to save outfit. Error code: " + str(err))
  
  	emit_signal("outfit_saved", success, name)
  	return success
  
  func load_favorite_outfits() -> Dictionary:
  	var config = ConfigFile.new()
  	var err = config.load(Constants.FAVORITES_FILE_PATH)
  
  	if err == OK:
  		return config.get_value(Constants.SECTION_FAVORITES, "outfits", {})
  	else:
  		return {}
  
  func delete_outfit(name: String) -> bool:
  	var favorites = load_favorite_outfits()
  
  	if not favorites.has(name):
  		return false
  
  	favorites.erase(name)
  
  	var config = ConfigFile.new()
  	config.set_value(Constants.SECTION_FAVORITES, "outfits", favorites)
  	var err = config.save(Constants.FAVORITES_FILE_PATH)
  
  	return (err == OK)
  
  # Helper functions
  func save_exists() -> bool:
  	return ResourceLoader.exists(Constants.SAVE_FILE_PATH)
  
  func clear_save_data() -> void:
  	var dir = DirAccess.open("user://")
  	if dir:
  		if dir.file_exists(Constants.SAVE_FILE_PATH):
  			dir.remove(Constants.SAVE_FILE_PATH)
  			print("Save data cleared")
  	current_save_data = SaveData.new()
  
  # Return a fresh instance of SaveData
  func create_new_save_data() -> SaveData:
  	return SaveData.new()
  
  # Helper method for other scripts to add callback function when save completes
  func connect_save_completed(target: Object, method: String, binds: Array = [], flags: int = 0) -> void:
  	if not is_connected("save_completed", Callable(target, method)):
  		connect("save_completed", Callable(target, method).bind(binds), flags)
  
  # Called when player instance is being initialized
  func _on_player_ready(player) -> void:
  	call_deferred("apply_save_data_to_player", player)

========================================
Contents of scripts\core\base_classes\base_enemy.gd:
========================================
  class_name BaseEnemy
  extends CharacterBody2D
  
  ## Base class for all enemies in the game
  ## Provides basic attributes and functionality only
  
  # Enemy properties - attributes only
  @export_category("Stats")
  @export var max_health: float = 100.0
  @export var speed: float = 80.0
  @export var chase_speed: float = 100.0
  @export var attack_damage: float = 50.0  # Geändert für konsistenten Schaden (0.5 Herzen)
  @export var attack_cooldown: float = 1.0
  @export var detection_radius: float = 200.0
  @export var attack_radius: float = 75.0
  @export var patrol_distance: float = 100.0
  
  # Current state - public attributes that states can modify
  var current_health: float
  var is_dead: bool = false
  var is_invulnerable: bool = false
  var can_attack: bool = true  # Can this enemy currently attack
  
  # Components (to be assigned by extending classes)
  var animated_sprite: AnimatedSprite2D
  var collision_shape: CollisionShape2D
  var state_machine: EnemyStateMachine
  
  # Signals - communicate with states instead of direct calls
  signal damaged(amount, attacker)
  signal died
  signal attack_executed(target, damage)
  signal attack_completed
  signal animation_finished(anim_name)
  
  func _ready():
  	# Initialize health
  	current_health = max_health
  	
  	# Find key components
  	animated_sprite = get_node_or_null("AnimatedSprite2D")
  	collision_shape = get_node_or_null("CollisionShape2D")
  	
  	# Connect to animation finished
  	if animated_sprite:
  		animated_sprite.animation_finished.connect(_on_animation_finished)
  	
  	# Make sure we're in the enemy group
  	if not is_in_group("enemy"):
  		add_to_group("enemy")
  	
  	# State machine now managed explicitly by child classes
  	state_machine = get_node_or_null("StateMachine") as EnemyStateMachine
  	
  	print(name + " initialized with " + str(current_health) + " health")
  
  func _physics_process(delta):
  	# Apply gravity if not on floor
  	if not is_on_floor():
  		velocity.y += calculate_gravity() * delta
  	
  	# Core movement - states will set velocity.x
  	move_and_slide()
  
  func calculate_gravity():
  	return ProjectSettings.get_setting("physics/2d/default_gravity")
  
  # Animation interface - states call this
  func play_animation(anim_name: String):
  	if animated_sprite and animated_sprite.sprite_frames and animated_sprite.sprite_frames.has_animation(anim_name):
  		animated_sprite.play(anim_name)
  	elif animated_sprite and animated_sprite.sprite_frames and animated_sprite.sprite_frames.has_animation("idle"):
  		animated_sprite.play("idle")
  		print("Animation not found for " + name + ": " + anim_name + ", using idle instead")
  
  # Handle animation completion - Notify states through signals
  func _on_animation_finished():
  	if animated_sprite:
  		emit_signal("animation_finished", animated_sprite.animation)
  
  # Damage interface - states handle effects of damage
  func take_damage(amount, attacker = null):
  	if is_dead or is_invulnerable:
  		return
  	
  	current_health -= amount
  	emit_signal("damaged", amount, attacker)
  	
  	print(name + " took " + str(amount) + " damage, health: " + str(current_health))
  	
  	if current_health <= 0 and not is_dead:
  		is_dead = true
  		emit_signal("died")
  
  # Attack interface - Actual behavior in attack states
  func execute_attack(target, damage_amount = null):
  	var actual_damage = damage_amount if damage_amount != null else attack_damage
  	emit_signal("attack_executed", target, actual_damage)
  	
  	# Direkten Schaden auf Spieler anwenden
  	if target.is_in_group("player") and target.has_method("take_damage"):
  		target.take_damage(actual_damage)
  	
  	# HUD aktualisieren
  	if target.is_in_group("player"):
  		var hud = get_tree().get_root().find_child("HUD", true, false)
  		if hud and hud.has_method("change_life"):
  			hud.change_life(-actual_damage / 100)  # Skalierung für HUD (0.5 für halbes Herz)
  	
  	# Let states know when attack completes through signal
  	can_attack = false
  	get_tree().create_timer(attack_cooldown).timeout.connect(func():
  		can_attack = true
  		emit_signal("attack_completed")
  	)
  
  # Hilfsmethode zum Einrichten einer neuen State Machine
  func setup_state_machine():
  	if state_machine:
  		return  # Bereits vorhanden
  		
  	state_machine = EnemyStateMachine.new()
  	state_machine.name = "StateMachine"
  	add_child(state_machine)
  	
  	# Konfiguriere Erkennungsbereiche
  	state_machine.detection_range = detection_radius
  	state_machine.attack_range = attack_radius
  	state_machine.patrol_range = patrol_distance

========================================
Contents of scripts\core\base_classes\base_power_up.gd:
========================================
  class_name BasePowerUp
  extends Area2D
  
  ## Base class for all power-ups in the game
  
  # Power-up properties
  @export var power_up_name: String = "Power Up"
  @export var description: String = "A mysterious power-up"
  @export var icon_texture: Texture2D
  @export var effect_duration: float = 0.0  # 0 means permanent effect
  @export var play_animation: bool = true
  @export var destroy_on_pickup: bool = true
  
  # Animation
  @export var bounce_height: float = 5.0
  @export var bounce_speed: float = 2.0
  @export var rotation_speed: float = 0.0
  
  # Internal variables
  var original_position: Vector2
  var animation_time: float = 0.0
  var player_ref = null
  
  # Signals
  signal power_up_collected(power_up, player)
  signal power_up_effect_started(power_up, player)
  signal power_up_effect_ended(power_up, player)
  
  func _ready():
  	original_position = global_position
  	
  	# Set up collision
  	if not has_node("CollisionShape2D"):
  		push_error("Power-up " + name + " has no CollisionShape2D!")
  	
  	# Set up sprite/animation if enabled
  	if play_animation and has_node("Sprite2D"):
  		var sprite = get_node("Sprite2D")
  		if icon_texture:
  			sprite.texture = icon_texture
  	
  	# Connect signals
  	body_entered.connect(_on_power_up_body_entered)
  
  func _process(delta):
  	if play_animation:
  		animate_power_up(delta)
  
  func animate_power_up(delta):
  	animation_time += delta
  	
  	# Bouncing animation
  	if bounce_height > 0:
  		var bounce_offset = sin(animation_time * bounce_speed) * bounce_height
  		global_position.y = original_position.y + bounce_offset
  	
  	# Rotation animation
  	if rotation_speed > 0 and has_node("Sprite2D"):
  		var sprite = get_node("Sprite2D")
  		sprite.rotation += rotation_speed * delta
  
  func _on_power_up_body_entered(body):
  	if body.is_in_group("Player") or body.name == "Player":
  		collect_power_up(body)
  
  func collect_power_up(player):
  	# Store reference to player
  	player_ref = player
  	
  	# Disable collision
  	set_collision_mask_value(1, false)
  	
  	# Emit collected signal
  	emit_signal("power_up_collected", self, player)
  	
  	# Play collection animation if available
  	if has_node("AnimationPlayer"):
  		var anim_player = get_node("AnimationPlayer")
  		if anim_player.has_animation("collect"):
  			anim_player.play("collect")
  			await anim_player.animation_finished
  		
  	# Apply effect
  	apply_effect(player)
  	
  	# Destroy if set
  	if destroy_on_pickup:
  		queue_free()
  
  func apply_effect(player):
  	# Base implementation just emits signal
  	# Override in child classes to implement specific effects
  	emit_signal("power_up_effect_started", self, player)
  	
  	# If temporary effect, setup timer to end effect
  	if effect_duration > 0:
  		await get_tree().create_timer(effect_duration).timeout
  		remove_effect(player)
  
  func remove_effect(player):
  	# Override in child classes to implement specific effect removal
  	emit_signal("power_up_effect_ended", self, player)
  
  # Optional methods for child classes to implement
  func get_effect_description() -> String:
  	return description
  
  func get_icon() -> Texture2D:
  	return icon_texture

========================================
Contents of scripts\core\base_classes\base_projectile.gd:
========================================
  class_name BaseProjectile
  extends CharacterBody2D
  
  ## Enhanced base class for all projectiles in the game
  ## Supports object pooling, various trajectories, and collision effects
  
  # Projectile properties
  @export_group("Basic Properties")
  @export var speed: float = 150.0
  @export var damage: float = 0.25  # Equivalent to 25 before scaling
  @export var lifetime: float = 5.0  # Time until automatic destruction
  @export var gravity_affected: bool = false  # Whether the projectile is affected by gravity
  
  @export_group("Behavior")
  @export var bounce: bool = false  # Whether the projectile can bounce
  @export var bounce_factor: float = 0.5  # How much velocity is retained when bouncing
  @export var penetration: bool = false  # Whether the projectile can penetrate multiple targets
  @export var max_penetrations: int = 0  # Max number of penetrations (0 = no limit)
  
  @export_group("Effects")
  @export var hit_effect_scene: PackedScene  # Effect on hit
  @export var trail_effect: bool = false  # Whether to display a movement path
  
  # Internal variables
  var direction: Vector2 = Vector2.ZERO
  var source_node = null  # Who fired the projectile
  var spawn_position: Vector2
  var spawn_rotation: float
  var time_alive: float = 0.0
  var has_hit: bool = false
  var is_from_pool: bool = false  # Whether this projectile is from a pool
  var penetration_count: int = 0  # Number of targets penetrated
  
  # For trails/particles
  var trail: Line2D = null
  var particles: GPUParticles2D = null
  
  # Signals
  signal projectile_hit(projectile, target, hit_position)
  signal projectile_expired(projectile)
  signal projectile_bounce(projectile, collision_point, collision_normal)
  
  func _ready():
  	# Start lifetime timer
  	if lifetime > 0:
  		get_tree().create_timer(lifetime).timeout.connect(_on_lifetime_expired)
  	
  	# Set up animation if available
  	var animated_sprite = get_node_or_null("AnimatedSprite2D")
  	if animated_sprite and animated_sprite.sprite_frames.has_animation("flying"):
  		animated_sprite.play("flying")
  	
  	# Create trail if enabled
  	if trail_effect:
  		_setup_trail()
  
  func _physics_process(delta):
  	time_alive += delta
  	
  	# Apply gravity if enabled
  	if gravity_affected:
  		velocity.y += ProjectSettings.get_setting("physics/2d/default_gravity") * delta
  	
  	# Implementiere Raycast für schnelle Projektile, um Tunneleffekt zu vermeiden
  	var start_pos = global_position
  	
  	# Move the projectile
  	var collision = move_and_collide(velocity * delta)
  	
  	# Zusätzlicher Raycast für schnelle Projektile, die möglicherweise Objekte "überspringen"
  	if not collision and velocity.length() > 0: # Temporary fix cause collisions not registered for unnkown reason
  		var space_state = get_world_2d().direct_space_state
  		var end_pos = start_pos + velocity * delta
  		var query = PhysicsRayQueryParameters2D.create(start_pos, end_pos)
  		query.exclude = [self]  # Exclude self from collision
  		
  		# Set collision mask to match this object's mask
  		query.collision_mask = collision_mask
  		
  		var result = space_state.intersect_ray(query)
  		if result:
  			# Manually create a collision object
  			collision = KinematicCollision2D.new()
  			# Unfortunately we can't fully construct a KinematicCollision2D manually,
  			# so we'll handle this collision directly
  			_on_raycast_collision(result)
  	
  	# Update trail if available
  	if trail:
  		trail.add_point(position)
  		# Limit trail length
  		while trail.get_point_count() > 20:
  			trail.remove_point(0)
  	
  	# Process collision
  	if collision and not has_hit:
  		_on_collision(collision)
  
  # Handle collisions detected by raycast
  func _on_raycast_collision(result):
  	var collider = result.collider
  	
  	# Set hit flag if not penetrating
  	if not penetration:
  		has_hit = true
  	else:
  		penetration_count += 1
  		if max_penetrations > 0 and penetration_count >= max_penetrations:
  			has_hit = true
  	
  	# Verify collider has the proper methods
  	var is_player = collider.is_in_group("player") if collider.has_method("is_in_group") else false
  	var is_enemy = collider.is_in_group("enemy") if collider.has_method("is_in_group") else false
  	
  	# Process different collision types
  	if is_player and source_node != collider:
  		_on_hit_player(collider, result.position)
  	elif is_enemy and source_node != collider:
  		_on_hit_enemy(collider, result.position)
  	else:
  		_on_hit_environment(collider, result.position)
  	
  	# If we're not penetrating or have reached the limit, recycle
  	if has_hit:
  		_recycle_or_free()
  
  # Initialize the projectile with direction and start position
  func setup(dir: Vector2, spawn_pos: Vector2, spawn_rot: float = 0.0, source = null):
  	direction = dir.normalized()
  	spawn_position = spawn_pos
  	spawn_rotation = spawn_rot
  	source_node = source
  	
  	# Set start position and rotation
  	global_position = spawn_position
  	global_rotation = spawn_rotation
  	
  	# Set velocity
  	velocity = direction * speed
  	
  	# Reset status
  	has_hit = false
  	time_alive = 0.0
  	penetration_count = 0
  	
  	return self  # For method chaining
  
  # Create a visual trail for the projectile
  func _setup_trail():
  	trail = Line2D.new()
  	trail.name = "Trail"
  	trail.width = 3.0
  	trail.default_color = Color(1, 0.7, 0.2, 0.5)  # Adjust based on projectile
  	add_child(trail)
  
  # Process collisions
  func _on_collision(collision):
  	var collider = collision.get_collider()
  	if collider == null:
  		return
  	
  	# Zusätzliche Prüfung auf gültige Gruppen
  	var is_player = collider.is_in_group("player") if collider.has_method("is_in_group") else false
  	var is_enemy = collider.is_in_group("enemy") if collider.has_method("is_in_group") else false
  	
  	# Check for bounce
  	if bounce and not (is_player or is_enemy):
  		var reflection = collision.get_remainder().bounce(collision.get_normal())
  		velocity = velocity.bounce(collision.get_normal()) * bounce_factor
  		global_position += reflection
  		
  		emit_signal("projectile_bounce", self, collision.get_position(), collision.get_normal())
  		_spawn_bounce_effect(collision.get_position(), collision.get_normal())
  		return
  	
  	# Set hit flag if not penetrating
  	if not penetration:
  		has_hit = true
  	else:
  		penetration_count += 1
  		if max_penetrations > 0 and penetration_count >= max_penetrations:
  			has_hit = true
  	
  	# Process different collision types
  	if is_player and source_node != collider:
  		_on_hit_player(collider, collision.get_position())
  	elif is_enemy and source_node != collider:
  		_on_hit_enemy(collider, collision.get_position())
  	else:
  		_on_hit_environment(collider, collision.get_position())
  	
  	# If we're not penetrating or have reached the limit, recycle
  	if has_hit:
  		_recycle_or_free()
  
  # On collision with player
  func _on_hit_player(player, hit_position):
  	emit_signal("projectile_hit", self, player, hit_position)
  	
  	# Debug-Ausgabe für Schadenserkennung
  	print("Projektil traf Spieler an Position: ", hit_position)
  	
  	# Apply damage based on Damage System if available
  	var damage_system = get_node_or_null("/root/DamageSystem")
  	if damage_system and source_node:
  		damage_system.process_attack(source_node, player, damage * 100)  # Scaling for DamageSystem
  		print("Schaden via DamageSystem: ", damage * 100)
  	elif player.has_method("take_damage"):
  		player.take_damage(damage * 100)  # Scaling for Player class
  		print("Schaden direkt an Spieler: ", damage * 100)
  	else:
  		print("FEHLER: Spieler hat keine take_damage Methode!")
  	
  	# Update HUD if available
  	var hud = get_tree().get_root().find_child("HUD", true, false)
  	hud.change_life(-damage)  # Keine Skalierung - HUD erwartet bereits den richtigen Wert (0.5 für halbes Herz)
  	print("HUD aktualisiert mit Schaden: ", damage)
  
  	# Spawn hit effect if available
  	_spawn_hit_effect(hit_position)
  
  # On collision with enemy
  func _on_hit_enemy(enemy, hit_position):
  	emit_signal("projectile_hit", self, enemy, hit_position)
  	
  	# Apply damage
  	var damage_system = get_node_or_null("/root/DamageSystem")
  	if damage_system and source_node:
  		damage_system.process_attack(source_node, enemy, damage * 100)
  	elif enemy.has_method("take_damage"):
  		enemy.take_damage(damage * 100)
  	
  	# Spawn hit effect if available
  	_spawn_hit_effect(hit_position)
  
  # On collision with environment
  func _on_hit_environment(object, hit_position):
  	emit_signal("projectile_hit", self, object, hit_position)
  	
  	# Spawn hit effect if available
  	_spawn_hit_effect(hit_position)
  
  # When lifetime expires
  func _on_lifetime_expired():
  	if not has_hit:
  		emit_signal("projectile_expired", self)
  		_recycle_or_free()
  
  # Spawn hit effect
  func _spawn_hit_effect(hit_position):
  	if hit_effect_scene:
  		var effect = hit_effect_scene.instantiate()
  		effect.global_position = hit_position
  		get_tree().current_scene.add_child(effect)
  	else:
  		# Fallback if no scene is set
  		var sprite = get_node_or_null("AnimatedSprite2D")
  		if sprite and sprite.sprite_frames.has_animation("hit"):
  			# Separate physics process
  			set_physics_process(false)
  			
  			# Stop movement
  			velocity = Vector2.ZERO
  			
  			# Play hit animation
  			sprite.play("hit")
  			
  			# Wait for animation to finish
  			await sprite.animation_finished
  
  # Spawn bounce effect
  func _spawn_bounce_effect(hit_position, normal):
  	# Just a few small particles
  	var particles = CPUParticles2D.new()
  	particles.position = hit_position
  	particles.emitting = true
  	particles.one_shot = true
  	particles.amount = 5
  	particles.explosiveness = 1.0
  	particles.direction = Vector2(-normal.x, -normal.y)
  	particles.spread = 30.0
  	particles.initial_velocity_min = 20.0
  	particles.initial_velocity_max = 40.0
  	particles.lifetime = 0.3
  	get_tree().current_scene.add_child(particles)
  	
  	# Auto-remove after short time
  	await get_tree().create_timer(0.5).timeout
  	particles.queue_free()
  
  # When spawned from an Object Pool
  func _on_spawn_from_pool():
  	is_from_pool = true
  	visible = true
  	set_physics_process(true)
  	
  	# Reset status
  	has_hit = false
  	time_alive = 0.0
  	penetration_count = 0
  	
  	# Reset trail if available
  	if trail:
  		trail.clear_points()
  
  # When returned to an Object Pool
  func _on_recycle_to_pool():
  	# Reset status
  	has_hit = false
  	time_alive = 0.0
  	velocity = Vector2.ZERO
  	source_node = null
  	penetration_count = 0
  	
  	# Reset trail if available
  	if trail:
  		trail.clear_points()
  	
  	# Reset animation if needed
  	var sprite = get_node_or_null("AnimatedSprite2D")
  	if sprite and sprite.sprite_frames.has_animation("flying"):
  		sprite.play("flying")
  		sprite.frame = 0
  
  # Either recycle to pool or delete based on whether we use pooling
  func _recycle_or_free():
  	if is_from_pool:
  		# Find the Object Pool that owns this projectile
  		var pool = null
  		
  		# First check if our source has a projectile pool
  		if source_node and source_node.has_node("ProjectilePool"):
  			pool = source_node.get_node("ProjectilePool")
  		
  		# Otherwise look in scene root
  		if not pool:
  			pool = get_tree().get_root().find_child("ProjectilePool", true, false)
  		
  		if pool and pool is ObjectPool:
  			# Return to pool
  			pool.recycle(self)
  		else:
  			# Fallback to queue_free
  			queue_free()
  	else:
  		# Not from pool, just delete
  		queue_free()

========================================
Contents of scripts\core\base_classes\state_machine\state.gd:
========================================
  class_name State
  extends Node
  
  ## Base class for all states in a state machine
  
  # Reference to the state machine
  var state_machine: StateMachine = null
  
  # Reference to the owner node
  var owner_node: Node = null
  
  # State parameters (can be extended by child classes)
  var parameters: Dictionary = {}
  
  
  # Called when entering this state
  func enter():
  	pass
  
  # Called when exiting this state
  func exit():
  	pass
  
  # Called during _process
  func process(delta: float):
  	pass
  
  # Called during _physics_process
  func physics_process(delta: float):
  	pass
  
  # Called during _input
  func handle_input(event: InputEvent):
  	pass
  
  # Override this to determine the next state to transition to
  func get_next_state() -> String:
  	return ""
  
  # Utility functions that can be used by derived states
  
  # Check if a condition is true
  func condition_met(condition_name: String) -> bool:
  	if owner_node.has_method("check_condition"):
  		return owner_node.check_condition(condition_name)
  	return false
  
  # Get a value from the owner
  func get_owner_property(property_name: String):
  	if owner_node and property_name in owner_node:
  		return owner_node.get(property_name)
  	return null
  
  # Set a value on the owner
  func set_owner_property(property_name: String, value):
  	if owner_node and property_name in owner_node:
  		owner_node.set(property_name, value)
  
  # Helper to check if owner is on floor (for platformers)
  func is_on_floor() -> bool:
  	if owner_node.has_method("is_on_floor"):
  		return owner_node.is_on_floor()
  	return false
  
  # Helper to get owner velocity (for physics bodies)
  func get_velocity() -> Vector2:
  	if "velocity" in owner_node:
  		return owner_node.velocity
  	return Vector2.ZERO
  
  # Helper to set owner velocity (for physics bodies)
  func set_velocity(value: Vector2):
  	if "velocity" in owner_node:
  		owner_node.velocity = value
  
  # Helper to play animations
  func play_animation(anim_name: String):
  	if owner_node.has_method("play_animation"):
  		owner_node.play_animation(anim_name)
  	elif owner_node.has_node("AnimatedSprite2D"):
  		var sprite = owner_node.get_node("AnimatedSprite2D")
  		if sprite.sprite_frames.has_animation(anim_name):
  			sprite.play(anim_name)

========================================
Contents of scripts\core\base_classes\state_machine\state_machine.gd:
========================================
  class_name StateMachine
  extends Node
  
  ## A finite state machine implementation for Godot 4.x
  
  # Current active state
  var current_state: State = null
  
  # Dictionary of available states
  var states: Dictionary = {}
  
  # The owner node that this state machine controls
  var owner_node: Node = null
  
  # Debug mode flag
  @export var debug_mode: bool = true
  
  # Signal emitted when state changes
  signal state_changed(from_state, to_state)
  
  func _ready():
  	owner_node = get_parent()
  
  	# Register all child states
  	for child in get_children():
  		if child is State:
  			register_state(child)
  
  	# Initialize the first state
  	if states.size() > 0:
  		var initial_state = states.values()[0]
  		change_state(initial_state.name)
  
  func _process(delta):
  	if current_state != null:
  		# Call the current state's process method
  		current_state.process(delta)
  
  		# Check for state transitions
  		var next_state = current_state.get_next_state()
  		if next_state != null and next_state != "" and states.has(next_state):
  			change_state(next_state)
  
  func _physics_process(delta):
  	if current_state != null:
  		# Call the current state's physics_process method
  		current_state.physics_process(delta)
  
  func _input(event):
  	if current_state != null:
  		# Call the current state's input method
  		current_state.handle_input(event)
  
  func register_state(state: State):
  	# Add to states dictionary
  	states[state.name] = state
  
  	# Set the state machine reference
  	state.state_machine = self
  
  	# Set the owner reference
  	state.owner_node = owner_node
  	
  	# Specifically initialize player references for PlayerState instances
  	if state is PlayerState:
  		state.player = owner_node
  	
  	if debug_mode:
  		print("Registered state: ", state.name)
  
  func change_state(new_state_name: String):
  	if not states.has(new_state_name):
  		push_error("State '" + new_state_name + "' not found in state machine!")
  		return
  
  	var from_state = current_state.name if current_state else "None"
  
  	if current_state != null:
  		if debug_mode:
  			print("Exiting state: ", current_state.name)
  		current_state.exit()
  
  	var next_state = states[new_state_name]
  	current_state = next_state
  	
  	# Make sure the player reference is properly set before entering the state
  	if current_state is PlayerState and current_state.player == null:
  		current_state.player = owner_node
  
  	if debug_mode:
  		print("Entering state: ", current_state.name)
  
  	current_state.enter()
  
  	# Emit state change signal
  	emit_signal("state_changed", from_state, new_state_name)
  
  func get_current_state() -> String:
  	if current_state != null:
  		return current_state.name
  	return "None"
  
  # Add a new state at runtime
  func add_state(state: State):
  	# Check if the state already has a parent
  	var current_parent = state.get_parent()
  
  	if current_parent != null and current_parent != self:
  		push_error("Cannot add state that is already a child of another node: " + state.name)
  		return
  	elif current_parent != self:
  		# If it doesn't have a parent, add it as a child
  		add_child(state)
  	# Register the state
  	register_state(state)
  	
  	if debug_mode:
  		print("Added state as child and registered: ", state.name)
  
  # Remove a state at runtime
  func remove_state(state_name: String):
  	if states.has(state_name):
  		states.erase(state_name)
  	else:
  		push_error("Tried to remove non-existent state: " + state_name)
  
  # Hole einen Zustand nach Namen
  func get_state(state_name: String) -> State:
  	if states.has(state_name):
  		return states[state_name]
  	return null

========================================
Contents of scripts\core\combat\damage_system.gd:
========================================
  class_name DamageSystem
  extends Node
  
  ## A centralized system for calculating and applying damage in the game
  
  # Damage types
  enum DamageType {
  	PHYSICAL,
  	MAGICAL,
  	TRUE      # Ignores defenses
  }
  
  # Hit types
  enum HitType {
  	NORMAL,
  	CRITICAL,
  	MISS
  }
  
  # Damage result structure
  class DamageResult:
  	var damage: float = 0
  	var hit_type: int = HitType.NORMAL
  	var damage_type: int = DamageType.PHYSICAL
  	var source = null
  	var target = null
  	
  	func _init(dmg: float, type: int = HitType.NORMAL, dmg_type: int = DamageType.PHYSICAL, src = null, tgt = null):
  		damage = dmg
  		hit_type = type
  		damage_type = dmg_type
  		source = src
  		target = tgt
  
  # Default critical hit modifier
  var critical_multiplier: float = 1.5
  # Base chance for a critical hit (0-1)
  var base_critical_chance: float = 0.1
  # Base chance to miss (0-1)
  var base_miss_chance: float = 0.05
  
  # Signal emitted when damage is calculated
  signal damage_calculated(result: DamageResult)
  # Signal emitted when damage is applied
  signal damage_applied(result: DamageResult)
  # Signal emitted when a lethal hit is dealt
  signal lethal_hit(target, source)
  
  ## Calculate raw damage based on attacker and defender stats
  func calculate_damage(attacker, defender, base_damage: float, damage_type: int = DamageType.PHYSICAL) -> DamageResult:
  	# Get attack power
  	var attack_power = base_damage
  	if attacker.has_method("get_attack_power"):
  		attack_power = attacker.get_attack_power()
  	elif "attack_damage" in attacker:
  		attack_power = attacker.attack_damage
  	
  	# Get defense
  	var defense = 0
  	if defender.has_method("get_defense"):
  		defense = defender.get_defense()
  	elif "defense" in defender:
  		defense = defender.defense
  	
  	# Determine hit type (miss, normal, critical)
  	var hit_type = HitType.NORMAL
  	var hit_chance = randf()
  	
  	# Check for miss
  	var miss_chance = base_miss_chance
  	if defender.has_method("get_dodge_chance"):
  		miss_chance += defender.get_dodge_chance()
  	
  	if hit_chance < miss_chance:
  		hit_type = HitType.MISS
  		attack_power = 0
  	else:
  		# Check for critical hit
  		var crit_chance = base_critical_chance
  		if attacker.has_method("get_critical_chance"):
  			crit_chance += attacker.get_critical_chance()
  			
  		if hit_chance > (1.0 - crit_chance):
  			hit_type = HitType.CRITICAL
  			attack_power *= critical_multiplier
  	
  	# Calculate damage based on type
  	var final_damage = attack_power
  	
  	match damage_type:
  		DamageType.PHYSICAL:
  			# Physical damage reduced by defense
  			final_damage = max(0, attack_power - defense)
  		DamageType.MAGICAL:
  			# Magical damage, different formula
  			var magic_defense = defense * 0.5  # Example: magic defense is half of physical
  			final_damage = max(0, attack_power - magic_defense)
  		DamageType.TRUE:
  			# True damage ignores defense
  			final_damage = attack_power
  	
  	# Create the damage result
  	var result = DamageResult.new(final_damage, hit_type, damage_type, attacker, defender)
  	
  	# Emit signal
  	emit_signal("damage_calculated", result)
  	
  	return result
  
  ## Apply calculated damage to the target
  func apply_damage(result: DamageResult) -> bool:
  	if result.hit_type == HitType.MISS:
  		# Missed attack
  		if result.target.has_method("on_damage_missed"):
  			result.target.on_damage_missed(result)
  		return false
  	
  	# Apply damage to the target
  	var was_lethal = false
  	
  	if result.target.has_method("take_damage"):
  		was_lethal = result.target.take_damage(result.damage)
  	elif "current_health" in result.target:
  		result.target.current_health -= result.damage
  		if result.target.current_health <= 0:
  			was_lethal = true
  	
  	# Emit the damage applied signal
  	emit_signal("damage_applied", result)
  	
  	# Handle lethal hit
  	if was_lethal:
  		emit_signal("lethal_hit", result.target, result.source)
  	
  	return was_lethal
  
  ## Process a direct attack from attacker to defender
  func process_attack(attacker, defender, base_damage: float, damage_type: int = DamageType.PHYSICAL) -> bool:
  	var result = calculate_damage(attacker, defender, base_damage, damage_type)
  	return apply_damage(result)
  
  ## Helper function to get the appropriate text for a hit type
  func get_hit_text(hit_type: int) -> String:
  	match hit_type:
  		HitType.MISS:
  			return "Miss"
  		HitType.CRITICAL:
  			return "Critical"
  		_:
  			return "Hit"

========================================
Contents of scripts\core\combat\hit_effect.gd:
========================================
  class_name HitEffect
  extends Node2D
  
  ## Visual and audio effects for combat hits
  ## Creates temporary visual effects at hit locations
  
  # Effect properties
  @export var lifetime: float = 0.5
  @export var scale_multiplier: float = 1.0
  @export var effect_color: Color = Color(1, 1, 1, 1)
  @export var hit_sound: AudioStream = null
  @export var hit_sound_volume: float = 0.0  # in dB
  
  # Effect type
  enum HitEffectType {
  	NORMAL,
  	CRITICAL,
  	BLOCK,
  	HEAL,
  	MAGIC
  }
  
  @export var effect_type: HitEffectType = HitEffectType.NORMAL
  
  # Animation properties
  @export var animation_speed: float = 1.0
  @export var sprite_frames: SpriteFrames = null
  
  # Animation node
  var animated_sprite: AnimatedSprite2D = null
  
  # Whether audio has been played
  var audio_played: bool = false
  
  # Signal when effect is finished
  signal effect_finished()
  
  # Initialize the hit effect
  func _ready():
  	# Create animated sprite if not already a child
  	if not has_node("AnimatedSprite2D"):
  		animated_sprite = AnimatedSprite2D.new()
  		animated_sprite.name = "AnimatedSprite2D"
  		add_child(animated_sprite)
  	else:
  		animated_sprite = $AnimatedSprite2D
  	
  	# Set up animation
  	if sprite_frames:
  		animated_sprite.sprite_frames = sprite_frames
  	
  	# Apply settings
  	animated_sprite.modulate = effect_color
  	scale = Vector2(scale_multiplier, scale_multiplier)
  	animated_sprite.speed_scale = animation_speed
  	
  	# Determine which animation to play
  	var anim_name = "normal" # Default animation
  	match effect_type:
  		HitEffectType.CRITICAL:
  			anim_name = "critical"
  		HitEffectType.BLOCK:
  			anim_name = "block"
  		HitEffectType.HEAL:
  			anim_name = "heal"
  		HitEffectType.MAGIC:
  			anim_name = "magic"
  	
  	# Check if animation exists
  	if animated_sprite.sprite_frames and animated_sprite.sprite_frames.has_animation(anim_name):
  		animated_sprite.play(anim_name)
  	else:
  		# Use first available animation
  		var animations = animated_sprite.sprite_frames.get_animation_names()
  		if animations.size() > 0:
  			animated_sprite.play(animations[0])
  	
  	# Play hit sound
  	if hit_sound and not audio_played:
  		var audio_player = AudioStreamPlayer.new()
  		audio_player.stream = hit_sound
  		audio_player.volume_db = hit_sound_volume
  		audio_player.name = "HitSound"
  		add_child(audio_player)
  		audio_player.play()
  		audio_player.finished.connect(func(): audio_player.queue_free())
  		audio_played = true
  	
  	# Connect to animation finished
  	animated_sprite.animation_finished.connect(_on_animation_finished)
  	
  	# Set up backup timeout
  	var timer = Timer.new()
  	timer.wait_time = lifetime
  	timer.one_shot = true
  	timer.name = "LifetimeTimer"
  	add_child(timer)
  	timer.timeout.connect(_on_timeout)
  	timer.start()
  
  # Process function for manual animation logic if needed
  func _process(delta):
  	# Add optional particle effects or additional animations
  	pass
  
  # Create and play a one-shot hit effect at a position
  static func create_hit_effect(
  	effect_scene: PackedScene,
  	position: Vector2,
  	type: HitEffectType = HitEffectType.NORMAL,
  	parent: Node = null
  ) -> HitEffect:
  	# Instance the effect
  	var effect_instance = effect_scene.instantiate()
  	
  	# Set effect properties
  	effect_instance.global_position = position
  	effect_instance.effect_type = type
  	
  	# Find parent to add to
  	var target_parent = parent
  	if not target_parent:
  		target_parent = Engine.get_main_loop().current_scene
  	
  	# Add to scene
  	target_parent.add_child(effect_instance)
  	
  	return effect_instance
  
  # Animation finished handler
  func _on_animation_finished():
  	queue_free()
  	emit_signal("effect_finished")
  
  # Backup timeout handler (in case animation doesn't finish)
  func _on_timeout():
  	queue_free()
  	emit_signal("effect_finished")
  
  # Apply a screen shake effect
  func apply_screen_shake(camera: Camera2D, intensity: float = 5.0, duration: float = 0.2) -> void:
  	if camera:
  		var original_offset = camera.offset
  		
  		# Create a tween for the shake
  		var tween = create_tween()
  		
  		# Add multiple shake steps
  		var shake_steps = 10
  		var time_per_step = duration / shake_steps
  		
  		for i in range(shake_steps):
  			var random_offset = Vector2(
  				randf_range(-intensity, intensity),
  				randf_range(-intensity, intensity)
  			)
  			
  			# Reduce intensity over time
  			random_offset *= 1.0 - (float(i) / shake_steps)
  			
  			tween.tween_property(camera, "offset", original_offset + random_offset, time_per_step)
  		
  		# Reset to original position
  		tween.tween_property(camera, "offset", original_offset, time_per_step)

========================================
Contents of scripts\core\enemies\behaviors\attack_behavior.gd:
========================================
  class_name AttackBehavior
  extends Node
  
  ## A modular component for enemy attack behavior
  
  # Attack types
  enum AttackType {
  	MELEE,    # Close range attack
  	RANGED,   # Projectile attack
  	AREA      # Area of effect attack
  }
  
  # The type of attack
  @export var attack_type: AttackType = AttackType.MELEE
  # Base damage for the attack
  @export var base_damage: float = 10.0
  # Cooldown between attacks (seconds)
  @export var cooldown: float = 1.0
  # Range at which attack can be performed
  @export var attack_range: float = 50.0
  # For ranged attacks, the projectile scene
  @export var projectile_scene: PackedScene = null
  # For area attacks, the area shape
  @export var area_shape: Shape2D = null
  # For area attacks, the area size
  @export var area_size: Vector2 = Vector2(100, 100)
  # Animation to play when attacking
  @export var attack_animation: String = "attack"
  # Whether to face the target when attacking
  @export var face_target: bool = true
  # For ranged attacks, the spawn offset
  @export var projectile_spawn_offset: Vector2 = Vector2(0, 0)
  # Path to the animated sprite (if not direct child)
  @export var animated_sprite_path: String = "AnimatedSprite2D"
  # Whether this attack is currently available
  @export var can_attack: bool = true
  
  # Reference to the character this behavior belongs to
  var character = null
  # Current attack target
  var target = null
  # Current cooldown timer
  var cooldown_timer: float = 0.0
  # Reference to the damage system (optional)
  var damage_system = null
  
  # Signals
  signal attack_started(target)
  signal attack_finished(target, hit)
  signal attack_cooldown_started(time)
  signal attack_cooldown_finished()
  
  func _ready():
  	# Get the owner character (parent node)
  	character = get_parent()
  	
  	# Try to get damage system reference
  	damage_system = get_node_or_null("/root/DamageSystem")
  
  func _process(delta):
  	# Handle cooldown
  	if not can_attack:
  		cooldown_timer -= delta
  		if cooldown_timer <= 0:
  			can_attack = true
  			emit_signal("attack_cooldown_finished")
  
  ## Check if a target is in attack range
  func is_target_in_range(check_target) -> bool:
  	if not check_target:
  		return false
  	
  	var distance = character.global_position.distance_to(check_target.global_position)
  	return distance <= attack_range
  
  ## Set a new attack target
  func set_target(new_target):
  	target = new_target
  
  ## Perform an attack against the current target
  func attack() -> bool:
  	if not can_attack or not target:
  		return false
  	
  	if not is_target_in_range(target):
  		return false
  	
  	# Face the target if enabled
  	if face_target:
  		_face_target(target)
  	
  	# Play attack animation
  	if character.has_method("play_animation"):
  		character.play_animation(attack_animation)
  	elif character.has_node(animated_sprite_path):
  		var sprite = character.get_node(animated_sprite_path)
  		if sprite.has_method("play"):
  			sprite.play(attack_animation)
  	
  	emit_signal("attack_started", target)
  	
  	# Handle different attack types
  	var hit = false
  	
  	match attack_type:
  		AttackType.MELEE:
  			hit = _perform_melee_attack()
  		AttackType.RANGED:
  			hit = _perform_ranged_attack()
  		AttackType.AREA:
  			# This is a coroutine, so we need to use await
  			hit = await _perform_area_attack()
  	
  	# Start cooldown
  	can_attack = false
  	cooldown_timer = cooldown
  	emit_signal("attack_cooldown_started", cooldown)
  	
  	# Wait for animation to finish
  	if character.has_node(animated_sprite_path):
  		var sprite = character.get_node(animated_sprite_path)
  		await sprite.animation_finished
  	else:
  		await get_tree().create_timer(0.5).timeout
  	
  	emit_signal("attack_finished", target, hit)
  	return hit
  
  ## Perform a melee attack
  func _perform_melee_attack() -> bool:
  	# If we have a damage system, use it
  	if damage_system:
  		return damage_system.process_attack(character, target, base_damage)
  	
  	# Otherwise use direct damage application
  	if target.has_method("take_damage"):
  		target.take_damage(base_damage)
  		return true
  	elif "current_health" in target:
  		target.current_health -= base_damage
  		return true
  	
  	return false
  
  ## Perform a ranged attack by spawning a projectile
  func _perform_ranged_attack() -> bool:
  	if not projectile_scene:
  		push_error("Projectile scene is not set for ranged attack!")
  		return false
  	
  	# Get spawn position
  	var spawn_pos = character.global_position + projectile_spawn_offset
  	
  	# Get direction to target
  	var direction = (target.global_position - spawn_pos).normalized()
  	
  	# Check if we have an object pool
  	var projectile_pool = character.get_node_or_null("ProjectilePool")
  	
  	if projectile_pool and projectile_pool is ObjectPool:
  		# Get a projectile from the pool
  		var projectile = projectile_pool.get_object()
  		if projectile:
  			if projectile.has_method("setup"):
  				projectile.setup(direction, spawn_pos, character.global_rotation, character)
  			return true
  	else:
  		# Create a new projectile
  		var projectile = projectile_scene.instantiate()
  		get_tree().get_root().add_child(projectile)
  		
  		if projectile.has_method("setup"):
  			projectile.setup(direction, spawn_pos, character.global_rotation, character)
  		elif "direction" in projectile:
  			projectile.direction = direction
  			projectile.global_position = spawn_pos
  			projectile.source_node = character
  		
  		return true
  	
  	return false
  
  ## Perform an area attack affecting all targets in an area
  func _perform_area_attack() -> bool:
  	var hit_something = false
  	
  	# Create area for attack
  	var area = Area2D.new()
  	var collision_shape = CollisionShape2D.new()
  	
  	# Configure shape
  	if area_shape:
  		collision_shape.shape = area_shape
  	else:
  		# Default to rectangle
  		var rect_shape = RectangleShape2D.new()
  		rect_shape.size = area_size
  		collision_shape.shape = rect_shape
  	
  	area.add_child(collision_shape)
  	character.add_child(area)
  	
  	# Check for bodies in the area
  	await get_tree().process_frame
  	var bodies = area.get_overlapping_bodies()
  	
  	for body in bodies:
  		if body != character and body.is_in_group("damageable"):
  			# If we have a damage system, use it
  			if damage_system:
  				damage_system.process_attack(character, body, base_damage)
  			# Otherwise use direct damage application
  			elif body.has_method("take_damage"):
  				body.take_damage(base_damage)
  			elif "current_health" in body:
  				body.current_health -= base_damage
  			
  			hit_something = true
  	
  	# Clean up
  	area.queue_free()
  	return hit_something
  
  ## Face the character towards the target
  func _face_target(face_target):
  	if not face_target:
  		return
  	
  	var direction = (face_target.global_position - character.global_position).normalized()
  	
  	# Handle sprite flipping
  	var sprite = character.get_node_or_null(animated_sprite_path)
  	if sprite and "flip_h" in sprite:
  		sprite.flip_h = direction.x < 0

========================================
Contents of scripts\core\enemies\behaviors\chase_behavior.gd:
========================================
  class_name ChaseBehavior
  extends Node
  
  ## A modular component for enemy chase behavior
  
  # Reference to the character this behavior belongs to
  var character = null
  # The target being chased
  var target = null
  # Speed while chasing
  @export var chase_speed: float = 100.0
  # Maximum chase distance before giving up
  @export var max_chase_distance: float = 300.0
  # Minimum distance to maintain from target
  @export var min_distance: float = 10.0
  # Whether to use prediction for moving targets
  @export var use_prediction: bool = false
  # How far ahead to predict target movement (0-1)
  @export var prediction_factor: float = 0.5
  # Whether to check for line of sight
  @export var check_line_of_sight: bool = true
  # Collision layer to check for line of sight (walls, obstacles)
  @export_flags_2d_physics var line_of_sight_mask: int = 1
  # Animation to play while chasing
  @export var chase_animation: String = "walk"
  # Path to the animated sprite (if not direct child)
  @export var animated_sprite_path: String = "AnimatedSprite2D"
  # Whether the chase is currently active
  @export var is_active: bool = false
  
  # Last known position of the target
  var last_known_position: Vector2 = Vector2.ZERO
  # Direction to the target
  var chase_direction: Vector2 = Vector2.ZERO
  # Time spent chasing without line of sight
  var lost_sight_time: float = 0.0
  # Maximum time to chase without line of sight
  @export var max_lost_sight_time: float = 2.0
  
  # Signals
  signal chase_started(target)
  signal chase_ended()
  signal chase_target_reached(target)
  signal target_lost()
  signal line_of_sight_lost()
  signal line_of_sight_regained()
  
  func _ready():
  	# Get the owner character (parent node)
  	character = get_parent()
  
  func _physics_process(delta):
  	if not is_active or not target:
  		return
  	
  	if not is_instance_valid(target):
  		end_chase()
  		return
  	
  	# Get positions
  	var character_pos = character.global_position
  	var target_pos = target.global_position
  	
  	# Check max chase distance
  	var distance_to_target = character_pos.distance_to(target_pos)
  	if distance_to_target > max_chase_distance:
  		emit_signal("target_lost")
  		end_chase()
  		return
  	
  	# Check line of sight if needed
  	var has_line_of_sight = true
  	if check_line_of_sight:
  		has_line_of_sight = _check_line_of_sight(target)
  		
  		if not has_line_of_sight:
  			lost_sight_time += delta
  			if lost_sight_time > max_lost_sight_time:
  				emit_signal("target_lost")
  				end_chase()
  				return
  		else:
  			if lost_sight_time > 0:
  				emit_signal("line_of_sight_regained")
  			lost_sight_time = 0
  			last_known_position = target_pos
  	
  	# Calculate target position (with prediction if enabled)
  	var chase_target_pos = target_pos
  	if use_prediction and "velocity" in target and target.velocity.length() > 0:
  		chase_target_pos += target.velocity * prediction_factor
  	
  	# Calculate direction and distance
  	chase_direction = (chase_target_pos - character_pos).normalized()
  	
  	# Check if we've reached minimum distance
  	if distance_to_target <= min_distance:
  		emit_signal("chase_target_reached", target)
  		if "velocity" in character:
  			character.velocity.x = 0
  		return
  	
  	# Apply movement
  	if "velocity" in character:
  		character.velocity.x = chase_direction.x * chase_speed
  	
  	# Update animation and facing
  	_update_animation(chase_direction)
  
  ## Start chasing a target
  func start_chase(new_target) -> bool:
  	if not new_target:
  		return false
  	
  	target = new_target
  	is_active = true
  	lost_sight_time = 0
  	last_known_position = target.global_position
  	
  	emit_signal("chase_started", target)
  	return true
  
  ## End the current chase
  func end_chase():
  	if is_active:
  		emit_signal("chase_ended")
  	
  	is_active = false
  	target = null
  	lost_sight_time = 0
  	
  	# Stop movement
  	if "velocity" in character:
  		character.velocity.x = 0
  
  ## Check if the character has line of sight to the target
  func _check_line_of_sight(check_target) -> bool:
  	if not check_target:
  		return false
  	
  	var space_state = character.get_world_2d().direct_space_state
  	var params = PhysicsRayQueryParameters2D.new()
  	params.from = character.global_position
  	params.to = check_target.global_position
  	params.collision_mask = line_of_sight_mask
  	params.exclude = [character]
  	
  	var result = space_state.intersect_ray(params)
  	
  	if result and result.collider != check_target:
  		if lost_sight_time == 0:
  			emit_signal("line_of_sight_lost")
  		return false
  	return true
  
  ## Get the current distance to the target
  func get_distance_to_target() -> float:
  	if not target:
  		return INF
  	return character.global_position.distance_to(target.global_position)
  
  ## Update character animation and direction based on movement
  func _update_animation(direction: Vector2):
  	# Play chase animation
  	if character.has_method("play_animation"):
  		character.play_animation(chase_animation)
  	
  	# Handle sprite flipping
  	var sprite = character.get_node_or_null(animated_sprite_path)
  	if sprite and "flip_h" in sprite:
  		sprite.flip_h = direction.x < 0

========================================
Contents of scripts\core\enemies\behaviors\patrol_behavior.gd:
========================================
  class_name PatrolBehavior
  extends Node
  
  ## A modular component for enemy patrol behavior
  
  # Patrol modes
  enum PatrolMode {
  	BACK_AND_FORTH,  # Move between start and end points
  	LOOP,            # Move in a loop through all points
  	RANDOM           # Choose random points to patrol to
  }
  
  # Patrol points - Vector2 positions for the patrol path
  @export var patrol_points: Array[Vector2] = []
  # Current patrol mode
  @export var mode: PatrolMode = PatrolMode.BACK_AND_FORTH
  # Speed while patrolling
  @export var patrol_speed: float = 60.0
  # Wait time at each patrol point (seconds)
  @export var wait_time: float = 1.0
  # Whether to use global coordinates or local coordinates
  @export var use_global_coordinates: bool = true
  # Whether the enemy should flip when changing direction
  @export var flip_on_direction_change: bool = true
  # Flip method (sprite or node)
  @export var flip_method: String = "sprite" # "sprite" or "node"
  # Whether patrol is currently active
  @export var is_active: bool = true
  
  # Reference to the owner character
  var character = null
  # Current target patrol point index
  var current_point_index: int = 0
  # Direction of travel for back-and-forth mode (1 = forwards, -1 = backwards)
  var travel_direction: int = 1
  # Whether we're currently waiting at a patrol point
  var is_waiting: bool = false
  # Wait timer
  var wait_timer: float = 0.0
  # Path to the animated sprite (if not direct child)
  @export var animated_sprite_path: String = "AnimatedSprite2D"
  # Animation to play while patrolling
  @export var patrol_animation: String = "walk"
  
  # Signals
  signal point_reached(point_index)
  signal patrol_completed()
  signal direction_changed(new_direction)
  
  func _ready():
  	# Get the owner character (parent node)
  	character = get_parent()
  	
  	# Initialize with first patrol point if available
  	if patrol_points.size() > 0:
  		current_point_index = 0
  	else:
  		# Add the character's current position as the first patrol point
  		if use_global_coordinates:
  			patrol_points.append(character.global_position)
  		else:
  			patrol_points.append(character.position)
  
  func _physics_process(delta):
  	if not is_active or patrol_points.size() < 2:
  		return
  	
  	if is_waiting:
  		# Handle waiting at patrol points
  		wait_timer -= delta
  		if wait_timer <= 0:
  			is_waiting = false
  			_move_to_next_point()
  		return
  	
  	# Get current target point
  	var target_position = patrol_points[current_point_index]
  	if use_global_coordinates:
  		target_position = target_position
  	
  	# Get current position
  	var current_position = character.global_position if use_global_coordinates else character.position
  	
  	# Check if we've reached the target point
  	var distance_to_target = current_position.distance_to(target_position)
  	if distance_to_target < 10.0:  # Within 10 pixels considered as "reached"
  		_on_point_reached()
  		return
  	
  	# Move towards the target point
  	var direction = (target_position - current_position).normalized()
  	
  	# Apply movement
  	if "velocity" in character:
  		character.velocity.x = direction.x * patrol_speed
  	
  	# Handle animation and flipping
  	_update_animation(direction)
  
  ## Start patrolling
  func start():
  	is_active = true
  	is_waiting = false
  
  ## Stop patrolling
  func stop():
  	is_active = false
  	if "velocity" in character:
  		character.velocity.x = 0
  
  ## Add a new patrol point
  func add_patrol_point(point: Vector2):
  	patrol_points.append(point)
  
  ## Clear all patrol points
  func clear_patrol_points():
  	patrol_points.clear()
  	current_point_index = 0
  
  ## Set new patrol points
  func set_patrol_points(points: Array[Vector2]):
  	patrol_points = points
  	current_point_index = 0
  
  ## Set the patrol mode
  func set_patrol_mode(new_mode: PatrolMode):
  	mode = new_mode
  	
  ## Get the current patrol target position
  func get_current_target() -> Vector2:
  	if patrol_points.size() > current_point_index:
  		return patrol_points[current_point_index]
  	return Vector2.ZERO
  
  ## Called when a patrol point is reached
  func _on_point_reached():
  	emit_signal("point_reached", current_point_index)
  	
  	# Start waiting
  	is_waiting = true
  	wait_timer = wait_time
  	
  	# Stop horizontal movement
  	if "velocity" in character:
  		character.velocity.x = 0
  
  ## Move to the next patrol point based on the patrol mode
  func _move_to_next_point():
  	match mode:
  		PatrolMode.BACK_AND_FORTH:
  			# Change direction at endpoints
  			if current_point_index == patrol_points.size() - 1:
  				travel_direction = -1
  				emit_signal("direction_changed", travel_direction)
  			elif current_point_index == 0:
  				travel_direction = 1
  				emit_signal("direction_changed", travel_direction)
  			
  			current_point_index += travel_direction
  			
  		PatrolMode.LOOP:
  			# Move to next point, wrap around to beginning
  			current_point_index = (current_point_index + 1) % patrol_points.size()
  			
  			if current_point_index == 0:
  				emit_signal("patrol_completed")
  				
  		PatrolMode.RANDOM:
  			# Choose a random point different from the current one
  			var new_index = current_point_index
  			while new_index == current_point_index and patrol_points.size() > 1:
  				new_index = randi() % patrol_points.size()
  			current_point_index = new_index
  
  ## Update character animation and direction based on movement
  func _update_animation(direction: Vector2):
  	# Play patrol animation
  	if character.has_method("play_animation"):
  		character.play_animation(patrol_animation)
  	
  	# Handle flipping
  	if flip_on_direction_change:
  		var sprite = null
  		
  		if flip_method == "sprite":
  			sprite = character.get_node_or_null(animated_sprite_path)
  			if sprite and "flip_h" in sprite:
  				sprite.flip_h = direction.x < 0
  		elif flip_method == "node":
  			# Flip the entire character node
  			character.scale.x = abs(character.scale.x) * sign(direction.x)

========================================
Contents of scripts\core\enemies\enemy_state_machine.gd:
========================================
  class_name EnemyStateMachine
  extends StateMachine
  
  ## Eine verbesserte State Machine speziell für Gegner
  ## Verbesserte Version mit besserer Target-Erkennung und Zustandsübergängen
  
  # Signals for key events
  signal player_detected(player)
  signal player_lost()
  signal action_completed(action_name)
  
  # Enemy sensing properties - used by all states
  var detection_range: float = 200.0
  var attack_range: float = 50.0
  var patrol_range: float = 100.0
  var can_see_through_walls: bool = false
  
  # Current target
  var target = null
  
  # Original position for patrols
  var initial_position: Vector2
  
  # Target tracking properties
  var target_visible_time: float = 0.0
  var target_lost_time: float = 0.0
  var minimum_detection_time: float = 0.1  # Time to confirm detection
  var maximum_lost_time: float = 0.5  # Time before target is considered lost
  
  # Enemy type-specific attributes
  var attack_state_name: String = "Attack"  # Default, will be overridden by specialized enemies
  var use_specialized_states: bool = false
  var specialized_enemy_type: String = "Generic"
  
  # Verbessertes Targeting
  var last_known_position: Vector2
  var prediction_enabled: bool = true  # Bewegungsvorhersage für Fernkampf
  var memory_duration: float = 3.0  # Wie lange der Gegner sich die letzte Position merkt
  
  func _ready():
  	super._ready()
  	
  	# Set initial position for patrol patterns
  	initial_position = owner_node.global_position
  	last_known_position = initial_position
  	
  	# Update range values from the owner
  	_update_ranges_from_owner()
  	
  	# Connect to owner signals
  	if owner_node is BaseEnemy:
  		owner_node.damaged.connect(_on_owner_damaged)
  		owner_node.died.connect(_on_owner_died)
  	
  	# Check for specialized enemy types and set appropriate attack state
  	_detect_specialized_enemy_type()
  	
  	# Enable debug mode in development builds only
  	debug_mode = false #OS.has_feature("debug")
  	print("EnemyStateMachine initialized for: " + owner_node.name + " with type: " + specialized_enemy_type)
  
  func _physics_process(delta):
  	super._physics_process(delta)
  	
  	# Check for target consistently
  	_update_target_detection(delta)
  
  # Transfer configuration from owner to state machine
  func _update_ranges_from_owner():
  	var enemy = owner_node as BaseEnemy
  	if enemy:
  		detection_range = enemy.detection_radius
  		attack_range = enemy.attack_radius
  		patrol_range = enemy.patrol_distance
  
  # Detect what kind of enemy we're attached to and configure accordingly
  func _detect_specialized_enemy_type():
  	if owner_node is GoblinArcher:
  		specialized_enemy_type = "Archer"
  		attack_state_name = "Shoot"
  		use_specialized_states = true
  		# Bogenschützen haben bessere Vorhersage
  		prediction_enabled = true
  		memory_duration = 4.0
  	elif owner_node is GoblinMage:
  		specialized_enemy_type = "Mage"
  		attack_state_name = "Cast"
  		use_specialized_states = true
  		# Magier haben längere Erinnerung
  		memory_duration = 5.0
  	elif owner_node is GoblinMelee:
  		specialized_enemy_type = "Melee"
  		attack_state_name = "Attack"  # Standard attack for melee
  		use_specialized_states = true
  		# Nahkämpfer haben kürzere Erinnerung
  		memory_duration = 2.0
  		
  	print("Detected enemy type: " + specialized_enemy_type + " with attack state: " + attack_state_name)
  
  # Initialize the state machine with the starting state
  func initialize(initial_state_name: String = ""):
  	# Default to first state if none specified
  	if initial_state_name.is_empty() and states.size() > 0:
  		initial_state_name = states.keys()[0]
  	# Change to initial state
  	if states.has(initial_state_name):
  		change_state(initial_state_name)
  	else:
  		push_error("State machine could not initialize with state: " + initial_state_name)
  
  # A more reliable target detection system
  func _update_target_detection(delta):
  	var player = _find_player()
  	var can_see_player = false
  	
  	if player:
  		# Check distance
  		var distance = owner_node.global_position.distance_to(player.global_position)
  		
  		if distance <= detection_range:
  			# Line of sight check
  			if can_see_through_walls or _has_line_of_sight(player):
  				can_see_player = true
  				
  				# Tracking for consistent detection
  				target_visible_time += delta
  				target_lost_time = 0
  				
  				# Confirm detection after minimum time
  				if target_visible_time >= minimum_detection_time:
  					if target != player:
  						print(owner_node.name + " detected player at distance " + str(distance))
  						set_target(player)
  					
  					# Aktualisiere zuletzt bekannte Position
  					last_known_position = player.global_position
  			else:
  				can_see_player = false
  		else:
  			can_see_player = false
  	
  	# Handle losing sight of target
  	if !can_see_player and target:
  		target_visible_time = 0
  		target_lost_time += delta
  		
  		# Clear target after max lost time
  		if target_lost_time >= maximum_lost_time:
  			# Verbessertes Verhalten: Je nach Gegnertyp unterschiedliche Reaktionen
  			if specialized_enemy_type == "Archer":
  				# Archer behält Target länger für Schüsse auf letzte bekannte Position
  				if target_lost_time >= maximum_lost_time * 2.0:
  					clear_target()
  			elif specialized_enemy_type == "Mage":
  				# Mage hat ähnliches Verhalten wie Archer aber mit anderen Timing
  				if target_lost_time >= maximum_lost_time * 1.5:
  					clear_target()
  			else:
  				# Standard-Verhalten: Clear target after max lost time
  				clear_target()
  
  # Find player in the scene
  func _find_player() -> Node:
  	# First check the Global singleton for player reference
  	if get_node_or_null("/root/Global") and get_node("/root/Global").has_method("get_player"):
  		return get_node("/root/Global").get_player()
  	
  	# Alternative: check for player in groups
  	var player = get_tree().get_first_node_in_group("player")
  	if not player:
  		# Last resort - search by name
  		player = get_tree().get_root().find_child("Player", true, false)
  	
  	return player
  
  # Check if there's a clear line of sight to the target
  func _has_line_of_sight(to_node: Node) -> bool:
  	if not is_instance_valid(to_node):
  		return false
  		
  	# Setup raycast
  	var space_state = owner_node.get_world_2d().direct_space_state
  	var query = PhysicsRayQueryParameters2D.create(
  		owner_node.global_position, 
  		to_node.global_position,
  		1, # Collision layer for obstacles 
  		[owner_node] # Exclude self from collision check
  	)
  	
  	var result = space_state.intersect_ray(query)
  	
  	# If nothing hit or hit the target, we have line of sight
  	return !result or result.collider == to_node
  
  # Set current target and notify states
  func set_target(new_target):
  	if new_target == target:
  		return
  		
  	var had_no_target = (target == null)
  	target = new_target
  	
  	if new_target and had_no_target:
  		emit_signal("player_detected", new_target)
  		
  		# Force state change based on distance if in Patrol state
  		if current_state and current_state.name == "Patrol":
  			if is_target_in_attack_range():
  				change_state(attack_state_name)  # Use appropriate attack state based on enemy type
  			elif specialized_enemy_type == "Archer":
  				change_state("Positioning")  # Archer goes to positioning
  			elif specialized_enemy_type == "Mage":
  				change_state("MagePositioning")  # Mage goes to positioning
  			else:
  				# Nahkämpfer verhalten sich wie bisher
  				change_state("Chase")
  
  # Clear current target
  func clear_target():
  	if target:
  		print(owner_node.name + " lost sight of player")
  		emit_signal("player_lost")
  		
  		# Return to patrol if we're in a state that needs a target
  		if current_state:
  			if specialized_enemy_type == "Archer":
  				if current_state.name in ["Shoot", "Positioning", "Retreat"]:
  					change_state("Patrol")
  			elif specialized_enemy_type == "Mage":
  				if current_state.name in ["Cast", "MagePositioning"]:
  					change_state("Patrol")
  			else:
  				if current_state.name in ["Chase", "Attack"]:
  					change_state("Patrol")
  	
  	target = null
  
  # Is target within attack range?
  func is_target_in_attack_range() -> bool:
  	if not target:
  		return false
  	
  	var distance = owner_node.global_position.distance_to(target.global_position)
  	return distance <= attack_range
  
  # Direction to current target
  func get_direction_to_target() -> Vector2:
  	if not target:
  		return Vector2.ZERO
  	
  	return (target.global_position - owner_node.global_position).normalized()
  
  # Direction to last known position
  func get_direction_to_last_known_position() -> Vector2:
  	return (last_known_position - owner_node.global_position).normalized()
  
  # Handle owner taking damage
  func _on_owner_damaged(amount, attacker):
  	# Transition to hurt state if not dead
  	if current_state and current_state.name != "Death" and current_state.name != "Hurt":
  		change_state("Hurt")
  
  # Handle owner death
  func _on_owner_died():
  	# Transition to death state
  	change_state("Death")

========================================
Contents of scripts\core\enemies\goblin_archer.gd:
========================================
  class_name GoblinArcher
  extends BaseEnemy
  
  ## Goblin Archer - Ranged enemy that shoots arrows/stones at the player
  ## Maintains distance and reloads after a certain number of shots
  
  # Archer-specific attributes
  @export_group("Archer Properties")
  @export var projectile_scene: PackedScene = preload("res://scenes/core/projectiles/rock.tscn")
  @export var quiver_size: int = 5  # Number of arrows before reload
  @export var reload_time: float = 2.0  # Time to reload in seconds
  @export var shooting_accuracy: float = 0.9  # 1.0 = perfect, lower = less accurate
  @export var optimal_distance: float = 150.0  # Optimal distance to player
  
  # Archer state tracking
  var arrows_remaining: int
  var is_reloading: bool = false
  
  # Projectile pool for arrows
  var projectile_pool: ObjectPool
  
  # Signals specific to archer
  signal arrow_shot
  signal quiver_empty
  signal reload_complete
  
  func _ready():
  	# Call parent ready
  	super._ready()
  	
  	# Set default values
  	max_health = 70.0
  	current_health = max_health
  	speed = 60.0  # Etwas schneller für bessere Positionierung
  	chase_speed = 60.0
  	attack_damage = 50.0  # Ensuring this gives 0.5 damage after scaling
  	attack_cooldown = 1.0
  	detection_radius = 350.0
  	attack_radius = 300.0
  	
  	# Initialize arrows
  	arrows_remaining = quiver_size
  	
  	# Connect signals
  	damaged.connect(_on_damaged)
  	died.connect(_on_died)
  	
  	# Make sure this node is in the enemy group
  	if not is_in_group("enemy"):
  		add_to_group("enemy")
  	
  	# Initialize projectile pool
  	_setup_projectile_pool()
  	
  	# Setup the state machine with archer states
  	setup_state_machine()
  	_setup_archer_states()
  
  # Initialize projectile pool
  func _setup_projectile_pool():
  	# Check if projectile_scene is valid
  	if projectile_scene == null:
  		push_error("GoblinArcher: projectile_scene is null. Trying direct load...")
  		projectile_scene = load("res://scenes/core/projectiles/rock.tscn")
  		
  	if projectile_scene == null:
  		push_error("GoblinArcher: Could not load projectile_scene. Pool not created.")
  		return
  		
  	# Create projectile pool for better performance
  	projectile_pool = ObjectPool.new(projectile_scene, 10, true)
  	projectile_pool.name = "ProjectilePool"
  	add_child(projectile_pool)
  
  # Improved setup for archer-specific states
  func _setup_archer_states():
  	# Add all states to the state machine - KEINE CHASE STATE!
  	state_machine.add_state(PatrolState.new())
  	state_machine.add_state(PositioningState.new())  # Neuer Positionierungsstate statt Chase
  	state_machine.add_state(ShootState.new())
  	state_machine.add_state(RetreatState.new())
  	state_machine.add_state(ReloadState.new())
  	state_machine.add_state(HurtState.new())
  	state_machine.add_state(DeathState.new())
  	
  	# Configure the specialized state machine behavior for archer
  	_configure_state_machine()
  	
  	# Initialize with patrol state
  	state_machine.initialize("Patrol")
  	print(name + " initialized with archer state machine")
  
  # Configure specialized transitions for archer state machine
  func _configure_state_machine():
  	# Connect to key state machine signals
  	state_machine.player_detected.connect(_on_player_detected)
  	state_machine.player_lost.connect(_on_player_lost)
  	
  	# Override the default attack range to ensure it works for shooting
  	state_machine.attack_range = attack_radius
  	
  	# Update the state machine to use the specialized attack state
  	var machine = state_machine as EnemyStateMachine
  	if machine:
  		machine.attack_state_name = "Shoot"
  
  # Handle player detection specifically for archer
  func _on_player_detected(player):
  	if not state_machine:
  		return
  		
  	var distance = global_position.distance_to(player.global_position)
  	
  	# Logische Entscheidung basierend auf der Situation
  	if distance <= attack_radius and arrows_remaining > 0:
  		state_machine.change_state("Shoot")
  	elif distance < optimal_distance * 0.7:  # Too close
  		state_machine.change_state("Retreat")
  	else:
  		# Anstatt Chase verwenden wir nun Positioning
  		state_machine.change_state("Positioning")
  
  # Handle player lost
  func _on_player_lost():
  	if state_machine:
  		state_machine.change_state("Patrol")
  
  # Shoot a projectile - called by Shoot state
  func shoot() -> bool:
  	if is_dead or is_reloading or arrows_remaining <= 0:
  		print(name + " can't shoot: " + 
  			("is dead" if is_dead else 
  			"is reloading" if is_reloading else 
  			"no arrows left"))
  		emit_signal("quiver_empty")
  		return false
  	
  	# Get target through state machine
  	var target = state_machine.target
  	if not target:
  		print(name + " can't shoot: no target")
  		return false
  	
  	# Determine direction with accuracy variation
  	var direction = (target.global_position - global_position).normalized()
  	if shooting_accuracy < 1.0:
  		# Add random deviation
  		var deviation = (1.0 - shooting_accuracy) * 0.2  # Max 20% deviation
  		direction = direction.rotated(randf_range(-deviation, deviation))
  	
  	# Determine spawn position - slightly offset in front of the enemy
  	var spawn_pos = global_position
  	spawn_pos.y -= 5  # Slightly above the enemy
  	var facing_direction = 1 if animated_sprite.flip_h else -1
  	spawn_pos.x += facing_direction * 15  # Offset in facing direction
  	
  	# Get projectile from pool or create a new one
  	var projectile = null
  	if projectile_pool:
  		projectile = projectile_pool.get_object()
  	
  	# If no projectile from pool, instantiate directly
  	if projectile == null:
  		if projectile_scene:
  			projectile = projectile_scene.instantiate()
  			get_tree().current_scene.add_child(projectile)
  		else:
  			print(name + " ERROR: Could not create projectile!")
  			return false
  	
  	# Stelle sicher, dass das Projektil ordnungsgemäß aus dem Pool zurückgesetzt wurde
  	projectile.set_physics_process(true)
  	
  	# Configure projectile - Make sure it's visible and active first
  	projectile.visible = true
  	if "process_mode" in projectile:
  		projectile.process_mode = Node.PROCESS_MODE_INHERIT
  	
  	# Move to correct position before setting up
  	projectile.global_position = spawn_pos
  	
  	# Configure using setup method if available
  	if projectile.has_method("setup"):
  		projectile.setup(direction, spawn_pos, 0, self)
  		
  		# Stelle sicher, dass die Geschwindigkeit korrekt ist
  		if "speed" in projectile:
  			projectile.velocity = direction * projectile.speed
  	else:
  		# Direct property setting as fallback
  		if "direction" in projectile:
  			projectile.direction = direction
  		if "velocity" in projectile:
  			projectile.velocity = direction * (projectile.speed if "speed" in projectile else 200.0)
  		if "source_node" in projectile:
  			projectile.source_node = self
  	
  	# Make sure the projectile is in the scene tree
  	if not projectile.is_inside_tree():
  		get_tree().current_scene.add_child.call_deferred(projectile)
  	
  	# Visual and audio feedback
  	_play_shoot_effects(spawn_pos)
  	
  	# Reduce arrows and emit signal
  	arrows_remaining -= 1
  	emit_signal("arrow_shot")
  	
  	# Start reloading if no arrows left
  	if arrows_remaining <= 0:
  		start_reloading()
  	
  	print(name + " successfully shot a projectile with speed: " + str(projectile.velocity.length()))
  	return true
  
  # Add visual/audio effects for shooting
  func _play_shoot_effects(position):
  	# Small particle burst
  	var particles = CPUParticles2D.new()
  	particles.emitting = true
  	particles.one_shot = true
  	particles.explosiveness = 1.0
  	particles.amount = 5
  	particles.lifetime = 0.3
  	particles.direction = Vector2(0, -1)
  	particles.spread = 45.0
  	particles.initial_velocity_min = 20.0
  	particles.initial_velocity_max = 40.0
  	particles.color = Color(0.7, 0.7, 0.5, 0.7)  # Dust color
  	
  	get_tree().current_scene.add_child(particles)
  	particles.global_position = position
  	
  	# Remove after lifetime
  	await get_tree().create_timer(particles.lifetime * 1.5).timeout
  	if is_instance_valid(particles):
  		particles.queue_free()
  		
  # Start reloading process
  func start_reloading():
  	if is_reloading:
  		return
  		
  	is_reloading = true
  	
  	# Play reload animation if available
  	if animated_sprite and animated_sprite.sprite_frames.has_animation("reload"):
  		animated_sprite.play("reload")
  	else:
  		play_animation("idle")
  	
  	# Emit signal
  	emit_signal("quiver_empty")
  	print(name + " started reloading...")
  	
  	# Create timer to finish reloading
  	get_tree().create_timer(reload_time).timeout.connect(_reload_complete)
  
  # Reloading completed
  func _reload_complete():
  	is_reloading = false
  	arrows_remaining = quiver_size
  	
  	# Emit signal
  	emit_signal("reload_complete")
  	print(name + " reloading complete, arrows: " + str(arrows_remaining))
  	
  	# Nach dem Nachladen Entscheidung für nächsten State
  	if state_machine.target:
  		var distance = global_position.distance_to(state_machine.target.global_position)
  		
  		if distance <= attack_radius:
  			state_machine.change_state("Shoot")
  		elif distance < optimal_distance * 0.7:
  			state_machine.change_state("Retreat") 
  		else:
  			state_machine.change_state("Positioning")
  
  # Handle damage
  func _on_damaged(amount, attacker):
  	# Archers might want to retreat when damaged
  	if state_machine and state_machine.target and randf() > 0.3:  # 70% chance to retreat when hit
  		state_machine.change_state("Retreat")
  
  # Handle death
  func _on_died():
  	_drop_loot()
  
  # Drop random loot
  func _drop_loot():
  	# Loot table
  	var loot_table = [
  		{"item": "res://scenes/core/items/coins.tscn", "chance": 0.8},
  		{"item": "res://scenes/core/items/power_jump.tscn", "chance": 0.2}
  	]
  	
  	randomize()
  	
  	for loot in loot_table:
  		if randf() <= loot.chance:
  			var item_scene = load(loot.item)
  			if item_scene:
  				var item = item_scene.instantiate()
  				item.global_position = global_position
  				get_tree().current_scene.add_child(item)
  				break

========================================
Contents of scripts\core\enemies\goblin_mage.gd:
========================================
  class_name GoblinMage
  extends BaseEnemy
  
  ## Goblin Mage - Caster enemy with teleportation and shield abilities
  ## Focuses on unique attributes and setup, delegates behavior to state machine
  
  # Mage-specific attributes
  @export_group("Magic Properties")
  @export var projectile_scene: PackedScene = preload("res://scenes/core/projectiles/mage_ball.tscn")
  @export var max_mana: float = 100.0
  @export var mana_regen_rate: float = 8.0  # Mana per second
  @export var spell_mana_cost: float = 20.0  # Mana cost per spell
  @export var teleport_mana_cost: float = 30.0  # Mana cost for teleportation
  @export var shield_mana_cost: float = 40.0  # Mana cost for shield
  
  # Mage state tracking
  var current_mana: float
  var is_teleporting: bool = false
  var is_shielding: bool = false
  var teleport_cooldown: float = 3.0
  var last_teleport_time: float = 0.0
  
  # Projectile pool for spell casting
  var projectile_pool: ObjectPool
  
  # Signals specific to mage
  signal spell_cast(spell_name)
  signal mana_depleted
  signal teleported
  signal shield_activated
  signal shield_deactivated
  
  func _ready():
  	# Call parent ready
  	super._ready()
  	
  	# Set default values
  	max_health = 60.0
  	current_health = max_health
  	speed = 50.0
  	chase_speed = 50.0
  	attack_damage = 50.0  # For consistent 0.5 heart damage
  	attack_cooldown = 2.0
  	detection_radius = 350.0
  	attack_radius = 300.0
  	patrol_distance = 80.0
  	
  	# Initialize mana
  	current_mana = max_mana
  	
  	# Make sure this node is in the enemy group
  	if not is_in_group("enemy"):
  		add_to_group("enemy")
  	
  	# Connect signals
  	damaged.connect(_on_damaged)
  	died.connect(_on_died)
  	
  	# Initialize projectile pool
  	_setup_projectile_pool()
  	
  	# Setup the state machine with mage states
  	setup_state_machine()
  	_setup_mage_states()
  
  func _physics_process(delta):
  	# Parent physics first
  	super._physics_process(delta)
  	
  	# Mana regeneration
  	if current_mana < max_mana:
  		current_mana = min(current_mana + mana_regen_rate * delta, max_mana)
  	
  	# Teleport cooldown update
  	if last_teleport_time > 0:
  		last_teleport_time = max(0, last_teleport_time - delta)
  
  # Initialize projectile pool
  func _setup_projectile_pool():
  	# Check if projectile_scene is valid
  	if projectile_scene == null:
  		push_error("GoblinMage: projectile_scene is null. Trying direct load...")
  		projectile_scene = load("res://scenes/core/projectiles/mage_ball.tscn")
  		
  	if projectile_scene == null:
  		push_error("GoblinMage: Could not load projectile_scene. Pool not created.")
  		return
  		
  	# Create projectile pool for better performance
  	projectile_pool = ObjectPool.new(projectile_scene, 8, true)
  	projectile_pool.name = "ProjectilePool"
  	add_child(projectile_pool)
  
  # Verbesserte Einrichtung der Mage-spezifischen States
  func _setup_mage_states():
  	if not state_machine:
  		push_error("No state machine found for " + name)
  		return
  	
  	# KEIN Chase-State mehr! Stattdessen MagePositioningState
  	state_machine.add_state(PatrolState.new())
  	state_machine.add_state(MagePositioningState.new())  # Neuer State statt Chase
  	state_machine.add_state(CastState.new())
  	state_machine.add_state(TeleportState.new())
  	state_machine.add_state(ShieldState.new())
  	state_machine.add_state(HurtState.new())
  	state_machine.add_state(DeathState.new())
  	
  	# Configure the specialized state machine behavior for mage
  	_configure_state_machine()
  	
  	# Initialize with patrol state
  	state_machine.initialize("Patrol")
  	print(name + " initialized with mage state machine")
  
  # Configure specialized transitions for mage state machine
  func _configure_state_machine():
  	# Connect to key state machine signals
  	state_machine.player_detected.connect(_on_player_detected)
  	state_machine.player_lost.connect(_on_player_lost)
  	
  	# Override the default attack range to ensure it works for casting
  	state_machine.attack_range = attack_radius
  	
  	# Update the state machine to use the specialized attack state
  	var machine = state_machine as EnemyStateMachine
  	if machine:
  		machine.attack_state_name = "Cast"
  
  # Handle player detection specifically for mage
  func _on_player_detected(player):
  	if not state_machine:
  		return
  		
  	var distance = global_position.distance_to(player.global_position)
  	
  	# Verbesserte Entscheidungslogik
  	if distance <= attack_radius and current_mana >= spell_mana_cost:
  		# Cast spell if in range and has mana
  		state_machine.change_state("Cast")
  	elif distance < 80:  # Too close
  		# Teleport if too close
  		if current_mana >= teleport_mana_cost and last_teleport_time <= 0:
  			state_machine.change_state("Teleport")
  		elif current_mana >= shield_mana_cost:
  			# Shield if can't teleport
  			state_machine.change_state("Shield")
  		else:
  			# Positionieren anstatt Chase
  			state_machine.change_state("MagePositioning")
  	else:
  		# Positionieren anstatt Chase
  		state_machine.change_state("MagePositioning")
  
  # Handle player lost
  func _on_player_lost():
  	if state_machine:
  		state_machine.change_state("Patrol")
  
  # Cast a spell - called by Cast state
  func cast_spell(spell_name: String = "fireball") -> bool:
  	if is_dead or current_mana < spell_mana_cost:
  		print(name + " can't cast: " + 
  			("is dead" if is_dead else "not enough mana (" + str(current_mana) + "/" + str(spell_mana_cost) + ")"))
  		emit_signal("mana_depleted")
  		return false
  	
  	# Get target through state machine
  	var target = state_machine.target
  	if not target:
  		print(name + " can't cast: no target")
  		return false
  	
  	# Determine direction - targeting slightly ahead of player for prediction
  	var target_pos = target.global_position
  	if "velocity" in target and target.velocity.length() > 0:
  		# Simple prediction - add a fraction of target's velocity
  		target_pos += target.velocity * 0.5
  	
  	var direction = (target_pos - global_position).normalized()
  	
  	# Determine spawn position - offset in front of the mage
  	var spawn_pos = global_position
  	spawn_pos.y -= 8  # Slightly above the enemy
  	var facing_direction = 1 if animated_sprite.flip_h else -1
  	spawn_pos.x += facing_direction * 20  # Offset in facing direction
  	
  	# Get projectile from pool or create a new one
  	var projectile = null
  	if projectile_pool:
  		projectile = projectile_pool.get_object()
  	
  	# If no projectile from pool, instantiate directly
  	if projectile == null:
  		if projectile_scene:
  			projectile = projectile_scene.instantiate()
  			get_tree().current_scene.add_child(projectile)
  		else:
  			print(name + " ERROR: Could not create projectile!")
  			return false
  	
  	# Make sure projectile is visible and active
  	projectile.visible = true
  	if "process_mode" in projectile:
  		projectile.process_mode = Node.PROCESS_MODE_INHERIT
  	
  	# Move to correct position before setup
  	projectile.global_position = spawn_pos
  	
  	# Configure projectile
  	if projectile.has_method("setup"):
  		projectile.setup(direction, spawn_pos, 0, self)
  	else:
  		# Direct property setting as fallback
  		if "direction" in projectile:
  			projectile.direction = direction
  		if "velocity" in projectile:
  			projectile.velocity = direction * (projectile.speed if "speed" in projectile else 200.0)
  		if "source_node" in projectile:
  			projectile.source_node = self
  		
  		# For mage ball specific properties
  		if projectile is MageBall:
  			if "homing_strength" in projectile:
  				projectile.homing_strength = 0.3  # Enable slight homing for magic
  	
  	# Make sure the projectile is in the scene tree
  	if not projectile.is_inside_tree():
  		get_tree().current_scene.add_child.call_deferred(projectile)
  	
  	# Visual and audio feedback
  	_show_cast_effect(spawn_pos)
  	
  	# Reduce mana and emit signal
  	current_mana -= spell_mana_cost
  	emit_signal("spell_cast", spell_name)
  	
  	print(name + " successfully cast " + spell_name + ", remaining mana: " + str(current_mana))
  	return true
  # Teleport to a new position - called by Teleport state
  func teleport() -> bool:
  	if is_dead or current_mana < teleport_mana_cost or last_teleport_time > 0:
  		print(name + " can't teleport: " + 
  			("is dead" if is_dead else 
  			"not enough mana" if current_mana < teleport_mana_cost else
  			"on cooldown"))
  		return false
  	
  	is_teleporting = true
  	
  	# Find target position
  	var teleport_pos = _find_teleport_position()
  	
  	# Fade-out effect
  	var tween = create_tween()
  	tween.tween_property(self, "modulate:a", 0.0, 0.2)
  	
  	# Wait for tween to finish
  	await tween.finished
  	
  	# Teleport
  	global_position = teleport_pos
  	
  	# Fade-in effect
  	tween = create_tween()
  	tween.tween_property(self, "modulate:a", 1.0, 0.2)
  	
  	# Reduce mana
  	current_mana -= teleport_mana_cost
  	
  	# Set cooldown
  	last_teleport_time = teleport_cooldown
  	
  	# Signal
  	emit_signal("teleported")
  	
  	is_teleporting = false
  	print(name + " teleported to " + str(teleport_pos))
  	
  	# Überarbeitete State-Übergänge nach Teleport
  	if state_machine.target:
  		var distance = global_position.distance_to(state_machine.target.global_position)
  		if distance <= attack_radius and current_mana >= spell_mana_cost:
  			state_machine.change_state("Cast")
  		else:
  			state_machine.change_state("MagePositioning")
  			
  	return true
  
  # Find a good teleport position
  func _find_teleport_position() -> Vector2:
  	var target = state_machine.target
  	var possible_positions = []
  	
  	# If no target, teleport randomly around current position
  	if not target:
  		for i in range(4):
  			var angle = randf() * 2 * PI
  			var distance = randf_range(80, 120)
  			possible_positions.append(global_position + Vector2(cos(angle), sin(angle)) * distance)
  	else:
  		# Teleport to positions with optimal distance from player
  		for i in range(4):
  			var angle = randf() * 2 * PI
  			var distance = randf_range(120, 180)  # Vergrößerte Teleport-Distanz
  			possible_positions.append(target.global_position + Vector2(cos(angle), sin(angle)) * distance)
  	
  	# Choose random position
  	return possible_positions[randi() % possible_positions.size()]
  
  # Activate magic shield - called by Shield state
  func activate_shield() -> bool:
  	if is_dead or current_mana < shield_mana_cost or is_shielding:
  		print(name + " can't activate shield: " + 
  			("is dead" if is_dead else 
  			"not enough mana" if current_mana < shield_mana_cost else
  			"shield already active"))
  		return false
  	
  	is_shielding = true
  	
  	# Create shield effect
  	var shield = Node2D.new()
  	shield.name = "MagicShield"
  	add_child(shield)
  	
  	# Create shield sprite
  	var shield_sprite = Sprite2D.new()
  	shield_sprite.texture = load("res://icon.png")  # Replace with actual shield texture
  	shield_sprite.scale = Vector2(1.5, 1.5)
  	shield_sprite.modulate = Color(0.3, 0.7, 1.0, 0.5)
  	shield.add_child(shield_sprite)
  	
  	# Reduce mana
  	current_mana -= shield_mana_cost
  	
  	# Signal
  	emit_signal("shield_activated")
  	
  	# Make enemy temporarily invulnerable
  	is_invulnerable = true
  	
  	print(name + " activated shield")
  	return true
  
  # Deactivate shield
  func deactivate_shield():
  	if not is_shielding:
  		return
  	
  	is_shielding = false
  	
  	# Remove shield node
  	if has_node("MagicShield"):
  		$MagicShield.queue_free()
  	
  	# Disable invulnerability
  	is_invulnerable = false
  	
  	# Signal
  	emit_signal("shield_deactivated")
  	print(name + " deactivated shield")
  
  # Show cast effect
  func _show_cast_effect(position):
  	# Create spell circle effect
  	var effect = CPUParticles2D.new()
  	effect.position = position - global_position  # Relative to mage position
  	effect.emitting = true
  	effect.one_shot = true
  	effect.explosiveness = 0.8
  	effect.amount = 16
  	effect.lifetime = 0.5
  	effect.emission_shape = CPUParticles2D.EMISSION_SHAPE_SPHERE
  	effect.emission_sphere_radius = 5.0
  	effect.color = Color(0.5, 0.1, 0.9, 0.8)
  	add_child(effect)
  	
  	# Remove after lifetime
  	get_tree().create_timer(effect.lifetime * 1.5).timeout.connect(func():
  		effect.queue_free()
  	)
  
  # Override damage to check for shield
  func _on_damaged(amount, attacker):
  	# If shield active, absorb damage and continue
  	if is_shielding:
  		return
  	
  	# Low health behavior
  	if current_health < max_health * 0.3:
  		# Try to teleport away if hurt badly
  		if current_mana >= teleport_mana_cost and last_teleport_time <= 0:
  			state_machine.change_state("Teleport")
  		# Or activate shield
  		elif current_mana >= shield_mana_cost and not is_shielding:
  			state_machine.change_state("Shield")
  
  # Handle death
  func _on_died():
  	_drop_loot()
  	_create_death_explosion()
  
  # Create death explosion effect
  func _create_death_explosion():
  	# Create particle explosion
  	var explosion = CPUParticles2D.new()
  	explosion.position = global_position
  	explosion.emitting = true
  	explosion.one_shot = true
  	explosion.explosiveness = 1.0
  	explosion.amount = 32
  	explosion.lifetime = 0.8
  	explosion.spread = 180.0
  	explosion.initial_velocity_min = 50.0
  	explosion.initial_velocity_max = 100.0
  	explosion.color = Color(0.8, 0.2, 0.9, 0.8)
  	get_tree().current_scene.add_child(explosion)
  	
  	# Remove after animation
  	get_tree().create_timer(explosion.lifetime * 1.5).timeout.connect(func():
  		explosion.queue_free()
  	)
  
  # Drop random loot
  func _drop_loot():
  	# Loot table
  	var loot_table = [
  		{"item": "res://scenes/core/items/coins.tscn", "chance": 0.7},
  		{"item": "res://scenes/core/items/elixir.tscn", "chance": 0.3},
  		{"item": "res://scenes/core/items/power_fly.tscn", "chance": 0.1}
  	]
  	
  	randomize()
  	
  	for loot in loot_table:
  		if randf() <= loot.chance:
  			var item_scene = load(loot.item)
  			if item_scene:
  				var item = item_scene.instantiate()
  				item.global_position = global_position
  				get_tree().current_scene.add_child(item)
  				break

========================================
Contents of scripts\core\enemies\goblin_melee.gd:
========================================
  class_name GoblinMelee
  extends BaseEnemy
  
  ## Goblin Melee - Aggressive melee enemy that becomes enraged when wounded
  ## Gains combat bonuses in rage mode
  
  # Melee-specific attributes
  @export_group("Rage Properties")
  @export var rage_threshold: float = 0.3  # Rage at 30% health
  @export var rage_damage_bonus: float = 1.5  # 50% more damage in rage
  @export var rage_speed_bonus: float = 1.3  # 30% more speed in rage
  
  # Rage state tracking
  var is_enraged: bool = false
  var base_speed: float
  var base_attack_damage: float
  
  # Signal for rage mode
  signal entered_rage_mode
  
  func _ready():
  	# Call parent ready FIRST
  	super._ready()
  	
  	# Set default values
  	max_health = 100.0
  	current_health = max_health
  	speed = 60.0
  	chase_speed = 80.0
  	attack_damage = 50.0  # Für 0.5 Herzen Schaden
  	attack_cooldown = 1.5
  	detection_radius = 150.0
  	attack_radius = 40.0
  	patrol_distance = 120.0
  	
  	# Store base values for rage calculations
  	base_speed = speed
  	base_attack_damage = attack_damage
  	
  	# Connect signals to handle damage
  	damaged.connect(_on_damaged)
  	died.connect(_on_died)
  	
  	# EXPLIZITES SETUP DER STATE MACHINE - neuer Ansatz
  	setup_state_machine()
  	_setup_melee_states()
  
  # Explizite Einrichtung der Melee-spezifischen States
  func _setup_melee_states():
  	if not state_machine:
  		push_error("No state machine found for " + name)
  		return
  	
  	# Füge Melee-spezifische States hinzu
  	var patrol_state = PatrolState.new()
  	var chase_state = ChaseState.new()
  	var attack_state = AttackState.new()
  	var rage_state = RageState.new()
  	var rage_chase_state = RageChaseState.new()
  	var charge_state = ChargeState.new()
  	var hurt_state = HurtState.new()
  	var death_state = DeathState.new()
  	
  	# Füge alle States zur State Machine hinzu
  	state_machine.add_state(patrol_state)
  	state_machine.add_state(chase_state)
  	state_machine.add_state(attack_state)
  	state_machine.add_state(rage_state)
  	state_machine.add_state(rage_chase_state)
  	state_machine.add_state(charge_state)
  	state_machine.add_state(hurt_state)
  	state_machine.add_state(death_state)
  	
  	# Initialisiere mit dem ersten State
  	state_machine.initialize("Patrol")
  
  # Handle damage events - check for rage threshold
  func _on_damaged(amount, attacker):
  	# Check if rage threshold reached
  	if not is_enraged and current_health <= max_health * rage_threshold:
  		enter_rage_mode()
  
  # Rage mode activation - just sets attributes
  func enter_rage_mode():
  	if is_enraged:
  		return
  		
  	is_enraged = true
  	
  	# Apply stat bonuses
  	speed = base_speed * rage_speed_bonus
  	chase_speed = speed * 1.2
  	attack_damage = base_attack_damage * rage_damage_bonus
  	
  	# Visual effect
  	modulate = Color(1.3, 0.7, 0.7)
  	
  	# Create rage particles if needed
  	if not has_node("RageParticles"):
  		var particles = CPUParticles2D.new()
  		particles.name = "RageParticles"
  		particles.amount = 10
  		particles.lifetime = 0.5
  		particles.emission_shape = CPUParticles2D.EMISSION_SHAPE_SPHERE
  		particles.emission_sphere_radius = 10.0
  		particles.gravity = Vector2(0, -20)
  		particles.initial_velocity_min = 10.0
  		particles.initial_velocity_max = 20.0
  		particles.color = Color(1.0, 0.3, 0.1, 0.7)
  		add_child(particles)
  		particles.emitting = true
  	
  	# Emit signal - states listen for this
  	emit_signal("entered_rage_mode")
  	
  	print(name + " entered rage mode!")
  
  # Handle death
  func _on_died():
  	_drop_loot()
  
  # Drop random loot
  func _drop_loot():
  	# Loot table
  	var loot_table = [
  		{"item": "res://scenes/core/items/coins.tscn", "chance": 0.7},
  		{"item": "res://scenes/core/items/elixir.tscn", "chance": 0.1},
  		{"item": "res://scenes/core/items/power_attack.tscn", "chance": 0.05}
  	]
  	
  	randomize()
  	
  	for loot in loot_table:
  		if randf() <= loot.chance:
  			var item_scene = load(loot.item)
  			if item_scene:
  				var item = item_scene.instantiate()
  				item.global_position = global_position
  				get_tree().current_scene.add_child(item)
  				break

========================================
Contents of scripts\core\enemies\states\archer\archer_state.gd:
========================================
  class_name ArcherState
  extends EnemyState
  
  ## Base class for specialized Goblin Archer enemy states
  
  func _init():
  	name = "ArcherState"

========================================
Contents of scripts\core\enemies\states\archer\positioning_state.gd:
========================================
  class_name PositioningState
  extends ArcherState
  
  ## Spezieller State für Bogenschützen, der sie in optimaler Schussdistanz positioniert
  ## Ersetzt den generischen ChaseState für bessere Fernkampftaktiken
  
  var optimal_distance: float = 150.0
  var position_timer: float = 0.0
  var positioning_timeout: float = 3.0  # Maximale Zeit für Positionierung
  var movement_pause_timer: float = 0.0
  var movement_pause_duration: float = 0.5  # Kurze Pausen während der Positionierung
  
  func _init():
  	name = "Positioning"
  
  func enter():
  	super.enter()
  	play_animation("walk")
  	position_timer = 0.0
  	movement_pause_timer = 0.0
  	
  	# Nutze die vom Archer definierte optimale Distanz
  	var archer = enemy as GoblinArcher
  	if archer and "optimal_distance" in archer:
  		optimal_distance = archer.optimal_distance
  	
  	print(enemy.name + " entered positioning state")
  
  func physics_process(delta: float):
  	position_timer += delta
  	
  	# Ziel aktualisieren
  	update_target()
  	
  	if not target:
  		enemy.velocity.x = 0
  		return
  	
  	# Abstand zum Ziel berechnen
  	var distance = get_distance_to_target()
  	
  	# Optimale Positionierung: Gelegentliche Pausen für realistischeres Verhalten
  	movement_pause_timer -= delta
  	if movement_pause_timer <= 0:
  		var direction = target.global_position.x - enemy.global_position.x
  		var normalized_dir = sign(direction)
  		
  		# Positionierungslogik
  		if distance < optimal_distance * 0.8:  # Zu nah
  			enemy.velocity.x = -normalized_dir * enemy.speed  # Wegbewegen
  		elif distance > optimal_distance * 1.2:  # Zu weit
  			enemy.velocity.x = normalized_dir * enemy.speed  # Annähern
  		else:
  			# Im optimalen Bereich - anhalten und ausrichten
  			enemy.velocity.x = 0
  			movement_pause_timer = movement_pause_duration  # Kurze Pause
  		
  		# Zum Ziel drehen, egal in welche Richtung wir uns bewegen
  		if enemy.animated_sprite:
  			enemy.animated_sprite.flip_h = direction > 0
  	else:
  		# Während der Pause nicht bewegen, aber zum Ziel ausrichten
  		enemy.velocity.x = 0
  		if enemy.animated_sprite and target:
  			var direction = target.global_position.x - enemy.global_position.x
  			enemy.animated_sprite.flip_h = direction > 0
  
  func get_next_state() -> String:
  	var next = super.get_next_state()
  	if next:
  		return next
  		
  	# Kein Ziel - zurück zur Patrouille
  	if not target:
  		return "Patrol"
  	
  	var archer = enemy as GoblinArcher
  	if not archer:
  		return "Patrol"
  	
  	# Schießen, wenn gute Position erreicht und Pfeile vorhanden
  	var distance = get_distance_to_target()
  	if distance >= optimal_distance * 0.8 and distance <= optimal_distance * 1.2:
  		if archer.arrows_remaining > 0:
  			return "Shoot"
  	
  	# Wenn zu nah am Spieler, zurückziehen
  	if distance < optimal_distance * 0.5:
  		return "Retreat"
  	
  	# Timeout für die Positionierung
  	if position_timer > positioning_timeout:
  		# Nach Timeout versuchen zu schießen, auch wenn nicht perfekt positioniert
  		if archer.arrows_remaining > 0:
  			return "Shoot"
  	
  	return ""

========================================
Contents of scripts\core\enemies\states\archer\reload_state.gd:
========================================
  class_name ReloadState
  extends ArcherState
  
  var reload_timer: float = 0.0
  var reload_time: float = 2.0
  
  func _init():
  	name = "Reload"
  
  func enter():
  	super.enter()
  	play_animation("idle")
  	
  	# Stop while reloading
  	enemy.velocity.x = 0
  		
  	reload_timer = 0.0
  	
  	# Start reloading
  	var archer = enemy as GoblinArcher
  	if archer:
  		archer.start_reloading()
  		reload_time = archer.reload_time
  		
  	print(enemy.name + " entered reload state")
  
  func physics_process(delta: float):
  	reload_timer += delta
  	
  	# Update target
  	update_target()
  
  func get_next_state() -> String:
  	var next = super.get_next_state()
  	if next:
  		return next
  	
  	# After reload completes
  	if reload_timer >= reload_time:
  		var archer = enemy as GoblinArcher
  		if not archer:
  			return "Patrol"
  		
  		# Retreat if player is close
  		if target and get_distance_to_target() < 100:
  			return "Retreat"
  		
  		# Otherwise chase or patrol
  		if target:
  			return "Chase"
  		else:
  			return "Patrol"
  	
  	return ""

========================================
Contents of scripts\core\enemies\states\archer\retreat_state.gd:
========================================
  class_name RetreatState
  extends ArcherState
  
  var retreat_timer: float = 0.0
  var retreat_duration: float = 1.5
  var optimal_distance: float = 150.0
  
  func _init():
  	name = "Retreat"
  
  func enter():
  	super.enter()
  	play_animation("walk")
  	retreat_timer = 0.0
  	
  	# Get optimal distance from the archer
  	var archer = enemy as GoblinArcher
  	if archer and "optimal_distance" in archer:
  		optimal_distance = archer.optimal_distance
  	
  	print(enemy.name + " entered retreat state")
  
  func physics_process(delta: float):
  	retreat_timer += delta
  	
  	# Update target reference
  	update_target()
  	
  	if not target:
  		return
  	
  	var distance = get_distance_to_target()
  	var direction = enemy.global_position.x - target.global_position.x
  	var normalized_dir = sign(direction)
  	
  	# Move away if too close
  	if distance < optimal_distance:
  		enemy.velocity.x = normalized_dir * enemy.speed
  		
  		if enemy.animated_sprite:
  			enemy.animated_sprite.flip_h = normalized_dir < 0
  	else:
  		enemy.velocity.x = 0
  		
  		# Face player but don't move
  		var look_dir = target.global_position.x - enemy.global_position.x
  		if enemy.animated_sprite:
  			enemy.animated_sprite.flip_h = look_dir > 0
  
  func get_next_state() -> String:
  	var next = super.get_next_state()
  	if next:
  		return next
  		
  	# Return to patrol if no target
  	if not target:
  		return "Patrol"
  	
  	# After retreat time, shoot
  	if retreat_timer >= retreat_duration:
  		var archer = enemy as GoblinArcher
  		var distance = get_distance_to_target()
  		
  		if archer and distance >= optimal_distance and archer.arrows_remaining > 0:
  			return "Shoot"
  		elif archer and archer.arrows_remaining <= 0:
  			return "Reload"
  	
  	return ""

========================================
Contents of scripts\core\enemies\states\archer\shoot_state.gd:
========================================
  class_name ShootState
  extends ArcherState
  
  var shoot_timer: float = 0.0
  var shoot_duration: float = 0.6  # Time for the complete shoot action
  var shoot_cooldown: float = 0.5  # Time between shots
  var current_cooldown: float = 0.0
  var shots_fired: int = 0
  var max_shots: int = 3  # Maximum shots per attack sequence
  var has_aimed: bool = false
  var is_firing: bool = false
  
  func _init():
  	name = "Shoot"
  
  func enter():
  	super.enter()
  	play_animation("attack")
  	
  	# Reset state variables
  	shoot_timer = 0.0
  	current_cooldown = 0.0
  	shots_fired = 0
  	has_aimed = false
  	is_firing = false
  	
  	# Stop movement when shooting
  	enemy.velocity.x = 0
  	
  	# Face the target
  	flip_to_target()
  	
  	print(enemy.name + " entered shoot state")
  
  func physics_process(delta: float):
  	shoot_timer += delta
  	
  	# Update target tracking
  	update_target()
  	
  	# Aim at target (slight delay before first shot)
  	if not has_aimed and shoot_timer >= 0.2:
  		# Face the target
  		flip_to_target()
  		has_aimed = true
  	
  	# Manage cooldown between shots
  	if current_cooldown > 0:
  		current_cooldown -= delta
  	
  	# Fire sequence
  	if has_aimed and current_cooldown <= 0 and shots_fired < max_shots:
  		if not is_firing:
  			is_firing = true
  			_fire_projectile()
  			
  			# Reset for next shot
  			current_cooldown = shoot_cooldown
  			shots_fired += 1
  			is_firing = false
  
  func _fire_projectile():
  	var archer = enemy as GoblinArcher
  	if not archer:
  		return
  	
  	# Call the archer's shoot method
  	var success = archer.shoot()
  	
  	if success:
  		# Play shoot sound if available
  		if enemy.has_node("ShootSound"):
  			var sound = enemy.get_node("ShootSound")
  			sound.play()
  		
  		print(enemy.name + " fired a projectile at " + target.name + " (shot " + str(shots_fired + 1) + "/" + str(max_shots) + ")")
  
  func get_next_state() -> String:
  	var next = super.get_next_state()
  	if next:
  		return next
  	
  	# Return to patrol if target lost
  	if not target:
  		return "Patrol"
  	
  	# Check if we need to reload
  	var archer = enemy as GoblinArcher
  	if archer and archer.arrows_remaining <= 0:
  		return "Reload"
  	
  	# Complete shooting sequence after max shots or if target out of range
  	if shots_fired >= max_shots or not is_target_in_attack_range():
  		# Check distance to determine next state
  		var distance = get_distance_to_target()
  		
  		if archer and distance < archer.optimal_distance * 0.7:
  			return "Retreat"  # Too close, back up
  		elif not is_target_in_attack_range():
  			return "Positioning"  # Not in range, reposition
  		else:
  			# Could transition back to positioning or stay in shoot based on arrow count
  			if archer and archer.arrows_remaining <= 1:
  				return "Reload"  # Almost out of arrows, reload now
  			elif distance >= archer.optimal_distance * 0.8 and distance <= archer.optimal_distance * 1.2:
  				return ""  # Stay in shoot state if at optimal distance with arrows left
  			else:
  				return "Positioning"  # Reposition for better shot
  	
  	return ""  # Stay in shoot state if none of the above conditions are met

========================================
Contents of scripts\core\enemies\states\common\attack_state.gd:
========================================
  class_name AttackState
  extends EnemyState
  
  var attack_timer: float = 0.0
  var attack_duration: float = 0.5
  var has_dealt_damage: bool = false
  
  func _init():
      name = "Attack"
      
  func enter():
      super.enter()
      play_animation("attack")
      
      attack_timer = 0.0
      has_dealt_damage = false
      
      # Stop movement during attack
      enemy.velocity.x = 0
      
      # Face target
      flip_to_target()
          
      print(enemy.name + " entered attack state")
  
  func physics_process(delta: float):
      attack_timer += delta
      
      # Deal damage in middle of animation
      if not has_dealt_damage and attack_timer >= attack_duration * 0.5:
          deal_damage()
          has_dealt_damage = true
  
  func deal_damage():
      if not target or not is_target_in_attack_range():
          return
      
      # Use enemy's execute_attack method
      enemy.execute_attack(target, enemy.attack_damage)
      
      print(enemy.name + " dealt damage to " + target.name)
  
  func get_next_state() -> String:
      var next = super.get_next_state()
      if next:
          return next
          
      # After attack is complete
      if attack_timer >= attack_duration:
          # If target out of range, chase
          if not is_target_in_attack_range():
              return "Chase"
          # If target in range but can't attack yet
          elif not enemy.can_attack:
              return "Chase"
          # If target in range and we can attack, stay in attack state
      
      return ""

========================================
Contents of scripts\core\enemies\states\common\chase_state.gd:
========================================
  class_name ChaseState
  extends EnemyState
  
  func _init():
      name = "Chase"
      
  func enter():
      super.enter()
      play_animation("walk")
      print(enemy.name + " entered chase state")
  
  func physics_process(delta: float):
      # Update target
      update_target()
      
      if not target:
          enemy.velocity.x = 0
          return
      
      # Direction to player
      var direction = target.global_position.x - enemy.global_position.x
      var normalized_dir = sign(direction)
      
      # Set velocity using chase speed
      enemy.velocity.x = normalized_dir * enemy.chase_speed
      
      # Flip sprite
      if enemy.animated_sprite:
          enemy.animated_sprite.flip_h = normalized_dir > 0
  
  func get_next_state() -> String:
      var next = super.get_next_state()
      if next:
          return next
          
      # Return to patrol if no target
      if not target:
          return "Patrol"
      
      # Switch to attack if in range
      if is_target_in_attack_range() and enemy.can_attack:
          return "Attack"
      
      return ""

========================================
Contents of scripts\core\enemies\states\common\death_state.gd:
========================================
  class_name DeathState
  extends EnemyState
  
  var death_timer: float = 0.0
  var death_duration: float = 1.0
  
  func _init():
  	name = "Death"
  	
  func enter():
  	super.enter()
  	play_animation("death")
  	
  	# Stop movement
  	enemy.velocity = Vector2.ZERO
  	
  	# Disable collision
  	if enemy.collision_shape:
  		enemy.collision_shape.set_deferred("disabled", true)
  	
  	death_timer = 0.0
  	print(enemy.name + " entered death state")
  
  func physics_process(delta: float):
  	death_timer += delta
  	
  	# Remove entity after animation completes
  	if death_timer >= death_duration and is_instance_valid(enemy):
  		enemy.queue_free()
  
  func get_next_state() -> String:
  	# Never leave death state
  	return ""

========================================
Contents of scripts\core\enemies\states\common\enemy_state.gd:
========================================
  class_name EnemyState
  extends State
  
  ## Base class for all enemy states
  ## Provides common functionality and utility methods
  
  # Get properly typed references
  var enemy: BaseEnemy = null
  var target = null
  
  # Get the current state machine properly typed
  var enemy_machine: EnemyStateMachine:
  	get: return state_machine as EnemyStateMachine
  
  func _init():
  	# This is called when the object is first created
  	name = "EnemyState"
  
  func enter():
  	# Ensure enemy reference is valid
  	enemy = owner_node as BaseEnemy
  	
  	if not enemy:
  		push_error("Enemy state attached to non-BaseEnemy object!")
  		return
  	
  	# Get current target from state machine
  	if enemy_machine:
  		target = enemy_machine.target
  
  func exit():
  	pass
  
  func get_next_state() -> String:
  	# Check for death - highest priority transition
  	if enemy and (enemy.is_dead or enemy.current_health <= 0):
  		return "Death"
  	
  	# No transition by default
  	return ""
  
  # Common utility functions
  func play_animation(anim_name: String):
  	if enemy:
  		enemy.play_animation(anim_name)
  
  func flip_to_target():
  	if not target or not enemy:
  		return
  		
  	if enemy.animated_sprite:
  		var direction = target.global_position.x - enemy.global_position.x
  		enemy.animated_sprite.flip_h = direction > 0
  
  # Distance to current target
  func get_distance_to_target() -> float:
  	if not target or not enemy:
  		return 9999.0
  	
  	return enemy.global_position.distance_to(target.global_position)
  
  # Is target in attack range?
  func is_target_in_attack_range() -> bool:
  	if enemy and "attack_radius" in enemy:
  		return get_distance_to_target() <= enemy.attack_radius
  	else:
  		return get_distance_to_target() <= 50.0  # Default
  
  # Is target in detection range?
  func is_target_in_detection_range() -> bool:
  	if enemy and "detection_radius" in enemy:
  		return get_distance_to_target() <= enemy.detection_radius
  	else:
  		return get_distance_to_target() <= 200.0  # Default
  
  # Update target reference
  func update_target():
  	if enemy_machine:
  		target = enemy_machine.target

========================================
Contents of scripts\core\enemies\states\common\hurt_state.gd:
========================================
  class_name HurtState
  extends EnemyState
  
  var hurt_timer: float = 0.0
  var hurt_duration: float = 0.3
  
  func _init():
      name = "Hurt"
      
  func enter():
      super.enter()
      play_animation("hurt")
      
      # Stop movement
      enemy.velocity.x = 0
          
      hurt_timer = 0.0
      print(enemy.name + " entered hurt state")
  
  func physics_process(delta: float):
      hurt_timer += delta
  
  func get_next_state() -> String:
      var next = super.get_next_state()
      if next:
          return next
          
      # After hurt animation
      if hurt_timer >= hurt_duration:
          if target:
              if is_target_in_attack_range() and enemy.can_attack:
                  return "Attack"
              else:
                  return "Chase"
          else:
              return "Patrol"
      
      return ""

========================================
Contents of scripts\core\enemies\states\common\patrol_state.gd:
========================================
  class_name PatrolState
  extends EnemyState
  
  var patrol_timer: float = 0.0
  var wait_time: float = 1.0
  var is_waiting: bool = false
  var direction: int = 1
  var patrol_points: Array = []
  
  func _init():
  	name = "Patrol"
  
  func enter():
  	super.enter()
  	play_animation("idle")
  	
  	# Set up patrol points if needed
  	if patrol_points.size() == 0 and enemy_machine:
  		var start_pos = enemy_machine.initial_position
  		patrol_points = [
  			start_pos,
  			start_pos + Vector2(enemy.patrol_distance, 0)
  		]
  	
  	patrol_timer = 0.0
  	is_waiting = false
  	print(enemy.name + " entered patrol state")
  
  func physics_process(delta: float):
  	patrol_timer += delta
  	
  	# Check for player - handled by state machine automatically
  	update_target()
  	
  	if is_waiting:
  		# Wait at patrol point
  		if patrol_timer >= wait_time:
  			is_waiting = false
  			patrol_timer = 0.0
  			# Reverse direction
  			direction *= -1
  			if enemy.animated_sprite:
  				enemy.animated_sprite.flip_h = direction > 0
  		return
  	
  	# Apply patrol movement
  	enemy.velocity.x = enemy.speed * direction
  	
  	# Play walk animation
  	play_animation("walk")
  	
  	# Check if patrol points are set up
  	if patrol_points.size() < 2:
  		return
  		
  	# Check if we've reached a boundary
  	if direction > 0 and enemy.global_position.x >= patrol_points[1].x:
  		enemy.global_position.x = patrol_points[1].x
  		handle_patrol_point_reached()
  	elif direction < 0 and enemy.global_position.x <= patrol_points[0].x:
  		enemy.global_position.x = patrol_points[0].x
  		handle_patrol_point_reached()
  
  func handle_patrol_point_reached():
  	enemy.velocity.x = 0
  	play_animation("idle")
  	is_waiting = true
  	patrol_timer = 0.0
  
  func get_next_state() -> String:
  	var next = super.get_next_state()
  	if next:
  		return next
  		
  	# Transition to chase if target detected - handled automatically by state machine
  	if target:
  		return "Chase"
  	
  	return ""

========================================
Contents of scripts\core\enemies\states\mage\cast_state.gd:
========================================
  class_name CastState
  extends MageState
  
  var cast_timer: float = 0.0
  var cast_duration: float = 0.8  # Time for the complete cast action
  var cast_cooldown: float = 1.2   # Time between spell casts
  var current_cooldown: float = 0.0
  var spells_cast: int = 0
  var max_spells: int = 2  # Maximum spells per cast sequence
  var is_charging: bool = false
  var charge_complete: bool = false
  var is_casting: bool = false
  var spell_type: String = "fireball"  # Default spell type
  
  # Visual effects
  var charge_particles: CPUParticles2D = null
  var cast_effect_active: bool = false
  
  func _init():
  	name = "Cast"
  
  func enter():
  	super.enter()
  	play_animation("cast")
  	
  	# Reset state variables
  	cast_timer = 0.0
  	current_cooldown = 0.0
  	spells_cast = 0
  	is_charging = false
  	charge_complete = false
  	is_casting = false
  	cast_effect_active = false
  	
  	# Stop movement when casting
  	enemy.velocity.x = 0
  	
  	# Face the target
  	flip_to_target()
  	
  	# Begin charging spell
  	_start_spell_charge()
  	
  	print(enemy.name + " entered cast state")
  
  func exit():
  	super.exit()
  	
  	# Clean up any active effects
  	_cleanup_effects()
  
  func physics_process(delta: float):
  	cast_timer += delta
  	
  	# Update target tracking
  	update_target()
  	
  	# Charge spell (visual buildup before first cast)
  	if is_charging and not charge_complete and cast_timer >= 0.4:
  		charge_complete = true
  		_complete_spell_charge()
  	
  	# Manage cooldown between casts
  	if current_cooldown > 0:
  		current_cooldown -= delta
  	
  	# Cast sequence
  	if charge_complete and current_cooldown <= 0 and spells_cast < max_spells:
  		if not is_casting:
  			is_casting = true
  			_cast_spell()
  			
  			# Reset for next cast
  			current_cooldown = cast_cooldown
  			spells_cast += 1
  			is_casting = false
  
  func _start_spell_charge():
  	is_charging = true
  	
  	# Create charge-up effect
  	var mage = enemy as GoblinMage
  	if not mage:
  		return
  	
  	# Create magical charging particles
  	charge_particles = CPUParticles2D.new()
  	charge_particles.name = "ChargeParticles"
  	charge_particles.emitting = true
  	charge_particles.amount = 16
  	charge_particles.lifetime = 0.5
  	charge_particles.explosiveness = 0.3
  	charge_particles.emission_shape = CPUParticles2D.EMISSION_SHAPE_SPHERE
  	charge_particles.emission_sphere_radius = 12.0
  	charge_particles.direction = Vector2(0, -1)
  	charge_particles.spread = 180.0
  	charge_particles.gravity = Vector2(0, -20)
  	charge_particles.initial_velocity_min = 5.0
  	charge_particles.initial_velocity_max = 15.0
  	charge_particles.color = Color(0.5, 0.2, 0.9, 0.7)  # Purple magic color
  	
  	enemy.add_child(charge_particles)
  	cast_effect_active = true
  
  func _complete_spell_charge():
  	# Visual effect for completed charge
  	if charge_particles:
  		# Pulse effect
  		var tween = enemy.create_tween()
  		tween.tween_property(charge_particles, "scale", Vector2(1.5, 1.5), 0.2)
  		tween.tween_property(charge_particles, "scale", Vector2(0.8, 0.8), 0.1)
  		
  		# Change particle color
  		charge_particles.color = Color(0.7, 0.3, 1.0, 0.8)  # Brighter magic color
  
  func _cast_spell():
  	var mage = enemy as GoblinMage
  	if not mage:
  		return
  	
  	# Call the mage's cast_spell method
  	var success = mage.cast_spell(spell_type)
  	
  	if success:
  		# Visual feedback
  		if charge_particles:
  			charge_particles.emitting = false
  			
  			# Create new emission burst
  			var burst = CPUParticles2D.new()
  			burst.name = "SpellBurst"
  			burst.emitting = true
  			burst.one_shot = true
  			burst.explosiveness = 1.0
  			burst.amount = 24
  			burst.lifetime = 0.5
  			burst.direction = Vector2(0, -1)
  			burst.spread = 180.0
  			burst.initial_velocity_min = 30.0
  			burst.initial_velocity_max = 60.0
  			burst.color = Color(0.7, 0.3, 1.0, 0.8)
  			
  			enemy.add_child(burst)
  			
  			# Remove after effect completes
  			await enemy.get_tree().create_timer(burst.lifetime * 1.5).timeout
  			if is_instance_valid(burst):
  				burst.queue_free()
  		
  		print(enemy.name + " cast a spell at " + target.name + " (spell " + str(spells_cast) + "/" + str(max_spells) + ")")
  
  func _cleanup_effects():
  	# Remove any active particles
  	if charge_particles and is_instance_valid(charge_particles):
  		charge_particles.queue_free()
  		charge_particles = null
  	
  	cast_effect_active = false
  
  func get_next_state() -> String:
  	var next = super.get_next_state()
  	if next:
  		return next
  	
  	# Return to patrol if target lost
  	if not target:
  		return "Patrol"
  	
  	# Check mana
  	var mage = enemy as GoblinMage
  	if mage and mage.current_mana < mage.spell_mana_cost:
  		# Not enough mana for another spell
  		return "MagePositioning"  # Reposition and wait for mana regen
  	
  	# Complete casting sequence after max spells or if target out of range
  	if spells_cast >= max_spells or not is_target_in_attack_range():
  		# Check distance to determine next state
  		var distance = get_distance_to_target()
  		
  		if distance < 80:
  			# Too close, try teleport or shield
  			if mage.current_mana >= mage.teleport_mana_cost and mage.last_teleport_time <= 0:
  				return "Teleport"
  			elif mage.current_mana >= mage.shield_mana_cost:
  				return "Shield"
  			else:
  				return "MagePositioning"
  		elif not is_target_in_attack_range():
  			return "MagePositioning"  # Not in range, reposition
  		else:
  			# Could stay in cast state if we have enough mana for another sequence
  			if mage and mage.current_mana >= mage.spell_mana_cost * 2:
  				return ""  # Stay in cast state with enough mana
  			else:
  				return "MagePositioning"  # Reposition and regenerate mana
  	
  	return ""  # Stay in cast state if none of the above conditions are met

========================================
Contents of scripts\core\enemies\states\mage\mage_state.gd:
========================================
  class_name MageState
  extends EnemyState
  
  ## Base class for specialized Goblin Melee enemy states
  
  func _init():
  	name = "MeleeState"
  "res://scripts/core/enemies/states/melee/melee_state.gd"

========================================
Contents of scripts\core\enemies\states\mage\positioning_state.gd:
========================================
  class_name MagePositioningState
  extends MageState
  
  ## Spezieller State für Magier, der sie in optimaler Zauber-Distanz positioniert
  ## Ersetzt den generischen ChaseState für bessere Fernkampftaktiken
  
  var optimal_distance: float = 180.0  # Magier bevorzugen größere Distanz als Bogenschützen
  var position_timer: float = 0.0
  var positioning_timeout: float = 3.0  # Maximale Zeit für Positionierung
  var movement_pause_timer: float = 0.0
  var movement_pause_duration: float = 0.7  # Längere Pausen für Magier (bedächtiger)
  var low_mana_threshold: float = 0.3  # Schwellwert für niedrigen Manavorrat (30%)
  
  func _init():
  	name = "MagePositioning"
  
  func enter():
  	super.enter()
  	play_animation("walk")
  	position_timer = 0.0
  	movement_pause_timer = 0.0
  	
  	print(enemy.name + " entered mage positioning state")
  
  func physics_process(delta: float):
  	position_timer += delta
  	
  	# Ziel aktualisieren
  	update_target()
  	
  	if not target:
  		enemy.velocity.x = 0
  		return
  	
  	# Abstand zum Ziel berechnen
  	var distance = get_distance_to_target()
  	
  	# Optimale Positionierung: Gelegentliche Pausen für realistischeres Verhalten
  	movement_pause_timer -= delta
  	if movement_pause_timer <= 0:
  		var direction = target.global_position.x - enemy.global_position.x
  		var normalized_dir = sign(direction)
  		
  		# Mage hat andere Positionierungslogik als Archer
  		var mage = enemy as GoblinMage
  		var mana_ratio = 1.0  # Standardwert
  		if mage:
  			mana_ratio = mage.current_mana / mage.max_mana
  		
  		# Positionierungslogik basierend auf Mana und Distanz
  		if mana_ratio < low_mana_threshold:
  			# Bei niedrigem Mana größeren Abstand halten
  			if distance < optimal_distance * 1.2:
  				enemy.velocity.x = -normalized_dir * enemy.speed  # Mehr Abstand gewinnen
  			else:
  				enemy.velocity.x = 0
  				movement_pause_timer = movement_pause_duration
  		else:
  			# Normale Positionierung
  			if distance < optimal_distance * 0.7:  # Zu nah
  				enemy.velocity.x = -normalized_dir * enemy.speed  # Wegbewegen
  			elif distance > optimal_distance * 1.3:  # Zu weit
  				enemy.velocity.x = normalized_dir * enemy.speed  # Annähern
  			else:
  				# Im optimalen Bereich - anhalten und ausrichten
  				enemy.velocity.x = 0
  				movement_pause_timer = movement_pause_duration
  		
  		# Zum Ziel drehen, unabhängig von der Bewegungsrichtung
  		if enemy.animated_sprite:
  			enemy.animated_sprite.flip_h = direction > 0
  	else:
  		# Während der Pause nicht bewegen, aber zum Ziel ausrichten
  		enemy.velocity.x = 0
  		if enemy.animated_sprite and target:
  			var direction = target.global_position.x - enemy.global_position.x
  			enemy.animated_sprite.flip_h = direction > 0
  
  func get_next_state() -> String:
  	var next = super.get_next_state()
  	if next:
  		return next
  		
  	# Kein Ziel - zurück zur Patrouille
  	if not target:
  		return "Patrol"
  	
  	var mage = enemy as GoblinMage
  	if not mage:
  		return "Patrol"
  	
  	# Notfall-Teleport wenn zu nah und Mana verfügbar
  	var distance = get_distance_to_target()
  	if distance < 70 and mage.current_mana >= mage.teleport_mana_cost and mage.last_teleport_time <= 0:
  		return "Teleport"
  	
  	# Schild aktivieren wenn zu nah und kein Teleport möglich
  	if distance < 80 and mage.current_mana >= mage.shield_mana_cost and not mage.is_shielding:
  		if mage.current_mana < mage.teleport_mana_cost or mage.last_teleport_time > 0:
  			return "Shield"
  	
  	# Zauber, wenn gute Position erreicht und genug Mana
  	if distance >= optimal_distance * 0.7 and distance <= optimal_distance * 1.5:
  		if mage.current_mana >= mage.spell_mana_cost:
  			return "Cast"
  	
  	# Timeout für die Positionierung
  	if position_timer > positioning_timeout:
  		# Nach Timeout versuchen zu zaubern, auch wenn nicht perfekt positioniert
  		if mage.current_mana >= mage.spell_mana_cost:
  			return "Cast"
  	
  	return ""

========================================
Contents of scripts\core\enemies\states\mage\shield_state.gd:
========================================
  class_name ShieldState
  extends MageState
  
  var shield_timer: float = 0.0
  var shield_duration: float = 5.0
  
  func _init():
  	name = "Shield"
  
  func enter():
  	super.enter()
  	play_animation("idle")
  	shield_timer = 0.0
  	
  	var mage = enemy as GoblinMage
  	if mage:
  		mage.activate_shield()
  		
  	print(enemy.name + " entered shield state")
  
  func exit():
  	super.exit()
  	
  	# Deactivate shield on exit
  	var mage = enemy as GoblinMage
  	if mage:
  		mage.deactivate_shield()
  
  func physics_process(delta: float):
  	shield_timer += delta
  	
  	# Update target
  	update_target()
  	
  	# Move slowly toward player with shield active
  	if target:
  		var direction = target.global_position.x - enemy.global_position.x
  		var normalized_dir = sign(direction)
  		enemy.velocity.x = normalized_dir * (enemy.speed * 0.5)  # Slower with shield
  		
  		if enemy.animated_sprite:
  			enemy.animated_sprite.flip_h = normalized_dir > 0
  	else:
  		enemy.velocity.x = 0
  
  func get_next_state() -> String:
  	var next = super.get_next_state()
  	if next:
  		return next
  		
  	if shield_timer >= shield_duration:
  		var mage = enemy as GoblinMage
  		if not mage:
  			return "Patrol"
  		
  		# Cast if enough mana
  		if target and mage.current_mana >= mage.spell_mana_cost:
  			return "Cast"
  		
  		# Otherwise chase or patrol
  		if target:
  			return "Chase"
  		else:
  			return "Patrol"
  	
  	return ""

========================================
Contents of scripts\core\enemies\states\mage\teleport_state.gd:
========================================
  class_name TeleportState
  extends MageState
  
  var teleport_timer: float = 0.0
  var teleport_duration: float = 0.5
  var has_teleported: bool = false
  
  func _init():
      name = "Teleport"
  
  func enter():
      super.enter()
      play_animation("idle")
      
      enemy.velocity = Vector2.ZERO
          
      teleport_timer = 0.0
      has_teleported = false
      
      print(enemy.name + " entered teleport state")
  
  func physics_process(delta: float):
      teleport_timer += delta
      
      # Teleport halfway through state duration
      if not has_teleported and teleport_timer >= teleport_duration * 0.5:
          _perform_teleport()
          has_teleported = true
  
  func _perform_teleport():
      var mage = enemy as GoblinMage
      if not mage:
          return
          
      # Use mage's teleport method
      mage.teleport()
      
      # Update target after teleport
      update_target()
  
  func get_next_state() -> String:
      var next = super.get_next_state()
      if next:
          return next
          
      # After teleport is complete
      if has_teleported and teleport_timer >= teleport_duration:
          var mage = enemy as GoblinMage
          if not mage:
              return "Patrol"
          
          # Return to appropriate state
          if target:
              # If enough mana to cast and in range, cast
              if mage.current_mana >= mage.spell_mana_cost and get_distance_to_target() <= enemy.attack_radius:
                  return "Cast"
              else:
                  return "Chase"
          else:
              return "Patrol"
      
      return ""

========================================
Contents of scripts\core\enemies\states\melee\charge_state.gd:
========================================
  class_name ChargeState
  extends MeleeState
  
  var charge_timer: float = 0.0
  var charge_duration: float = 0.75
  var charge_speed_multiplier: float = 2.0
  var has_started_charge: bool = false
  
  func _init():
      name = "Charge"
  
  func enter():
      super.enter()
      play_animation("walk")
      
      charge_timer = 0.0
      has_started_charge = false
      
      # Brief pause before charging
      enemy.velocity.x = 0
          
      print(enemy.name + " entered charge state")
  
  func physics_process(delta: float):
      charge_timer += delta
      
      # Start charge after brief delay
      if not has_started_charge and charge_timer >= 0.2:
          _start_charge()
          has_started_charge = true
      
      # Update target
      update_target()
  
  func _start_charge():
      if not target:
          return
          
      # Direction to player
      var direction = target.global_position.x - enemy.global_position.x
      var normalized_dir = sign(direction)
      
      # Apply charge speed
      enemy.velocity.x = normalized_dir * enemy.speed * charge_speed_multiplier
      
      # Flip sprite
      if enemy.animated_sprite:
          enemy.animated_sprite.flip_h = normalized_dir > 0
  
  func get_next_state() -> String:
      var next = super.get_next_state()
      if next:
          return next
          
      # After charge completes
      if charge_timer >= charge_duration:
          # Attack immediately if in range
          if is_target_in_attack_range():
              var melee = enemy as GoblinMelee
              if melee and melee.is_enraged:
                  return "Rage"
              else:
                  return "Attack"
          else:
              # Otherwise continue chasing
              var melee = enemy as GoblinMelee
              if melee and melee.is_enraged:
                  return "RageChase" 
              else:
                  return "Chase"
      
      return ""

========================================
Contents of scripts\core\enemies\states\melee\melee_state.gd:
========================================
  class_name MeleeState
  extends EnemyState
  
  ## Base class for specialized Goblin Melee enemy states
  
  func _init():
  	name = "MeleeState"
  "res://scripts/core/enemies/states/melee/melee_state.gd"

========================================
Contents of scripts\core\enemies\states\melee\rage_chase_state.gd:
========================================
  class_name RageChaseState
  extends MeleeState
  
  func _init():
      name = "RageChase"
  
  func enter():
      super.enter()
      play_animation("walk")
      
      print(enemy.name + " entered rage chase state")
  
  func physics_process(delta: float):
      # Update target
      update_target()
      
      if not target:
          enemy.velocity.x = 0
          return
      
      # Direction to player
      var direction = target.global_position.x - enemy.global_position.x
      var normalized_dir = sign(direction)
      
      # Use rage speed bonus
      var melee = enemy as GoblinMelee
      var speed_multiplier = melee.rage_speed_bonus if melee else 1.3
      
      # Apply movement with rage bonus
      enemy.velocity.x = normalized_dir * enemy.chase_speed * speed_multiplier
      
      # Flip sprite
      if enemy.animated_sprite:
          enemy.animated_sprite.flip_h = normalized_dir > 0
  
  func get_next_state() -> String:
      var next = super.get_next_state()
      if next:
          return next
          
      # Return to patrol if no target
      if not target:
          return "Patrol"
      
      # Switch to rage attack if in range
      if is_target_in_attack_range() and enemy.can_attack:
          return "Rage"
      
      return ""

========================================
Contents of scripts\core\enemies\states\melee\rage_state.gd:
========================================
  class_name RageState
  extends MeleeState
  
  var rage_timer: float = 0.0
  var rage_duration: float = 0.8  # Faster attack in rage mode
  var has_dealt_damage: bool = false
  
  func _init():
      name = "Rage"
  
  func enter():
      super.enter()
      play_animation("attack")
      
      # Stop movement during attack
      enemy.velocity.x = 0
          
      rage_timer = 0.0
      has_dealt_damage = false
      
      print(enemy.name + " entered rage attack state")
  
  func physics_process(delta: float):
      rage_timer += delta
      
      # Deal damage faster than normal attack
      if not has_dealt_damage and rage_timer >= rage_duration * 0.3:
          deal_rage_damage()
          has_dealt_damage = true
  
  func deal_rage_damage():
      if not target or not is_target_in_attack_range():
          return
          
      var melee = enemy as GoblinMelee
      if not melee:
          return
          
      # Execute attack with rage bonus
      var rage_damage = enemy.attack_damage
      enemy.execute_attack(target, rage_damage)
      
      print(enemy.name + " dealt RAGE damage to " + target.name)
  
  func get_next_state() -> String:
      var next = super.get_next_state()
      if next:
          return next
          
      # After rage attack completes
      if rage_timer >= rage_duration:
          # Chase with rage speed if target not in range
          if not is_target_in_attack_range():
              return "RageChase"
      
      return ""

========================================
Contents of scripts\core\items\coins.gd:
========================================
  class_name Coins
  extends Area2D
  
  signal coin_collected
  
  func _on_coins_body_entered(body):
  	GlobalHUD.coin_collected()
  	$AnimationPlayer.play("bounce")
  	set_collision_mask_value(1,false)
  
  
  func _on_animation_player_animation_finished(anim_name):
  	queue_free()

========================================
Contents of scripts\core\items\elixir.gd:
========================================
  class_name Elixir
  extends BasePowerUp
  
  ## Power-up that gives the player temporary flying ability via a magical elixir
  
  func _ready():
  	# Set power-up properties
  	power_up_name = "Magic Elixir"
  	description = "Grants temporary flying ability"
  	effect_duration = 20.0  # 20 seconds of flight
  	destroy_on_pickup = true
  	
  	# Set animation properties (optional: tweak to differentiate visually from Angel Wings)
  	bounce_height = 6.0
  	bounce_speed = 2.0
  	rotation_speed = 1.0
  	
  	# Call parent ready method
  	super._ready()
  
  func apply_effect(player):
  	# Call the parent implementation for signals
  	super.apply_effect(player)
  	
  	# Set the player's movement mode
  	if player.has_method("set_movement_mode"):
  		player.set_movement_mode("fly")
  	else:
  		player.mode = "fly"
  		
  	print("Player gained flight ability via Elixir")
  
  	# Update the Elixir fill in HUD
  	var hud = get_tree().get_root().find_child("HUD", true, false)
  	if hud:
  		hud.collect_softpower()  # This will add 25% elixir
  
  	# Show notification to player
  	var popup_manager = get_node_or_null("/root/PopupManager")
  	if popup_manager:
  		popup_manager.info("Elixir Power", "You've drunk the magic elixir! You can fly for " + str(effect_duration) + " seconds.")
  	
  	# Add a visible timer to the HUD if available
  	if hud and hud.has_method("show_ability_timer"):
  		hud.show_ability_timer("Flight", effect_duration)
  
  func remove_effect(player):
  	# Set the player's movement mode back to normal
  	if player.has_method("set_movement_mode"):
  		player.set_movement_mode("normal")
  	else:
  		player.mode = "normal"
  		
  	player.passed_fly_time = 0.0
  	
  	# Let the player know the effect has ended
  	var popup_manager = get_node_or_null("/root/PopupManager")
  	if popup_manager:
  		popup_manager.info("Elixir Expired", "The elixir's magic has worn off. You can't fly anymore.")
  	
  	super.remove_effect(player)

========================================
Contents of scripts\core\items\power_attack.gd:
========================================
  class_name PowerAttack
  extends BasePowerUp
  
  ## Power-up that gives the player an axe attack ability
  
  func _ready():
  	# Set power-up properties
  	power_up_name = "Battle Axe"
  	description = "Grants the ability to attack with a powerful axe"
  	destroy_on_pickup = true
  	
  	# Set animation properties
  	bounce_height = 5.0
  	bounce_speed = 2.0
  	rotation_speed = 1.0
  	
  	# Call parent ready method
  	super._ready()
  
  func apply_effect(player):
  	# Call the parent implementation for signals
  	super.apply_effect(player)
  	
  	# Set the player's attack animation
  	if player.has_method("set_attack_animation"):
  		player.set_attack_animation("walking6")
  	else:
  		# Fallback for current implementation
  		player.attack_animation = "walking6"
  		
  	# Enable attack ability if player has the method
  	if player.has_method("enable_attack"):
  		player.enable_attack(true)
  	
  	print("Player gained axe attack ability")
  	
  	# Show notification to player
  	var popup_manager = get_node_or_null("/root/PopupManager")
  	if popup_manager:
  		popup_manager.info("New Ability", "You've acquired a battle axe! Press the attack button to use it.")

========================================
Contents of scripts\core\items\power_fly.gd:
========================================
  class_name PowerFly
  extends BasePowerUp
  
  ## Power-up that gives the player temporary flying ability
  
  func _ready():
  	# Set power-up properties
  	power_up_name = "Angel Wings"
  	description = "Grants temporary flying ability"
  	effect_duration = 20.0  # 20 seconds of flight
  	destroy_on_pickup = true
  	
  	# Set animation properties
  	bounce_height = 8.0
  	bounce_speed = 1.5
  	rotation_speed = 0.5
  	
  	# Call parent ready method
  	super._ready()
  
  func apply_effect(player):
  	# Call the parent implementation for signals
  	super.apply_effect(player)
  	
  	# Set the player's movement mode
  	if player.has_method("set_movement_mode"):
  		player.set_movement_mode("fly")
  	else:
  		# Fallback for current implementation
  		player.mode = "fly"
  		
  	print("Player gained flight ability")
  	
  	# Show notification to player
  	var popup_manager = get_node_or_null("/root/PopupManager")
  	if popup_manager:
  		popup_manager.info("New Ability", "You've acquired angel wings! You can now fly for " + str(effect_duration) + " seconds.")
  	
  	# Add a visible timer to the HUD if available
  	var hud = get_node_or_null("../../HUD")
  	if hud and hud.has_method("show_ability_timer"):
  		hud.show_ability_timer("Flight", effect_duration)
  
  func remove_effect(player):
  	# Set the player's movement mode back to normal
  	if player.has_method("set_movement_mode"):
  		player.set_movement_mode("normal")
  	else:
  		# Fallback for current implementation
  		player.mode = "normal"
  		
  	# Reset player's flight timer
  	player.passed_fly_time = 0.0
  	
  	# Let the player know the effect has ended
  	var popup_manager = get_node_or_null("/root/PopupManager")
  	if popup_manager:
  		popup_manager.info("Ability Expired", "Your angel wings have disappeared.")
  	
  	# Call the parent implementation for signals
  	super.remove_effect(player)

========================================
Contents of scripts\core\items\power_jump.gd:
========================================
  class_name PowerJump
  extends BasePowerUp
  
  ## Power-up that gives the player double jump ability
  
  @export var extra_jumps: int = 1  # How many extra jumps to grant
  
  func _ready():
  	# Set power-up properties
  	power_up_name = "Feather Boots"
  	description = "Grants the ability to double jump"
  	destroy_on_pickup = true
  	
  	# Set animation properties
  	bounce_height = 10.0
  	bounce_speed = 3.0
  	rotation_speed = 0.0
  	
  	# Call parent ready method
  	super._ready()
  
  func apply_effect(player):
  	# Call the parent implementation for signals
  	super.apply_effect(player)
  	
  	# Increase player's allowed jumps
  	if player.has_method("add_extra_jumps"):
  		player.add_extra_jumps(extra_jumps)
  	else:
  		# Fallback for current implementation
  		player.allowed_jumps += extra_jumps
  		
  	# Set the player's movement mode to normal (in case they were flying)
  	if player.has_method("set_movement_mode"):
  		player.set_movement_mode("normal")
  	else:
  		# Fallback for current implementation
  		player.mode = "normal"
  	
  	print("Player gained double jump ability")
  	
  	# Show notification to player
  	var popup_manager = get_node_or_null("/root/PopupManager")
  	if popup_manager:
  		if extra_jumps == 1:
  			popup_manager.info("New Ability", "You've acquired Feather Boots! You can now double jump in mid-air.")
  		else:
  			popup_manager.info("New Ability", "You've acquired Feather Boots! You can now perform " + str(extra_jumps + 1) + " jumps in a row.")
========================================
Contents of scripts\core\player\character_sprites.gd:
========================================
  class_name CharacterSprites
  extends Node2D
  
  var animation_frames = {
  	"idle": [0, 1, 2, 3, 4, 5, 6, 7],
  	"animation1": [8, 9, 10, 11, 12, 13, 14, 15],
  	"animation2": [16, 17, 18, 19, 20, 21, 22, 23],
  	"walking": [24, 25, 26, 27, 28, 29, 30, 31],
  	"animation4": [32, 33, 34, 35, 36],
  	"animation5": [40, 41, 42, 43, 44],
  	"animation6": [48, 49, 50, 51, 52],
  	"animation7": [56, 57, 58, 59, 60],
  	"animation8": [64, 65, 66, 67, 68],
  	"animation9": [72, 73, 74, 75, 76],
  	"animation10": [80, 81, 82, 83, 84],
  	"animation11": [88, 89, 90, 91, 92],
  	"animation12": [96, 97, 98, 99, 100, 101, 102, 103],
  	"animation13": [104, 105, 106, 107, 108, 109, 110, 111],
  	"animation14": [112, 113, 114, 115, 116, 117, 118, 119],
  	"animation15": [120, 121, 122, 123, 124, 125, 126, 127],
  	"animation16": [128, 129, 130, 131],
  	"animation17": [136, 137, 138, 139],
  	"animation18": [144, 145, 146, 147], #attack knife
  	"animation19": [152, 153, 154, 155],
  	"animation20": [160],
  	"animation21": [168],
  	"animation22": [176],
  	"animation23": [184],
  	"animation24": [192],
  	"animation25": [200],
  	"animation26": [208],
  	"animation27": [216],
  	"dead": [224, 225],
  	"animation29": [232, 233, 234, 235, 236],
  	"walking0": [240, 241, 242, 243, 244],
  	"walking1": [248, 249, 250, 251, 252],
  	"walking2": [256, 257, 258, 259, 260],
  	"walking3": [264, 265, 266, 267, 268],
  	"walking4": [272, 273, 274, 275, 276],
  	"walking5": [280, 281, 282, 283, 284], #attack axe right
  	"walking6": [288, 289, 290, 291, 292], #attack axe left
  	"walking7": [296, 297],
  	"walking8": [304, 305],
  	"walking9": [312, 313],
  	"animation40": [320, 321],
  	"animation41": [328, 329, 330, 331, 332],
  	"animation42": [336, 337, 338, 339, 340],
  	"animation43": [344, 345, 346, 347, 348],
  	"animation44": [352, 353, 354, 355, 356],
  	"animation45": [360, 361, 362, 363, 364],
  	"animation46": [368, 369, 370, 371, 372],
  	"animation47": [376, 377, 378, 379, 380],
  	"animation48": [384, 385, 386, 387, 388],
  	"hurt":        [25*8, 27*8],
  }
  
  var default_outfit = {
  	"beard": 1,
  	"lipstick": 1,
  	"eyes": 1,
  	"shoes": 1,
  	"earrings": 1,
  	"hats": 1,
  	"glasses": 1,
  	"clothes_down": 1,
  	"clothes_up": 1,
  	"clothes_complete": 1,
  	"bodies": 1,
  	"hair": 1
  }

========================================
Contents of scripts\core\player\player.gd:
========================================
  class_name Player
  extends CharacterBody2D
  
  @export var joystick_right: VirtualJoystick
  @export var debug_mode: bool = false
  
  # Environment variables - use constants from Constants singleton
  var SPEED = Constants.PLAYER_DEFAULT_SPEED
  var JUMP_VELOCITY = Constants.PLAYER_DEFAULT_JUMP_VELOCITY
  var FLY_VELOCITY = Constants.PLAYER_DEFAULT_FLY_VELOCITY
  var GRAVITY = Constants.PLAYER_DEFAULT_GRAVITY
  
  # Character mode variables
  var mode = "normal"
  var passed_fly_time = 0.0
  var jump_counter = 0
  var ready_for_jump = true
  var allowed_jumps = Constants.PLAYER_MAX_JUMPS
  
  # Character health reference
  var hud
  
  # Character design variables
  var player_animations
  var current_animation = Constants.ANIMATION_IDLE
  var player_outfit
  var play_attack_animation = false
  var attack_animation = Constants.ANIMATION_ATTACK
  
  # Resource-based outfit system
  var current_outfit: PlayerOutfitResource = null
  
  # Reference to the state machine
  @onready var state_machine = $StateMachine
  
  func _ready() -> void:
  	add_to_group("player") 
  	# Initialize your global variables here
  	hud = get_node_or_null("../HUD")
  	player_animations = get_node("character_sprites").animation_frames
  
  	# Initialize outfit with defaults
  	var default_player_outfit = get_node("character_sprites").default_outfit
  	get_node("character_sprites/masks").visible = false
  	player_outfit = default_player_outfit.duplicate(true)
  
  	# Create outfit resource
  	current_outfit = PlayerOutfitResource.new()
  
  	# Register with GameManager
  	if get_node_or_null("/root/Global"):
  		Global.register_player(self)
  
  	# Connect to SaveManager signals
  	if get_node_or_null("/root/SaveManager"):
  		SaveManager.connect("load_completed", Callable(self, "_on_save_loaded"))
  		SaveManager.connect("settings_loaded", Callable(self, "_on_settings_loaded"))
  		
  		# Load settings from SaveManager
  		if SaveManager.current_save_data:
  			update_from_save_data()
  	
  	_setup_state_machine()
  	
  	if debug_mode:
  		print("Player ready, State Machine initialized")
  		print("Initial player stats: Speed=", SPEED, ", Jump=", JUMP_VELOCITY,
  			  ", Fly=", FLY_VELOCITY, ", Gravity=", GRAVITY)
  			
  # Setup the state machine and initialize all player states
  func _setup_state_machine():
  	# Check if StateMachine node exists
  	if not has_node("StateMachine"):
  		var sm = StateMachine.new()
  		sm.name = "StateMachine"
  		add_child(sm)
  		state_machine = sm
  	
  	# Set owner reference for StateMachine
  	state_machine.owner_node = self
  	
  	# Set debug mode
  	state_machine.debug_mode = debug_mode
  	
  	# Add all player states as children
  	_add_player_states()
  
  # Add all player states to the state machine
  func _add_player_states():
  	# If states already exist, don't add them again
  	if state_machine.get_child_count() > 0:
  		return
  	
  	# Define state classes to use (imported from player_states)
  	var state_classes = {
  		"PlayerIdleState": PlayerIdleState,
  		"PlayerWalkState": PlayerWalkState,
  		"PlayerJumpState": PlayerJumpState,
  		"PlayerFallState": PlayerFallState,
  		"PlayerAttackState": PlayerAttackState,
  		"PlayerFlyState": PlayerFlyState,
  		"PlayerHurtState": PlayerHurtState,
  		"PlayerDeathState": PlayerDeathState
  	}
  	
  	# Add each state as a child node
  	for state_name in state_classes:
  		var state = state_classes[state_name].new()
  		state.name = state_name
  		state_machine.add_child(state)
  		
  		# Register the state with the state machine
  		state_machine.register_state(state)
  	
  	# Set initial state to Idle
  	state_machine.change_state("PlayerIdleState")
  	
  	if debug_mode:
  		print("Player states added to StateMachine:", state_machine.states.keys())
  
  # Save current player settings
  func save_settings():
  	if get_node_or_null("/root/SaveManager"):
  		SaveManager.save_settings()
  
  # New methods for SaveManager integration
  func _on_save_loaded(success, message):
  	if success:
  		update_from_save_data()
  
  func _on_settings_loaded(success):
  	if success:
  		update_from_save_data()
  
  func update_from_save_data():
  	if not get_node_or_null("/root/SaveManager") or not SaveManager.current_save_data:
  		print("No save data available to update from")
  		return
  
  	var save_data = SaveManager.current_save_data
  	
  	# Update movement parameters
  	SPEED = save_data.player_speed
  	JUMP_VELOCITY = save_data.player_jump_velocity
  	FLY_VELOCITY = save_data.player_fly_velocity
  	GRAVITY = save_data.player_gravity
  	
  	# Update state
  	mode = save_data.player_mode
  	passed_fly_time = save_data.player_passed_fly_time
  	jump_counter = save_data.player_jump_counter
  	ready_for_jump = save_data.player_ready_for_jump
  	allowed_jumps = save_data.player_allowed_jumps
  
  	# Apply outfit if available
  	if save_data.player_outfit and not save_data.player_outfit.is_empty():
  		# Update resource and dictionary
  		if current_outfit:
  			current_outfit.from_dictionary(save_data.player_outfit)
  		else:
  			current_outfit = PlayerOutfitResource.new().from_dictionary(save_data.player_outfit)
  
  		# Apply current outfit to character
  		player_outfit = save_data.player_outfit.duplicate(true)
  		_update_outfit_visuals()
  		
  	if debug_mode:
  		print("Updated player from save data: Speed=", SPEED, ", Jump=", JUMP_VELOCITY)
  		print("Outfit loaded:", player_outfit)
  
  # Update outfit sprite visibility and animations
  func _update_outfit_visuals():
  	for category in player_outfit:
  		if has_node("character_sprites/" + category):
  			var sprite = get_node("character_sprites/" + category)
  			var value = str(player_outfit[category])
  			
  			if value == "none":
  				sprite.visible = false
  			else:
  				sprite.visible = true
  				sprite.animation = value
  				sprite.frame = 1
  
  # Helper method to play animations
  func play_animation(anim_name: String):
  	current_animation = anim_name
  
  # Return gravity as a Vector2 to avoid conflicts with PhysicsBody2D
  func calculate_gravity() -> Vector2:
  	return Vector2(0, GRAVITY)
  
  # Keep portal handlers and other methods
  func _on_test_portal_entered(_body):
  	if get_node_or_null("/root/Global"):
  		Global.change_scene(Constants.MAIN_MENU_SCENE)
  	mode = "fly"
  	save_settings()
  
  func _on_elias_portal_entered(_body):
  	print("Elias")
  	save_settings()
  
  func _on_ardit_portal_entered(_body):
  	if get_node_or_null("/root/Global"):
  		Global.change_scene("res://Arrogance.tscn")
  	save_settings()
  
  func _on_sebastian_portal_entered(_body):
  	mode = "normal"
  	if get_node_or_null("/root/Global"):
  		Global.change_scene("res://scenes/levels/sebastian_levels/level_1.tscn")
  	save_settings()
  
  func _on_prince_portal_entered(_body):
  	if get_node_or_null("/root/Global"):
  		Global.change_scene("res://scenes/levels/prince_levels/platform.tscn")
  	save_settings()
  
  func _on_fallzone_body_entered(_body):
  	if get_node_or_null("/root/Global"):
  		Global.change_scene("res://scenes/levels/ardit_levels/arrogance.tscn")
  
  func _on_life_up_body_entered(_body):
  	if hud:
  		hud.change_life(0.25)
  
  func _on_life_down_body_entered(_body):
  	if hud:
  		hud.change_life(-0.25)
  
  func _on_test_portal_body_entered(_body):
  	if get_node_or_null("/root/Global"):
  		Global.change_scene("res://scenes/levels/adventure_mode/MainMap.tscn")
  
  # New methods for gameplay enhancement
  func set_movement_mode(new_mode: String) -> void:
  	mode = new_mode
  
  	if new_mode == "fly":
  		passed_fly_time = 0.0
  
  	if debug_mode:
  		print("Movement mode changed to: ", new_mode)
  
  func enable_attack(enable: bool) -> void:
  	play_attack_animation = enable
  
  func set_attack_animation(anim_name: String) -> void:
  	attack_animation = anim_name
  
  func add_extra_jumps(extra_jumps: int) -> void:
  	allowed_jumps += extra_jumps
  
  
  # Modified player take_damage function
  func take_damage(amount: float) -> void:
  	# Use GlobalHUD instead of direct HUD reference
  	if get_node_or_null("/root/GlobalHUD"):
  		GlobalHUD.change_health(-amount / 100.0)
  	elif hud:
  		# Fallback to local HUD if global not available
  		hud.change_life(-amount / 100.0)
  # Modified player bounce function
  func bounce() -> void:
  	velocity.y = JUMP_VELOCITY * 0.7 # Less powerful than a regular jump
  
  # Modified player death function
  func death():
  	$CollisionShape2D.disabled = true
  	current_animation = "dead"
  	await get_tree().create_timer(1.0).timeout
  	# Notify GameManager of player death
  	if get_node_or_null("/root/Global"):
  		Global.player_death()
  
  	self.queue_free()
  	
  	if get_node_or_null("/root/Global"):
  		Global.go_to_main_menu()

========================================
Contents of scripts\core\player\player_camera.gd:
========================================
  class_name PlayerCamera
  extends Camera2D
  
  
  # Called when the node enters the scene tree for the first time.
  func _ready():
  	pass # Replace with function body.
  
  
  # Called every frame. 'delta' is the elapsed time since the previous frame.
  func _process(delta):
  	pass

========================================
Contents of scripts\core\player\player_states\player_attack_state.gd:
========================================
  class_name PlayerAttackState
  extends PlayerState
  
  var attack_timer: float = 0.0
  var attack_duration: float = 0.5  # Dauer der Angriffsanimation
  var has_checked_for_enemies: bool = false
  
  func enter():
  	player.current_animation = player.attack_animation
  	player.play_attack_animation = true
  	attack_timer = 0.0
  	has_checked_for_enemies = false
  	
  	# Attacke-Sound abspielen, falls vorhanden
  	if player.has_node("AttackSound"):
  		player.get_node("AttackSound").play()
  
  func physics_process(delta: float):
  	# Nur einmal pro Angriff nach Feinden suchen
  	if not has_checked_for_enemies:
  		_check_for_enemies()
  		has_checked_for_enemies = true
  	
  	# Schwerkraft anwenden
  	var velocity = get_velocity()
  	velocity.y += player.GRAVITY * delta
  	
  	# Bewegung während des Angriffs reduzieren
  	velocity.x = move_toward(velocity.x, 0, 20)
  	
  	set_velocity(velocity)
  	player.move_and_slide()
  	
  	# Timer aktualisieren
  	attack_timer += delta
  	
  	# Outfit aktualisieren
  	update_outfit()
  
  func _check_for_enemies():
  	# Direkt um den Spieler herum nach Feinden suchen
  	var player_pos = player.global_position
  	
  	# Blickrichtung des Spielers ermitteln
  	var player_facing_right = player.get_node("character_sprites/bodies").flip_h
  	
  	# Alle Gegner in der Szene durchgehen
  	var enemies = get_tree().get_nodes_in_group("enemy")
  	for enemy in enemies:
  		# Abstand zum Feind prüfen (einfache Entfernungsprüfung)
  		var distance = player_pos.distance_to(enemy.global_position)
  		if distance <= 60.0:  # 60 Pixel Reichweite
  			# Prüfen, ob Spieler zum Feind schaut
  			var enemy_is_right = enemy.global_position.x > player_pos.x
  			
  			# Wenn Spieler in die richtige Richtung schaut und nah genug ist
  			if (player_facing_right and enemy_is_right) or (not player_facing_right and not enemy_is_right):
  				# Feind töten
  				if enemy.has_method("take_damage"):
  					enemy.take_damage(enemy.current_health) # Sofortiger Tod
  					print("Enemy killed: ", enemy.name)
  
  func get_next_state() -> String:
  	# State-Übergänge prüfen
  	var life_state = check_life()
  	if life_state:
  		return life_state
  	
  	# Nach Ende der Animation zum passenden State zurückkehren
  	if attack_timer >= attack_duration:
  		player.play_attack_animation = false
  		
  		if player.is_on_floor():
  			var x_input = Input.get_axis("left", "right")
  			if x_input != 0:
  				return "PlayerWalkState"
  			else:
  				return "PlayerIdleState"
  		else:
  			return "PlayerFallState"
  	
  	# Im Angriffszustand bleiben
  	return ""
  	
  func handle_input(event: InputEvent):
  	check_menu_input(event)

========================================
Contents of scripts\core\player\player_states\player_base_state.gd:
========================================
  class_name PlayerState
  extends State
  
  # Base functions shared by all player states
  var player: Player
  
  func _ready():
  	# Set player reference during initialization
  	player = owner_node as Player
  
  # Function to update the outfit based on the current state
  func update_outfit():
  	var player_outfit = player.player_outfit
  	var player_animations = player.player_animations
  	var current_animation = player.current_animation
  
  	for outfit in player_outfit:
  		var animated_sprite = player.get_node("character_sprites/" + outfit)
  		var selected_outfit = player_outfit[outfit]
  
  		if str(selected_outfit) == "none":
  			animated_sprite.visible = false
  		else:
  			animated_sprite.visible = true
  			animated_sprite.play(str(selected_outfit))
  			animated_sprite.speed_scale = 2.0
  
  			# Set direction based on movement
  			var x_input = Input.get_axis("left", "right")
  			if x_input != 0:
  				animated_sprite.flip_h = x_input > 0
  
  			# Frame management
  			if current_animation in player_animations:
  				if animated_sprite.frame < player_animations[current_animation][0] or animated_sprite.frame >= player_animations[current_animation][-1]:
  					animated_sprite.frame = player_animations[current_animation][0]
  
  # Function to check life and handle death
  func check_life():
  	# Check for player health in the HUD
  	if GlobalHUD:
  		var health_value = 0
  		
  		# Try to get health using the current API or the legacy API
  		if "current_health" in GlobalHUD:
  			health_value = GlobalHUD.current_health
  		elif "lifes" in GlobalHUD:
  			health_value = GlobalHUD.lifes
  			
  		if health_value <= 0:
  			return "PlayerDeathState"
  	
  	return ""
  
  # Function to check menu input
  func check_menu_input(event):
  	if event is InputEvent and event.is_action_pressed("Menu"):
  		get_tree().change_scene_to_file("res://scenes/ui/main_menu/main_menu.tscn")
  		if player.has_method("save_settings"):
  			player.save_settings()

========================================
Contents of scripts\core\player\player_states\player_death_state.gd:
========================================
  class_name PlayerDeathState
  extends PlayerState
  
  var death_timer: float = 0.0
  var death_duration: float = 1.5  # Duration before scene transition
  
  func enter():
      player.current_animation = "death"
      player.get_node("CollisionShape2D").disabled = true
      death_timer = 0.0
  
  func physics_process(delta: float):
      # Update death animation timer
      death_timer += delta
      
      # Update outfit
      update_outfit()
  
  func get_next_state() -> String:
      # Scene transition after death animation
      if death_timer >= death_duration:
          player.queue_free()
          get_tree().change_scene_to_file("res://scenes/ui/main_menu/main_menu.tscn")
      
      # Stay in death state
      return ""
========================================
Contents of scripts\core\player\player_states\player_fall_state.gd:
========================================
  class_name PlayerFallState
  extends PlayerState
  
  func enter():
  	# player.current_animation = "idle"  # You may want a falling animation
  	
  	# Mark as not ready for jump
  	if player.jump_counter == 0:
  		player.ready_for_jump = false
  		
  func physics_process(delta: float):
  	# Apply gravity
  	var velocity = get_velocity()
  	velocity.y += player.GRAVITY * delta
  	
  	# Read the input
  	var x_input = Input.get_axis("left", "right")
  	var y_input = Input.get_axis("down", "up")
  	
  	# Apply horizontal movement
  	if x_input != 0:
  		velocity.x = x_input * player.SPEED
  		player.current_animation = "walking"
  	else:
  		velocity.x = move_toward(velocity.x, 0, 30)
  	
  	# Check for double jump if allowed
  	if y_input > 0.4 && player.jump_counter < player.allowed_jumps && player.ready_for_jump:
  		velocity.y = player.JUMP_VELOCITY * y_input
  		player.jump_counter += 1
  		player.ready_for_jump = false
  	elif y_input < 0.4:
  		player.ready_for_jump = true
  		
  	set_velocity(velocity)
  	
  	# Handle movement for character body
  	player.move_and_slide()
  	
  	# Update outfit
  	update_outfit()
  
  func get_next_state() -> String:
  	# Check state transitions
  	var life_state = check_life()
  	if life_state:
  		return life_state
  		
  	# Check for attack input
  	if Input.is_action_just_pressed("attack"):
  		return "PlayerAttackState"
  		
  	# Check for fly mode
  	if player.mode == "fly":
  		return "PlayerFlyState"
  	
  	# Landing transition
  	if player.is_on_floor():
  		player.jump_counter = 0
  		player.ready_for_jump = true
  		player.passed_fly_time = 0.0
  		
  		# Check if still moving
  		var x_input = Input.get_axis("left", "right")
  		if x_input != 0:
  			return "PlayerWalkState"
  		else:
  			return "PlayerIdleState"
  			
  	# Double jump transition
  	var y_input = Input.get_axis("down", "up")
  	if y_input > 0.4 && player.jump_counter < player.allowed_jumps && player.ready_for_jump:
  		return "PlayerJumpState"
  	
  	# Stay in fall state
  	return ""
  	
  func handle_input(event: InputEvent):
  	check_menu_input(event)

========================================
Contents of scripts\core\player\player_states\player_fly_state.gd:
========================================
  class_name PlayerFlyState
  extends PlayerState
  
  var elixir_drain_timer: float = 0.0
  var drain_interval: float = 3.0  # Drain every 5 seconds
  var drain_amount: float = 0.25   # Drain 25% each time
  
  func enter():
  	player.current_animation = "idle"  # You may want a specific fly animation
  	elixir_drain_timer = 0.0  # Reset timer on state entry
  
  func physics_process(delta: float):
  	# Apply gravity
  	var velocity = get_velocity()
  	velocity.y += player.GRAVITY * delta
  	
  	# Read inputs
  	var x_input = Input.get_axis("left", "right")
  	var y_input = Input.get_axis("down", "up")
  	
  	# Apply horizontal movement
  	if x_input != 0:
  		velocity.x = x_input * player.SPEED
  	else:
  		velocity.x = move_toward(velocity.x, 0, 30)
  		
  	# Update fly time counter
  	if player.passed_fly_time < 4:
  		player.passed_fly_time += delta
  		if y_input != 0:
  			velocity.y = player.FLY_VELOCITY * y_input
  	
  	# Handle elixir drain
  	elixir_drain_timer += delta
  	if elixir_drain_timer >= drain_interval:
  		elixir_drain_timer = 0.0  # Reset timer
  		GlobalHUD.use_softpower()
  	
  	if GlobalHUD.elixir_fill_level <= 0:
  		player.mode = "normal"
  		
  	
  	
  	set_velocity(velocity)
  	
  	# Handle movement for character body
  	player.move_and_slide()
  	
  	# Update outfit
  	update_outfit()
  
  func get_next_state() -> String:
  	# Check state transitions
  	var life_state = check_life()
  	if life_state:
  		return life_state
  		
  	# Check for attack input
  	if Input.is_action_just_pressed("attack"):
  		return "PlayerAttackState"
  	
  	# Check elixir level - transition to fall if empty
  	if GlobalHUD.elixir_fill_level <= 0:
  		player.passed_fly_time = 0.0  # Reset fly time
  		return "PlayerFallState"
  	
  	# Landing transition
  	if player.is_on_floor():
  		player.jump_counter = 0
  		player.ready_for_jump = true
  		player.passed_fly_time = 0.0
  		
  		# Check movement direction after landing
  		var x_input = Input.get_axis("left", "right")
  		if x_input != 0:
  			return "PlayerWalkState"
  		else:
  			return "PlayerIdleState"
  	
  	# Time limit check
  	if player.passed_fly_time >= 4:
  		return "PlayerFallState"
  	
  	# Stay in fly state
  	return ""
  	
  func handle_input(event: InputEvent):
  	check_menu_input(event)

========================================
Contents of scripts\core\player\player_states\player_hurt_state.gd:
========================================
  class_name PlayerHurtState
  extends PlayerState

========================================
Contents of scripts\core\player\player_states\player_idle_state.gd:
========================================
  class_name PlayerIdleState
  extends PlayerState
  
  func enter():
  	player.current_animation = "idle"
  	# Reset horizontal velocity
  	var velocity = get_velocity()
  	velocity.x = 0
  	set_velocity(velocity)
  	
  	if player.debug_mode:
  		print("Entered Idle State")
  
  func physics_process(delta: float):
  	# Apply gravity
  	var velocity = get_velocity()
  	velocity.y += player.GRAVITY * delta
  	set_velocity(velocity)
  	
  	# Handle movement for character body
  	player.move_and_slide()
  	
  	# Update outfit
  	update_outfit()
  
  func get_next_state() -> String:
  	# Check for death
  	var life_state = check_life()
  	if life_state != "":
  		return life_state
  	
  	# Check input for state transitions
  	var x_input = Input.get_axis("left", "right")
  	var y_input = Input.get_axis("down", "up")
  	
  	# Check for attack
  	if Input.is_action_just_pressed("attack"):
  		return "PlayerAttackState"
  	
  	# Check for movement
  	if x_input != 0:
  		return "PlayerWalkState"
  	
  	# Check for jumping
  	if y_input > 0.4 and player.is_on_floor():
  		return "PlayerJumpState"
  	
  	# Check for falling
  	if !player.is_on_floor():
  		return "PlayerFallState"
  	
  	# No transition
  	return ""
  
  func handle_input(event: InputEvent):
  	check_menu_input(event)

========================================
Contents of scripts\core\player\player_states\player_jump_state.gd:
========================================
  # Fix for player_jump_state.gd - Correct class name
  class_name PlayerJumpState
  extends PlayerState
  
  func enter():
  	# player.current_animation = "idle"  # You may want to use a jump animation
  
  	# Apply initial jump velocity
  	var velocity = get_velocity()
  	var y_input = Input.get_axis("down", "up")
  	velocity.y = player.JUMP_VELOCITY * y_input
  	set_velocity(velocity)
  
  	# Update jump counter
  	player.jump_counter += 1
  	player.ready_for_jump = false
  	
  	if player.debug_mode:
  		print("Entered Jump State")
  
  func physics_process(delta: float):
  	# Apply gravity
  	var velocity = get_velocity()
  	velocity.y += player.GRAVITY * delta
  
  	# Read horizontal input
  	var x_input = Input.get_axis("left", "right")
  
  	# Apply horizontal movement
  	if x_input != 0:
  		velocity.x = x_input * player.SPEED
  		player.current_animation = "walking"
  	else:
  		velocity.x = move_toward(velocity.x, 0, 30)
  
  	set_velocity(velocity)
  
  	# Handle movement for character body
  	player.move_and_slide()
  
  	# Reset jump readiness when input is released
  	var y_input = Input.get_axis("down", "up")
  	if y_input < 0.4:
  		player.ready_for_jump = true
  
  	# Update outfit
  	update_outfit()
  
  func get_next_state() -> String:
  	# Check state transitions
  	var life_state = check_life()
  	if life_state:
  		return life_state
  
  	# Check for attack input
  	if Input.is_action_just_pressed("attack"):
  		return "PlayerAttackState"
  
  	# Fly state transition
  	if player.mode == "fly":
  		return "PlayerFlyState"
  
  	# Landing transition
  	if player.is_on_floor():
  		player.jump_counter = 0
  		player.ready_for_jump = true
  
  		# Check if still moving
  		var x_input = Input.get_axis("left", "right")
  		if x_input != 0:
  			return "PlayerWalkState"
  		else:
  			return "PlayerIdleState"
  
  	# Falling transition
  	if get_velocity().y > 0:
  		return "PlayerFallState"
  
  	# Stay in jump state
  	return ""
  
  func handle_input(event: InputEvent):
  	check_menu_input(event)

========================================
Contents of scripts\core\player\player_states\player_state.gd:
========================================
  class_name PlayerState
  extends State
  
  # Base functions shared by all player states
  var player: Player
  
  func _ready():
  	# Set player reference during initialization
  	player = owner_node as Player
  
  # Function to update the outfit based on the current state
  func update_outfit():
  	var player_outfit = player.player_outfit
  	var player_animations = player.player_animations
  	var current_animation = player.current_animation
  
  	for outfit in player_outfit:
  		var animated_sprite = player.get_node("character_sprites/" + outfit)
  		var selected_outfit = player_outfit[outfit]
  
  		if str(selected_outfit) == "none":
  			animated_sprite.visible = false
  		else:
  			animated_sprite.visible = true
  			animated_sprite.play(str(selected_outfit))
  			animated_sprite.speed_scale = 2.0
  
  			# Set direction based on movement
  			var x_input = Input.get_axis("left", "right")
  			if x_input != 0:
  				animated_sprite.flip_h = x_input > 0
  
  			# Frame management
  			if current_animation in player_animations:
  				if animated_sprite.frame < player_animations[current_animation][0] or animated_sprite.frame >= player_animations[current_animation][-1]:
  					animated_sprite.frame = player_animations[current_animation][0]
  
  # Function to check life and handle death
  func check_life():
  	if  GlobalHUD.current_health <= 0:
  		return "PlayerDeathState"
  	return ""
  
  # Function to check menu input
  func check_menu_input(event):
  	if event is InputEvent and event.is_action_pressed("Menu"):
  		get_tree().change_scene_to_file("res://scenes/ui/main_menu/main_menu.tscn")
  		if player.has_method("save_settings"):
  			player.save_settings()

========================================
Contents of scripts\core\player\player_states\player_walk_state.gd:
========================================
  class_name PlayerWalkState
  extends PlayerState
  
  func enter():
  	player.current_animation = "walking"  # Walk animation
  	
  	if player.debug_mode:
  		print("Entered Walk State")
  
  func physics_process(delta: float):
  	# Apply gravity
  	var velocity = get_velocity()
  	velocity.y += player.GRAVITY * delta
  	
  	# Read the input
  	var x_input = Input.get_axis("left", "right")
  	
  	# Apply horizontal movement
  	if x_input != 0:
  		velocity.x = x_input * player.SPEED
  	else:
  		velocity.x = move_toward(velocity.x, 0, 30)
  		
  	set_velocity(velocity)
  	
  	# Handle movement for character body
  	player.move_and_slide()
  	
  	# Update outfit
  	update_outfit()
  
  func get_next_state() -> String:
  	# Check for death
  	var life_state = check_life()
  	if life_state != "":
  		return life_state
  		
  	# Check for attack
  	if Input.is_action_just_pressed("attack"):
  		return "PlayerAttackState"
  	
  	# Read inputs
  	var x_input = Input.get_axis("left", "right")
  	var y_input = Input.get_axis("down", "up")
  	
  	# Stop walking
  	if x_input == 0:
  		return "PlayerIdleState"
  	
  	# Jump while moving
  	if y_input > 0.4 and player.is_on_floor():
  		return "PlayerJumpState"
  		
  	# Fall transition
  	if !player.is_on_floor():
  		return "PlayerFallState"
  	
  	# Stay in walk state
  	return ""
  	
  func handle_input(event: InputEvent):
  	check_menu_input(event)

========================================
Contents of scripts\core\projectiles\mage_ball.gd:
========================================
  class_name MageBall
  extends BaseProjectile
  
  ## Magisches Projektil verwendet von Goblin Mages
  ## Enthält Partikeleffekte und hat spezielle Treffereffekte
  
  # Zusätzliche Mage Ball-spezifische Eigenschaften
  @export var magic_color: Color = Color(0.5, 0.2, 0.9, 0.7)  # Lila Magie-Farbe
  @export var homing_strength: float = 0.0  # Optional: Stärke des Zielsuchens (0 = aus)
  @export var emit_particles: bool = true   # Partikel während des Flugs
  @export var magic_sound: AudioStream     # Soundeffekt für Magie
  
  # Tracking für Partikelsysteme
  var current_particles = []
  
  func _ready():
  	# Setze Standardeigenschaften
  	speed = 90.0
  	damage = 0.5  # 0.25 Leben (der Spieler hat 3 Leben)
  	lifetime = 6.0
  	gravity_affected = false
  	bounce = false
  	trail_effect = true
  	
  	# Magischen Trail-Effekt erstellen
  	if trail_effect:
  		_setup_magical_trail()
  	
  	# Animation abspielen
  	if has_node("AnimatedSprite2D"):
  		$AnimatedSprite2D.play("flying")
  		# Magische Farbe anwenden
  		$AnimatedSprite2D.modulate = magic_color
  	
  	# Lichteffekt hinzufügen, wenn nicht schon vorhanden
  	if not has_node("PointLight2D"):
  		var light = PointLight2D.new()
  		light.color = magic_color
  		light.energy = 0.7
  		light.texture = load("res://icon.png")  # Ersetze mit besserem Licht-Texture
  		light.texture_scale = 0.5
  		add_child(light)
  	
  	# Aura-Sprite hinzufügen
  	if not has_node("AuraSprite"):
  		var aura = Sprite2D.new()
  		aura.name = "AuraSprite"
  		aura.texture = load("res://icon.png")  # Ersetze mit Aura-Texture
  		aura.modulate = magic_color.lightened(0.3)
  		aura.modulate.a = 0.4
  		aura.scale = Vector2(1.5, 1.5)
  		add_child(aura)
  		
  		# Aura-Animation
  		var tween = create_tween().set_loops()
  		tween.tween_property(aura, "scale", Vector2(1.7, 1.7), 0.6)
  		tween.tween_property(aura, "scale", Vector2(1.5, 1.5), 0.6)
  	
  	super._ready()
  
  func _physics_process(delta):
  	# Magische Heimsuche, wenn aktiviert
  	if homing_strength > 0 and is_instance_valid(source_node) and source_node.state_machine and source_node.state_machine.target:
  		var target = source_node.state_machine.target
  		if is_instance_valid(target):
  			var direction_to_target = (target.global_position - global_position).normalized()
  			velocity = velocity.lerp(direction_to_target * speed, homing_strength * delta)
  	
  	# Partikel emittieren während des Flugs
  	if emit_particles and randf() < 0.2:  # 20% Chance pro Frame
  		_emit_magic_particle()
  	
  	# Standard-Physik
  	super._physics_process(delta)
  
  # Erstelle einen magischen Trail
  func _setup_magical_trail():
  	if trail:
  		trail.default_color = magic_color
  		trail.width = 4.0
  		
  		# Farbverlauf hinzufügen
  		trail.gradient = Gradient.new()
  		trail.gradient.add_point(0.0, magic_color.darkened(0.2))
  		trail.gradient.add_point(1.0, magic_color.lightened(0.3))
  
  # Emittiere einen einzelnen magischen Partikel
  func _emit_magic_particle():
  	var particle = CPUParticles2D.new()
  	particle.emitting = true
  	particle.amount = 3
  	particle.lifetime = 0.4
  	particle.explosiveness = 0.7
  	particle.direction = Vector2(0, 0)
  	particle.spread = 180
  	particle.gravity = Vector2.ZERO
  	particle.initial_velocity_min = 10
  	particle.initial_velocity_max = 20
  	particle.scale_amount_min = 2.0
  	particle.scale_amount_max = 2.0
  	particle.color = magic_color
  	
  	# Füge zum Hauptbaum hinzu (damit sie beim Recycling nicht verschwinden)
  	get_tree().current_scene.add_child(particle)
  	particle.global_position = global_position
  	
  	# Tracking für Cleanup
  	current_particles.append(particle)
  	
  	# Auto-Entfernung nach Lebenszeit
  	await get_tree().create_timer(particle.lifetime * 1.5).timeout
  	if is_instance_valid(particle):
  		current_particles.erase(particle)
  		particle.queue_free()
  
  # Überschreibe die Treffereffektsmethode für magischen Effekt
  func _spawn_hit_effect(hit_position):
  	# Magic-Explosion-Effekt
  	var explosion = CPUParticles2D.new()
  	explosion.emitting = true
  	explosion.one_shot = true
  	explosion.amount = 20
  	explosion.lifetime = 0.5
  	explosion.explosiveness = 1.0
  	explosion.direction = Vector2(0, -1)
  	explosion.spread = 180
  	explosion.gravity = Vector2(0, 0)
  	explosion.initial_velocity_min = 30
  	explosion.initial_velocity_max = 70
  	explosion.scale_amount_min = 2.0
  	explosion.scale_amount_max = 2.0
  	explosion.color = magic_color
  	
  	get_tree().current_scene.add_child(explosion)
  	explosion.global_position = hit_position
  	
  	# Spiele magischen Sound ab, wenn verfügbar
  	if magic_sound:
  		var audio_player = AudioStreamPlayer2D.new()
  		audio_player.stream = magic_sound
  		audio_player.volume_db = -5
  		audio_player.max_distance = 300
  		audio_player.position = hit_position
  		get_tree().current_scene.add_child(audio_player)
  		audio_player.play()
  		
  		# Entferne Audio nach dem Abspielen
  		audio_player.finished.connect(func(): audio_player.queue_free())
  	
  	# Magisches Leuchten (wird mit Zeit schwächer)
  	var light = PointLight2D.new()
  	light.color = magic_color
  	light.energy = 1.0
  	light.texture = load("res://icon.png")  # Ersetze mit besserem Licht-Texture
  	light.texture_scale = 2.0
  	light.position = hit_position
  	get_tree().current_scene.add_child(light)
  	
  	# Ausblenden mit Tween
  	var tween = create_tween()
  	tween.tween_property(light, "energy", 0.0, 0.5)
  	tween.tween_callback(func(): light.queue_free())
  	
  	# Entferne Explosion nach der Lebenszeit
  	await get_tree().create_timer(explosion.lifetime * 1.5).timeout
  	if is_instance_valid(explosion):
  		explosion.queue_free()
  
  # Überschreibe die Recycling-Methode
  func _on_recycle_to_pool():
  	super._on_recycle_to_pool()
  	
  	# Bereinige alle noch aktiven Partikel
  	for particle in current_particles:
  		if is_instance_valid(particle):
  			particle.queue_free()
  	current_particles.clear()

========================================
Contents of scripts\core\projectiles\rock.gd:
========================================
  class_name Rock
  extends BaseProjectile
  
  ## Stein-Projektil abgeschossen von Goblin Archers
  ## Ist von der Schwerkraft beeinflusst und kann abprallen
  
  # Rock-spezifische Eigenschaften
  @export var max_bounces: int = 2  # Maximale Anzahl an Abprallvorgängen
  @export var impact_sound: AudioStream  # Sound beim Aufprall
  @export var size_variation: float = 0.2  # Zufällige Größenvariation
  @export var dust_on_bounce: bool = true  # Staubeffekt beim Abprallen
  @export var rotation_speed: float = 5.0  # Wie schnell der Stein rotiert
  
  # Tracking-Variablen
  var bounces_remaining: int = 0
  var current_dust_particles = []
  
  func _ready():
  	# Setze Standardeigenschaften
  	speed = 300.0  # Reduzierte Geschwindigkeit für bessere Kollisionserkennung
  	damage = 0.25  # 0.25 Leben (weniger Schaden als Magie)
  	lifetime = 4.0
  	gravity_affected = true
  	bounce = true
  	bounce_factor = 0.6  # Verliert 40% Energie beim Abprallen
  	
  	# Setze Abprallzähler
  	bounces_remaining = max_bounces
  	
  	# Animation abspielen
  	if has_node("AnimatedSprite2D"):
  		$AnimatedSprite2D.play("flying")
  		
  		# Zufällige Größenvariation für mehr Natürlichkeit
  		var size_factor = 1.0 + randf_range(-size_variation, size_variation)
  		$AnimatedSprite2D.scale = Vector2(size_factor, size_factor)
  		
  		# Zufällige Anfangsrotation
  		$AnimatedSprite2D.rotation = randf() * TAU
  	
  	# Zufällige Variation in der Geschwindigkeit (reduziert auf ±5%)
  	speed = speed * (1.0 + randf_range(-0.05, 0.05))
  	
  	super._ready()
  
  func _physics_process(delta):
  	# Drehe den Sprite basierend auf der Bewegungsrichtung
  	var sprite = get_node_or_null("AnimatedSprite2D")
  	if sprite:
  		sprite.rotation += rotation_speed * delta
  	
  	# Standard-Physik
  	super._physics_process(delta)
  
  # Überschriebene Kollisionsmethode für verbesserte Abprall-Logik
  func _on_collision(collision):
  	var collider = collision.get_collider()
  	if collider == null:
  		return
  	# Zusätzliche Prüfung auf gültige Gruppen
  	var is_player = collider.is_in_group("player") if collider.has_method("is_in_group") else false
  	var is_enemy = collider.is_in_group("enemy") if collider.has_method("is_in_group") else false
  	
  	# Prüfe auf Abprallen für Umgebungsobjekte
  	if bounce and bounces_remaining > 0 and not (is_player or is_enemy):
  		var reflection = collision.get_remainder().bounce(collision.get_normal())
  		velocity = velocity.bounce(collision.get_normal()) * bounce_factor
  		global_position += reflection
  		
  		# Reduziere verbleibende Abprallvorgänge
  		bounces_remaining -= 1
  		
  		# Spiele Abprallsound ab
  		_play_bounce_sound(collision.get_position())
  		
  		# Erzeuge Staubeffekt
  		if dust_on_bounce:
  			_spawn_dust_effect(collision.get_position(), collision.get_normal())
  		
  		# Sende Abprall-Signal
  		emit_signal("projectile_bounce", self, collision.get_position(), collision.get_normal())
  		
  		# Wenn keine Abprallvorgänge mehr übrig, markiere als getroffen bei nächster Kollision
  		if bounces_remaining <= 0:
  			bounce = false
  		
  		return
  	
  	# Standard-Kollision für alles andere
  	has_hit = true
  	
  	# Verarbeite verschiedene Kollisionstypen
  	if is_player and source_node != collider:
  		_on_hit_player(collider, collision.get_position())
  	elif is_enemy and source_node != collider:
  		_on_hit_enemy(collider, collision.get_position())
  	else:
  		_on_hit_environment(collider, collision.get_position())
  	
  	_recycle_or_free()
  
  # Spiele Abprallsound ab
  func _play_bounce_sound(position):
  	if impact_sound:
  		var audio_player = AudioStreamPlayer2D.new()
  		audio_player.stream = impact_sound
  		audio_player.volume_db = -10
  		audio_player.max_distance = 200
  		audio_player.position = position
  		get_tree().current_scene.add_child(audio_player)
  		audio_player.play()
  		
  		# Entferne Audio nach dem Abspielen
  		audio_player.finished.connect(func(): audio_player.queue_free())
  	else:
  		# Standardsound wenn keiner definiert ist
  		var audio_player = AudioStreamPlayer2D.new()
  		var sound_index = randi() % 3 + 1  # Zufällig zwischen 1-3
  		var sound_path = "res://assets/audio/sfx/rock_impact" + str(sound_index) + ".wav"
  		var sound = load(sound_path) if ResourceLoader.exists(sound_path) else null
  		
  		if sound:
  			audio_player.stream = sound
  			audio_player.volume_db = -15
  			audio_player.position = position
  			get_tree().current_scene.add_child(audio_player)
  			audio_player.play()
  			audio_player.finished.connect(func(): audio_player.queue_free())
  
  # Erzeuge Staubeffekt beim Abprallen
  func _spawn_dust_effect(position, normal):
  	var dust = CPUParticles2D.new()
  	dust.emitting = true
  	dust.one_shot = true
  	dust.explosiveness = 0.8
  	dust.amount = 8
  	dust.lifetime = 0.5
  	dust.direction = Vector2(-normal.x, -normal.y)
  	dust.spread = 45
  	dust.gravity = Vector2(0, 20)
  	dust.initial_velocity_min = 10
  	dust.initial_velocity_max = 30
  	dust.scale_amount = 1.5
  	dust.color = Color(0.7, 0.7, 0.5, 0.7)  # Staubfarbe
  	
  	get_tree().current_scene.add_child(dust)
  	dust.global_position = position
  	
  	# Tracking für Cleanup
  	current_dust_particles.append(dust)
  	
  	# Auto-Entfernung nach Lebenszeit
  	await get_tree().create_timer(dust.lifetime * 1.5).timeout
  	if is_instance_valid(dust):
  		current_dust_particles.erase(dust)
  		dust.queue_free()
  
  # Überschreibe die Treffereffektsmethode für Steineffekt
  func _spawn_hit_effect(hit_position):
  	# Steinimpakt-Effekt mit Steinsplittern
  	var impact = CPUParticles2D.new()
  	impact.emitting = true
  	impact.one_shot = true
  	impact.amount = 10
  	impact.lifetime = 0.7
  	impact.explosiveness = 1.0
  	impact.spread = 180
  	impact.gravity = Vector2(0, 98)
  	impact.initial_velocity_min = 20
  	impact.initial_velocity_max = 50
  	impact.scale_amount_min = 2.0
  	impact.scale_amount_max = 2.0
  	impact.color = Color(0.6, 0.5, 0.4)  # Steinfarbe
  	
  	get_tree().current_scene.add_child(impact)
  	impact.global_position = hit_position
  	
  	# Spiele Aufprallsound ab
  	_play_bounce_sound(hit_position)
  	
  	# Entferne Impact nach der Lebenszeit
  	await get_tree().create_timer(impact.lifetime * 1.5).timeout
  	if is_instance_valid(impact):
  		impact.queue_free()
  
  # Setup-Methode überschreiben um Abprallzähler zurückzusetzen
  func setup(dir: Vector2, spawn_pos: Vector2, spawn_rot: float = 0.0, source = null):
  	# Normal-Setup durchführen
  	super.setup(dir, spawn_pos, spawn_rot, source)
  	
  	# Abprallzähler zurücksetzen
  	bounces_remaining = max_bounces
  	bounce = true
  	
  	# Stelle sicher, dass Geschwindigkeit korrekt gesetzt wird
  	velocity = direction.normalized() * speed
  	
  	return self
  
  # Überschreibe die Recycling-Methode
  func _on_recycle_to_pool():
  	super._on_recycle_to_pool()
  	
  	# Abprallzähler zurücksetzen
  	bounces_remaining = max_bounces
  	bounce = true
  	
  	# Bereinige alle noch aktiven Partikel
  	for particle in current_dust_particles:
  		if is_instance_valid(particle):
  			particle.queue_free()
  	current_dust_particles.clear()

========================================
Contents of scripts\levels\base_level.gd:
========================================
  class_name BaseLevel
  extends Node2D
  
  var boss_music = load("res://assets/audio/music/Tracks/the-epic-2-by-rafael-krux(chosic.com).mp3")
  # Called when the node enters the scene tree for the first time.
  func _ready():
  	AudioManager.play_track(boss_music)
  
  # Called every frame. 'delta' is the elapsed time since the previous frame.
  func _process(_delta):
  	pass

========================================
Contents of scripts\resources\player_outfit_resource.gd:
========================================
  class_name PlayerOutfitResource
  extends Resource
  
  ## Resource-based outfit system for The Little Saint
  ## Provides structured way to store and manage player appearance
  
  # Outfit components
  @export var beard: String = "none"
  @export var lipstick: String = "none"
  @export var eyes: String = "1"
  @export var shoes: String = "1"
  @export var earrings: String = "none"
  @export var hat: String = "none"
  @export var glasses: String = "none"
  @export var clothes_down: String = "1"
  @export var clothes_up: String = "1"
  @export var clothes_complete: String = "none"
  @export var body: String = "1"
  @export var hair: String = "1"
  
  # Outfit metadata
  @export var outfit_name: String = "Default Outfit"
  @export var is_favorite: bool = false
  @export var creation_date: String = ""
  
  # Initialize with default values
  func _init():
  	creation_date = Time.get_datetime_string_from_system(false, true)
  
  # Convert to dictionary format (for backwards compatibility)
  func to_dictionary() -> Dictionary:
  	return {
  		"beard": beard,
  		"lipstick": lipstick,
  		"eyes": eyes,
  		"shoes": shoes,
  		"earrings": earrings,
  		"hats": hat,
  		"glasses": glasses,
  		"clothes_down": clothes_down,
  		"clothes_up": clothes_up,
  		"clothes_complete": clothes_complete,
  		"bodies": body,
  		"hair": hair
  	}
  
  # Create from dictionary (for backwards compatibility)
  func from_dictionary(dict: Dictionary) -> PlayerOutfitResource:
  	beard = str(dict.get("beard", "none"))
  	lipstick = str(dict.get("lipstick", "none"))
  	eyes = str(dict.get("eyes", "1"))
  	shoes = str(dict.get("shoes", "1"))
  	earrings = str(dict.get("earrings", "none"))
  	hat = str(dict.get("hats", "none"))
  	glasses = str(dict.get("glasses", "none"))
  	clothes_down = str(dict.get("clothes_down", "1"))
  	clothes_up = str(dict.get("clothes_up", "1"))
  	clothes_complete = str(dict.get("clothes_complete", "none"))
  	body = str(dict.get("bodies", "1"))
  	hair = str(dict.get("hair", "1"))
  	return self
  
  # Check if a component is visible
  func is_visible(component: String) -> bool:
  	match component:
  		"beard", "lipstick", "earrings", "hat", "glasses", "clothes_complete":
  			return get(component) != "none"
  		_:
  			return true
  
  # Check if this is a complete outfit (has all required elements)
  func is_complete() -> bool:
  	return body != "none" and eyes != "none"
  
  # Reset to default values
  func reset() -> void:
  	beard = "none"
  	lipstick = "none"
  	eyes = "1"
  	shoes = "1"
  	earrings = "none"
  	hat = "none"
  	glasses = "none"
  	clothes_down = "1"
  	clothes_up = "1"
  	clothes_complete = "none"
  	body = "1"
  	hair = "1"
  	outfit_name = "Default Outfit"
  	is_favorite = false
  	creation_date = Time.get_datetime_string_from_system(false, true)
  
  # Create a randomized outfit
  func randomize_outfit() -> PlayerOutfitResource:
  	# Use true randomization
  	randomize()
  	
  	# Always set essential parts
  	body = str(randi_range(1, 10))  # Assuming there are 10 body options
  	eyes = str(randi_range(1, 14))  # Assuming there are 14 eye options
  	
  	# Randomly decide for all other parts
  	beard = _random_part(["none", "1", "2", "3"], 0.7)  # 70% chance for none
  	lipstick = _random_part(["none", "1", "2", "3"], 0.8)  # 80% chance for none
  	shoes = str(randi_range(1, 10))  # Assuming there are 10 shoe options
  	earrings = _random_part(["none", "1", "2", "3"], 0.8)  # 80% chance for none
  	hat = _random_part(["none", "1", "2", "3", "4"], 0.6)  # 60% chance for none
  	glasses = _random_part(["none", "1", "2"], 0.9)  # 90% chance for none
  	
  	# Either use separate top/bottom or complete outfit
  	if randf() > 0.3:  # 70% chance for separate clothes
  		clothes_down = str(randi_range(1, 10))
  		clothes_up = str(randi_range(1, 10))
  		clothes_complete = "none"
  	else:  # 30% chance for complete outfit
  		clothes_down = "none"
  		clothes_up = "none"
  		clothes_complete = str(randi_range(1, 5))  # Assuming there are 5 complete outfit options
  	
  	# Hair is important for character look
  	hair = str(randi_range(1, 14))  # Assuming there are 14 hair options
  	
  	outfit_name = "Random Outfit"
  	creation_date = Time.get_datetime_string_from_system(false, true)
  	
  	return self
  
  # Helper for randomizing parts with "none" option
  func _random_part(options: Array, none_chance: float) -> String:
  	if randf() < none_chance:
  		return "none"
  	
  	var valid_options = options.duplicate()
  	valid_options.erase("none")
  	return valid_options[randi() % valid_options.size()]
  
  # Create a duplicate of this outfit
  func duplicate_outfit() -> PlayerOutfitResource:
  	var new_outfit = PlayerOutfitResource.new()
  	new_outfit.beard = beard
  	new_outfit.lipstick = lipstick
  	new_outfit.eyes = eyes
  	new_outfit.shoes = shoes
  	new_outfit.earrings = earrings
  	new_outfit.hat = hat
  	new_outfit.glasses = glasses
  	new_outfit.clothes_down = clothes_down
  	new_outfit.clothes_up = clothes_up
  	new_outfit.clothes_complete = clothes_complete
  	new_outfit.body = body
  	new_outfit.hair = hair
  	new_outfit.outfit_name = outfit_name + " (Copy)"
  	new_outfit.is_favorite = is_favorite
  	new_outfit.creation_date = Time.get_datetime_string_from_system(false, true)
  	return new_outfit
  
  # Create a new default outfit resource
  static func create_default() -> PlayerOutfitResource:
  	return PlayerOutfitResource.new()
  
  # Check for equality with another outfit
  func equals(other: PlayerOutfitResource) -> bool:
  	return (
  		beard == other.beard and
  		lipstick == other.lipstick and
  		eyes == other.eyes and
  		shoes == other.shoes and
  		earrings == other.earrings and
  		hat == other.hat and
  		glasses == other.glasses and
  		clothes_down == other.clothes_down and
  		clothes_up == other.clothes_up and
  		clothes_complete == other.clothes_complete and
  		body == other.body and
  		hair == other.hair
  	)
  
  # Apply this outfit to character sprites
  func apply_to_sprites(character_sprites: Node2D) -> void:
  	var outfit_dict = to_dictionary()
  	
  	for category in outfit_dict:
  		if character_sprites.has_node(category):
  			var sprite = character_sprites.get_node(category)
  			var value = outfit_dict[category]
  			
  			if value == "none":
  				sprite.visible = false
  			else:
  				sprite.visible = true
  				sprite.animation = value
  				sprite.frame = 1

========================================
Contents of scripts\ui\character_customizer\customizer_controller.gd:
========================================
  class_name CustomizerController
  # UI.gd
  extends Control
  
  # Spieler-Outfit-Eigenschaften
  var body
  var player_outfit
  var selected_outfit_category = ""
  var player_animations
  var options_per_category = {}
  var has_unsaved_changes = false  # Neue Variable für ungespeicherte Änderungen
  
  # Resource-basiertes Outfit System
  var current_outfit_resource: PlayerOutfitResource = null
  
  # Signal für Debugging
  signal debug_message(message)
  
  func _ready():
  	randomize() # Initialisiere den Zufallsgenerator
  	get_node("character_sprites/masks").visible = false
  	player_outfit = get_node("character_sprites").default_outfit
  	player_animations = get_node("character_sprites").animation_frames
  	
  	# Create outfit resource
  	current_outfit_resource = PlayerOutfitResource.new()
  	
  	# Connect to PopupManager
  	PopupManager.dialog_confirmed.connect(_on_dialog_confirmed)
  
  	# UI-Elemente für jede Outfit-Kategorie erstellen
  	setup_outfit_categories()
  
  	# Versuche, gespeicherte Outfits zu laden
  	load_saved_outfit()
  
  	# Bei Programmstart gibt es keine ungespeicherten Änderungen
  	has_unsaved_changes = false
  
  # Erstellt UI-Elemente für alle Outfit-Kategorien
  func setup_outfit_categories():
  	for category in player_outfit:
  		var category_button = Button.new()
  		var items_container = ScrollContainer.new()
  		var item_container_grid = GridContainer.new()
  
  		# Kategorie-Button einrichten
  		category_button.text = category
  		category_button.pressed.connect(_on_category_button_pressed.bind(category))
  		$Outfit_Category_Picker/GridContainer.add_child(category_button)
  
  		# Container für Items einrichten
  		items_container.size = Vector2(620, 400)
  		items_container.position = Vector2(600, 200)
  		items_container.add_child(item_container_grid)
  		items_container.name = category
  		add_child(items_container)
  		items_container.hide()
  
  		# Grid für Items einrichten
  		item_container_grid.columns = 6
  		var current_item = 0
  		var button_size = Vector2(100, 100)
  
  		# Leeren Button für optionale Kategorien hinzufügen
  		if category != "bodies":
  			var empty_button = Button.new()
  			empty_button.custom_minimum_size = button_size
  			empty_button.pressed.connect(_on_item_button_pressed.bind("none"))
  			item_container_grid.add_child(empty_button)
  
  			var animated_sprite = get_node("character_sprites/" + category)
  			animated_sprite.visible = false
  			player_outfit[category] = "none"
  
  		# Alle verfügbaren Items für diese Kategorie hinzufügen
  		while true:
  			current_item += 1
  			var texture = get_node("character_sprites/"+category).sprite_frames.get_frame_texture(str(current_item), 1)
  			if texture == null:
  				break
  
  			var item_texture = TextureRect.new()
  			item_texture.texture = texture
  			item_texture.custom_minimum_size = button_size
  			item_texture.stretch_mode = TextureRect.STRETCH_KEEP_ASPECT_CENTERED
  
  			var item_button = Button.new()
  			item_button.custom_minimum_size = button_size
  			item_button.add_child(item_texture)
  			item_button.pressed.connect(_on_item_button_pressed.bind(str(current_item)))
  			item_container_grid.add_child(item_button)
  
  		options_per_category[category] = current_item - 1
  
  # Aktualisiert die Animations-Frames basierend auf dem gewählten Outfit
  func _process(_delta):
  	for outfit in player_outfit:
  		var animated_sprite = get_node("character_sprites/" + outfit)
  		animated_sprite.animation = player_outfit[outfit]
  		animated_sprite.frame = 1
  
  # Wird aufgerufen, wenn ein Item ausgewählt wird
  func _on_item_button_pressed(item):
  	var animated_sprite = get_node("character_sprites/" + selected_outfit_category)
  	var old_value = player_outfit[selected_outfit_category]
  	var new_value = str(item)
  
  	if new_value == "none":
  		animated_sprite.visible = false
  	else:
  		animated_sprite.visible = true
  
  	# Setze has_unsaved_changes nur, wenn sich etwas geändert hat
  	if old_value != new_value:
  		player_outfit[selected_outfit_category] = new_value
  		has_unsaved_changes = true
  		
  		# Update outfit resource
  		if selected_outfit_category == "bodies":
  			current_outfit_resource.body = new_value
  		elif selected_outfit_category == "hats":
  			current_outfit_resource.hat = new_value
  		elif current_outfit_resource.get(selected_outfit_category) != null:
  			current_outfit_resource.set(selected_outfit_category, new_value)
  	else:
  		player_outfit[selected_outfit_category] = new_value
  
  # Wird aufgerufen, wenn eine Kategorie ausgewählt wird
  func _on_category_button_pressed(category):
  	if selected_outfit_category:
  		get_node(selected_outfit_category).hide()
  	get_node(category).show()
  	selected_outfit_category = category
  
  # Generiert ein zufälliges Outfit
  func _random_button_pressed():
  	current_outfit_resource.randomize_outfit()
  	var outfit_dict = current_outfit_resource.to_dictionary()
  	var had_changes = false
  	
  	# Update the player_outfit from the resource
  	for category in outfit_dict:
  		if player_outfit.has(category):
  			var new_value = outfit_dict[category]
  			if player_outfit[category] != new_value:
  				player_outfit[category] = new_value
  				had_changes = true
  			
  			# Update sprite visibility
  			var animated_sprite = get_node("character_sprites/" + category)
  			if new_value == "none":
  				animated_sprite.visible = false
  			else:
  				animated_sprite.visible = true
  
  	if had_changes:
  		has_unsaved_changes = true
  
  # Speichert das aktuelle Outfit
  func _save_button_pressed():
  	# Update the outfit resource
  	current_outfit_resource.from_dictionary(player_outfit)
  	current_outfit_resource.outfit_name = "Last Saved Outfit"
  
  	# Save to both the favorites and the player's current outfit
  	SaveManager.save_outfit(player_outfit, "Last Saved Outfit")
  	
  	# Ensure the current save data has the outfit
  	if SaveManager.current_save_data:
  		SaveManager.current_save_data.player_outfit = player_outfit.duplicate(true)
  	
  	# Save both settings and game data
  	SaveManager.save_settings()
  	SaveManager.save_game()  # Add this line to ensure full game save
  	
  	has_unsaved_changes = false
  	show_message("Outfit erfolgreich gespeichert!", Color(0.3, 1, 0.3, 1))
  
  # Setzt alle optionalen Teile des Outfits zurück
  func _reset_button_pressed():
  	# Use the resource method to reset
  	current_outfit_resource.reset()
  	var outfit_dict = current_outfit_resource.to_dictionary()
  	var had_changes = false
  	
  	# Apply the reset to player_outfit
  	for category in outfit_dict:
  		if player_outfit.has(category) and category != "bodies":
  			var animated_sprite = get_node("character_sprites/" + category)
  			animated_sprite.visible = false
  			
  			if player_outfit[category] != "none":
  				player_outfit[category] = "none"
  				had_changes = true
  
  	if had_changes:
  		has_unsaved_changes = true
  
  	show_message("Outfit zurückgesetzt!", Color(0.3, 0.7, 1, 1))
  
  # Hilfsfunktion zum Anzeigen von Nachrichten
  func show_message(text, color = Color(1, 1, 1, 1)):
  	if has_node("save_feedback"):
  		var label = get_node("save_feedback")
  		label.text = text
  		label.modulate = color
  
  		# Timer zum Ausblenden nach 2 Sekunden
  		get_tree().create_timer(2.0).timeout.connect(func():
  			if has_node("save_feedback"):
  				get_node("save_feedback").text = ""
  		)
  
  # Lädt das gespeicherte Outfit, falls vorhanden
  func load_saved_outfit():
  	# First try to load from current save data
  	if SaveManager.current_save_data and SaveManager.current_save_data.player_outfit:
  		var saved_outfit = SaveManager.current_save_data.player_outfit
  		
  		# Log for debugging
  		print("Loading outfit from save data: ", saved_outfit)
  		
  		# Update the outfit resource
  		current_outfit_resource.from_dictionary(saved_outfit)
  		
  		# Update the UI
  		for category in saved_outfit:
  			if player_outfit.has(category):
  				var outfit_value = str(saved_outfit[category])
  				player_outfit[category] = outfit_value
  				
  				# Update visibility
  				var animated_sprite = get_node("character_sprites/" + category)
  				if outfit_value == "none":
  					animated_sprite.visible = false
  				else:
  					animated_sprite.visible = true
  		
  		print("Outfit loaded successfully")
  	else:
  		print("No saved outfit found in save data")
  
  
  func _on_back_pressed() -> void:
  	if has_unsaved_changes:
  		PopupManager.confirm(
  			"Nicht gespeicherte Änderungen",
  			"Du hast nicht gespeicherte Änderungen. Möchtest du wirklich ohne Speichern zurückkehren?",
  			"Abbrechen",
  			"Zurück",
  			"back_confirmation"
  		)
  	else:
  		get_tree().change_scene_to_file("res://scenes/ui/settings/settings_menu.tscn")
  
  func _on_dialog_confirmed(dialog_id):
  	if dialog_id == "back_confirmation":
  		get_tree().change_scene_to_file("res://scenes/ui/settings/settings_menu.tscn")

========================================
Contents of scripts\ui\character_customizer\outfit_showcase.gd:
========================================
  class_name OutfitShowcase
  # outfit_showcase.gd
  extends Control
  
  var current_outfits = {}
  var preview_container
  var outfit_grid
  var back_button
  var outfit_name_field
  var save_button
  var delete_button
  var preview_helper
  
  func _ready():
  	preview_helper = load("res://scripts/ui/character_customizer/preview_helper.gd").new()
  	add_child(preview_helper)
  	
  	# UI erstellen
  	setup_ui()
  	
  	# Gespeicherte Outfits laden
  	load_saved_outfits()
  
  func setup_ui():
  	# Container für die Vorschau
  	preview_container = ScrollContainer.new()
  	preview_container.position = Vector2(50, 50)
  	preview_container.size = Vector2(900, 400)
  	add_child(preview_container)
  	
  	# Grid für Outfit-Vorschaubilder
  	outfit_grid = GridContainer.new()
  	outfit_grid.columns = 4
  	preview_container.add_child(outfit_grid)
  	
  	# Textfeld für Outfit-Namen
  	var name_label = Label.new()
  	name_label.text = "Outfit-Name:"
  	name_label.position = Vector2(50, 470)
  	add_child(name_label)
  	
  	outfit_name_field = LineEdit.new()
  	outfit_name_field.position = Vector2(150, 470)
  	outfit_name_field.size = Vector2(300, 30)
  	outfit_name_field.placeholder_text = "Mein cooles Outfit"
  	add_child(outfit_name_field)
  	
  	# Save-Button
  	save_button = Button.new()
  	save_button.text = "Speichern"
  	save_button.position = Vector2(470, 470)
  	save_button.size = Vector2(120, 30)
  	save_button.pressed.connect(_on_save_pressed)
  	add_child(save_button)
  	
  	# Delete-Button
  	delete_button = Button.new()
  	delete_button.text = "Löschen"
  	delete_button.position = Vector2(600, 470)
  	delete_button.size = Vector2(120, 30)
  	delete_button.pressed.connect(_on_delete_pressed)
  	add_child(delete_button)
  	
  	# Back-Button
  	back_button = Button.new()
  	back_button.text = "Zurück"
  	back_button.position = Vector2(400, 550)
  	back_button.size = Vector2(200, 40)
  	back_button.pressed.connect(_on_back_pressed)
  	add_child(back_button)
  
  # Lädt alle gespeicherten Outfits und zeigt sie an
  func load_saved_outfits():
  	current_outfits = preview_helper.load_favorites()
  	
  	# UI aktualisieren
  	update_showcase()
  
  # Aktualisiert die Anzeige der Outfits
  func update_showcase():
  	# Alle vorherigen Kinder entfernen
  	for child in outfit_grid.get_children():
  		outfit_grid.remove_child(child)
  		child.queue_free()
  	
  	# Aktuelle Outfit-Liste durchgehen
  	for outfit_name in current_outfits:
  		var outfit_config = current_outfits[outfit_name]
  		
  		# Container für jedes Outfit
  		var outfit_container = VBoxContainer.new()
  		outfit_grid.add_child(outfit_container)
  		
  		# Vorschaubild generieren
  		var preview_image = await preview_helper.generate_outfit_preview(
  			get_node("/root/Main/character_sprites"), 
  			outfit_config
  		)
  		
  		# TextureRect für das Vorschaubild
  		var preview_rect = TextureRect.new()
  		var image_texture = ImageTexture.create_from_image(preview_image)
  		preview_rect.texture = image_texture
  		preview_rect.custom_minimum_size = Vector2(200, 200)
  		preview_rect.stretch_mode = TextureRect.STRETCH_KEEP_ASPECT_CENTERED
  		outfit_container.add_child(preview_rect)
  		
  		# Label für den Namen
  		var name_label = Label.new()
  		name_label.text = outfit_name
  		name_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
  		outfit_container.add_child(name_label)
  		
  		# Button zum Laden dieses Outfits
  		var load_button = Button.new()
  		load_button.text = "Laden"
  		load_button.pressed.connect(_on_load_outfit_pressed.bind(outfit_name))
  		outfit_container.add_child(load_button)
  
  # Event-Handler
  
  func _on_save_pressed():
  	var current_outfit = get_node("/root/Main").get_current_outfit()
  	var name = outfit_name_field.text
  	
  	if name.empty():
  		name = "Outfit " + str(current_outfits.size() + 1)
  	
  	# Outfit zu Favoriten hinzufügen
  	preview_helper.save_to_favorites(current_outfit, name)
  	
  	# Liste aktualisieren
  	load_saved_outfits()
  
  func _on_delete_pressed():
  	var name = outfit_name_field.text
  	if current_outfits.has(name):
  		current_outfits.erase(name)
  		
  		# Aktualisierte Liste speichern
  		var config = ConfigFile.new()
  		config.set_value("favorites", "outfits", current_outfits)
  		config.save("user://favorites.cfg")
  		
  		# UI aktualisieren
  		update_showcase()
  
  func _on_load_outfit_pressed(outfit_name):
  	var outfit_config = current_outfits[outfit_name]
  	get_node("/root/Main").apply_outfit(outfit_config)
  	
  	# Eingabefeld aktualisieren
  	outfit_name_field.text = outfit_name
  
  func _on_back_pressed():
  	get_tree().change_scene_to_file("res://scenes/ui/character_customizer/customizer.tscn")

========================================
Contents of scripts\ui\character_customizer\preview_helper.gd:
========================================
  class_name PreviewHelper
  # preview_helper.gd
  # Diese Datei enthält Hilfsfunktionen für die Vorschau im Character-Customizer
  
  extends Node
  
  # Cache für Outfit-Vorschaubilder
  var preview_cache = {}
  
  # Generiert ein Vorschaubild für ein komplettes Outfit
  # Kann verwendet werden, um mehrere Outfits nebeneinander anzuzeigen
  func generate_outfit_preview(character_sprites, outfit_config):
  	var viewport = SubViewport.new()
  	viewport.size = Vector2i(128, 128)
  	viewport.transparent_bg = true
  	viewport.render_target_update_mode = SubViewport.UPDATE_ONCE
  	
  	var sprites_instance = character_sprites.duplicate()
  	viewport.add_child(sprites_instance)
  	
  	# Positioniere die Sprites in der Mitte des Viewports
  	sprites_instance.position = Vector2(64, 64)
  	sprites_instance.scale = Vector2(4, 4)
  	
  	# Setze das Outfit gemäß der Konfiguration
  	for category in outfit_config:
  		if sprites_instance.has_node(category):
  			var sprite = sprites_instance.get_node(category)
  			if str(outfit_config[category]) == "none":
  				sprite.visible = false
  			else:
  				sprite.visible = true
  				sprite.animation = str(outfit_config[category])
  				sprite.frame = 1
  	
  	# Rendern und Vorschaubild zurückgeben
  	await get_tree().process_frame
  	await get_tree().process_frame
  	
  	var texture = viewport.get_texture()
  	var image = texture.get_image()
  	
  	# Viewport und Duplikat aufräumen
  	viewport.remove_child(sprites_instance)
  	sprites_instance.queue_free()
  	viewport.queue_free()
  	
  	return image
  
  # Speichert ein Outfit in einem gesonderten Bereich für Favoriten
  func save_to_favorites(outfit_config, name = ""):
  	var favorites = load_favorites()
  	
  	if name.empty():
  		name = "Outfit " + str(favorites.size() + 1)
  	
  	favorites[name] = outfit_config
  	
  	var config = ConfigFile.new()
  	config.set_value("favorites", "outfits", favorites)
  	var err = config.save("user://favorites.cfg")
  	
  	return err == OK
  
  # Lädt alle gespeicherten Favoriten
  func load_favorites():
  	var config = ConfigFile.new()
  	var err = config.load("user://favorites.cfg")
  	
  	if err == OK:
  		return config.get_value("favorites", "outfits", {})
  	else:
  		return {}
  
  # Konvertiert ein Outfit in ein exportierbares Format (z.B. JSON)
  func export_outfit_to_json(outfit_config):
  	return JSON.stringify(outfit_config)
  
  # Importiert ein Outfit aus einem exportierten Format
  func import_outfit_from_json(json_string):
  	var json = JSON.new()
  	var error = json.parse(json_string)
  	if error == OK:
  		return json.get_data()
  	else:
  		return null

========================================
Contents of scripts\ui\controls\attack_button.gd:
========================================
  class_name AttackButton
  extends Button
  
  
  @onready var attack = $"."
  
  func _ready():
  	attack.modulate = Color(2, 2, 2, 0.5) 
  
  
  func _on_button_up():
  	attack.modulate = Color(2, 2, 2, 0.5) 
  	Input.action_release("attack")
  
  
  func _on_button_down():
  	attack.modulate = Color(1.0, 1.0, 1.0, 0.5) 
  	Input.action_press("attack")

========================================
Contents of scripts\ui\controls\defend_button.gd:
========================================
  class_name DefendButton
  extends Button
  
  
  @onready var defend = $"."
  
  func _ready():
  	defend.modulate = Color(2, 2, 2, 0.5) 
  
  
  func _on_button_up():
  	defend.modulate = Color(2, 2, 2, 0.5) 
  	Input.action_release("defend")
  
  func _on_button_down():
  	defend.modulate = Color(1.0, 1.0, 1.0, 0.5) 
  	Input.action_press("defend")
  	

========================================
Contents of scripts\ui\dialogs\popup_dialog.gd:
========================================
  class_name PopupDialog
  extends CanvasLayer
  
  # Signal, wenn der primäre (rechte) Button gedrückt wird
  signal confirmed
  # Signal, wenn der sekundäre (linke) Button gedrückt wird
  signal canceled
  
  # UI-Elemente
  var dimmer
  var dialog_panel
  var title_label
  var message_label
  var button_container
  var cancel_button
  var confirm_button
  
  # Standardwerte
  var _title_text = "Bestätigung"
  var _message_text = "Möchtest du fortfahren?"
  var _cancel_text = "Abbrechen"
  var _confirm_text = "Bestätigen"
  var _confirm_color = Color(0.7, 0.2, 0.2, 1)  # Rot
  var _auto_hide = true
  
  func _init():
  	# Erstelle alle UI-Elemente programmatisch
  	_create_ui()
  
  func _ready():
  	# Bei Start nicht anzeigen
  	hide()
  	
  	# Verbinde Button-Signale
  	cancel_button.pressed.connect(_on_cancel_pressed)
  	confirm_button.pressed.connect(_on_confirm_pressed)
  
  # Erstellt die komplette UI-Struktur
  func _create_ui():
  	# Dimmer (Hintergrund-Verdunkelung)
  	dimmer = ColorRect.new()
  	dimmer.name = "Dimmer"
  	dimmer.color = Color(0, 0, 0, 0.6)  # Halbtransparentes Schwarz
  	add_child(dimmer)
  	
  	# DialogPanel
  	dialog_panel = Panel.new()
  	dialog_panel.name = "DialogPanel"
  	
  	# Panel-Design
  	var panel_style = StyleBoxFlat.new()
  	panel_style.bg_color = Color(0.12, 0.12, 0.15, 1.0)
  	panel_style.border_width_left = 2
  	panel_style.border_width_top = 2
  	panel_style.border_width_right = 2
  	panel_style.border_width_bottom = 2
  	panel_style.border_color = Color(0.6, 0.6, 1.0, 0.7)
  	panel_style.corner_radius_top_left = 15
  	panel_style.corner_radius_top_right = 15
  	panel_style.corner_radius_bottom_left = 15
  	panel_style.corner_radius_bottom_right = 15
  	panel_style.shadow_color = Color(0, 0, 0, 0.3)
  	panel_style.shadow_size = 8
  	dialog_panel.add_theme_stylebox_override("panel", panel_style)
  	dimmer.add_child(dialog_panel)
  	
  	# Titel
  	title_label = Label.new()
  	title_label.name = "Title"
  	title_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
  	title_label.add_theme_font_size_override("font_size", 24)
  	title_label.add_theme_color_override("font_color", Color(1, 1, 1, 1))
  	dialog_panel.add_child(title_label)
  	
  	# Nachricht
  	message_label = Label.new()
  	message_label.name = "Message"
  	message_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
  	message_label.autowrap_mode = TextServer.AUTOWRAP_WORD_SMART
  	message_label.add_theme_font_size_override("font_size", 18)
  	message_label.add_theme_color_override("font_color", Color(0.9, 0.9, 0.9, 1))
  	dialog_panel.add_child(message_label)
  	
  	# Buttons-Container
  	button_container = HBoxContainer.new()
  	button_container.name = "ButtonContainer"
  	button_container.alignment = BoxContainer.ALIGNMENT_CENTER
  	button_container.add_theme_constant_override("separation", 20)
  	dialog_panel.add_child(button_container)
  	
  	# Button-Style vorbereiten
  	var button_style_normal = StyleBoxFlat.new()
  	button_style_normal.bg_color = Color(0.2, 0.2, 0.25, 1)
  	button_style_normal.border_width_left = 0
  	button_style_normal.border_width_top = 0
  	button_style_normal.border_width_right = 0
  	button_style_normal.border_width_bottom = 0
  	button_style_normal.corner_radius_top_left = 8
  	button_style_normal.corner_radius_top_right = 8
  	button_style_normal.corner_radius_bottom_left = 8
  	button_style_normal.corner_radius_bottom_right = 8
  	
  	var button_style_hover = StyleBoxFlat.new()
  	button_style_hover.bg_color = Color(0.25, 0.25, 0.3, 1)
  	button_style_hover.border_width_left = 0
  	button_style_hover.border_width_top = 0
  	button_style_hover.border_width_right = 0
  	button_style_hover.border_width_bottom = 0
  	button_style_hover.corner_radius_top_left = 8
  	button_style_hover.corner_radius_top_right = 8
  	button_style_hover.corner_radius_bottom_left = 8
  	button_style_hover.corner_radius_bottom_right = 8
  	
  	var button_style_pressed = StyleBoxFlat.new()
  	button_style_pressed.bg_color = Color(0.15, 0.15, 0.2, 1)
  	button_style_pressed.border_width_left = 0
  	button_style_pressed.border_width_top = 0
  	button_style_pressed.border_width_right = 0
  	button_style_pressed.border_width_bottom = 0
  	button_style_pressed.corner_radius_top_left = 8
  	button_style_pressed.corner_radius_top_right = 8
  	button_style_pressed.corner_radius_bottom_left = 8
  	button_style_pressed.corner_radius_bottom_right = 8
  	
  	# Abbrechen-Button
  	cancel_button = Button.new()
  	cancel_button.name = "CancelButton"
  	cancel_button.add_theme_font_size_override("font_size", 18)
  	cancel_button.add_theme_stylebox_override("normal", button_style_normal.duplicate())
  	cancel_button.add_theme_stylebox_override("hover", button_style_hover.duplicate())
  	cancel_button.add_theme_stylebox_override("pressed", button_style_pressed.duplicate())
  	button_container.add_child(cancel_button)
  	
  	# Bestätigen-Button
  	confirm_button = Button.new()
  	confirm_button.name = "ConfirmButton"
  	confirm_button.add_theme_font_size_override("font_size", 18)
  	
  	# Rote Button-Stile
  	var confirm_style_normal = button_style_normal.duplicate()
  	confirm_style_normal.bg_color = Color(0.7, 0.2, 0.2, 1)
  	var confirm_style_hover = button_style_hover.duplicate()
  	confirm_style_hover.bg_color = Color(0.8, 0.3, 0.3, 1)
  	var confirm_style_pressed = button_style_pressed.duplicate()
  	confirm_style_pressed.bg_color = Color(0.6, 0.15, 0.15, 1)
  	
  	confirm_button.add_theme_stylebox_override("normal", confirm_style_normal)
  	confirm_button.add_theme_stylebox_override("hover", confirm_style_hover)
  	confirm_button.add_theme_stylebox_override("pressed", confirm_style_pressed)
  	button_container.add_child(confirm_button)
  
  # Setzt Text-Inhalte und Farben
  func setup(title: String = "", message: String = "", 
  		   cancel_text: String = "", confirm_text: String = "",
  		   confirm_button_color: Color = Color(0.7, 0.2, 0.2, 1)):
  	
  	# Setze nur nicht-leere Werte
  	if title:
  		_title_text = title
  	if message:
  		_message_text = message
  	if cancel_text:
  		_cancel_text = cancel_text
  	if confirm_text:
  		_confirm_text = confirm_text
  		
  	_confirm_color = confirm_button_color
  	
  	return self  # Für Methoden-Verkettung
  
  # Einstellen, ob das Popup sich automatisch schließen soll
  func set_auto_hide(value: bool):
  	_auto_hide = value
  	return self  # Für Methoden-Verkettung
  
  # Zeigt den Dialog an
  func popup():
  	# Fenstergröße aktualisieren
  	var viewport_size = get_viewport().get_visible_rect().size
  	dimmer.size = viewport_size
  	
  	var dialog_width = min(500, viewport_size.x * 0.8)
  	var dialog_height = 230
  	dialog_panel.size = Vector2(dialog_width, dialog_height)
  	dialog_panel.position = (viewport_size - dialog_panel.size) / 2
  	dialog_panel.pivot_offset = dialog_panel.size / 2
  	
  	# Layout aktualisieren
  	title_label.position = Vector2(0, 20)
  	title_label.size = Vector2(dialog_width, 30)
  	
  	message_label.position = Vector2(20, 60)
  	message_label.size = Vector2(dialog_width - 40, 60)
  	
  	button_container.position = Vector2(20, dialog_height - 80)
  	button_container.size = Vector2(dialog_width - 40, 60)
  	
  	cancel_button.custom_minimum_size = Vector2(dialog_width * 0.35, 60)
  	confirm_button.custom_minimum_size = Vector2(dialog_width * 0.35, 60)
  	
  	# Aktualisiere UI
  	title_label.text = _title_text
  	message_label.text = _message_text
  	cancel_button.text = _cancel_text
  	confirm_button.text = _confirm_text
  	
  	# Setze Button-Farbe
  	var normal_style = confirm_button.get_theme_stylebox("normal").duplicate()
  	var hover_style = confirm_button.get_theme_stylebox("hover").duplicate()
  	var pressed_style = confirm_button.get_theme_stylebox("pressed").duplicate()
  	
  	normal_style.bg_color = _confirm_color
  	hover_style.bg_color = _confirm_color.lightened(0.1)
  	pressed_style.bg_color = _confirm_color.darkened(0.1)
  	
  	confirm_button.add_theme_stylebox_override("normal", normal_style)
  	confirm_button.add_theme_stylebox_override("hover", hover_style)
  	confirm_button.add_theme_stylebox_override("pressed", pressed_style)
  	
  	# Dialog anzeigen mit Animation
  	show()
  	dimmer.modulate = Color(1, 1, 1, 0)
  	
  	var tween = create_tween()
  	tween.tween_property(dimmer, "modulate", Color(1, 1, 1, 1), 0.3).set_ease(Tween.EASE_OUT)
  	
  	# Dialog-Panel Animation (Skalierung)
  	dialog_panel.scale = Vector2(0.9, 0.9)
  	tween.parallel().tween_property(dialog_panel, "scale", Vector2(1, 1), 0.3).set_ease(Tween.EASE_OUT)
  	
  	return self  # Für Methoden-Verkettung
  
  # Schließt den Dialog
  func close():
  	var tween = create_tween()
  	tween.tween_property(dimmer, "modulate", Color(1, 1, 1, 0), 0.2).set_ease(Tween.EASE_IN)
  	tween.parallel().tween_property(dialog_panel, "scale", Vector2(0.9, 0.9), 0.2).set_ease(Tween.EASE_IN)
  	
  	# Warte auf das Ende der Animation
  	await tween.finished
  	hide()
  
  # Button-Handling
  func _on_cancel_pressed():
  	emit_signal("canceled")
  	if _auto_hide:
  		close()
  
  func _on_confirm_pressed():
  	emit_signal("confirmed")
  	if _auto_hide:
  		close()

========================================
Contents of scripts\ui\dialogs\popup_manager.gd:
========================================
  extends Node
  
  # Signal, dass ein zuvor erstellter Dialog bestätigt wurde
  signal dialog_confirmed(dialog_id: String)
  # Signal, dass ein zuvor erstellter Dialog abgebrochen wurde
  signal dialog_canceled(dialog_id: String)
  
  # Speichert alle aktiven Popups
  var _active_popups = {}
  
  # Zeigt eine einfache Bestätigungsabfrage
  func confirm(title: String, message: String, 
  			 cancel_text: String = "Abbrechen", confirm_text: String = "Bestätigen",
  			 dialog_id: String = "") -> String:
  				
  	# Generiere eine eindeutige ID, falls keine angegeben wurde
  	var id = dialog_id if dialog_id else _generate_id()
  	
  	# Erstelle und zeige das Popup an
  	var popup = _create_popup()
  	popup.setup(title, message, cancel_text, confirm_text)
  	
  	# Verbinde Signale, um weiterzuleiten
  	popup.confirmed.connect(func(): 
  		emit_signal("dialog_confirmed", id)
  		_active_popups.erase(id)
  	)
  	popup.canceled.connect(func(): 
  		emit_signal("dialog_canceled", id)
  		_active_popups.erase(id)
  	)
  	
  	# Speichere das Popup für spätere Referenz
  	_active_popups[id] = popup
  	
  	# Zeige das Popup an
  	popup.popup()
  	
  	return id
  
  # Zeigt einen Warnungs-Dialog
  func warning(title: String, message: String, button_text: String = "OK") -> String:
  	var id = _generate_id()
  	var popup = _create_popup()
  	
  	# Stelle Warnungs-Dialog ein
  	popup.setup(
  		title, 
  		message, 
  		"", # Kein Abbrechen-Button
  		button_text,
  		Color(0.9, 0.6, 0.1, 1) # Orange für Warnungen
  	)
  	
  	# Verbinde Signale
  	popup.confirmed.connect(func():
  		emit_signal("dialog_confirmed", id)
  		_active_popups.erase(id)
  	)
  	
  	# Verstecke den Abbrechen-Button
  	popup.cancel_button.visible = false
  	
  	# Speichere und zeige an
  	_active_popups[id] = popup
  	popup.popup()
  	
  	return id
  
  # Zeigt einen Fehler-Dialog
  func error(title: String, message: String, button_text: String = "OK") -> String:
  	var id = _generate_id()
  	var popup = _create_popup()
  	
  	# Stelle Fehler-Dialog ein
  	popup.setup(
  		title, 
  		message, 
  		"", # Kein Abbrechen-Button
  		button_text,
  		Color(0.8, 0.1, 0.1, 1) # Rot für Fehler
  	)
  	
  	# Verbinde Signale
  	popup.confirmed.connect(func():
  		emit_signal("dialog_confirmed", id)
  		_active_popups.erase(id)
  	)
  	
  	# Verstecke den Abbrechen-Button
  	popup.cancel_button.visible = false
  	
  	# Speichere und zeige an
  	_active_popups[id] = popup
  	popup.popup()
  	
  	return id
  
  # Zeigt eine Info-Nachricht
  func info(title: String, message: String, button_text: String = "OK") -> String:
  	var id = _generate_id()
  	var popup = _create_popup()
  	
  	# Stelle Info-Dialog ein
  	popup.setup(
  		title, 
  		message, 
  		"", # Kein Abbrechen-Button
  		button_text,
  		Color(0.2, 0.6, 0.8, 1) # Blau für Info
  	)
  	
  	# Verbinde Signale
  	popup.confirmed.connect(func():
  		emit_signal("dialog_confirmed", id)
  		_active_popups.erase(id)
  	)
  	
  	# Verstecke den Abbrechen-Button
  	popup.cancel_button.visible = false
  	
  	# Speichere und zeige an
  	_active_popups[id] = popup
  	popup.popup()
  	
  	return id
  
  # Schließt einen bestimmten Dialog
  func close_dialog(dialog_id: String) -> bool:
  	if _active_popups.has(dialog_id):
  		_active_popups[dialog_id].close()
  		_active_popups.erase(dialog_id)
  		return true
  	return false
  
  # Schließt alle aktiven Dialoge
  func close_all_dialogs():
  	for id in _active_popups:
  		_active_popups[id].close()
  	_active_popups.clear()
  
  # Erstellt eine neue Popup-Instanz
  func _create_popup():
  	var popup_script = load("res://scripts/ui/dialogs/popup_dialog.gd")
  	# Hier ist die Korrektur: Wir erstellen einen CanvasLayer statt eines Node
  	var popup_instance = CanvasLayer.new()
  	popup_instance.set_script(popup_script)
  	add_child(popup_instance)
  	return popup_instance
  
  # Generiert eine eindeutige ID für Dialoge
  func _generate_id() -> String:
  	return "dialog_" + str(randi())

========================================
Contents of scripts\ui\hud\hud_controller.gd:
========================================
  class_name HUDController
  extends CanvasLayer
  
  # HUD Components reference
  @onready var hearts_full = $HeartsFull
  @onready var coins_label = $LabelCoinSum
  @onready var bottle = $bottle
  @onready var elixir_fill = $elixir
  @onready var initial_heart_size = $HeartsFull.size
  @onready var initial_heart_position = $HeartsFull.position
  
  # Optional components
  @onready var objective_display = $ObjectiveTracker if has_node("ObjectiveTracker") else null
  @onready var ability_timer_display = $AbilityTimer if has_node("AbilityTimer") else null
  @onready var notification_container = $NotificationContainer if has_node("NotificationContainer") else null
  
  # UI Theme reference
  var ui_theme = null
  
  func _ready():
  	# Initialize UI theme
  	ui_theme = get_node_or_null("/root/UITheme")
  	if ui_theme:
  		_apply_theme()
  		ui_theme.theme_changed.connect(_on_theme_changed)
  	
  	# Register with GlobalHUD
  	if get_node_or_null("/root/GlobalHUD"):
  		GlobalHUD.register_hud(self)
  		
  		# Connect to GlobalHUD signals
  		GlobalHUD.health_changed.connect(_on_global_health_changed)
  		GlobalHUD.coins_changed.connect(_on_global_coins_changed)
  		GlobalHUD.elixir_changed.connect(_on_global_elixir_changed)
  		GlobalHUD.power_up_activated.connect(_on_global_power_up_activated)
  		GlobalHUD.power_up_deactivated.connect(_on_global_power_up_deactivated)
  
  # --- VISUAL UPDATE METHODS ---
  # These don't modify game state, only update the visual representation
  
  func update_health_display(current_health: float, max_health: float) -> void:
  	if hearts_full:
  		hearts_full.size.x = current_health * initial_heart_size.x
  		hearts_full.position.x = initial_heart_position.x - ((current_health-1) * initial_heart_size.x)
  
  func update_coins_display(amount: int) -> void:
  	if coins_label:
  		coins_label.text = str(amount)
  
  func update_elixir_display(fill_level: float) -> void:
  	if elixir_fill and bottle:
  		# Enable region clipping for partial display
  		elixir_fill.region_enabled = true
  		
  		# Get texture size (unscaled)
  		var tex_size = elixir_fill.texture.get_size()
  		
  		# Calculate visible height based on fill level
  		var visible_height = tex_size.y * fill_level
  		
  		# Set the region rect (clip from bottom)
  		elixir_fill.region_rect = Rect2(
  			Vector2(0, tex_size.y - visible_height),
  			Vector2(tex_size.x, visible_height)
  		)
  		
  		# Position the fill inside the bottle
  		var bottle_texture_size = bottle.texture.get_size()
  		var elixir_texture_size = elixir_fill.texture.get_size()
  		
  		var bottle_scale = bottle.scale
  		var elixir_scale = elixir_fill.scale
  		
  		var bottle_size = bottle_texture_size.y * bottle_scale.y
  		var elixir_size = visible_height * elixir_scale.y
  		
  		# Center the elixir horizontally and position it at the bottom of bottle
  		elixir_fill.position.x = bottle.position.x
  		elixir_fill.position.y = bottle.position.y + ((bottle_size - elixir_size) / 2)
  
  func update_power_up_display(power_up_name: String, duration: float) -> void:
  	if ability_timer_display:
  		ability_timer_display.show_timer(power_up_name, duration)
  
  func hide_power_up_display(power_up_name: String) -> void:
  	if ability_timer_display:
  		ability_timer_display.hide_timer(power_up_name)
  
  # --- VISUAL EFFECTS ---
  
  func play_damage_effect() -> void:
  	var canvas_modulate = get_node_or_null("DamageEffect")
  	if canvas_modulate:
  		var tween = create_tween()
  		canvas_modulate.color = Color(1, 0, 0, 0.3)
  		canvas_modulate.visible = true
  		tween.tween_property(canvas_modulate, "color:a", 0.0, 0.5)
  		tween.tween_callback(func(): canvas_modulate.visible = false)
  
  func play_healing_effect() -> void:
  	var canvas_modulate = get_node_or_null("HealEffect")
  	if canvas_modulate:
  		var tween = create_tween()
  		canvas_modulate.color = Color(0, 1, 0, 0.3)
  		canvas_modulate.visible = true
  		tween.tween_property(canvas_modulate, "color:a", 0.0, 0.5)
  		tween.tween_callback(func(): canvas_modulate.visible = false)
  
  func play_coin_effect() -> void:
  	if coins_label:
  		var tween = create_tween()
  		tween.tween_property(coins_label, "modulate", Color(1, 1, 0, 1), 0.1)
  		tween.tween_property(coins_label, "modulate", Color(1, 1, 1, 1), 0.2)
  
  func play_elixir_effect() -> void:
  	if elixir_fill:
  		var tween = create_tween()
  		tween.tween_property(elixir_fill, "modulate", Color(1.5, 1.5, 1.5, 1), 0.1)
  		tween.tween_property(elixir_fill, "modulate", Color(1, 1, 1, 1), 0.2)
  
  # --- SIGNAL HANDLERS ---
  
  func _on_global_health_changed(new_health, _max_health):
  	update_health_display(new_health, _max_health)
  
  func _on_global_coins_changed(new_amount):
  	update_coins_display(new_amount)
  
  func _on_global_elixir_changed(new_level):
  	update_elixir_display(new_level)
  
  func _on_global_power_up_activated(power_up_name, duration):
  	update_power_up_display(power_up_name, duration)
  
  func _on_global_power_up_deactivated(power_up_name):
  	hide_power_up_display(power_up_name)
  
  func _on_theme_changed(_theme_name):
  	_apply_theme()
  
  func _apply_theme() -> void:
  	if ui_theme:
  		# Apply theme to various HUD elements
  		if coins_label:
  			coins_label.add_theme_color_override("font_color", ui_theme.get_color("accent"))
  
  # --- LEGACY API (Forwards to GlobalHUD) ---
  
  func set_lifes(value: float) -> void:
  	if get_node_or_null("/root/GlobalHUD"):
  		var change_amount = value - GlobalHUD.current_health
  		GlobalHUD.change_health(change_amount)
  
  func get_lifes() -> float:
  	if get_node_or_null("/root/GlobalHUD"):
  		return GlobalHUD.current_health
  	return 0.0
  
  var lifes: float:
  	get: return get_lifes()
  	set(value): set_lifes(value)
  
  func change_life(amount: float) -> void:
  	if get_node_or_null("/root/GlobalHUD"):
  		GlobalHUD.change_health(amount)
  
  func change_health(amount: float) -> void:
  	if get_node_or_null("/root/GlobalHUD"):
  		GlobalHUD.change_health(amount)
  
  func add_coins(amount: int = 1) -> void:
  	if get_node_or_null("/root/GlobalHUD"):
  		GlobalHUD.add_coins(amount)
  
  func set_coins(amount: int) -> void:
  	if get_node_or_null("/root/GlobalHUD"):
  		GlobalHUD.set_coins(amount)
  
  func coin_collected() -> void:
  	if get_node_or_null("/root/GlobalHUD"):
  		GlobalHUD.coin_collected()
  
  func set_elixir_fill(level: float) -> void:
  	if get_node_or_null("/root/GlobalHUD"):
  		GlobalHUD.update_elixir_fill(level - GlobalHUD.elixir_fill_level)
  
  func collect_softpower(amount: float = 0.25) -> void:
  	if get_node_or_null("/root/GlobalHUD"):
  		GlobalHUD.collect_softpower(amount)

========================================
Contents of scripts\ui\main_menu\camera.gd:
========================================
  class_name Camera
  extends Camera2D
  
  
  # Called when the node enters the scene tree for the first time.
  func _ready():
  	pass # Replace with function body.
  
  
  # Called every frame. 'delta' is the elapsed time since the previous frame.
  func _process(delta):
  	pass

========================================
Contents of scripts\ui\main_menu\customizer_button.gd:
========================================
  class_name CustomizerButton
  extends Button
  
  
  # Called when the node enters the scene tree for the first time.
  func _ready():
  	pass # Replace with function body.
  
  
  # Called every frame. 'delta' is the elapsed time since the previous frame.
  func _process(delta):
  	pass

========================================
Contents of scripts\ui\main_menu\main_menu.gd:
========================================
  class_name MainMenu
  extends Node2D
  
  
  func _on_exit_button_pressed():
  	get_tree().quit()
  
  
  func _on_settings_button_pressed():
  	get_tree().change_scene_to_file("res://scenes/ui/settings/settings_menu.tscn")
  
  
  func _on_start_button_pressed():
  	get_tree().change_scene_to_file("res://scenes/levels/adventure_mode/base_level.tscn")

========================================
Contents of scripts\ui\main_menu\menu_buttons.gd:
========================================
  class_name MenuButtons
  extends Button
  
  
  # Called when the node enters the scene tree for the first time.
  func _ready():
  	pass # Replace with function body.
  
  
  # Called every frame. 'delta' is the elapsed time since the previous frame.
  func _process(_delta):
  	pass

========================================
Contents of scripts\ui\main_menu\start_background.gd:
========================================
  class_name StartBackground
  extends ParallaxBackground
  
  var scrolling_speed = 50
  # Called every frame. 'delta' is the elapsed time since the previous frame.
  func _process(delta):
  	scroll_offset.x -= scrolling_speed * delta

========================================
Contents of scripts\ui\objective_tracker.gd:
========================================
  class_name ObjectiveTracker
  extends Control
  
  ## A UI component for tracking and displaying game objectives
  ## Supports multiple objectives with progress tracking
  
  # UI components
  @onready var objectives_container = $ObjectivesContainer
  @onready var objective_template = $ObjectiveTemplate
  
  # Data structure for tracking objectives
  var objectives = {}
  
  # Optional theme reference
  var ui_theme = null
  
  # Signals
  signal objective_added(objective_id, description, total)
  signal objective_updated(objective_id, progress, total)
  signal objective_completed(objective_id)
  signal all_objectives_completed()
  
  func _ready():
  	# Hide the template
  	if objective_template:
  		objective_template.visible = false
  	
  	# Try to get UI theme
  	ui_theme = get_node_or_null("/root/UITheme")
  	if ui_theme:
  		ui_theme.theme_changed.connect(_on_theme_changed)
  		_apply_theme()
  
  # Add a new objective to track
  func add_objective(objective_id: String, description: String, total: int = 1) -> bool:
  	if objectives.has(objective_id):
  		push_warning("Objective already exists: " + objective_id)
  		return false
  	
  	# Create new objective data
  	objectives[objective_id] = {
  		"description": description,
  		"progress": 0,
  		"total": total,
  		"completed": false,
  		"ui_element": null
  	}
  	
  	# Create UI element
  	_create_objective_ui(objective_id)
  	
  	emit_signal("objective_added", objective_id, description, total)
  	return true
  
  # Update an objective's progress
  func update_objective(objective_id: String, progress: int, total: int = -1, description: String = "") -> bool:
  	if not objectives.has(objective_id):
  		push_warning("Cannot update non-existent objective: " + objective_id)
  		return false
  	
  	var objective = objectives[objective_id]
  	
  	# Update the progress
  	objective.progress = progress
  	
  	# Update total if specified
  	if total > 0:
  		objective.total = total
  		
  	# Update description if provided
  	if description != "":
  		objective.description = description
  	
  	# Check if newly completed
  	var newly_completed = false
  	if progress >= objective.total and not objective.completed:
  		objective.completed = true
  		newly_completed = true
  	
  	# Update UI
  	_update_objective_ui(objective_id)
  	
  	# Handle completion
  	if newly_completed:
  		emit_signal("objective_completed", objective_id)
  		_check_all_objectives_completed()
  	else:
  		emit_signal("objective_updated", objective_id, progress, objective.total)
  	
  	return true
  
  # Mark an objective as complete
  func complete_objective(objective_id: String) -> bool:
  	if not objectives.has(objective_id):
  		push_warning("Cannot complete non-existent objective: " + objective_id)
  		return false
  	
  	var objective = objectives[objective_id]
  	
  	# Check if already completed
  	if objective.completed:
  		return true
  	
  	# Set as completed
  	objective.progress = objective.total
  	objective.completed = true
  	
  	# Update UI
  	_update_objective_ui(objective_id)
  	
  	emit_signal("objective_completed", objective_id)
  	_check_all_objectives_completed()
  	
  	return true
  
  # Remove an objective
  func remove_objective(objective_id: String) -> bool:
  	if not objectives.has(objective_id):
  		push_warning("Cannot remove non-existent objective: " + objective_id)
  		return false
  	
  	var objective = objectives[objective_id]
  	
  	# Remove UI element if it exists
  	if objective.ui_element and is_instance_valid(objective.ui_element):
  		objective.ui_element.queue_free()
  	
  	# Remove from tracking
  	objectives.erase(objective_id)
  	
  	return true
  
  # Clear all objectives
  func clear_all_objectives() -> void:
  	# Remove all UI elements
  	for objective_id in objectives:
  		var objective = objectives[objective_id]
  		if objective.ui_element and is_instance_valid(objective.ui_element):
  			objective.ui_element.queue_free()
  	
  	# Clear the tracking dictionary
  	objectives.clear()
  
  # Check if all objectives are completed
  func are_all_objectives_completed() -> bool:
  	if objectives.size() == 0:
  		return false
  	
  	for objective_id in objectives:
  		if not objectives[objective_id].completed:
  			return false
  	
  	return true
  
  # Check if a specific objective exists
  func has_objective(objective_id: String) -> bool:
  	return objectives.has(objective_id)
  
  # Check if a specific objective is completed
  func is_objective_completed(objective_id: String) -> bool:
  	if not objectives.has(objective_id):
  		return false
  	return objectives[objective_id].completed
  
  # Get objective progress
  func get_objective_progress(objective_id: String) -> Dictionary:
  	if not objectives.has(objective_id):
  		return {}
  	
  	var objective = objectives[objective_id]
  	return {
  		"progress": objective.progress,
  		"total": objective.total,
  		"completed": objective.completed
  	}
  
  # Create UI for a new objective
  func _create_objective_ui(objective_id: String) -> void:
  	if not objective_template or not objectives_container:
  		push_error("Objective tracker UI components not found")
  		return
  	
  	var objective = objectives[objective_id]
  	
  	# Create from template
  	var new_objective_ui = objective_template.duplicate()
  	new_objective_ui.name = "Objective_" + objective_id
  	new_objective_ui.visible = true
  	objectives_container.add_child(new_objective_ui)
  	
  	# Set initial content
  	var description_label = new_objective_ui.get_node_or_null("Description")
  	var progress_label = new_objective_ui.get_node_or_null("Progress")
  	var progress_bar = new_objective_ui.get_node_or_null("ProgressBar")
  	
  	if description_label:
  		description_label.text = objective.description
  	
  	if progress_label:
  		if objective.total > 1:
  			progress_label.text = str(objective.progress) + " / " + str(objective.total)
  		else:
  			progress_label.visible = false
  	
  	if progress_bar:
  		if objective.total > 1:
  			progress_bar.max_value = objective.total
  			progress_bar.value = objective.progress
  		else:
  			progress_bar.visible = false
  	
  	# Store the UI reference
  	objective.ui_element = new_objective_ui
  	
  	# Apply theme
  	if ui_theme:
  		_apply_theme_to_objective(new_objective_ui, objective.completed)
  
  # Update UI for an existing objective
  func _update_objective_ui(objective_id: String) -> void:
  	if not objectives.has(objective_id):
  		return
  	
  	var objective = objectives[objective_id]
  	var ui_element = objective.ui_element
  	
  	if not ui_element or not is_instance_valid(ui_element):
  		return
  	
  	# Update content
  	var description_label = ui_element.get_node_or_null("Description")
  	var progress_label = ui_element.get_node_or_null("Progress")
  	var progress_bar = ui_element.get_node_or_null("ProgressBar")
  	var completed_icon = ui_element.get_node_or_null("CompletedIcon")
  	
  	if description_label:
  		description_label.text = objective.description
  	
  	if progress_label:
  		if objective.total > 1:
  			progress_label.text = str(objective.progress) + " / " + str(objective.total)
  			progress_label.visible = true
  		else:
  			progress_label.visible = false
  	
  	if progress_bar:
  		if objective.total > 1:
  			progress_bar.max_value = objective.total
  			progress_bar.value = objective.progress
  			progress_bar.visible = true
  		else:
  			progress_bar.visible = false
  	
  	if completed_icon:
  		completed_icon.visible = objective.completed
  	
  	# Apply theme with completion state
  	if ui_theme:
  		_apply_theme_to_objective(ui_element, objective.completed)
  	
  	# Apply completed styling
  	if objective.completed:
  		# Visual indication of completion
  		if description_label:
  			description_label.modulate = Color(0.7, 1.0, 0.7)  # Slight green tint
  		
  		# Add completion animation if needed
  		if not ui_element.has_meta("completion_animated"):
  			var tween = create_tween()
  			tween.tween_property(ui_element, "modulate", Color(1.5, 1.5, 1.5), 0.2)
  			tween.tween_property(ui_element, "modulate", Color(1, 1, 1), 0.3)
  			ui_element.set_meta("completion_animated", true)
  
  # Check if all objectives are completed and emit signal if so
  func _check_all_objectives_completed() -> void:
  	if are_all_objectives_completed():
  		emit_signal("all_objectives_completed")
  
  # Apply theme to the entire tracker
  func _apply_theme() -> void:
  	if not ui_theme:
  		return
  	
  	# Apply to container background if needed
  	var panel = get_node_or_null("Background")
  	if panel and panel is Panel:
  		var style = ui_theme.create_panel_style("background", "", "small", 0)
  		panel.add_theme_stylebox_override("panel", style)
  	
  	# Apply to all objective UI elements
  	for objective_id in objectives:
  		var objective = objectives[objective_id]
  		if objective.ui_element and is_instance_valid(objective.ui_element):
  			_apply_theme_to_objective(objective.ui_element, objective.completed)
  
  # Apply theme to a specific objective UI element
  func _apply_theme_to_objective(ui_element: Control, is_completed: bool) -> void:
  	if not ui_theme:
  		return
  	
  	var description_label = ui_element.get_node_or_null("Description")
  	var progress_label = ui_element.get_node_or_null("Progress")
  	var progress_bar = ui_element.get_node_or_null("ProgressBar")
  	
  	if description_label:
  		var color = ui_theme.get_color("success") if is_completed else ui_theme.get_color("foreground")
  		description_label.add_theme_color_override("font_color", color)
  	
  	if progress_label:
  		progress_label.add_theme_color_override("font_color", ui_theme.get_color("secondary"))
  	
  	if progress_bar:
  		# Style the progress bar
  		var fg_stylebox = StyleBoxFlat.new()
  		fg_stylebox.bg_color = ui_theme.get_color("primary")
  		fg_stylebox.corner_radius_top_left = ui_theme.get_corner_radius("small")
  		fg_stylebox.corner_radius_top_right = ui_theme.get_corner_radius("small")
  		fg_stylebox.corner_radius_bottom_left = ui_theme.get_corner_radius("small")
  		fg_stylebox.corner_radius_bottom_right = ui_theme.get_corner_radius("small")
  		
  		var bg_stylebox = fg_stylebox.duplicate()
  		bg_stylebox.bg_color = ui_theme.get_color("background").lightened(0.1)
  		
  		progress_bar.add_theme_stylebox_override("fill", fg_stylebox)
  		progress_bar.add_theme_stylebox_override("background", bg_stylebox)
  
  # Handle theme changes
  func _on_theme_changed(_theme_name) -> void:
  	_apply_theme()

========================================
Contents of scripts\ui\settings\audio_settings.gd:
========================================
  class_name AudioSettings
  extends Node2D
  
  
  # Called when the node enters the scene tree for the first time.
  func _ready():
  	pass # Replace with function body.
  
  
  # Called every frame. 'delta' is the elapsed time since the previous frame.
  func _process(delta):
  	pass
  
  
  func _on_back_button_pressed():
  	get_tree().change_scene_to_file("res://scenes/ui/settings/settings_menu.tscn")
  	
  var master_bus = AudioServer.get_bus_index("Master")
  
  
  func _on_h_slider_value_changed(value):
  	AudioServer.set_bus_volume_db(master_bus, value)
  	
  	if value == -30:
  		AudioServer.set_bus_mute(master_bus, true)
  	else:
  		AudioServer.set_bus_mute(master_bus, false)

========================================
Contents of scripts\ui\settings\settings_menu.gd:
========================================
  class_name SettingsMenu
  extends Node2D
  
  "res://scripts/ui/settings/settings_menu.gd"
  # Called when the node enters the scene tree for the first time.
  func _ready():
  	pass # Replace with function body.
  
  
  # Called every frame. 'delta' is the elapsed time since the previous frame.
  func _process(delta):
  	pass
  
  
  func _on_back_button_pressed():
  	get_tree().change_scene_to_file("res://scenes/ui/main_menu/main_menu.tscn")
  
  
  func _on_audio_button_pressed():
  	get_tree().change_scene_to_file("res://scenes/ui/settings/audio_settings.tscn")
  
  
  func _on_customizer_button_pressed():
  	get_tree().change_scene_to_file("res://scenes/ui/character_customizer/customizer.tscn")

========================================
Contents of scripts\utils\game_resource_preloader.gd:
========================================
  class_name GameResourcePreloader
  extends Node
  
  ## A utility class for preloading and managing game resources
  ## Helps improve loading times by caching frequently used resources
  
  # Resource cache organized by type and ID
  var _cache = {
  	"scenes": {},
  	"textures": {},
  	"audio": {},
  	"fonts": {},
  	"materials": {},
  	"animations": {},
  	"other": {}
  }
  
  # Signal emitted when a resource is loaded
  signal resource_loaded(type, id, resource)
  # Signal emitted when all queued resources are loaded
  signal all_resources_loaded()
  # Signal emitted on loading progress update
  signal loading_progress(progress, total)
  
  # Queue of resources to load
  var _load_queue = []
  # Count of loaded resources
  var _loaded_count = 0
  # Whether we're currently loading resources
  var _is_loading = false
  # Progress interval for emitting loading_progress signals
  var _progress_interval = 0.1
  var _last_progress_time = 0
  
  ## Initialize with default resources to preload
  func _ready():
  	# Nothing to preload by default
  	pass
  
  ## Add a resource to the preload queue
  func queue_resource(path: String, type: String = "other", id: String = ""):
  	if id == "":
  		id = path.get_file().get_basename()
  
  	# Check if already in cache
  	if has_resource(type, id):
  		return true
  
  	# Add to queue
  	_load_queue.append({
  		"path": path,
  		"type": type,
  		"id": id
  	})
  	
  	return true
  
  ## Start loading all queued resources
  func load_queued_resources(use_thread: bool = true):
  	if _is_loading:
  		return false
  	
  	if _load_queue.size() == 0:
  		emit_signal("all_resources_loaded")
  		return true
  	
  	_is_loading = true
  	_loaded_count = 0
  	_last_progress_time = Time.get_ticks_msec() / 1000.0
  	
  	if use_thread:
  		_start_threaded_loading()
  	else:
  		_start_immediate_loading()
  	
  	return true
  
  ## Load a single resource immediately
  func load_resource(path: String, type: String = "other", id: String = "") -> Resource:
  	if id == "":
  		id = path.get_file().get_basename()
  	
  	# Check if already in cache
  	if has_resource(type, id):
  		return get_resource(type, id)
  	
  	# Load and cache
  	var resource = ResourceLoader.load(path)
  	if resource:
  		_cache_resource(resource, type, id)
  		emit_signal("resource_loaded", type, id, resource)
  		return resource
  	
  	push_error("Failed to load resource: " + path)
  	return null
  
  ## Check if a resource is in the cache
  func has_resource(type: String, id: String) -> bool:
  	if not _cache.has(type):
  		return false
  	return _cache[type].has(id)
  
  ## Get a resource from the cache
  func get_resource(type: String, id: String) -> Resource:
  	if not has_resource(type, id):
  		push_error("Resource not found in cache: " + type + "/" + id)
  		return null
  	
  	return _cache[type][id]
  
  ## Clear the cache for a specific type
  func clear_cache(type: String = ""):
  	if type == "":
  		# Clear all caches
  		for t in _cache:
  			_cache[t].clear()
  	elif _cache.has(type):
  		_cache[type].clear()
  
  ## Clear the load queue
  func clear_queue():
  	_load_queue.clear()
  	_loaded_count = 0
  	_is_loading = false
  
  ## Get cache statistics
  func get_cache_stats() -> Dictionary:
  	var stats = {}
  	
  	for type in _cache:
  		stats[type] = _cache[type].size()
  	
  	stats["total"] = 0
  	for type in stats:
  		stats["total"] += stats[type]
  	
  	return stats
  
  ## Process loading queue in the main thread (immediate)
  func _start_immediate_loading():
  	for resource_info in _load_queue:
  		var resource = ResourceLoader.load(resource_info.path)
  		if resource:
  			_cache_resource(resource, resource_info.type, resource_info.id)
  			_loaded_count += 1
  			
  			# Emit progress signal at intervals
  			var current_time = Time.get_ticks_msec() / 1000.0
  			if current_time - _last_progress_time >= _progress_interval:
  				_last_progress_time = current_time
  				emit_signal("loading_progress", _loaded_count, _load_queue.size())
  			
  			emit_signal("resource_loaded", resource_info.type, resource_info.id, resource)
  		else:
  			push_error("Failed to load resource: " + resource_info.path)
  	
  	_load_queue.clear()
  	_is_loading = false
  	emit_signal("loading_progress", _loaded_count, _loaded_count)
  	emit_signal("all_resources_loaded")
  
  ## Process loading queue in a background thread
  func _start_threaded_loading():
  	# Create a new thread for loading
  	var thread = Thread.new()
  	thread.start(Callable(self, "_threaded_loading"))
  	
  	# Thread cleanup will happen in _threaded_loading
  
  ## Thread function for background loading
  func _threaded_loading():
  	var total = _load_queue.size()
  	
  	for resource_info in _load_queue:
  		var path = resource_info.path
  		var type = resource_info.type
  		var id = resource_info.id
  		
  		# Use ResourceLoader.load_threaded_request to start loading
  		ResourceLoader.load_threaded_request(path)
  		
  		# Poll until loading completes
  		var status = ResourceLoader.load_threaded_get_status(path)
  		while status == ResourceLoader.THREAD_LOAD_IN_PROGRESS:
  			OS.delay_msec(10) # Small delay to prevent high CPU usage
  			status = ResourceLoader.load_threaded_get_status(path)
  		
  		# Process the result
  		if status == ResourceLoader.THREAD_LOAD_LOADED:
  			var resource = ResourceLoader.load_threaded_get(path)
  			if resource:
  				# Use call_deferred to update the cache on the main thread
  				call_deferred("_cache_resource", resource, type, id)
  				_loaded_count += 1
  				
  				# Emit signals on the main thread
  				var progress_data = {"count": _loaded_count, "total": total}
  				call_deferred("_emit_loading_progress", progress_data)
  				call_deferred("_emit_resource_loaded", type, id, resource)
  			else:
  				push_error("Failed to load threaded resource: " + path)
  		else:
  			push_error("Failed to load threaded resource: " + path + ", status: " + str(status))
  	
  	# Clear queue and emit completion on the main thread
  	call_deferred("_finish_loading")
  	
  	# Thread cleanup happens automatically in Godot 4.x
  
  ## Safely emit loading progress signal from thread
  func _emit_loading_progress(data: Dictionary):
  	var current_time = Time.get_ticks_msec() / 1000.0
  	if current_time - _last_progress_time >= _progress_interval:
  		_last_progress_time = current_time
  		emit_signal("loading_progress", data.count, data.total)
  
  ## Safely emit resource loaded signal from thread
  func _emit_resource_loaded(type: String, id: String, resource: Resource):
  	emit_signal("resource_loaded", type, id, resource)
  
  ## Finish loading process
  func _finish_loading():
  	_load_queue.clear()
  	_is_loading = false
  	emit_signal("loading_progress", _loaded_count, _loaded_count)
  	emit_signal("all_resources_loaded")
  
  ## Add a resource to the cache
  func _cache_resource(resource: Resource, type: String, id: String):
  	# Create the type category if it doesn't exist
  	if not _cache.has(type):
  		_cache[type] = {}
  	
  	# Cache the resource
  	_cache[type][id] = resource
  
  ## Preload common resources for a specific level or scene
  func preload_level_resources(level_name: String) -> bool:
  	# This method should be customized per game to preload
  	# appropriate resources for each level
  	match level_name:
  		"main_menu":
  			queue_resource("res://scenes/ui/main_menu/main_menu.tscn", "scenes", "main_menu")
  			# Add UI elements, backgrounds, etc.
  			return true
  			
  		"adventure_level":
  			queue_resource("res://scenes/levels/adventure_mode/adventure_level.tscn", "scenes", "adventure_level")
  			# Add player, enemies, items, etc.
  			return true
  			
  		_:
  			push_warning("No preload configuration for level: " + level_name)
  			return false
  	
  	return false
  
  ## Unload resources that are not needed for the current scene
  func unload_unused_resources(keep_types: Array = []):
  	var stats_before = get_cache_stats()
  	
  	# Keep all resources of specified types
  	for type in _cache:
  		if type in keep_types:
  			continue
  		
  		# Clear this type of resources
  		_cache[type].clear()
  	
  	var stats_after = get_cache_stats()
  	print("Unloaded resources - Before: ", stats_before.total, ", After: ", stats_after.total)
  	
  	# Force garbage collection
  	ResourceLoader.load_threaded_request("res://")
  	ResourceLoader.load_threaded_get_status("res://")

========================================
Contents of scripts\utils\killzone.gd:
========================================
  class_name Killzone
  extends Area2D
  
  @onready var timer = $Timer
  
  func _on_body_entered(body):
  	print("you died!")
  	Engine.time_scale = 0.5
  	body.get_node("CollisionShape2D").queue_free()
  	timer.start()
  	
  
  
  func _on_timer_timeout():
  	Engine.time_scale = 1.0
  	get_tree().reload_current_scene()

========================================
Contents of scripts\utils\object_pool.gd:
========================================
  class_name ObjectPool
  extends Node
  
  ## A generic object pooling system for reusing objects instead of creating and destroying them
  ## Improved to work better with the state-driven architecture
  
  # The scene to create objects from
  var scene: PackedScene
  # Maximum number of objects to keep in the pool (0 = unlimited)
  var max_size: int = 0
  # Container for inactive objects
  var inactive_objects: Array = []
  # Container to track all spawned objects (both active and inactive)
  var all_objects: Array = []
  # Whether to automatically resize the pool as needed
  var auto_resize: bool = true
  # Parent node for spawned objects
  var parent_node: Node = null
  
  # Signal emitted when an object is taken from the pool
  signal object_spawned(object)
  # Signal emitted when an object is returned to the pool
  signal object_recycled(object)
  # Signal emitted when the pool is resized
  signal pool_resized(new_size)
  # Signal emitted when the pool is cleared
  signal pool_cleared
  
  ## Create a new object pool with the specified scene
  func _init(object_scene: PackedScene, pool_size: int = 10, auto_resize_pool: bool = true):
  	scene = object_scene
  	max_size = pool_size
  	auto_resize = auto_resize_pool
  	
  	# Check if scene is valid before pre-populating
  	if scene == null:
  		push_error("ObjectPool: Cannot initialize with null scene")
  		return
  	
  	# Pre-populate the pool with objects
  	for i in range(pool_size):
  		var obj = _create_object()
  		if obj != null:
  			inactive_objects.append(obj)
  			all_objects.append(obj)
  
  ## Set the parent node for all pooled objects
  func set_parent(parent: Node):
  	parent_node = parent
  	
  	# Reparent existing objects
  	for obj in all_objects:
  		if obj.get_parent():
  			obj.get_parent().remove_child(obj)
  		parent_node.add_child(obj)
  
  ## Get an object from the pool, or create a new one if the pool is empty
  func get_object() -> Node:
  	# First check if the scene is valid
  	if scene == null:
  		push_error("ObjectPool: Cannot get object from pool with null scene")
  		return null
  		
  	var obj = null
  	
  	if inactive_objects.size() > 0:
  		# Take an object from the inactive pool
  		obj = inactive_objects.pop_back()
  	elif auto_resize:
  		# Create a new object if we're allowed to resize the pool
  		obj = _create_object()
  		if obj != null:
  			all_objects.append(obj)
  	else:
  		push_error("Object pool is empty and auto-resize is disabled!")
  		return null
  	
  	if obj != null:
  		# Call spawn method if available
  		if obj.has_method("_on_spawn_from_pool"):
  			obj._on_spawn_from_pool()
  		
  		# Ensure the object is visible and active
  		obj.visible = true
  		obj.process_mode = Node.PROCESS_MODE_INHERIT
  		
  		emit_signal("object_spawned", obj)
  	
  	return obj
  
  ## Return an object to the pool for reuse
  func recycle(obj: Node) -> void:
  	if not all_objects.has(obj):
  		push_error("Attempted to recycle an object that wasn't created by this pool!")
  		return
  	
  	# Make sure it's not already in the inactive pool
  	if inactive_objects.has(obj):
  		return
  	
  	# Prepare the object for recycling
  	if obj.has_method("_on_recycle_to_pool"):
  		obj._on_recycle_to_pool()
  	
  	# Hide and disable the object
  	obj.visible = false
  	obj.process_mode = Node.PROCESS_MODE_DISABLED
  	
  	# Add to inactive pool, respecting max size
  	if max_size <= 0 or inactive_objects.size() < max_size:
  		inactive_objects.append(obj)
  	else:
  		# If the pool is full, destroy the object
  		all_objects.erase(obj)
  		obj.queue_free()
  	
  	emit_signal("object_recycled", obj)
  
  ## Clear the entire pool, freeing all objects
  func clear_pool() -> void:
  	for obj in all_objects:
  		obj.queue_free()
  	
  	inactive_objects.clear()
  	all_objects.clear()
  	
  	emit_signal("pool_cleared")
  
  ## Resize the pool to the specified size
  func resize(new_size: int) -> void:
  	if new_size < 0:
  		push_error("Cannot resize pool to negative size!")
  		return
  	
  	if new_size < inactive_objects.size():
  		# Need to shrink the pool
  		while inactive_objects.size() > new_size:
  			var obj = inactive_objects.pop_back()
  			all_objects.erase(obj)
  			obj.queue_free()
  	else:
  		# Need to grow the pool
  		for i in range(new_size - inactive_objects.size()):
  			var obj = _create_object()
  			if obj != null:
  				inactive_objects.append(obj)
  				all_objects.append(obj)
  	
  	max_size = new_size
  	emit_signal("pool_resized", new_size)
  
  ## Get the current number of active objects
  func active_count() -> int:
  	return all_objects.size() - inactive_objects.size()
  
  ## Get the current number of inactive objects
  func inactive_count() -> int:
  	return inactive_objects.size()
  
  ## Get the total number of objects managed by this pool
  func total_count() -> int:
  	return all_objects.size()
  
  ## Create a new object and set it up for the pool
  func _create_object() -> Node:
  	if scene == null:
  		push_error("ObjectPool: Cannot instantiate from null scene")
  		return null
  
  	var obj = scene.instantiate()
  	
  	# Set up parent if specified
  	if parent_node:
  		parent_node.add_child(obj)
  	
  	# Hide and disable by default
  	obj.visible = false
  	obj.process_mode = Node.PROCESS_MODE_DISABLED
  	
  	# Set is_from_pool property if object has it
  	if "is_from_pool" in obj:
  		obj.is_from_pool = true
  	
  	return obj
  
  ## Get all active objects from the pool
  func get_active_objects() -> Array:
  	var active = []
  	for obj in all_objects:
  		if not inactive_objects.has(obj):
  			active.append(obj)
  	return active
  
  ## Recycle all active objects
  func recycle_all() -> void:
  	var active = get_active_objects()
  	for obj in active:
  		recycle(obj)
  
  ## Check if an object belongs to this pool
  func owns_object(obj: Node) -> bool:
  	return all_objects.has(obj)

========================================
Contents of scripts\utils\save_data.gd:
========================================
  class_name SaveData
  extends Resource
  
  ## Data structure for saved games in The Little Saint
  ## Stores player stats, game progress, and settings
  
  # Version for compatibility checks
  @export var save_version: int = 1
  
  # Save metadata
  @export var save_date: String = ""
  @export var playtime_seconds: int = 0
  
  # Player position and level
  @export var player_position: Vector2 = Vector2.ZERO
  @export var current_level: String = ""
  
  # Player stats
  @export var health: float = 3.0
  @export var coins: int = 0
  @export var player_speed: float = Constants.PLAYER_DEFAULT_SPEED
  @export var player_jump_velocity: float = Constants.PLAYER_DEFAULT_JUMP_VELOCITY
  @export var player_fly_velocity: float = Constants.PLAYER_DEFAULT_FLY_VELOCITY
  @export var player_gravity: float = Constants.PLAYER_DEFAULT_GRAVITY
  
  # Player state
  @export var player_mode: String = "normal"
  @export var player_passed_fly_time: float = 0.0
  @export var player_jump_counter: int = 0
  @export var player_ready_for_jump: bool = true
  @export var player_allowed_jumps: int = 1
  
  # Player appearance
  @export var player_outfit: Dictionary = {}
  
  # Game progress
  @export var collected_coins: int = 0
  @export var unlocked_levels: Array = []
  @export var completed_quests: Array = []
  
  # Initialize with default values
  func _init():
  	save_date = Time.get_datetime_string_from_system(false, true)
  	
  	# Set default player outfit if none exists
  	if player_outfit.is_empty():
  		# Create a default outfit
  		player_outfit = {
  			"beard": "none",
  			"lipstick": "none",
  			"eyes": "1",
  			"shoes": "1",
  			"earrings": "none",
  			"hats": "none",
  			"glasses": "none",
  			"clothes_down": "1",
  			"clothes_up": "1",
  			"clothes_complete": "none",
  			"bodies": "1",
  			"hair": "1"
  		}
  
  # Validate the save data to ensure it's not corrupted
  func validate() -> bool:
  	# Basic validation to ensure critical fields are present
  	if player_speed <= 0 or player_gravity <= 0:
  		return false
  	
  	# Check that outfit dictionary has expected keys
  	var required_outfit_keys = [
  		"beard", "lipstick", "eyes", "shoes", "earrings", 
  		"hats", "glasses", "clothes_down", "clothes_up", 
  		"clothes_complete", "bodies", "hair"
  	]
  	
  	for key in required_outfit_keys:
  		if not player_outfit.has(key):
  			return false
  	
  	return true
  
  # Create a dictionary representation of the save data for debug purposes
  func to_dict() -> Dictionary:
  	return {
  		"save_version": save_version,
  		"save_date": save_date,
  		"playtime_seconds": playtime_seconds,
  		"player_position": {"x": player_position.x, "y": player_position.y},
  		"current_level": current_level,
  		"health": health,
  		"coins": coins,
  		"player_speed": player_speed,
  		"player_jump_velocity": player_jump_velocity,
  		"player_fly_velocity": player_fly_velocity,
  		"player_gravity": player_gravity,
  		"player_mode": player_mode,
  		"player_passed_fly_time": player_passed_fly_time,
  		"player_jump_counter": player_jump_counter,
  		"player_ready_for_jump": player_ready_for_jump,
  		"player_allowed_jumps": player_allowed_jumps,
  		"player_outfit": player_outfit,
  		"collected_coins": collected_coins,
  		"unlocked_levels": unlocked_levels,
  		"completed_quests": completed_quests
  	}
  
  # Return a string representation for debugging
  func _to_string() -> String:
  	return JSON.stringify(to_dict(), "\t")
  
  # Update playtime
  func update_playtime(seconds_to_add: int) -> void:
  	playtime_seconds += seconds_to_add
  
  # Get formatted playtime as string
  func get_playtime_string() -> String:
  	var hours = playtime_seconds / 3600
  	var minutes = (playtime_seconds % 3600) / 60
  	var seconds = playtime_seconds % 60
  	
  	return "%02d:%02d:%02d" % [hours, minutes, seconds]
  
  # Create a deep copy of this save data
  func duplicate_data() -> SaveData:
  	var new_data = SaveData.new()
  	
  	new_data.save_version = save_version
  	new_data.save_date = save_date
  	new_data.playtime_seconds = playtime_seconds
  	new_data.player_position = player_position
  	new_data.current_level = current_level
  	new_data.health = health
  	new_data.coins = coins
  	new_data.player_speed = player_speed
  	new_data.player_jump_velocity = player_jump_velocity
  	new_data.player_fly_velocity = player_fly_velocity
  	new_data.player_gravity = player_gravity
  	new_data.player_mode = player_mode
  	new_data.player_passed_fly_time = player_passed_fly_time
  	new_data.player_jump_counter = player_jump_counter
  	new_data.player_ready_for_jump = player_ready_for_jump
  	new_data.player_allowed_jumps = player_allowed_jumps
  	new_data.player_outfit = player_outfit.duplicate(true)
  	new_data.collected_coins = collected_coins
  	new_data.unlocked_levels = unlocked_levels.duplicate()
  	new_data.completed_quests = completed_quests.duplicate()
  	
  	return new_data
  
  # Create a new save with default values
  static func create_new_save() -> SaveData:
  	var save = SaveData.new()
  	save.save_date = Time.get_datetime_string_from_system(false, true)
  	return save

========================================
Contents of scripts\utils\ui_theme.gd:
========================================
  class_name UITheme
  extends Node
  
  ## A central manager for UI themes and styling across the game
  ## Handles theme properties, color palettes, and consistent UI elements
  
  # Current theme name
  var current_theme: String = "default"
  
  # Available themes
  var available_themes: Array = ["default", "dark", "light", "custom"]
  
  # Color palettes for each theme
  var theme_colors = {
  	"default": {
  		"background": Color("#1f1f1f"),
  		"foreground": Color("#ffffff"),
  		"primary": Color("#e7896a"),      # Clay/terracotta color from your game
  		"secondary": Color("#4aa8d8"),    # Blue accent
  		"accent": Color("#a8d84a"),       # Green accent
  		"error": Color("#d84a4a"),        # Red for errors/warnings
  		"success": Color("#4ad84a"),      # Green for success
  		"warning": Color("#d8d84a"),      # Yellow for warnings
  		"disabled": Color("#7f7f7f"),     # Gray for disabled elements
  		"transparent": Color(0, 0, 0, 0)  # Fully transparent
  	},
  	"dark": {
  		"background": Color("#121212"),
  		"foreground": Color("#f0f0f0"),
  		"primary": Color("#d87a5f"),      # Darker clay color
  		"secondary": Color("#3a8ab8"),    # Darker blue
  		"accent": Color("#8ab83a"),       # Darker green
  		"error": Color("#b83a3a"),        # Darker red
  		"success": Color("#3ab83a"),      # Darker green
  		"warning": Color("#b8b83a"),      # Darker yellow
  		"disabled": Color("#5f5f5f"),     # Darker gray
  		"transparent": Color(0, 0, 0, 0)
  	},
  	"light": {
  		"background": Color("#f5f5f5"),
  		"foreground": Color("#202020"),
  		"primary": Color("#ff9478"),      # Lighter clay color
  		"secondary": Color("#78c4ff"),    # Lighter blue
  		"accent": Color("#c4ff78"),       # Lighter green
  		"error": Color("#ff7878"),        # Lighter red
  		"success": Color("#78ff78"),      # Lighter green
  		"warning": Color("#ffff78"),      # Lighter yellow
  		"disabled": Color("#a0a0a0"),     # Lighter gray
  		"transparent": Color(0, 0, 0, 0)
  	},
  	"custom": {
  		# Will be populated from user settings
  	}
  }
  
  # Font sizes for different UI elements
  var font_sizes = {
  	"small": 12,
  	"regular": 16,
  	"large": 20,
  	"title": 24,
  	"heading": 32
  }
  
  # Margin and padding sizes
  var spacing = {
  	"tiny": 2,
  	"small": 4,
  	"regular": 8,
  	"large": 16,
  	"xlarge": 24
  }
  
  # Corner radius for UI elements
  var corner_radius = {
  	"none": 0,
  	"small": 4,
  	"regular": 8,
  	"large": 16,
  	"pill": 9999  # Very large value for pill shape
  }
  
  # Animation durations
  var animation_durations = {
  	"fast": 0.1,
  	"regular": 0.3,
  	"slow": 0.5
  }
  
  # Default fonts
  var fonts = {
  	"regular": null,
  	"bold": null,
  	"title": null,
  	"monospace": null
  }
  
  # Signal emitted when theme changes
  signal theme_changed(theme_name)
  
  # Initialize the theme system
  func _ready():
  	# Load fonts
  	_load_fonts()
  	
  	# Try to load user theme preferences
  	_load_theme_preferences()
  	
  	print("UI Theme Manager initialized with theme: ", current_theme)
  
  # Set the active theme
  func set_theme(theme_name: String) -> bool:
  	if theme_name in available_themes:
  		current_theme = theme_name
  		emit_signal("theme_changed", theme_name)
  		return true
  	return false
  
  # Get a color from the current theme
  func get_color(color_name: String) -> Color:
  	if theme_colors.has(current_theme) and theme_colors[current_theme].has(color_name):
  		return theme_colors[current_theme][color_name]
  	
  	# Fallback to default theme
  	if theme_colors["default"].has(color_name):
  		return theme_colors["default"][color_name]
  	
  	# Ultimate fallback
  	push_warning("Color not found: " + color_name)
  	return Color.WHITE
  
  # Get a font size
  func get_font_size(size_name: String) -> int:
  	if font_sizes.has(size_name):
  		return font_sizes[size_name]
  	
  	push_warning("Font size not found: " + size_name)
  	return font_sizes["regular"]
  
  # Get spacing value
  func get_spacing(spacing_name: String) -> int:
  	if spacing.has(spacing_name):
  		return spacing[spacing_name]
  	
  	push_warning("Spacing not found: " + spacing_name)
  	return spacing["regular"]
  
  # Get corner radius
  func get_corner_radius(radius_name: String) -> int:
  	if corner_radius.has(radius_name):
  		return corner_radius[radius_name]
  	
  	push_warning("Corner radius not found: " + radius_name)
  	return corner_radius["regular"]
  
  # Get animation duration
  func get_animation_duration(duration_name: String) -> float:
  	if animation_durations.has(duration_name):
  		return animation_durations[duration_name]
  	
  	push_warning("Animation duration not found: " + duration_name)
  	return animation_durations["regular"]
  
  # Get a font
  func get_font(font_name: String) -> Font:
  	if fonts.has(font_name) and fonts[font_name] != null:
  		return fonts[font_name]
  	
  	push_warning("Font not found: " + font_name)
  	return fonts["regular"] if fonts["regular"] != null else null
  
  # Create a panel style with theme colors
  func create_panel_style(
  	bg_color_name: String = "background",
  	border_color_name: String = "",
  	radius_name: String = "regular",
  	border_width: int = 0
  ) -> StyleBoxFlat:
  	var style = StyleBoxFlat.new()
  	
  	# Set background color
  	style.bg_color = get_color(bg_color_name)
  	
  	# Set corner radius
  	var radius = get_corner_radius(radius_name)
  	style.corner_radius_top_left = radius
  	style.corner_radius_top_right = radius
  	style.corner_radius_bottom_left = radius
  	style.corner_radius_bottom_right = radius
  	
  	# Set border if requested
  	if border_color_name != "" and border_width > 0:
  		style.border_width_left = border_width
  		style.border_width_top = border_width
  		style.border_width_right = border_width
  		style.border_width_bottom = border_width
  		style.border_color = get_color(border_color_name)
  	
  	return style
  
  # Create a button style with normal, hover, pressed states
  func create_button_style(
  	normal_color_name: String = "primary",
  	hover_color_name: String = "",
  	pressed_color_name: String = "",
  	disabled_color_name: String = "disabled",
  	radius_name: String = "regular",
  	border_width: int = 0
  ) -> Dictionary:
  	# Get the normal color
  	var normal_color = get_color(normal_color_name)
  	
  	# Calculate derived colors or get specified colors
  	var hover_color: Color
  	var pressed_color: Color
  	
  	if hover_color_name == "":
  		hover_color = normal_color.lightened(0.1)
  	else:
  		hover_color = get_color(hover_color_name)
  	
  	if pressed_color_name == "":
  		pressed_color = normal_color.darkened(0.1)
  	else:
  		pressed_color = get_color(pressed_color_name)
  	
  	# Create styles for each state
  	var normal_style = create_panel_style(normal_color_name, "", radius_name, border_width)
  	
  	var hover_style = normal_style.duplicate()
  	hover_style.bg_color = hover_color
  	
  	var pressed_style = normal_style.duplicate()
  	pressed_style.bg_color = pressed_color
  	
  	var disabled_style = normal_style.duplicate()
  	disabled_style.bg_color = get_color(disabled_color_name)
  	
  	return {
  		"normal": normal_style,
  		"hover": hover_style,
  		"pressed": pressed_style,
  		"disabled": disabled_style
  	}
  
  # Apply theme to a control
  func apply_theme_to_control(control: Control, theme_preset: String = "default") -> void:
  	match theme_preset:
  		"default":
  			_apply_default_theme(control)
  		"button":
  			_apply_button_theme(control)
  		"panel":
  			_apply_panel_theme(control)
  		"label":
  			_apply_label_theme(control)
  		_:
  			push_warning("Unknown theme preset: " + theme_preset)
  			_apply_default_theme(control)
  
  # Set custom theme colors
  func set_custom_colors(colors: Dictionary) -> void:
  	for color_name in colors:
  		if color_name in theme_colors["custom"]:
  			theme_colors["custom"][color_name] = colors[color_name]
  	
  	# Ensure all colors are defined
  	for color_name in theme_colors["default"]:
  		if not theme_colors["custom"].has(color_name):
  			theme_colors["custom"][color_name] = theme_colors["default"][color_name]
  	
  	# If custom theme is current, notify of change
  	if current_theme == "custom":
  		emit_signal("theme_changed", current_theme)
  
  # Save theme preferences
  func save_theme_preferences() -> bool:
  	var config = ConfigFile.new()
  	
  	# Store current theme
  	config.set_value("theme", "current_theme", current_theme)
  	
  	# Store custom theme colors
  	config.set_value("theme", "custom_colors", theme_colors["custom"])
  	
  	# Store font sizes
  	config.set_value("theme", "font_sizes", font_sizes)
  	
  	# Save the config
  	var err = config.save("user://theme_settings.cfg")
  	return err == OK
  
  # Load the fonts
  func _load_fonts() -> void:
  	var default_font = load("res://assets/fonts/general/default_font.tres") if ResourceLoader.exists("res://assets/fonts/general/default_font.tres") else null
  	
  	fonts["regular"] = default_font
  	fonts["bold"] = load("res://assets/fonts/general/default_font_bold.tres") if ResourceLoader.exists("res://assets/fonts/general/default_font_bold.tres") else default_font
  	fonts["title"] = load("res://assets/fonts/special/copyduck/Copyduck.ttf") if ResourceLoader.exists("res://assets/fonts/special/copyduck/Copyduck.ttf") else default_font
  	fonts["monospace"] = load("res://assets/fonts/general/default_mono.tres") if ResourceLoader.exists("res://assets/fonts/general/default_mono.tres") else default_font
  
  # Load theme preferences from config
  func _load_theme_preferences() -> void:
  	var config = ConfigFile.new()
  	var err = config.load("user://theme_settings.cfg")
  	
  	if err == OK:
  		# Load current theme
  		var saved_theme = config.get_value("theme", "current_theme", "default")
  		if saved_theme in available_themes:
  			current_theme = saved_theme
  		
  		# Load custom colors
  		var saved_colors = config.get_value("theme", "custom_colors", {})
  		for color_name in saved_colors:
  			theme_colors["custom"][color_name] = saved_colors[color_name]
  		
  		# Load font sizes
  		var saved_font_sizes = config.get_value("theme", "font_sizes", {})
  		for size_name in saved_font_sizes:
  			font_sizes[size_name] = saved_font_sizes[size_name]
  	else:
  		# If no config exists, initialize custom theme with default colors
  		theme_colors["custom"] = theme_colors["default"].duplicate()
  
  # Apply default theme to a control
  func _apply_default_theme(control: Control) -> void:
  	var theme_override = Theme.new()
  	
  	# Set default font
  	if fonts["regular"]:
  		theme_override.default_font = fonts["regular"]
  		theme_override.default_font_size = get_font_size("regular")
  	
  	# Set default colors
  	theme_override.set_color("font_color", "Label", get_color("foreground"))
  	theme_override.set_color("font_focus_color", "Label", get_color("primary"))
  	
  	control.theme = theme_override
  
  # Apply button theme
  func _apply_button_theme(button: Control) -> void:
  	if not button is Button:
  		push_warning("Cannot apply button theme to non-Button control")
  		return
  	
  	# Apply default theme first
  	_apply_default_theme(button)
  	
  	# Create button styles
  	var styles = create_button_style()
  	
  	# Apply button styles
  	button.add_theme_stylebox_override("normal", styles["normal"])
  	button.add_theme_stylebox_override("hover", styles["hover"])
  	button.add_theme_stylebox_override("pressed", styles["pressed"])
  	button.add_theme_stylebox_override("disabled", styles["disabled"])
  	
  	# Set colors
  	button.add_theme_color_override("font_color", get_color("foreground"))
  	button.add_theme_color_override("font_focus_color", get_color("foreground"))
  	button.add_theme_color_override("font_disabled_color", get_color("disabled"))
  	
  	# Set font
  	if fonts["bold"]:
  		button.add_theme_font_override("font", fonts["bold"])
  
  # Apply panel theme
  func _apply_panel_theme(panel: Control) -> void:
  	if not panel is Panel:
  		push_warning("Cannot apply panel theme to non-Panel control")
  		return
  	
  	# Apply default theme first
  	_apply_default_theme(panel)
  	
  	# Create panel style
  	var style = create_panel_style("background", "foreground", "regular", 1)
  	
  	# Apply panel style
  	panel.add_theme_stylebox_override("panel", style)
  
  # Apply label theme
  func _apply_label_theme(label: Control) -> void:
  	if not label is Label:
  		push_warning("Cannot apply label theme to non-Label control")
  		return
  	
  	# Apply default theme first
  	_apply_default_theme(label)
  	
  	# Set colors
  	label.add_theme_color_override("font_color", get_color("foreground"))
  	label.add_theme_color_override("font_shadow_color", get_color("background"))
  	
  	# Set font
  	label.add_theme_font_override("font", fonts["regular"])
  	label.add_theme_font_size_override("font_size", get_font_size("regular"))

==================================================
Scan completed at 2025-04-12 14:47:04
