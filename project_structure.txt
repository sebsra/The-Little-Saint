PROJECT STRUCTURE FOR: c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint
==================================================

[DIR] .git (skipped)
[DIR] .godot (skipped)
[DIR] .vscode (skipped)
[DIR] Artefakte
  - # Refactoring TODO List.md
  - Game Improvements_ Object Pooling and Enemy Behaviors - Claude.html
  [DIR] Game Improvements_ Object Pooling and Enemy Behaviors - Claude_files
    - 2a6c828a2c61eee7.css
    - 66ce72d8d8960cc4.css
    - 81f7f7f9632d10e1.css
    - 9b094e616fc0d0cc.css
    - dfb136612d1c5192.css
    - ef46db3751d8e999.css
    - inner.html
    - m-outer-3437aaddcdf6922d623e172c2d6f9278.html
    - saved_resource(1).html
    - saved_resource.html
- README.md
[DIR] addons
  [DIR] virtual_joystick
    [DIR] previews
    [DIR] test
      - player.gd
      - test.tscn
    [DIR] textures
    - virtual_joystick.gd
    - virtual_joystick_instantiator.gd
    - virtual_joystick_plugin.gd
    - virtual_joystick_scene.tscn
[DIR] assets
  [DIR] audio
    [DIR] music
      [DIR] Tracks
    [DIR] sfx
  [DIR] fonts
    [DIR] general
    [DIR] special
      [DIR] copyduck
        - More Info.txt
  [DIR] sprites
    [DIR] characters
      [DIR] acc
      [DIR] characters
      [DIR] clothes
      [DIR] eyes
      [DIR] greyscale
        [DIR] acc
          [DIR] acc
          [DIR] modular
        [DIR] character
          [DIR] without
        [DIR] clothes
          [DIR] clothes
          [DIR] modular
        [DIR] eyes
        [DIR] hair
        - info.txt
        [DIR] tools
      [DIR] hair
      - info.txt
      - list.txt
      [DIR] separate
        [DIR] axe
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
          [DIR] tool
          [DIR] without
        [DIR] block
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
          [DIR] tool
          [DIR] without
        [DIR] carry
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
        [DIR] die
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
        [DIR] fish
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
          [DIR] tool
          [DIR] without
        [DIR] hoe
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
          [DIR] tool
          [DIR] without
        [DIR] hurt
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
        [DIR] jump
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
        [DIR] pickaxe
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
          [DIR] tool
          [DIR] without
        [DIR] pickup
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
        [DIR] sword
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
          [DIR] tool
          [DIR] without
        [DIR] walk
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
        [DIR] water
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
          [DIR] tool
          [DIR] without
    [DIR] enemies
      [DIR] 1 Bat
      [DIR] 2 Goblin_Mage
      [DIR] 3 Goblin_Melee
      [DIR] 4 Goblin_Range
      [DIR] 5 Small_Mushroom
      [DIR] 6 Big_Mushroom
    [DIR] environment
      [DIR] craftpix-896753-village-pixel-art-environment-assets-pack
        - License.txt
        [DIR] PNG
          [DIR] Objects
          [DIR] Tiles
        - readme.txt
      [DIR] craftpix-net-352322-nature-pixel-art-environment-free-assets-pack
        - License.txt
        [DIR] PNG
          [DIR] Objects
          [DIR] Tiles
        - readme.txt
      [DIR] craftpix-net-481981-free-summer-pixel-art-backgrounds
        - License.txt
        [DIR] PNG
          [DIR] summer 1
          [DIR] summer 2
          [DIR] summer 3
          [DIR] summer 4
          [DIR] summer5
          [DIR] summer6
          [DIR] summer7
          [DIR] summer8
        - readme.txt
      [DIR] craftpix-net-965049-free-industrial-zone-tileset-pixel-art
        [DIR] 1 Tiles
        [DIR] 2 Background
        [DIR] 3 Objects
        [DIR] 4 Animated objects
        - Font.txt
        - license.txt
      [DIR] peasant's_house
        [DIR] Peasant's_House
          [DIR] Door_Animation
            [DIR] Door_Animation-FrameByFrame
          [DIR] House_in_the_middle
            [DIR] Door_Animation
            [DIR] Window_Animation
          [DIR] Peasant's_House-NoAnimation
          - README.txt
          [DIR] Window_Animation
            [DIR] Window_Animation-FrameByFrame
      [DIR] sunny-land-files
        [DIR] Sunny-land-files
          [DIR] Graphical Assets
            [DIR] environment
              [DIR] Background
              [DIR] Props
            [DIR] sprites
              [DIR] cherry
              [DIR] eagle
              [DIR] enemy-death
              [DIR] frog
                [DIR] idle
                [DIR] jump
              [DIR] gem
              [DIR] item-feedback
              [DIR] opossum
              [DIR] player
                [DIR] climb
                [DIR] crouch
                [DIR] hurt
                [DIR] idle
                [DIR] jump
                [DIR] run
            [DIR] spritesheets
          - public-license.txt
    [DIR] items
    [DIR] ui
    [DIR] unsorted
      [DIR] Audio
        [DIR] Tracks
      [DIR] Bushes
      [DIR] Character v.2
        [DIR] acc
        [DIR] characters
        [DIR] clothes
        [DIR] eyes
        [DIR] greyscale
          [DIR] acc
            [DIR] acc
            [DIR] modular
          [DIR] character
            [DIR] without
          [DIR] clothes
            [DIR] clothes
            [DIR] modular
          [DIR] eyes
          [DIR] hair
          [DIR] tools
        [DIR] hair
        [DIR] separate
          [DIR] axe
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
            [DIR] tool
            [DIR] without
          [DIR] block
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
            [DIR] tool
            [DIR] without
          [DIR] carry
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
          [DIR] die
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
          [DIR] fish
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
            [DIR] tool
            [DIR] without
          [DIR] hoe
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
            [DIR] tool
            [DIR] without
          [DIR] hurt
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
          [DIR] jump
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
          [DIR] pickaxe
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
            [DIR] tool
            [DIR] without
          [DIR] pickup
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
          [DIR] sword
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
            [DIR] tool
            [DIR] without
          [DIR] walk
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
          [DIR] water
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
            [DIR] tool
            [DIR] without
      [DIR] Font
      [DIR] Fonts
        [DIR] copyduck
      - License.txt
      [DIR] Monsters
        [DIR] 1 Bat
        [DIR] 2 Goblin_Mage
        [DIR] 3 Goblin_Melee
        [DIR] 4 Goblin_Range
        [DIR] 5 Small_Mushroom
        [DIR] 6 Big_Mushroom
        [DIR] PSD
      [DIR] Peasant's_House
        [DIR] Peasant's_House
          [DIR] Door_Animation
            [DIR] Door_Animation-FrameByFrame
          [DIR] House_in_the_middle
            [DIR] Door_Animation
            [DIR] Window_Animation
          [DIR] Peasant's_House-NoAnimation
          [DIR] Window_Animation
            [DIR] Window_Animation-FrameByFrame
      [DIR] Sunny-land-files
        [DIR] Sunny-land-files
          [DIR] Graphical Assets
            [DIR] Aseprite
            [DIR] GIF Previews
              [DIR] FX
              [DIR] eagle
              [DIR] frog
              [DIR] items
              [DIR] opossum
              [DIR] player
            [DIR] PSD
              [DIR] MISC
              [DIR] environment
              [DIR] sprites
                [DIR] FX
                [DIR] eagle
                [DIR] frog
                [DIR] items
                [DIR] opossum
                [DIR] player
            [DIR] environment
              [DIR] Background
              [DIR] Props
            [DIR] sprites
              [DIR] cherry
              [DIR] eagle
              [DIR] enemy-death
              [DIR] frog
                [DIR] idle
                [DIR] jump
              [DIR] gem
              [DIR] item-feedback
              [DIR] opossum
              [DIR] player
                [DIR] climb
                [DIR] crouch
                [DIR] hurt
                [DIR] idle
                [DIR] jump
                [DIR] run
            [DIR] spritesheets
      [DIR] craftpix-896753-village-pixel-art-environment-assets-pack
        [DIR] PNG
          [DIR] Objects
          [DIR] Tiles
        [DIR] Village_PixelArt_Environment.unitypackage
      [DIR] craftpix-net-352322-nature-pixel-art-environment-free-assets-pack
        [DIR] PNG
          [DIR] Objects
          [DIR] Tiles
      [DIR] craftpix-net-481981-free-summer-pixel-art-backgrounds
        [DIR] PNG
          [DIR] summer 1
          [DIR] summer 2
          [DIR] summer 3
          [DIR] summer 4
          [DIR] summer5
          [DIR] summer6
          [DIR] summer7
          [DIR] summer8
        [DIR] PSD
      [DIR] craftpix-net-965049-free-industrial-zone-tileset-pixel-art
        [DIR] 1 Tiles
        [DIR] 2 Background
        [DIR] 3 Objects
        [DIR] 4 Animated objects
        [DIR] PSD
      [DIR] princefotos
  [DIR] tilemaps
[DIR] config
[DIR] docs
- get_structure.py
- project.godot
- project_structure.txt
[DIR] scenes
  [DIR] common
    [DIR] enemies
    [DIR] items
  [DIR] core
    [DIR] character
      - character_sprites.tscn
      - player.tscn
    [DIR] enemies
      - ardit_enemy.tscn
      - goblin_archer.tscn
      - goblin_mage.tscn
      - goblin_melee.tscn
      - prince_enemy.tscn
    [DIR] items
      - coins.tscn
      - elixir.tscn
      - killzone.tscn
      - power_attack.tscn
      - power_fly.tscn
      - power_jump.tscn
    [DIR] projectiles
      - mage_ball.tscn
      - rock.tscn
  [DIR] levels
    [DIR] adventure_mode
      - adventure_level.tscn
      - base_level.tscn
    [DIR] ardit_levels
      [DIR] Egypt
      [DIR] Free
        [DIR] Background
        [DIR] Items
          [DIR] Boxes
            [DIR] Box1
            [DIR] Box2
            [DIR] Box3
          [DIR] Checkpoints
            [DIR] Checkpoint
            [DIR] End
            [DIR] Start
          [DIR] Fruits
        [DIR] Main Characters
          [DIR] Mask Dude
          [DIR] Ninja Frog
          [DIR] Pink Man
          [DIR] Virtual Guy
        [DIR] Menu
          [DIR] Buttons
          [DIR] Levels
          [DIR] Text
        [DIR] Other
        [DIR] Terrain
        [DIR] Traps
          [DIR] Arrow
          [DIR] Blocks
          [DIR] Falling Platforms
          [DIR] Fan
          [DIR] Fire
          [DIR] Platforms
          [DIR] Rock Head
          [DIR] Sand Mud Ice
          [DIR] Saw
          [DIR] Spike Head
          [DIR] Spiked Ball
          [DIR] Spikes
          [DIR] Trampoline
      [DIR] Free Version
        [DIR] Tiles
      [DIR] [Free-Version] The Lost Tomb - [24x24] Dungeon Asset pack
      - arrogance.tscn
      [DIR] egyptian-game-ui-frames-assets
      [DIR] enemy1
    [DIR] prince_levels
      [DIR] Scriptprince
      [DIR] Tiles
        [DIR] fourSeasonsPlatformer
          - - READ ME -.txt
          [DIR] background_
          [DIR] foreground_
          [DIR] midground_
          [DIR] objects_
      - game_prince.tscn
      - platform.tscn
    [DIR] sebastian_levels
      - level_1.tscn
  [DIR] managers
    - audio_manager.tscn
  [DIR] ui
    [DIR] character_customizer
      - customizer.tscn
      - outfit_showcase.tscn
    [DIR] controls
      - gui.tscn
      - joystick.tscn
    [DIR] dialogs
      - popup_dialog.tscn
    [DIR] hud
      - hud.tscn
    [DIR] loading_screen
    [DIR] main_menu
      - main_menu.tscn
      - start_background.tscn
    [DIR] settings
      - audio_settings.tscn
      - settings_menu.tscn
[DIR] scripts
  [DIR] autoload
    - audio_manager.gd
    - constants.gd
    - game_manager.gd
    - save_manager.gd
  [DIR] core
    [DIR] base_classes
      - base_enemy.gd
      - base_power_up.gd
      - base_projectile.gd
    [DIR] characters
      - character_sprites.gd
      - player.gd
      - player_camera.gd
    [DIR] combat
      - damage_system.gd
      - hit_effect.gd
    [DIR] enemies
      - ardit_enemy.gd
      [DIR] behaviors
        - attack_behavior.gd
        - chase_behavior.gd
        - patrol_behavior.gd
      - goblin_archer.gd
      - goblin_mage.gd
      - goblin_melee.gd
      - prince_enemy.gd
    [DIR] items
      - coins.gd
      - elixir.gd
      - power_attack.gd
      - power_fly.gd
      - power_jump.gd
    [DIR] projectiles
      - mage_ball.gd
      - rock.gd
    [DIR] state_machine
      [DIR] enemy_states
        - enemy_idle_state.gd
      [DIR] player_states
        - player_attack_state.gd
        - player_base_state.gd
        - player_death_state.gd
        - player_fall_state.gd
        - player_fly_state.gd
        - player_hurt_state.gd
        - player_idle_state.gd
        - player_jump_state.gd
        - player_walk_state.gd
      - state.gd
      - state_machine.gd
  [DIR] levels
    - base_level.gd
  [DIR] resources
    - player_outfit_resource.gd
  [DIR] ui
    [DIR] character_customizer
      - customizer_controller.gd
      - outfit_showcase.gd
      - preview_helper.gd
    [DIR] controls
      - attack_button.gd
      - defend_button.gd
    [DIR] dialogs
      - popup_dialog.gd
      - popup_manager.gd
    [DIR] hud
      - hud_controller.gd
      - objective_tracker.gd
    [DIR] main_menu
      - camera.gd
      - customizer_button.gd
      - main_menu.gd
      - menu_buttons.gd
      - start_background.gd
    [DIR] settings
      - audio_settings.gd
      - settings_menu.gd
  [DIR] utils
    - game_resource_preloader.gd
    - killzone.gd
    - object_pool.gd
    - save_data.gd
    - ui_theme.gd

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\Artefakte\# Refactoring TODO List.md:
========================================
  # Prioritized Refactoring Analysis for The Little Saint
  
  After reviewing your Godot project structure and the refactoring ideas you've proposed, I've analyzed each suggestion based on:
  - Impact on code quality and maintainability
  - Performance improvements
  - Development workflow enhancement
  - User experience benefits
  - Current project architecture
  
  Here's my prioritized recommendation, organized by importance:
  
  ## HIGH PRIORITY
  
  1. **Core Infrastructure & Performance**
     - [NEW] `scripts/utils/object_pool.gd` - Generic object pooling system
     - [MODIFY] `scripts/core/projectiles/base_projectile.gd` - Update to use pooling
     - [MODIFY] `scripts/core/projectiles/mage_ball.gd` & `rock.gd` - Convert to use pooling
  
     **Rationale:** Object pooling will significantly improve performance, especially during combat with many projectiles. Your existing architecture already has good base classes, making this a high-impact change with relatively low implementation difficulty.
  
  2. **Combat System Enhancement**
     - [NEW] `scripts/core/combat/damage_system.gd` - Centralized damage calculation
     - [NEW] `scripts/core/enemies/behaviors/patrol_behavior.gd` - Modular patrol behavior
     - [NEW] `scripts/core/enemies/behaviors/chase_behavior.gd` - Enhanced chase behavior
     - [NEW] `scripts/core/enemies/behaviors/attack_behavior.gd` - Modular attack behavior
  
     **Rationale:** These will significantly improve your core gameplay systems. Your current enemy implementations have duplicate code that could be extracted into these behavior modules. The damage system would centralize logic currently scattered between players, enemies, and projectiles.
  
  3. **Save System Improvement**
     - [MODIFY] `scripts/autoload/save_manager.gd` - Add autosave and better error handling
  
     **Rationale:** Your current save system is already well-structured but could be enhanced with autosaving and better error handling to prevent data loss, which is critical for player experience.
  
  ## MEDIUM PRIORITY
  
  1. **Resource Management**
     - [NEW] `scripts/utils/resource_preloader.gd` - Asset preloading system
     - [MODIFY] `scripts/autoload/game_manager.gd` - Add resource preloading support
  
     **Rationale:** Proper resource management will improve loading times and memory usage but depends on the scale of your game. I noticed you're already using scene management in your game_manager.gd.
  
  2. **UI Framework Enhancements**
     - [NEW] `scripts/ui/components/ui_theme.gd` - Central theme manager
     - [MODIFY] `scripts/ui/hud/hud_controller.gd` - Refactor for modularity
  
     **Rationale:** These changes would improve your UI consistency and dialog system, which appear to be core mechanics. Your popup_manager.gd shows you're already using dialogs, so expanding this is a natural next step.
  
  3. **Player Experience**
     - [NEW] `scripts/ui/hud/objective_tracker.gd` - Quest tracking
     - [NEW] `scripts/core/combat/hit_effect.gd` - Visual hit effects
  
  4. **Audio System Enhancements**
     - [MODIFY] `scripts/autoload/audio_manager.gd`
  
  
  
  ## LOW PRIORITY
  
  1. **Visual Polish & Effects**
     - [NEW] `scripts/ui/transitions/screen_transition.gd` - Scene transition effects
     - [NEW] `scripts/core/combat/screen_shake.gd` - Camera effects for impacts
     - [NEW] `scripts/ui/components/toast_notification.gd` - Pop-up notification system
  
     **Rationale:** These are "nice-to-have" features that add polish but don't affect core functionality.
  
  2. **Development Tools**
     - [NEW] `scripts/utils/debug_console.gd` - In-game debugging console
     - [NEW] `scripts/utils/performance_monitor.gd` - Track and report performance metrics
     - [NEW] `scripts/utils/cheat_system.gd` - Developer testing cheats
  
     **Rationale:** Helpful for development but don't directly impact the end product.
  
  3. **Documentation & Advanced Systems**
     - [NEW] `docs/code_standards.md` - Coding standards
     - [NEW] `docs/architecture.md` - Project architecture documentation
     - [NEW] `scripts/audio/music_controller.gd` - Dynamic music system
     - [NEW] `scripts/utils/save_migrator.gd` - Handle save data versioning
  
     **Rationale:** Important for long-term maintenance but less immediate impact.
  
  ## Implementation Strategy
  
  I recommend implementing these changes in phases:
  
  1. **Phase 1:** High-priority infrastructure (object pooling, base improvements)
  2. **Phase 2:** Combat system enhancements
  3. **Phase 3:** UI and player experience improvements
  4. **Phase 4:** Audio and visual polish
  5. **Phase 5:** Development tools and documentation
  
  This approach ensures you're building on a solid foundation and addressing the most impactful improvements first.
  
  Looking at your existing refactoring TODO list, this plan aligns with many of those tasks but reorders some priorities based on my analysis of your codebase. Would you like me to generate a more detailed implementation plan for any specific high-priority items?

[Skipped c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\Artefakte\Game Improvements_ Object Pooling and Enemy Behaviors - Claude.html: File too large (934 KB)]

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\Artefakte\Game Improvements_ Object Pooling and Enemy Behaviors - Claude_files\2a6c828a2c61eee7.css:
========================================
  .prismjs.code-block__code,code[class*=language-]{background:#282c34;color:#abb2bf;text-shadow:0 1px rgba(0,0,0,.3);font-family:Fira Code,Fira Mono,Menlo,Consolas,DejaVu Sans Mono,monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:2;-o-tab-size:2;tab-size:2;-webkit-hyphens:none;hyphens:none}.prismjs.code-block__code{padding:1em;margin:.5em 0;overflow:auto;border-radius:.3em}.prismjs.code-block__code .table{display:inline}code[class*=language-] ::-moz-selection,code[class*=language-]::-moz-selection,pre[class*=language-] ::-moz-selection,pre[class*=language-]::-moz-selection{background:#383e49;text-shadow:none}code[class*=language-] ::selection,code[class*=language-]::selection,pre[class*=language-] ::selection,pre[class*=language-]::selection{text-shadow:none}@media print{code[class*=language-],pre[class*=language-]{text-shadow:none}}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}:not(pre)>code[class*=language-],pre[class*=language-]{background:#282c34}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#5c6370}.token.punctuation{color:#abb2bf}.token.selector,.token.tag{color:#e06c75}.token.attr-name,.token.boolean,.token.constant,.token.deleted,.token.number,.token.property,.token.symbol{color:#d19a66}.token.attr-value,.token.builtin,.token.char,.token.inserted,.token.string{color:#98c379}.language-css .token.string,.style .token.string,.token.entity,.token.operator,.token.url{color:#56b6c2}.token.atrule,.token.keyword{color:#c678dd}.token.function{color:#61afef}.token.important,.token.regex,.token.variable{color:#c678dd}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}pre.line-numbers{padding-left:3.8em;counter-reset:linenumber}pre.line-numbers,pre.line-numbers>code{position:relative}.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:0;font-size:100%;left:-3.8em;width:3em;letter-spacing:-1px;border-right:0;-webkit-user-select:none;-moz-user-select:none;user-select:none}.line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.line-numbers-rows>span:before{content:counter(linenumber);color:#5c6370;display:block;padding-right:.8em;text-align:right}@font-face{font-family:KaTeX_AMS;font-style:normal;font-weight:400;src:url(/_next/static/media/KaTeX_AMS-Regular.a79f1c31.woff2) format("woff2"),url(/_next/static/media/KaTeX_AMS-Regular.1608a09b.woff) format("woff"),url(/_next/static/media/KaTeX_AMS-Regular.4aafdb68.ttf) format("truetype")}@font-face{font-family:KaTeX_Caligraphic;font-style:normal;font-weight:700;src:url(/_next/static/media/KaTeX_Caligraphic-Bold.ec17d132.woff2) format("woff2"),url(/_next/static/media/KaTeX_Caligraphic-Bold.b6770918.woff) format("woff"),url(/_next/static/media/KaTeX_Caligraphic-Bold.cce5b8ec.ttf) format("truetype")}@font-face{font-family:KaTeX_Caligraphic;font-style:normal;font-weight:400;src:url(/_next/static/media/KaTeX_Caligraphic-Regular.55fac258.woff2) format("woff2"),url(/_next/static/media/KaTeX_Caligraphic-Regular.dad44a7f.woff) format("woff"),url(/_next/static/media/KaTeX_Caligraphic-Regular.07ef19e7.ttf) format("truetype")}@font-face{font-family:KaTeX_Fraktur;font-style:normal;font-weight:700;src:url(/_next/static/media/KaTeX_Fraktur-Bold.d42a5579.woff2) format("woff2"),url(/_next/static/media/KaTeX_Fraktur-Bold.9f256b85.woff) format("woff"),url(/_next/static/media/KaTeX_Fraktur-Bold.b18f59e1.ttf) format("truetype")}@font-face{font-family:KaTeX_Fraktur;font-style:normal;font-weight:400;src:url(/_next/static/media/KaTeX_Fraktur-Regular.d3c882a6.woff2) format("woff2"),url(/_next/static/media/KaTeX_Fraktur-Regular.7c187121.woff) format("woff"),url(/_next/static/media/KaTeX_Fraktur-Regular.ed38e79f.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:normal;font-weight:700;src:url(/_next/static/media/KaTeX_Main-Bold.c3fb5ac2.woff2) format("woff2"),url(/_next/static/media/KaTeX_Main-Bold.d181c465.woff) format("woff"),url(/_next/static/media/KaTeX_Main-Bold.b74a1a8b.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:italic;font-weight:700;src:url(/_next/static/media/KaTeX_Main-BoldItalic.6f2bb1df.woff2) format("woff2"),url(/_next/static/media/KaTeX_Main-BoldItalic.e3f82f9d.woff) format("woff"),url(/_next/static/media/KaTeX_Main-BoldItalic.70d8b0a5.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:italic;font-weight:400;src:url(/_next/static/media/KaTeX_Main-Italic.8916142b.woff2) format("woff2"),url(/_next/static/media/KaTeX_Main-Italic.9024d815.woff) format("woff"),url(/_next/static/media/KaTeX_Main-Italic.47373d1e.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:normal;font-weight:400;src:url(/_next/static/media/KaTeX_Main-Regular.0462f03b.woff2) format("woff2"),url(/_next/static/media/KaTeX_Main-Regular.7f51fe03.woff) format("woff"),url(/_next/static/media/KaTeX_Main-Regular.b7f8fe9b.ttf) format("truetype")}@font-face{font-family:KaTeX_Math;font-style:italic;font-weight:700;src:url(/_next/static/media/KaTeX_Math-BoldItalic.572d331f.woff2) format("woff2"),url(/_next/static/media/KaTeX_Math-BoldItalic.f1035d8d.woff) format("woff"),url(/_next/static/media/KaTeX_Math-BoldItalic.a879cf83.ttf) format("truetype")}@font-face{font-family:KaTeX_Math;font-style:italic;font-weight:400;src:url(/_next/static/media/KaTeX_Math-Italic.f28c23ac.woff2) format("woff2"),url(/_next/static/media/KaTeX_Math-Italic.5295ba48.woff) format("woff"),url(/_next/static/media/KaTeX_Math-Italic.939bc644.ttf) format("truetype")}@font-face{font-family:"KaTeX_SansSerif";font-style:normal;font-weight:700;src:url(/_next/static/media/KaTeX_SansSerif-Bold.8c5b5494.woff2) format("woff2"),url(/_next/static/media/KaTeX_SansSerif-Bold.bf59d231.woff) format("woff"),url(/_next/static/media/KaTeX_SansSerif-Bold.94e1e8dc.ttf) format("truetype")}@font-face{font-family:"KaTeX_SansSerif";font-style:italic;font-weight:400;src:url(/_next/static/media/KaTeX_SansSerif-Italic.3b1e59b3.woff2) format("woff2"),url(/_next/static/media/KaTeX_SansSerif-Italic.7c9bc82b.woff) format("woff"),url(/_next/static/media/KaTeX_SansSerif-Italic.b4c20c84.ttf) format("truetype")}@font-face{font-family:"KaTeX_SansSerif";font-style:normal;font-weight:400;src:url(/_next/static/media/KaTeX_SansSerif-Regular.ba21ed5f.woff2) format("woff2"),url(/_next/static/media/KaTeX_SansSerif-Regular.74048478.woff) format("woff"),url(/_next/static/media/KaTeX_SansSerif-Regular.d4d7ba48.ttf) format("truetype")}@font-face{font-family:KaTeX_Script;font-style:normal;font-weight:400;src:url(/_next/static/media/KaTeX_Script-Regular.03e9641d.woff2) format("woff2"),url(/_next/static/media/KaTeX_Script-Regular.07505710.woff) format("woff"),url(/_next/static/media/KaTeX_Script-Regular.fe9cbbe1.ttf) format("truetype")}@font-face{font-family:KaTeX_Size1;font-style:normal;font-weight:400;src:url(/_next/static/media/KaTeX_Size1-Regular.eae34984.woff2) format("woff2"),url(/_next/static/media/KaTeX_Size1-Regular.e1e279cb.woff) format("woff"),url(/_next/static/media/KaTeX_Size1-Regular.fabc004a.ttf) format("truetype")}@font-face{font-family:KaTeX_Size2;font-style:normal;font-weight:400;src:url(/_next/static/media/KaTeX_Size2-Regular.5916a24f.woff2) format("woff2"),url(/_next/static/media/KaTeX_Size2-Regular.57727022.woff) format("woff"),url(/_next/static/media/KaTeX_Size2-Regular.d6b476ec.ttf) format("truetype")}@font-face{font-family:KaTeX_Size3;font-style:normal;font-weight:400;src:url(/_next/static/media/KaTeX_Size3-Regular.b4230e7e.woff2) format("woff2"),url(/_next/static/media/KaTeX_Size3-Regular.9acaf01c.woff) format("woff"),url(/_next/static/media/KaTeX_Size3-Regular.a144ef58.ttf) format("truetype")}@font-face{font-family:KaTeX_Size4;font-style:normal;font-weight:400;src:url(/_next/static/media/KaTeX_Size4-Regular.10d95fd3.woff2) format("woff2"),url(/_next/static/media/KaTeX_Size4-Regular.7a996c9d.woff) format("woff"),url(/_next/static/media/KaTeX_Size4-Regular.fbccdabe.ttf) format("truetype")}@font-face{font-family:KaTeX_Typewriter;font-style:normal;font-weight:400;src:url(/_next/static/media/KaTeX_Typewriter-Regular.a8709e36.woff2) format("woff2"),url(/_next/static/media/KaTeX_Typewriter-Regular.6258592b.woff) format("woff"),url(/_next/static/media/KaTeX_Typewriter-Regular.d97aaf4a.ttf) format("truetype")}.katex{font:normal 1.21em KaTeX_Main,Times New Roman,serif;line-height:1.2;text-indent:0;text-rendering:auto}.katex *{-ms-high-contrast-adjust:none!important;border-color:currentColor}.katex .katex-version:after{content:"0.16.10"}.katex .katex-mathml{clip:rect(1px,1px,1px,1px);border:0;height:1px;overflow:hidden;padding:0;position:absolute;width:1px}.katex .katex-html>.newline{display:block}.katex .base{position:relative;white-space:nowrap;width:-moz-min-content;width:min-content}.katex .base,.katex .strut{display:inline-block}.katex .textbf{font-weight:700}.katex .textit{font-style:italic}.katex .textrm{font-family:KaTeX_Main}.katex .textsf{font-family:KaTeX_SansSerif}.katex .texttt{font-family:KaTeX_Typewriter}.katex .mathnormal{font-family:KaTeX_Math;font-style:italic}.katex .mathit{font-family:KaTeX_Main;font-style:italic}.katex .mathrm{font-style:normal}.katex .mathbf{font-family:KaTeX_Main;font-weight:700}.katex .boldsymbol{font-family:KaTeX_Math;font-style:italic;font-weight:700}.katex .amsrm,.katex .mathbb,.katex .textbb{font-family:KaTeX_AMS}.katex .mathcal{font-family:KaTeX_Caligraphic}.katex .mathfrak,.katex .textfrak{font-family:KaTeX_Fraktur}.katex .mathboldfrak,.katex .textboldfrak{font-family:KaTeX_Fraktur;font-weight:700}.katex .mathtt{font-family:KaTeX_Typewriter}.katex .mathscr,.katex .textscr{font-family:KaTeX_Script}.katex .mathsf,.katex .textsf{font-family:KaTeX_SansSerif}.katex .mathboldsf,.katex .textboldsf{font-family:KaTeX_SansSerif;font-weight:700}.katex .mathitsf,.katex .textitsf{font-family:KaTeX_SansSerif;font-style:italic}.katex .mainrm{font-family:KaTeX_Main;font-style:normal}.katex .vlist-t{border-collapse:collapse;display:inline-table;table-layout:fixed}.katex .vlist-r{display:table-row}.katex .vlist{display:table-cell;position:relative;vertical-align:bottom}.katex .vlist>span{display:block;height:0;position:relative}.katex .vlist>span>span{display:inline-block}.katex .vlist>span>.pstrut{overflow:hidden;width:0}.katex .vlist-t2{margin-right:-2px}.katex .vlist-s{display:table-cell;font-size:1px;min-width:2px;vertical-align:bottom;width:2px}.katex .vbox{align-items:baseline;display:inline-flex;flex-direction:column}.katex .hbox{width:100%}.katex .hbox,.katex .thinbox{display:inline-flex;flex-direction:row}.katex .thinbox{max-width:0;width:0}.katex .msupsub{text-align:left}.katex .mfrac>span>span{text-align:center}.katex .mfrac .frac-line{border-bottom-style:solid;display:inline-block;width:100%}.katex .hdashline,.katex .hline,.katex .mfrac .frac-line,.katex .overline .overline-line,.katex .rule,.katex .underline .underline-line{min-height:1px}.katex .mspace{display:inline-block}.katex .clap,.katex .llap,.katex .rlap{position:relative;width:0}.katex .clap>.inner,.katex .llap>.inner,.katex .rlap>.inner{position:absolute}.katex .clap>.fix,.katex .llap>.fix,.katex .rlap>.fix{display:inline-block}.katex .llap>.inner{right:0}.katex .clap>.inner,.katex .rlap>.inner{left:0}.katex .clap>.inner>span{margin-left:-50%;margin-right:50%}.katex .rule{border:0 solid;display:inline-block;position:relative}.katex .hline,.katex .overline .overline-line,.katex .underline .underline-line{border-bottom-style:solid;display:inline-block;width:100%}.katex .hdashline{border-bottom-style:dashed;display:inline-block;width:100%}.katex .sqrt>.root{margin-left:.27777778em;margin-right:-.55555556em}.katex .fontsize-ensurer.reset-size1.size1,.katex .sizing.reset-size1.size1{font-size:1em}.katex .fontsize-ensurer.reset-size1.size2,.katex .sizing.reset-size1.size2{font-size:1.2em}.katex .fontsize-ensurer.reset-size1.size3,.katex .sizing.reset-size1.size3{font-size:1.4em}.katex .fontsize-ensurer.reset-size1.size4,.katex .sizing.reset-size1.size4{font-size:1.6em}.katex .fontsize-ensurer.reset-size1.size5,.katex .sizing.reset-size1.size5{font-size:1.8em}.katex .fontsize-ensurer.reset-size1.size6,.katex .sizing.reset-size1.size6{font-size:2em}.katex .fontsize-ensurer.reset-size1.size7,.katex .sizing.reset-size1.size7{font-size:2.4em}.katex .fontsize-ensurer.reset-size1.size8,.katex .sizing.reset-size1.size8{font-size:2.88em}.katex .fontsize-ensurer.reset-size1.size9,.katex .sizing.reset-size1.size9{font-size:3.456em}.katex .fontsize-ensurer.reset-size1.size10,.katex .sizing.reset-size1.size10{font-size:4.148em}.katex .fontsize-ensurer.reset-size1.size11,.katex .sizing.reset-size1.size11{font-size:4.976em}.katex .fontsize-ensurer.reset-size2.size1,.katex .sizing.reset-size2.size1{font-size:.83333333em}.katex .fontsize-ensurer.reset-size2.size2,.katex .sizing.reset-size2.size2{font-size:1em}.katex .fontsize-ensurer.reset-size2.size3,.katex .sizing.reset-size2.size3{font-size:1.16666667em}.katex .fontsize-ensurer.reset-size2.size4,.katex .sizing.reset-size2.size4{font-size:1.33333333em}.katex .fontsize-ensurer.reset-size2.size5,.katex .sizing.reset-size2.size5{font-size:1.5em}.katex .fontsize-ensurer.reset-size2.size6,.katex .sizing.reset-size2.size6{font-size:1.66666667em}.katex .fontsize-ensurer.reset-size2.size7,.katex .sizing.reset-size2.size7{font-size:2em}.katex .fontsize-ensurer.reset-size2.size8,.katex .sizing.reset-size2.size8{font-size:2.4em}.katex .fontsize-ensurer.reset-size2.size9,.katex .sizing.reset-size2.size9{font-size:2.88em}.katex .fontsize-ensurer.reset-size2.size10,.katex .sizing.reset-size2.size10{font-size:3.45666667em}.katex .fontsize-ensurer.reset-size2.size11,.katex .sizing.reset-size2.size11{font-size:4.14666667em}.katex .fontsize-ensurer.reset-size3.size1,.katex .sizing.reset-size3.size1{font-size:.71428571em}.katex .fontsize-ensurer.reset-size3.size2,.katex .sizing.reset-size3.size2{font-size:.85714286em}.katex .fontsize-ensurer.reset-size3.size3,.katex .sizing.reset-size3.size3{font-size:1em}.katex .fontsize-ensurer.reset-size3.size4,.katex .sizing.reset-size3.size4{font-size:1.14285714em}.katex .fontsize-ensurer.reset-size3.size5,.katex .sizing.reset-size3.size5{font-size:1.28571429em}.katex .fontsize-ensurer.reset-size3.size6,.katex .sizing.reset-size3.size6{font-size:1.42857143em}.katex .fontsize-ensurer.reset-size3.size7,.katex .sizing.reset-size3.size7{font-size:1.71428571em}.katex .fontsize-ensurer.reset-size3.size8,.katex .sizing.reset-size3.size8{font-size:2.05714286em}.katex .fontsize-ensurer.reset-size3.size9,.katex .sizing.reset-size3.size9{font-size:2.46857143em}.katex .fontsize-ensurer.reset-size3.size10,.katex .sizing.reset-size3.size10{font-size:2.96285714em}.katex .fontsize-ensurer.reset-size3.size11,.katex .sizing.reset-size3.size11{font-size:3.55428571em}.katex .fontsize-ensurer.reset-size4.size1,.katex .sizing.reset-size4.size1{font-size:.625em}.katex .fontsize-ensurer.reset-size4.size2,.katex .sizing.reset-size4.size2{font-size:.75em}.katex .fontsize-ensurer.reset-size4.size3,.katex .sizing.reset-size4.size3{font-size:.875em}.katex .fontsize-ensurer.reset-size4.size4,.katex .sizing.reset-size4.size4{font-size:1em}.katex .fontsize-ensurer.reset-size4.size5,.katex .sizing.reset-size4.size5{font-size:1.125em}.katex .fontsize-ensurer.reset-size4.size6,.katex .sizing.reset-size4.size6{font-size:1.25em}.katex .fontsize-ensurer.reset-size4.size7,.katex .sizing.reset-size4.size7{font-size:1.5em}.katex .fontsize-ensurer.reset-size4.size8,.katex .sizing.reset-size4.size8{font-size:1.8em}.katex .fontsize-ensurer.reset-size4.size9,.katex .sizing.reset-size4.size9{font-size:2.16em}.katex .fontsize-ensurer.reset-size4.size10,.katex .sizing.reset-size4.size10{font-size:2.5925em}.katex .fontsize-ensurer.reset-size4.size11,.katex .sizing.reset-size4.size11{font-size:3.11em}.katex .fontsize-ensurer.reset-size5.size1,.katex .sizing.reset-size5.size1{font-size:.55555556em}.katex .fontsize-ensurer.reset-size5.size2,.katex .sizing.reset-size5.size2{font-size:.66666667em}.katex .fontsize-ensurer.reset-size5.size3,.katex .sizing.reset-size5.size3{font-size:.77777778em}.katex .fontsize-ensurer.reset-size5.size4,.katex .sizing.reset-size5.size4{font-size:.88888889em}.katex .fontsize-ensurer.reset-size5.size5,.katex .sizing.reset-size5.size5{font-size:1em}.katex .fontsize-ensurer.reset-size5.size6,.katex .sizing.reset-size5.size6{font-size:1.11111111em}.katex .fontsize-ensurer.reset-size5.size7,.katex .sizing.reset-size5.size7{font-size:1.33333333em}.katex .fontsize-ensurer.reset-size5.size8,.katex .sizing.reset-size5.size8{font-size:1.6em}.katex .fontsize-ensurer.reset-size5.size9,.katex .sizing.reset-size5.size9{font-size:1.92em}.katex .fontsize-ensurer.reset-size5.size10,.katex .sizing.reset-size5.size10{font-size:2.30444444em}.katex .fontsize-ensurer.reset-size5.size11,.katex .sizing.reset-size5.size11{font-size:2.76444444em}.katex .fontsize-ensurer.reset-size6.size1,.katex .sizing.reset-size6.size1{font-size:.5em}.katex .fontsize-ensurer.reset-size6.size2,.katex .sizing.reset-size6.size2{font-size:.6em}.katex .fontsize-ensurer.reset-size6.size3,.katex .sizing.reset-size6.size3{font-size:.7em}.katex .fontsize-ensurer.reset-size6.size4,.katex .sizing.reset-size6.size4{font-size:.8em}.katex .fontsize-ensurer.reset-size6.size5,.katex .sizing.reset-size6.size5{font-size:.9em}.katex .fontsize-ensurer.reset-size6.size6,.katex .sizing.reset-size6.size6{font-size:1em}.katex .fontsize-ensurer.reset-size6.size7,.katex .sizing.reset-size6.size7{font-size:1.2em}.katex .fontsize-ensurer.reset-size6.size8,.katex .sizing.reset-size6.size8{font-size:1.44em}.katex .fontsize-ensurer.reset-size6.size9,.katex .sizing.reset-size6.size9{font-size:1.728em}.katex .fontsize-ensurer.reset-size6.size10,.katex .sizing.reset-size6.size10{font-size:2.074em}.katex .fontsize-ensurer.reset-size6.size11,.katex .sizing.reset-size6.size11{font-size:2.488em}.katex .fontsize-ensurer.reset-size7.size1,.katex .sizing.reset-size7.size1{font-size:.41666667em}.katex .fontsize-ensurer.reset-size7.size2,.katex .sizing.reset-size7.size2{font-size:.5em}.katex .fontsize-ensurer.reset-size7.size3,.katex .sizing.reset-size7.size3{font-size:.58333333em}.katex .fontsize-ensurer.reset-size7.size4,.katex .sizing.reset-size7.size4{font-size:.66666667em}.katex .fontsize-ensurer.reset-size7.size5,.katex .sizing.reset-size7.size5{font-size:.75em}.katex .fontsize-ensurer.reset-size7.size6,.katex .sizing.reset-size7.size6{font-size:.83333333em}.katex .fontsize-ensurer.reset-size7.size7,.katex .sizing.reset-size7.size7{font-size:1em}.katex .fontsize-ensurer.reset-size7.size8,.katex .sizing.reset-size7.size8{font-size:1.2em}.katex .fontsize-ensurer.reset-size7.size9,.katex .sizing.reset-size7.size9{font-size:1.44em}.katex .fontsize-ensurer.reset-size7.size10,.katex .sizing.reset-size7.size10{font-size:1.72833333em}.katex .fontsize-ensurer.reset-size7.size11,.katex .sizing.reset-size7.size11{font-size:2.07333333em}.katex .fontsize-ensurer.reset-size8.size1,.katex .sizing.reset-size8.size1{font-size:.34722222em}.katex .fontsize-ensurer.reset-size8.size2,.katex .sizing.reset-size8.size2{font-size:.41666667em}.katex .fontsize-ensurer.reset-size8.size3,.katex .sizing.reset-size8.size3{font-size:.48611111em}.katex .fontsize-ensurer.reset-size8.size4,.katex .sizing.reset-size8.size4{font-size:.55555556em}.katex .fontsize-ensurer.reset-size8.size5,.katex .sizing.reset-size8.size5{font-size:.625em}.katex .fontsize-ensurer.reset-size8.size6,.katex .sizing.reset-size8.size6{font-size:.69444444em}.katex .fontsize-ensurer.reset-size8.size7,.katex .sizing.reset-size8.size7{font-size:.83333333em}.katex .fontsize-ensurer.reset-size8.size8,.katex .sizing.reset-size8.size8{font-size:1em}.katex .fontsize-ensurer.reset-size8.size9,.katex .sizing.reset-size8.size9{font-size:1.2em}.katex .fontsize-ensurer.reset-size8.size10,.katex .sizing.reset-size8.size10{font-size:1.44027778em}.katex .fontsize-ensurer.reset-size8.size11,.katex .sizing.reset-size8.size11{font-size:1.72777778em}.katex .fontsize-ensurer.reset-size9.size1,.katex .sizing.reset-size9.size1{font-size:.28935185em}.katex .fontsize-ensurer.reset-size9.size2,.katex .sizing.reset-size9.size2{font-size:.34722222em}.katex .fontsize-ensurer.reset-size9.size3,.katex .sizing.reset-size9.size3{font-size:.40509259em}.katex .fontsize-ensurer.reset-size9.size4,.katex .sizing.reset-size9.size4{font-size:.46296296em}.katex .fontsize-ensurer.reset-size9.size5,.katex .sizing.reset-size9.size5{font-size:.52083333em}.katex .fontsize-ensurer.reset-size9.size6,.katex .sizing.reset-size9.size6{font-size:.5787037em}.katex .fontsize-ensurer.reset-size9.size7,.katex .sizing.reset-size9.size7{font-size:.69444444em}.katex .fontsize-ensurer.reset-size9.size8,.katex .sizing.reset-size9.size8{font-size:.83333333em}.katex .fontsize-ensurer.reset-size9.size9,.katex .sizing.reset-size9.size9{font-size:1em}.katex .fontsize-ensurer.reset-size9.size10,.katex .sizing.reset-size9.size10{font-size:1.20023148em}.katex .fontsize-ensurer.reset-size9.size11,.katex .sizing.reset-size9.size11{font-size:1.43981481em}.katex .fontsize-ensurer.reset-size10.size1,.katex .sizing.reset-size10.size1{font-size:.24108004em}.katex .fontsize-ensurer.reset-size10.size2,.katex .sizing.reset-size10.size2{font-size:.28929605em}.katex .fontsize-ensurer.reset-size10.size3,.katex .sizing.reset-size10.size3{font-size:.33751205em}.katex .fontsize-ensurer.reset-size10.size4,.katex .sizing.reset-size10.size4{font-size:.38572806em}.katex .fontsize-ensurer.reset-size10.size5,.katex .sizing.reset-size10.size5{font-size:.43394407em}.katex .fontsize-ensurer.reset-size10.size6,.katex .sizing.reset-size10.size6{font-size:.48216008em}.katex .fontsize-ensurer.reset-size10.size7,.katex .sizing.reset-size10.size7{font-size:.57859209em}.katex .fontsize-ensurer.reset-size10.size8,.katex .sizing.reset-size10.size8{font-size:.69431051em}.katex .fontsize-ensurer.reset-size10.size9,.katex .sizing.reset-size10.size9{font-size:.83317261em}.katex .fontsize-ensurer.reset-size10.size10,.katex .sizing.reset-size10.size10{font-size:1em}.katex .fontsize-ensurer.reset-size10.size11,.katex .sizing.reset-size10.size11{font-size:1.19961427em}.katex .fontsize-ensurer.reset-size11.size1,.katex .sizing.reset-size11.size1{font-size:.20096463em}.katex .fontsize-ensurer.reset-size11.size2,.katex .sizing.reset-size11.size2{font-size:.24115756em}.katex .fontsize-ensurer.reset-size11.size3,.katex .sizing.reset-size11.size3{font-size:.28135048em}.katex .fontsize-ensurer.reset-size11.size4,.katex .sizing.reset-size11.size4{font-size:.32154341em}.katex .fontsize-ensurer.reset-size11.size5,.katex .sizing.reset-size11.size5{font-size:.36173633em}.katex .fontsize-ensurer.reset-size11.size6,.katex .sizing.reset-size11.size6{font-size:.40192926em}.katex .fontsize-ensurer.reset-size11.size7,.katex .sizing.reset-size11.size7{font-size:.48231511em}.katex .fontsize-ensurer.reset-size11.size8,.katex .sizing.reset-size11.size8{font-size:.57877814em}.katex .fontsize-ensurer.reset-size11.size9,.katex .sizing.reset-size11.size9{font-size:.69453376em}.katex .fontsize-ensurer.reset-size11.size10,.katex .sizing.reset-size11.size10{font-size:.83360129em}.katex .fontsize-ensurer.reset-size11.size11,.katex .sizing.reset-size11.size11{font-size:1em}.katex .delimsizing.size1{font-family:KaTeX_Size1}.katex .delimsizing.size2{font-family:KaTeX_Size2}.katex .delimsizing.size3{font-family:KaTeX_Size3}.katex .delimsizing.size4{font-family:KaTeX_Size4}.katex .delimsizing.mult .delim-size1>span{font-family:KaTeX_Size1}.katex .delimsizing.mult .delim-size4>span{font-family:KaTeX_Size4}.katex .nulldelimiter{display:inline-block;width:.12em}.katex .delimcenter,.katex .op-symbol{position:relative}.katex .op-symbol.small-op{font-family:KaTeX_Size1}.katex .op-symbol.large-op{font-family:KaTeX_Size2}.katex .accent>.vlist-t,.katex .op-limits>.vlist-t{text-align:center}.katex .accent .accent-body{position:relative}.katex .accent .accent-body:not(.accent-full){width:0}.katex .overlay{display:block}.katex .mtable .vertical-separator{display:inline-block;min-width:1px}.katex .mtable .arraycolsep{display:inline-block}.katex .mtable .col-align-c>.vlist-t{text-align:center}.katex .mtable .col-align-l>.vlist-t{text-align:left}.katex .mtable .col-align-r>.vlist-t{text-align:right}.katex .svg-align{text-align:left}.katex svg{fill:currentColor;stroke:currentColor;fill-rule:nonzero;fill-opacity:1;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;display:block;height:inherit;position:absolute;width:100%}.katex svg path{stroke:none}.katex img{border-style:none;max-height:none;max-width:none;min-height:0;min-width:0}.katex .stretchy{display:block;overflow:hidden;position:relative;width:100%}.katex .stretchy:after,.katex .stretchy:before{content:""}.katex .hide-tail{overflow:hidden;position:relative;width:100%}.katex .halfarrow-left{left:0;overflow:hidden;position:absolute;width:50.2%}.katex .halfarrow-right{overflow:hidden;position:absolute;right:0;width:50.2%}.katex .brace-left{left:0;overflow:hidden;position:absolute;width:25.1%}.katex .brace-center{left:25%;overflow:hidden;position:absolute;width:50%}.katex .brace-right{overflow:hidden;position:absolute;right:0;width:25.1%}.katex .x-arrow-pad{padding:0 .5em}.katex .cd-arrow-pad{padding:0 .55556em 0 .27778em}.katex .mover,.katex .munder,.katex .x-arrow{text-align:center}.katex .boxpad{padding:0 .3em}.katex .fbox,.katex .fcolorbox{border:.04em solid;box-sizing:border-box}.katex .cancel-pad{padding:0 .2em}.katex .cancel-lap{margin-left:-.2em;margin-right:-.2em}.katex .sout{border-bottom-style:solid;border-bottom-width:.08em}.katex .angl{border-right:.049em solid;border-top:.049em solid;box-sizing:border-box;margin-right:.03889em}.katex .anglpad{padding:0 .03889em}.katex .eqn-num:before{content:"(" counter(katexEqnNo) ")";counter-increment:katexEqnNo}.katex .mml-eqn-num:before{content:"(" counter(mmlEqnNo) ")";counter-increment:mmlEqnNo}.katex .mtr-glue{width:50%}.katex .cd-vert-arrow{display:inline-block;position:relative}.katex .cd-label-left{display:inline-block;position:absolute;right:calc(50% + .3em);text-align:left}.katex .cd-label-right{display:inline-block;left:calc(50% + .3em);position:absolute;text-align:right}.katex-display{display:block;margin:1em 0;text-align:center}.katex-display>.katex{display:block;text-align:center;white-space:nowrap}.katex-display>.katex>.katex-html{display:block;position:relative}.katex-display>.katex>.katex-html>.tag{position:absolute;right:0}.katex-display.leqno>.katex>.katex-html>.tag{left:0;right:auto}.katex-display.fleqn>.katex{padding-left:2em;text-align:left}body{counter-reset:katexEqnNo mmlEqnNo}

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\Artefakte\Game Improvements_ Object Pooling and Enemy Behaviors - Claude_files\66ce72d8d8960cc4.css:
========================================
  @font-face{font-family:__styreneA_dcab32;src:url(/_next/static/media/db2277a4dc542e54-s.p.woff2) format("woff2");font-display:swap;font-weight:500;font-style:normal}@font-face{font-family:__styreneA_dcab32;src:url(/_next/static/media/cfe503504e29ad5d-s.p.woff2) format("woff2");font-display:swap;font-weight:500;font-style:italic}@font-face{font-family:__styreneA_dcab32;src:url(/_next/static/media/d7440d3c533a1aec-s.p.woff2) format("woff2");font-display:swap;font-weight:400;font-style:normal}@font-face{font-family:__styreneA_dcab32;src:url(/_next/static/media/2d21c5135ef46b39-s.p.woff2) format("woff2");font-display:swap;font-weight:400;font-style:italic}@font-face{font-family:__styreneA_Fallback_dcab32;src:local("Arial");ascent-override:87.08%;descent-override:19.74%;line-gap-override:0.00%;size-adjust:119.55%}.__className_dcab32{font-family:__styreneA_dcab32,__styreneA_Fallback_dcab32}.__variable_dcab32{--font-styrene-a:"__styreneA_dcab32","__styreneA_Fallback_dcab32"}@font-face{font-family:__copernicus_669e4a;src:url(/_next/static/media/4e8887750eb14755-s.p.woff2) format("woff2");font-display:swap;font-weight:500;font-style:normal}@font-face{font-family:__copernicus_669e4a;src:url(/_next/static/media/5cc13524e09f5d21-s.p.woff2) format("woff2");font-display:swap;font-weight:500;font-style:italic}@font-face{font-family:__copernicus_669e4a;src:url(/_next/static/media/177b7db6a26ff4c3-s.p.woff2) format("woff2");font-display:swap;font-weight:400;font-style:normal}@font-face{font-family:__copernicus_669e4a;src:url(/_next/static/media/6a2030c2a5787e7a-s.p.woff2) format("woff2");font-display:swap;font-weight:400;font-style:italic}@font-face{font-family:__copernicus_Fallback_669e4a;src:local("Arial");ascent-override:91.25%;descent-override:39.11%;line-gap-override:0.00%;size-adjust:115.07%}.__className_669e4a{font-family:__copernicus_669e4a,__copernicus_Fallback_669e4a}.__variable_669e4a{--font-copernicus:"__copernicus_669e4a","__copernicus_Fallback_669e4a"}@font-face{font-family:__styreneB_820c23;src:url(/_next/static/media/183a0d33cd5ef006-s.p.woff2) format("woff2");font-display:swap;font-weight:400;font-style:normal}@font-face{font-family:__styreneB_820c23;src:url(/_next/static/media/5fee9713a1748cc9-s.p.woff2) format("woff2");font-display:swap;font-weight:400;font-style:italic}@font-face{font-family:__styreneB_820c23;src:url(/_next/static/media/8217ebd4682cfe49-s.p.woff2) format("woff2");font-display:swap;font-weight:500;font-style:normal}@font-face{font-family:__styreneB_820c23;src:url(/_next/static/media/d13ff1ddfcb21419-s.p.woff2) format("woff2");font-display:swap;font-weight:500;font-style:italic}@font-face{font-family:__styreneB_Fallback_820c23;src:local("Arial");ascent-override:91.44%;descent-override:23.76%;line-gap-override:2.60%;size-adjust:111.54%}.__className_820c23{font-family:__styreneB_820c23,__styreneB_Fallback_820c23}.__variable_820c23{--font-styrene-b:"__styreneB_820c23","__styreneB_Fallback_820c23"}@font-face{font-family:__openDyslexic_e4ce97;src:url(/_next/static/media/a72997480c14a9d4-s.p.woff2) format("woff2");font-display:swap;font-weight:500;font-style:normal}@font-face{font-family:__openDyslexic_e4ce97;src:url(/_next/static/media/a0eafab536ffd221-s.p.woff2) format("woff2");font-display:swap;font-weight:500;font-style:italic}@font-face{font-family:__openDyslexic_e4ce97;src:url(/_next/static/media/b96accb76593e50d-s.p.woff2) format("woff2");font-display:swap;font-weight:400;font-style:normal}@font-face{font-family:__openDyslexic_e4ce97;src:url(/_next/static/media/d4ad98ce6ee578c0-s.p.woff2) format("woff2");font-display:swap;font-weight:400;font-style:italic}@font-face{font-family:__openDyslexic_Fallback_e4ce97;src:local("Arial");ascent-override:100.70%;descent-override:40.28%;line-gap-override:0.00%;size-adjust:124.14%}.__className_e4ce97{font-family:__openDyslexic_e4ce97,__openDyslexic_Fallback_e4ce97}.__variable_e4ce97{--font-open-dyslexic:"__openDyslexic_e4ce97","__openDyslexic_Fallback_e4ce97"}@font-face{font-family:__tiempos_b4db0f;src:url(/_next/static/media/f6f0b26c2c0e7b63-s.p.woff2) format("woff2");font-display:swap;font-weight:400;font-style:normal}@font-face{font-family:__tiempos_b4db0f;src:url(/_next/static/media/2cc8547efe9f163a-s.p.woff2) format("woff2");font-display:swap;font-weight:400;font-style:italic}@font-face{font-family:__tiempos_b4db0f;src:url(/_next/static/media/3b066fe34f61f169-s.p.woff2) format("woff2");font-display:swap;font-weight:700;font-style:normal}@font-face{font-family:__tiempos_b4db0f;src:url(/_next/static/media/ae9d065a0123ed8a-s.p.woff2) format("woff2");font-display:swap;font-weight:700;font-style:italic}@font-face{font-family:__tiempos_Fallback_b4db0f;src:local("Arial");ascent-override:97.15%;descent-override:23.67%;line-gap-override:0.00%;size-adjust:105.61%}.__className_b4db0f{font-family:__tiempos_b4db0f,__tiempos_Fallback_b4db0f}.__variable_b4db0f{--font-tiempos:"__tiempos_b4db0f","__tiempos_Fallback_b4db0f"}

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\Artefakte\Game Improvements_ Object Pooling and Enemy Behaviors - Claude_files\81f7f7f9632d10e1.css:
========================================
  .cm-editor,.cm-merge-theme,.cm-mergeView,.cm-scroller,.cm-theme-dark,.cm-theme-light{width:100%;height:100%}.cm-deletedChunk{.cm-chunkButtons{display:none}&:hover{.cm-chunkButtons{display:block}}}

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\Artefakte\Game Improvements_ Object Pooling and Enemy Behaviors - Claude_files\9b094e616fc0d0cc.css:
========================================
  .hljs{display:block;overflow-x:auto;padding:.5em;color:#abb2bf;background:#282c34}.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#c678dd}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#98c379}.hljs-built_in,.hljs-class .hljs-title{color:#e6c07b}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}:root{--always-white:0 0% 100%;--always-black:0 0% 0%;--constant-book-cloth:15 52.3% 58%;--constant-clay:15 63.1% 59.6%;--constant-kraft:25 49.7% 66.5%;--constant-manilla:40 54% 82.9%;--constant-slate-000:0 0% 100%;--constant-slate-050:48 33.3% 97.1%;--constant-slate-100:53 28.6% 94.5%;--constant-slate-1000:60 3.4% 5.7%;--constant-slate-150:48 25% 92.2%;--constant-slate-200:50 20.7% 88.6%;--constant-slate-250:51 16.5% 84.5%;--constant-slate-300:50 11.5% 79.6%;--constant-slate-350:50 9% 73.7%;--constant-slate-400:49 6.5% 66.9%;--constant-slate-450:48 4.8% 59.2%;--constant-slate-500:53 3.2% 51.4%;--constant-slate-550:51 3.1% 43.7%;--constant-slate-600:48 2.7% 35.9%;--constant-slate-650:48 3.4% 29.2%;--constant-slate-700:60 2.5% 23.3%;--constant-slate-750:60 2.1% 18.4%;--constant-slate-800:60 2.7% 14.5%;--constant-slate-850:30 3.3% 11.8%;--constant-slate-900:30 4% 9.8%;--constant-slate-950:60 2.6% 7.6%}[data-theme=claude],[data-theme=claude][data-mode=light]{--accent-brand:var(--constant-clay);--accent-main-000:15 52.7% 43.9%;--accent-main-100:16 53.8% 47.5%;--accent-main-200:15 55.6% 52.4%;--accent-main-900:15 48% 90.2%;--accent-pro-000:251 34.2% 33.3%;--accent-pro-100:251 40% 45.1%;--accent-pro-200:251 61% 72.2%;--accent-pro-900:253 33.3% 91.8%;--accent-secondary-000:210 74.2% 42.1%;--accent-secondary-100:210 74.8% 49.8%;--accent-secondary-200:210 74.8% 57%;--accent-secondary-900:210 68.8% 93.3%;--bg-000:var(--constant-slate-000);--bg-100:var(--constant-slate-050);--bg-200:var(--constant-slate-150);--bg-300:var(--constant-slate-200);--bg-400:var(--constant-slate-250);--bg-500:var(--constant-slate-300);--border-100:var(--constant-slate-500);--border-200:var(--constant-slate-500);--border-300:var(--constant-slate-500);--border-400:var(--constant-slate-500);--danger-000:5 74% 28%;--danger-100:5 73.9% 37.7%;--danger-200:5 49.5% 58%;--danger-900:0 40.3% 89%;--oncolor-100:var(--constant-slate-000);--oncolor-200:60 6.7% 97.1%;--oncolor-300:60 6.7% 97.1%;--text-000:49 6.9% 5.5%;--text-100:49 19.6% 13.3%;--text-200:49 18.8% 20%;--text-300:49 9% 30%;--text-400:49 7% 37%;--text-500:51 7.5% 42.1%}[data-theme=claude][data-mode=dark]{--accent-brand:var(--constant-clay);--accent-main-000:18 50.4% 47.5%;--accent-main-100:18 56.8% 43.5%;--accent-main-200:19 58.3% 40.4%;--accent-main-900:16 41.3% 18%;--accent-pro-000:251 84.6% 74.5%;--accent-pro-100:251 40.2% 54.1%;--accent-pro-200:251 40% 45.1%;--accent-pro-900:250 25.3% 19.4%;--accent-secondary-000:210 74.8% 57%;--accent-secondary-100:210 74.8% 49.8%;--accent-secondary-200:210 74.2% 42.1%;--accent-secondary-900:210 19.5% 18%;--bg-000:var(--constant-slate-700);--bg-100:var(--constant-slate-750);--bg-200:var(--constant-slate-800);--bg-300:var(--constant-slate-850);--bg-400:var(--constant-slate-900);--bg-500:var(--constant-slate-950);--border-100:var(--constant-slate-600);--border-200:var(--constant-slate-600);--border-300:var(--constant-slate-600);--border-400:var(--constant-slate-600);--danger-000:5 69.4% 72.9%;--danger-100:5 79.4% 70.8%;--danger-200:5 53.6% 44.8%;--danger-900:0 21.4% 17.6%;--oncolor-100:var(--constant-slate-000);--oncolor-200:60 6.7% 97.1%;--oncolor-300:60 6.7% 97.1%;--text-000:60 6.7% 97.1%;--text-100:50 23.1% 94.9%;--text-200:60 5.5% 89.2%;--text-300:47 8.4% 79%;--text-400:48 9.6% 69.2%;--text-500:45 6.3% 62.9%}@media (prefers-color-scheme:dark){[data-theme=claude]{--accent-brand:var(--constant-clay);--accent-main-000:18 50.4% 47.5%;--accent-main-100:18 56.8% 43.5%;--accent-main-200:19 58.3% 40.4%;--accent-main-900:16 41.3% 18%;--accent-pro-000:251 84.6% 74.5%;--accent-pro-100:251 40.2% 54.1%;--accent-pro-200:251 40% 45.1%;--accent-pro-900:250 25.3% 19.4%;--accent-secondary-000:210 74.8% 57%;--accent-secondary-100:210 74.8% 49.8%;--accent-secondary-200:210 74.2% 42.1%;--accent-secondary-900:210 19.5% 18%;--bg-000:var(--constant-slate-700);--bg-100:var(--constant-slate-750);--bg-200:var(--constant-slate-800);--bg-300:var(--constant-slate-850);--bg-400:var(--constant-slate-900);--bg-500:var(--constant-slate-950);--border-100:var(--constant-slate-600);--border-200:var(--constant-slate-600);--border-300:var(--constant-slate-600);--border-400:var(--constant-slate-600);--danger-000:5 69.4% 72.9%;--danger-100:5 79.4% 70.8%;--danger-200:5 53.6% 44.8%;--danger-900:0 21.4% 17.6%;--oncolor-100:var(--constant-slate-000);--oncolor-200:60 6.7% 97.1%;--oncolor-300:60 6.7% 97.1%;--text-000:60 6.7% 97.1%;--text-100:50 23.1% 94.9%;--text-200:60 5.5% 89.2%;--text-300:47 8.4% 79%;--text-400:48 9.6% 69.2%;--text-500:45 6.3% 62.9%}}[data-theme=console],[data-theme=console][data-mode=dark]{--accent-brand:var(--constant-clay);--accent-main-000:18 50.4% 47.5%;--accent-main-100:18 56.8% 43.5%;--accent-main-200:19 58.3% 40.4%;--accent-main-900:16 21.6% 20%;--accent-pro-000:251 40.2% 54.1%;--accent-pro-100:251 40% 45.1%;--accent-pro-200:251 34.2% 33.3%;--accent-pro-900:249 25% 19.4%;--accent-secondary-000:158 68% 32%;--accent-secondary-100:158 80.4% 28%;--accent-secondary-200:158 79.2% 24.5%;--accent-secondary-900:160 18.1% 16.3%;--bg-000:0 0% 6%;--bg-100:0 0% 10%;--bg-200:0 0% 14%;--bg-300:0 0% 17%;--bg-400:0 0% 19%;--bg-500:0 0% 23%;--border-100:0 0% 42%;--border-200:0 0% 42%;--border-300:0 0% 42%;--border-400:0 0% 42%;--danger-000:4 90.4% 79.5%;--danger-100:5 91.7% 72.5%;--danger-200:5 58.4% 33.9%;--danger-900:0 48.2% 16.5%;--oncolor-100:var(--constant-slate-000);--oncolor-200:60 6.7% 97.1%;--oncolor-300:60 6.7% 97.1%;--text-000:var(--constant-slate-000);--text-100:60 3.7% 94.7%;--text-200:60 1.5% 86.9%;--text-300:30 1.4% 71.8%;--text-400:50 0.8% 65.1%;--text-500:45 0.6% 48%}[data-theme=claude2025],[data-theme=claude2025][data-mode=light]{--accent-brand:var(--constant-clay);--accent-main-000:15 52.7% 43.9%;--accent-main-100:16 53.8% 47.5%;--accent-main-200:15 55.6% 52.4%;--accent-main-900:15 48% 90.2%;--accent-pro-000:251 34.2% 33.3%;--accent-pro-100:251 40% 45.1%;--accent-pro-200:251 61% 72.2%;--accent-pro-900:253 33.3% 91.8%;--accent-secondary-000:210 74.2% 42.1%;--accent-secondary-100:210 74.8% 49.8%;--accent-secondary-200:210 74.8% 57%;--accent-secondary-900:210 68.8% 93.3%;--bg-000:0 0% 100%;--bg-100:45 100% 99%;--bg-200:48 33% 97%;--bg-300:53 29% 95%;--bg-400:48 25% 92%;--bg-500:50 21% 89%;--border-100:var(--constant-slate-500);--border-200:var(--constant-slate-500);--border-300:var(--constant-slate-500);--border-400:var(--constant-slate-500);--danger-000:5 74% 28%;--danger-100:5 73.9% 37.7%;--danger-200:5 49.5% 58%;--danger-900:0 40.3% 89%;--oncolor-100:var(--constant-slate-000);--oncolor-200:60 6.7% 97.1%;--oncolor-300:60 6.7% 97.1%;--text-000:60 3% 6%;--text-100:60 3% 6%;--text-200:60 3% 6%;--text-300:48 3% 36%;--text-400:48 3% 36%;--text-500:51 3% 44%}[data-theme=claude2025][data-mode=dark]{--accent-brand:var(--constant-clay);--accent-main-000:18 50.4% 47.5%;--accent-main-100:18 56.8% 43.5%;--accent-main-200:19 58.3% 40.4%;--accent-main-900:16 41.3% 18%;--accent-pro-000:251 84.6% 74.5%;--accent-pro-100:251 40.2% 54.1%;--accent-pro-200:251 40% 45.1%;--accent-pro-900:250 25.3% 19.4%;--accent-secondary-000:210 74.8% 57%;--accent-secondary-100:210 74.8% 49.8%;--accent-secondary-200:210 74.2% 42.1%;--accent-secondary-900:210 19.5% 18%;--bg-000:60 2% 18%;--bg-100:60 3% 15%;--bg-200:30 3% 12%;--bg-300:60 3% 8%;--bg-400:60 3% 6%;--bg-500:0 0% 0%;--border-100:var(--constant-slate-600);--border-200:var(--constant-slate-600);--border-300:var(--constant-slate-600);--border-400:var(--constant-slate-600);--danger-000:5 69.4% 72.9%;--danger-100:5 79.4% 70.8%;--danger-200:5 53.6% 44.8%;--danger-900:0 21.4% 17.6%;--oncolor-100:var(--constant-slate-000);--oncolor-200:60 6.7% 97.1%;--oncolor-300:60 6.7% 97.1%;--text-000:48 33% 97%;--text-100:48 33% 97%;--text-200:48 33% 97%;--text-300:50 9% 74%;--text-400:50 9% 74%;--text-500:48 5% 59%}@media (prefers-color-scheme:dark){[data-theme=claude]{--accent-brand:var(--constant-clay);--accent-main-000:18 50.4% 47.5%;--accent-main-100:18 56.8% 43.5%;--accent-main-200:19 58.3% 40.4%;--accent-main-900:16 41.3% 18%;--accent-pro-000:251 84.6% 74.5%;--accent-pro-100:251 40.2% 54.1%;--accent-pro-200:251 40% 45.1%;--accent-pro-900:250 25.3% 19.4%;--accent-secondary-000:210 74.8% 57%;--accent-secondary-100:210 74.8% 49.8%;--accent-secondary-200:210 74.2% 42.1%;--accent-secondary-900:210 19.5% 18%;--bg-000:60 2% 18%;--bg-100:60 3% 15%;--bg-200:30 3% 12%;--bg-300:60 3% 8%;--bg-400:60 3% 6%;--bg-500:0 0% 0%;--border-100:var(--constant-slate-600);--border-200:var(--constant-slate-600);--border-300:var(--constant-slate-600);--border-400:var(--constant-slate-600);--danger-000:5 69.4% 72.9%;--danger-100:5 79.4% 70.8%;--danger-200:5 53.6% 44.8%;--danger-900:0 21.4% 17.6%;--oncolor-100:var(--constant-slate-000);--oncolor-200:60 6.7% 97.1%;--oncolor-300:60 6.7% 97.1%;--text-000:48 33% 97%;--text-100:48 33% 97%;--text-200:48 33% 97%;--text-300:50 9% 74%;--text-400:50 9% 74%;--text-500:48 5% 59%}}

[Skipped c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\Artefakte\Game Improvements_ Object Pooling and Enemy Behaviors - Claude_files\dfb136612d1c5192.css: File too large (171 KB)]

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\Artefakte\Game Improvements_ Object Pooling and Enemy Behaviors - Claude_files\ef46db3751d8e999.css:
========================================


========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\Artefakte\Game Improvements_ Object Pooling and Enemy Behaviors - Claude_files\inner.html:
========================================
  <!DOCTYPE html>
  <!-- saved from url=(0270)https://m.stripe.network/inner.html#url=https%3A%2F%2Fclaude.ai%2Fnew&title=Claude&referrer=https%3A%2F%2Fclaude.ai%2Fchat%2Fbcd9939d-f03f-4456-954e-090c43df4816&muid=8bc0f6e7-6924-4f07-b250-f9d8c6d9316d38eae1&sid=NA&version=6&preview=false&__shared_params__[version]=v3 -->
  <html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>StripeM-Inner</title></head><body><script>!function(){var e=document.createElement("script");e.defer=!0,e.src="out-4.5.44.js",e.onload=function(){var e;window.StripeM&&(e=window.location.hash,/ping=false/.test(e)||(e=(e=e.match(/version=(4|6)/))?e[1]:"4",window.StripeM.p({t:!0,v:e})),e=function(e){if(window.opener||window.parent||window)try{var i=((t=JSON.parse(e.data)).message||t).action,t=t.message?t.message.payload:t;switch(i){case"ping":window.StripeM.p({t:!0,o:{muid:t.muid,sid:t.sid,referrer:t.referrer,url:t.url,title:t.title,v2:t.v2},v:t.version||"4"});break;case"track":if(!t.source||!t.data)return;window.StripeM.b({muid:t.muid,sid:t.sid,url:t.url,source:t.source,data:t.data},t.version||"4")}}catch(e){}},window.addEventListener?window.addEventListener("message",e,!1):window.attachEvent("onMessage",e))},document.body.appendChild(e)}()</script><script defer="" src="./out-4.5.44.js.Download"></script></body></html>

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\Artefakte\Game Improvements_ Object Pooling and Enemy Behaviors - Claude_files\m-outer-3437aaddcdf6922d623e172c2d6f9278.html:
========================================
  <!DOCTYPE html>
  <!-- saved from url=(0305)https://js.stripe.com/v3/m-outer-3437aaddcdf6922d623e172c2d6f9278.html#url=https%3A%2F%2Fclaude.ai%2Fnew&title=Claude&referrer=https%3A%2F%2Fclaude.ai%2Fchat%2Fbcd9939d-f03f-4456-954e-090c43df4816&muid=8bc0f6e7-6924-4f07-b250-f9d8c6d9316d38eae1&sid=NA&version=6&preview=false&__shared_params__[version]=v3 -->
  <html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script defer="defer" src="./m-outer-15a2b40a058ddff1cffdb63779fe3de1.js.Download"></script></head><body><iframe src="./inner.html"></iframe></body></html>

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\Artefakte\Game Improvements_ Object Pooling and Enemy Behaviors - Claude_files\saved_resource(1).html:
========================================
  
  <!-- saved from url=(0011)about:blank -->
  <html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
        <script type="text/javascript" charset="utf-8" src="https://js.intercomcdn.com/frame-modern.06c0ae9a.js"></script><script type="text/javascript" charset="utf-8" src="https://js.intercomcdn.com/vendor-modern.fe3bc4ee.js"></script></head>
        <body>
  
      </body></html>

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\Artefakte\Game Improvements_ Object Pooling and Enemy Behaviors - Claude_files\saved_resource.html:
========================================
  
  <!-- saved from url=(0011)about:blank -->
  <html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script>window.__CF$cv$params={r:'924001e8bd2adbc3',t:'MTc0MjU4NjkzMi4wMDAwMDA='};var a=document.createElement('script');a.nonce='7e5f32bf-2854-4b63-a6d2-6f0730d44c18';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);</script><script src="https://claude.ai/cdn-cgi/challenge-platform/scripts/jsd/main.js"></script></head><body></body></html>

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\README.md:
========================================
  # Godot Virtual Joystick
  
  <img src="addons/virtual_joystick/previews/icon.png" width="200">
  
  A simple virtual joystick for touchscreens, with useful options.
  
  GitHub Page: https://github.com/MarcoFazioRandom/Virtual-Joystick-Godot
  
  Godot Engine: https://godotengine.org
  
  ## PREVIEWS:
  
  <img src="addons/virtual_joystick/previews/preview1.png" width="300">    <img src="addons/virtual_joystick/previews/preview2.png" width="300">
  
  Easy to use:
  
  ```GDScript
  extends Sprite2D
  
  @export var speed : float = 100
  
  @export var joystick_left : VirtualJoystick
  
  @export var joystick_right : VirtualJoystick
  
  var move_vector := Vector2.ZERO
  
  func _process(delta: float) -> void:
  	## Movement using the joystick output:
  #	if joystick_left and joystick_left.is_pressed:
  #		position += joystick_left.output * speed * delta
  
  	## Movement using Input functions:
  	move_vector = Vector2.ZERO
  	move_vector = Input.get_vector("ui_left","ui_right","ui_up","ui_down")
  	position += move_vector * speed * delta
  
  	# Rotation:
  	if joystick_right and joystick_right.is_pressed:
  		rotation = joystick_right.output.angle()
  ```
  
  
  ## OPTIONS:
  
  - Joystick mode:
  	- Fixed: The joystick doesn't move.
  	- Dynamic: Every time the joystick area is pressed, the joystick position is set on the touched position.
  	- Following: When the finger moves outside the joystick area, the joystick will follow it.
  
  - Dead zone size: If the tip is inside this range the output is zero.
  
  - Clamp zone size: The max distance the tip can reach.
  
  - Visibility mode:
  	- always: Always visible.
  	- touchscreen only: Visible on touch screens only (will hide if the device has not a touchscreen).
  	- when_touched: Visible only when touched.
  
  - Use input actions: if true the joystick will trigger the input actions created in Project -> Project Settings -> Input Map
  
  ## HELP:
  - The Control parent of the joystick is the area in which the joystick can move in Dynamic mode.
  - For moving the joystick inside his area, select it, right click, turn on "Editable Children" and then change the position of the Base node.
  - With "Editable Children" turned on you can also edit the joystick textures and colors.
  - Create a CanvasLayer node and name it "UI", it'll contain all the UI elements, then add the Joystick scene as a child of the UI node and move it where you prefer.
  - An example scene is provided in the "Test" folder.
  
  ## FAQ
  ### Multitouch doesn't work / can't use two joystick at the same time:
  In Godot, the input events from the mouse don't support multitouch, so make sure to have this configuration:
  Project -> Project Settings -> General -> Input Devices
  "emulate touch from mouse" ON
  "emulate mouse from touch" OFF
  
  ### The joystick doesn't work when using Input.get_vector():
  ⚠ **This has been fixed in Godot Engine!**
  Unfortunately, this a bug in the Godot engine, so the only solution for now is using Input.get_axis:
  This doesn't work:
  ```gdscript
  input_vector := Input.get_vector("ui_left","ui_right","ui_up","ui_down")
  ```
  This works:
  ```gdscript
  input_vector := Vector2.ZERO
  input_vector.x = Input.get_axis("ui_left", "ui_right")
  input_vector.y = Input.get_axis("ui_up", "ui_down")
  ```

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\addons\virtual_joystick\test\player.gd:
========================================
  extends Sprite2D
  
  @export var speed : float = 100
  
  @export var joystick_left : VirtualJoystick
  
  @export var joystick_right : VirtualJoystick
  
  var move_vector := Vector2.ZERO
  
  func _process(delta: float) -> void:
  	## Movement using the joystick output:
  #	if joystick_left and joystick_left.is_pressed:
  #		position += joystick_left.output * speed * delta
  
  	## Movement using Input functions:
  	move_vector = Vector2.ZERO
  	move_vector = Input.get_vector("ui_left","ui_right","ui_up","ui_down")
  	position += move_vector * speed * delta
  
  	# Rotation:
  	if joystick_right and joystick_right.is_pressed:
  		rotation = joystick_right.output.angle()

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\addons\virtual_joystick\virtual_joystick.gd:
========================================
  class_name VirtualJoystick
  
  extends Control
  
  ## A simple virtual joystick for touchscreens, with useful options.
  ## Github: https://github.com/MarcoFazioRandom/Virtual-Joystick-Godot
  
  # EXPORTED VARIABLE
  
  ## The color of the button when the joystick is pressed.
  @export var pressed_color := Color.GRAY
  
  ## If the input is inside this range, the output is zero.
  @export_range(0, 200, 1) var deadzone_size : float = 10
  
  ## The max distance the tip can reach.
  @export_range(0, 500, 1) var clampzone_size : float = 75
  
  enum Joystick_mode {
  	FIXED, ## The joystick doesn't move.
  	DYNAMIC, ## Every time the joystick area is pressed, the joystick position is set on the touched position.
  	FOLLOWING ## When the finger moves outside the joystick area, the joystick will follow it.
  }
  
  ## If the joystick stays in the same position or appears on the touched position when touch is started
  @export var joystick_mode := Joystick_mode.FIXED
  
  enum Visibility_mode {
  	ALWAYS, ## Always visible
  	TOUCHSCREEN_ONLY, ## Visible on touch screens only
  	WHEN_TOUCHED ## Visible only when touched
  }
  
  ## If the joystick is always visible, or is shown only if there is a touchscreen
  @export var visibility_mode := Visibility_mode.ALWAYS
  
  ## If true, the joystick uses Input Actions (Project -> Project Settings -> Input Map)
  @export var use_input_actions := true
  
  @export var action_left := "ui_left"
  @export var action_right := "ui_right"
  @export var action_up := "ui_up"
  @export var action_down := "ui_down"
  
  # PUBLIC VARIABLES
  
  ## If the joystick is receiving inputs.
  var is_pressed := false
  
  # The joystick output.
  var output := Vector2.ZERO
  
  # PRIVATE VARIABLES
  
  var _touch_index : int = -1
  
  @onready var _base := $Base
  @onready var _tip := $Base/Tip
  
  @onready var _base_default_position : Vector2 = _base.position
  @onready var _tip_default_position : Vector2 = _tip.position
  
  @onready var _default_color : Color = _tip.modulate
  
  # FUNCTIONS
  
  func _ready() -> void:
  	if ProjectSettings.get_setting("input_devices/pointing/emulate_mouse_from_touch"):
  		printerr("The Project Setting 'emulate_mouse_from_touch' should be set to False")
  	if not ProjectSettings.get_setting("input_devices/pointing/emulate_touch_from_mouse"):
  		printerr("The Project Setting 'emulate_touch_from_mouse' should be set to True")
  
  	if not DisplayServer.is_touchscreen_available() and visibility_mode == Visibility_mode.TOUCHSCREEN_ONLY :
  		hide()
  
  	if visibility_mode == Visibility_mode.WHEN_TOUCHED:
  		hide()
  
  func _input(event: InputEvent) -> void:
  	if event is InputEventScreenTouch:
  		if event.pressed:
  			if _is_point_inside_joystick_area(event.position) and _touch_index == -1:
  				if joystick_mode == Joystick_mode.DYNAMIC or joystick_mode == Joystick_mode.FOLLOWING or (joystick_mode == Joystick_mode.FIXED and _is_point_inside_base(event.position)):
  					if joystick_mode == Joystick_mode.DYNAMIC or joystick_mode == Joystick_mode.FOLLOWING:
  						_move_base(event.position)
  					if visibility_mode == Visibility_mode.WHEN_TOUCHED:
  						show()
  					_touch_index = event.index
  					_tip.modulate = pressed_color
  					_update_joystick(event.position)
  					get_viewport().set_input_as_handled()
  		elif event.index == _touch_index:
  			_reset()
  			if visibility_mode == Visibility_mode.WHEN_TOUCHED:
  				hide()
  			get_viewport().set_input_as_handled()
  	elif event is InputEventScreenDrag:
  		if event.index == _touch_index:
  			_update_joystick(event.position)
  			get_viewport().set_input_as_handled()
  
  func _move_base(new_position: Vector2) -> void:
  	_base.global_position = new_position - _base.pivot_offset * get_global_transform_with_canvas().get_scale()
  
  func _move_tip(new_position: Vector2) -> void:
  	_tip.global_position = new_position - _tip.pivot_offset * _base.get_global_transform_with_canvas().get_scale()
  
  func _is_point_inside_joystick_area(point: Vector2) -> bool:
  	var x: bool = point.x >= global_position.x and point.x <= global_position.x + (size.x * get_global_transform_with_canvas().get_scale().x)
  	var y: bool = point.y >= global_position.y and point.y <= global_position.y + (size.y * get_global_transform_with_canvas().get_scale().y)
  	return x and y
  
  func _get_base_radius() -> Vector2:
  	return _base.size * _base.get_global_transform_with_canvas().get_scale() / 2
  
  func _is_point_inside_base(point: Vector2) -> bool:
  	var _base_radius = _get_base_radius()
  	var center : Vector2 = _base.global_position + _base_radius
  	var vector : Vector2 = point - center
  	if vector.length_squared() <= _base_radius.x * _base_radius.x:
  		return true
  	else:
  		return false
  
  func _update_joystick(touch_position: Vector2) -> void:
  	var _base_radius = _get_base_radius()
  	var center : Vector2 = _base.global_position + _base_radius
  	var vector : Vector2 = touch_position - center
  	vector = vector.limit_length(clampzone_size)
  
  	if joystick_mode == Joystick_mode.FOLLOWING and touch_position.distance_to(center) > clampzone_size:
  		_move_base(touch_position - vector)
  
  	_move_tip(center + vector)
  
  	if vector.length_squared() > deadzone_size * deadzone_size:
  		is_pressed = true
  		output = (vector - (vector.normalized() * deadzone_size)) / (clampzone_size - deadzone_size)
  	else:
  		is_pressed = false
  		output = Vector2.ZERO
  
  	if use_input_actions:
  		if output.x > 0:
  			Input.action_release(action_left)
  			Input.action_press(action_right, output.x)
  		else:
  			Input.action_release(action_right)
  			Input.action_press(action_left, -output.x)
  
  		if output.y > 0:
  			Input.action_release(action_up)
  			Input.action_press(action_down, output.y)
  		else:
  			Input.action_release(action_down)
  			Input.action_press(action_up, -output.y)
  
  func _reset():
  	is_pressed = false
  	output = Vector2.ZERO
  	_touch_index = -1
  	_tip.modulate = _default_color
  	_base.position = _base_default_position
  	_tip.position = _tip_default_position
  	if use_input_actions:
  		for action in [action_left, action_right, action_down, action_up]:
  			Input.action_release(action)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\addons\virtual_joystick\virtual_joystick_instantiator.gd:
========================================
  @tool
  extends Control
  
  var scene
  
  func _enter_tree():
  	scene = preload("res://addons/virtual_joystick/virtual_joystick_scene.tscn").instantiate()
  	add_child(scene)
  
  	if ProjectSettings.get_setting("input_devices/pointing/emulate_mouse_from_touch"):
  		printerr("The Project Setting 'emulate_mouse_from_touch' should be set to False")
  	if not ProjectSettings.get_setting("input_devices/pointing/emulate_touch_from_mouse"):
  		printerr("The Project Setting 'emulate_touch_from_mouse' should be set to True")
  
  
  func _exit_tree():
  	scene.free()

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\addons\virtual_joystick\virtual_joystick_plugin.gd:
========================================
  @tool
  extends EditorPlugin
  
  
  func _enter_tree():
  	add_custom_type("Virtual Joystick", "Control", preload("virtual_joystick_instantiator.gd"), preload("virtual_joystick_icon.png"))
  
  
  func _exit_tree():
  	remove_custom_type("Virtual Joystick")

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\fonts\special\copyduck\More Info.txt:
========================================
  First of All,
  
  Thank you for download my product.
  This product 100% free for personal use & commercial use
  
  File include :
  
  1. Copyduck.ttf
  2. Copyduck.otf
  
  More Info :
  khurasantype@gmail.com
  
  For Donation:
  paypal.me/khurasantype
  
  My OnlineShop:
  https://www.creativefabrica.com/ref/53/
  
  My Portofolio:
  https://www.behance.net/khurasan
  
  My web:
  www.khurasanstudio.com
  www.mbkaos.com

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\sprites\characters\greyscale\info.txt:
========================================
  
  How to use modular clothing
  
  Use basic_grey (clothes) as base and add the detail (modular) you want:
  	floral, overalls, sailor, skull, sporty, stripe
  
  "button_grey" works for clown outfit and pumpkin outfit
  
  "shoes_grey" works for all outfits besides "witch_grey"
  
  "gloves_grey" works for clown, pumpkin and spooky
  
  
  Modular hair
  
  Use "braids_tie_grey" on top of braids to adjust color of hair ties
  

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\sprites\characters\info.txt:
========================================
  
  GRID SIZE 32x32
  CELL SIZE MERGED: 256x1568
  
  WALK FR: 100
  Cell Size: 256x128
  
  JUMP FR: 100; 200; 100; 120; 100
  Cell Size: 160x128
  
  PICK UP FR: 150; 150; 100; 100; 150
  Cell Size: 160x128
  
  CARRY FR:100
  Cell Size: 256x128
  (char moved  up 1px)
  
  SWORD FR: 100; 200; 80; 100
  Cell Size: 128x128
  
  BLOCK Cell Size: 32x128
  
  HURT Cell Size: 32x128
  
  DIE FR: 500
  Cell Size: 64x32
  
  PICKAXE/ AXE FR: 100; 100; 250; 60; 100
  Cell Size: 160x128
  
  WATER FR: 300; 600
  Cell Size: 64x128
  (char moved up 5 px)
  
  HOE FR: 200; 150; 200; 200; 200
  Cell Size: 160x128
  (down: char moved up 8 px; left/right char moved up 1 px)
  
  FISHING L/R FR: 100; 100; 250; 60; 100
  FISHING U/D FR: 100; 250; 60; 100; 100
  Cell Size: 160x128
  (char moved up 4 px)
  
  LAYERS
  1. Characters
  2. Eyes ->Blush/Lipstick
  3. Clothes: Shirt -> Pants -> Shoes
  4. Hair
  5. Accessories Beard -> Glasses -> Hat
  
  
  
  
  
  
  
  
  
  

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\sprites\characters\list.txt:
========================================
  
  HAIR
  1. Black
  2. Blonde
  3. Brown
  4. Brown Light
  5. Copper
  6. Emerald
  7. Green
  8. Grey
  9. Lilac
  10. Navy
  11. Pink
  12. Purple
  13. Red
  14. Turquoise
  
  Clothes:
  1. Black
  2. Blue
  3. Blue Light
  4. Brown
  5. Green
  6. Green Light
  7. Pink
  8. Purple
  9. Red
  10. White/Grey
  
  Eyes:
  1. Black
  2. Blue
  3. Blue Light
  4. Brown
  5. Brown Dark
  6. Brown Light
  7. Green
  8. Green Dark
  9. Green Light
  10. Grey
  11. Grey Light
  12. Pink
  13. Pink Light
  14. Red
  
  Lipstick and Blush are sorted from light to dark.
  
  

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\sprites\environment\craftpix-896753-village-pixel-art-environment-assets-pack\License.txt:
========================================
  https://craftpix.net/file-licenses/

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\sprites\environment\craftpix-896753-village-pixel-art-environment-assets-pack\readme.txt:
========================================
  Font that was used for the background of the preview:
  https://www.dafont.com/pixellari.font

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\sprites\environment\craftpix-net-352322-nature-pixel-art-environment-free-assets-pack\License.txt:
========================================
  https://craftpix.net/file-licenses/

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\sprites\environment\craftpix-net-352322-nature-pixel-art-environment-free-assets-pack\readme.txt:
========================================
  Font that was used for the background of the preview:
  https://www.dafont.com/pixellari.font

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\sprites\environment\craftpix-net-481981-free-summer-pixel-art-backgrounds\License.txt:
========================================
  https://craftpix.net/file-licenses/

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\sprites\environment\craftpix-net-481981-free-summer-pixel-art-backgrounds\readme.txt:
========================================
  Font that was used for the background of the preview:
  https://www.dafont.com/digital-disco.font

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\sprites\environment\craftpix-net-965049-free-industrial-zone-tileset-pixel-art\Font.txt:
========================================
  Future Millennium
  https://www.dafont.com/futuremillennium.font

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\sprites\environment\craftpix-net-965049-free-industrial-zone-tileset-pixel-art\license.txt:
========================================
  https://craftpix.net/file-licenses/

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\sprites\environment\peasant's_house\Peasant's_House\README.txt:
========================================
  THIS MATERIAL IS COMPLETELY FREE, AND YOU CAN FIND IT ON MY PAGE "https://ericksazevedo.itch.io/". IF YOU PAID FOR THIS MATERIAL, DEMAND A REFUND!
  
  I'm glad you chose my art for your project, I hope it proves to be very useful to you.
  
  INTRODUTION
  
  My name is Ericks Azevedo. I created this artwork for study purposes and in the hope that it will be useful for other people's projects. If you're interested in more art, take a look at my page "https://ericksazevedo.itch.io/". I'll be regularly posting new art there whenever possible
  
  LICENSES
  
  * You can use the artwork in both free and commercial projects, as long as you give me credit. For that purpose, use my Instagram profile "@ericks.azevedo".
  * You can edit the images as you prefer; for this purpose, I'm providing the files in .aseprite format.
  * Selling these assets is not allowed, even if modifications have been made.
  
  INSTRUCTIONS
  
  * In each folder, you will find two ways to import your files: one using image sequences and the other with individual frames. Both methods have their own .aseprite file, in case you want to make modifications.
  * Pay attention to the "House_in_the_middle" folder. Inside it, you will find the images split in half, both for the door animation and the window animation. Both of them have the same sprite size, so you just need to overlay one onto the other. I organized it this way because the window and the door have different animation timings, and one is a loop while the other is not.
  
  If you want to support my work, please follow my page on itch.io ;)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\sprites\environment\sunny-land-files\Sunny-land-files\public-license.txt:
========================================
  Artwork created by Luis Zuno @ansimuz
  
  License for Everyone.
  
  Public domain and free to use on whatever you want, personal or commercial. Credit is not required but appreciated.
  
  Get more Free Assetslike these at: ansimuz.itch.io
  or at my patreon page: patreon.com/ansimuz
  
  

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\sprites\unsorted\License.txt:
========================================
  https://craftpix.net/file-licenses/

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\project.godot:
========================================
  ; Engine configuration file.
  ; It's best edited using the editor UI and not directly,
  ; since the parameters that go here are not all obvious.
  ;
  ; Format:
  ;   [section] ; section goes between []
  ;   param=value ; assign values to parameters
  
  config_version=5
  
  [application]
  
  config/name="The Little Saint"
  run/main_scene="uid://dh7t0n4nj8w4o"
  config/features=PackedStringArray("4.4", "Mobile")
  
  [autoload]
  
  Constants="*res://scripts/autoload/constants.gd"
  AudioManager="*res://scripts/autoload/audio_manager.gd"
  SaveManager="*res://scripts/autoload/save_manager.gd"
  Global="*res://scripts/autoload/game_manager.gd"
  PopupManager="*res://scripts/ui/dialogs/popup_manager.gd"
  
  [display]
  
  window/size/viewport_width=1280
  window/size/viewport_height=720
  window/stretch/mode="canvas_items"
  window/stretch/aspect="expand"
  
  [input]
  
  right={
  "deadzone": 0.5,
  "events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":68,"key_label":0,"unicode":100,"location":0,"echo":false,"script":null)
  , Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194321,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
  ]
  }
  left={
  "deadzone": 0.5,
  "events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":65,"key_label":0,"unicode":97,"location":0,"echo":false,"script":null)
  , Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194319,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
  ]
  }
  up={
  "deadzone": 0.5,
  "events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":87,"key_label":0,"unicode":119,"location":0,"echo":false,"script":null)
  , Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194320,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
  ]
  }
  down={
  "deadzone": 0.5,
  "events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":83,"key_label":0,"unicode":115,"location":0,"echo":false,"script":null)
  , Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194322,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
  ]
  }
  attack={
  "deadzone": 0.5,
  "events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":85,"physical_keycode":0,"key_label":0,"unicode":117,"location":0,"echo":false,"script":null)
  ]
  }
  defend={
  "deadzone": 0.5,
  "events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":73,"physical_keycode":0,"key_label":0,"unicode":105,"location":0,"echo":false,"script":null)
  ]
  }
  Menu={
  "deadzone": 0.5,
  "events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194305,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
  ]
  }
  
  [input_devices]
  
  pointing/emulate_touch_from_mouse=true
  pointing/emulate_mouse_from_touch=false
  
  [layer_names]
  
  2d_physics/layer_1="player"
  2d_physics/layer_2="ports"
  2d_physics/layer_3="item"
  2d_physics/layer_4="enemy"
  
  [physics]
  
  2d/physics_engine="GodotPhysics2D"
  
  [rendering]
  
  textures/canvas_textures/default_texture_filter=0
  renderer/rendering_method="mobile"
  environment/defaults/default_clear_color=Color(0, 0, 0, 1)

[Skipped c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scenes\core\character\character_sprites.tscn: File too large (25611 KB)]

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scenes\levels\prince_levels\Tiles\fourSeasonsPlatformer\- READ ME -.txt:
========================================
  
                                                                - READ ME -
  
  Thank you for using the fourSeasonsPlatformer_ [tileset]...part of the fourSeasonPlatformer_ series' of assets on itch.io!
  
  Stuff to know - Tilesets
  
  - Each tile is 16x16 pixels...although some objects/structures/terrain are 16x32/32x16/32x32...[e.g. trees, beehives, big terrain tile]
  - The blackout_ tileset is designed to black out the spaces between tiles [optional]
  
  Stuff to know - Animations
  
  - coin_ animation is 12 frames
  - each eventBlock_ animation is 14 frames [6 animations total]
  - each foreground animation is 8 frames
  
  If you have any questions or requests you can contact me at analogstudios.inc@gmail.com
  
  
  
  
  
  

[Skipped c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scenes\levels\prince_levels\game_prince.tscn: File too large (148 KB)]

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\autoload\audio_manager.gd:
========================================
  extends Node
  
  ## Enhanced Audio Manager for managing all game audio
  ## Supports categories, multiple channels, and persistent settings
  
  # Audio bus names
  const MASTER_BUS = "Master"
  const MUSIC_BUS = "Music"
  const SFX_BUS = "SFX"
  const UI_BUS = "UI"
  const VOICE_BUS = "Voice"
  
  # Volume ranges
  const MIN_VOLUME_DB = -80.0
  const MAX_VOLUME_DB = 6.0
  
  # Fade durations
  const DEFAULT_FADE_DURATION = 1.0
  
  # Music properties
  @export var autoplay: bool = false
  @export var default_music_stream: AudioStream = null
  @export var default_music_volume: float = 0.0  # in dB
  @export var crossfade_duration: float = 1.0
  
  # Current audio tracks
  var current_music_track: AudioStream = null
  var current_music_player: AudioStreamPlayer = null
  var next_music_player: AudioStreamPlayer = null  # For crossfading
  
  # Audio player pools
  var music_players = []
  var sfx_players = {}
  var ui_players = []
  var voice_players = []
  
  # Audio stream cache
  var stream_cache = {}
  
  # Signals
  signal music_started(track_name)
  signal music_stopped()
  signal music_finished()
  signal music_faded(from_volume, to_volume)
  signal sfx_played(sfx_name)
  
  func _ready():
  	# Ensure we have all the audio buses we need
  	_setup_audio_buses()
  
  	# Create initial audio players
  	_setup_audio_players()
  
  	# Load settings
  	_load_audio_settings()
  
  	# Autoplay if enabled
  	if autoplay and default_music_stream:
  		play_music(default_music_stream)
  
  func _setup_audio_buses():
  	# Create buses if they don't exist
  	var bus_names = [MASTER_BUS, MUSIC_BUS, SFX_BUS, UI_BUS, VOICE_BUS]
  
  	for i in range(AudioServer.get_bus_count()):
  		var bus_name = AudioServer.get_bus_name(i)
  		bus_names.erase(bus_name)
  
  	# Add any missing buses
  	for bus_name in bus_names:
  		if bus_name != MASTER_BUS:  # Master is always bus 0
  			var idx = AudioServer.bus_count
  			AudioServer.add_bus(idx)
  			AudioServer.set_bus_name(idx, bus_name)
  
  			# Connect to Master
  			AudioServer.set_bus_send(idx, MASTER_BUS)
  
  func _setup_audio_players():
  	# Create music players for crossfading
  	for i in range(2):
  		var player = AudioStreamPlayer.new()
  		player.name = "MusicPlayer_" + str(i)
  		player.bus = MUSIC_BUS
  		player.volume_db = default_music_volume
  		add_child(player)
  		music_players.append(player)
  		player.finished.connect(_on_music_finished.bind(player))
  
  	# Set current music player
  	current_music_player = music_players[0]
  
  # Music playback control
  func play_music(stream: AudioStream, fade_in: float = DEFAULT_FADE_DURATION, volume_db: float = default_music_volume, loop: bool = true):
  	if not stream:
  		push_error("Cannot play null music stream")
  		return
  
  	# Check if this is the current track
  	if current_music_track == stream and current_music_player.playing:
  		return
  
  	# Choose which player to use
  	var player
  	if current_music_player and current_music_player.playing:
  		# Crossfade
  		player = _get_unused_music_player()
  		next_music_player = player
  	else:
  		# No crossfade needed
  		player = current_music_player if current_music_player else music_players[0]
  
  	# Set up the player
  	player.stream = stream
  	player.volume_db = MIN_VOLUME_DB if fade_in > 0 else volume_db
  	player.play()
  
  	# Apply loop setting
  	if stream is AudioStreamMP3 or stream is AudioStreamOggVorbis:
  		stream.loop = loop
  
  	# Store current track
  	current_music_track = stream
  
  	# Handle fade in if needed
  	if fade_in > 0:
  		var tween = create_tween()
  		tween.tween_property(player, "volume_db", volume_db, fade_in)
  
  		# If we're crossfading, fade out the old track
  		if current_music_player and current_music_player != player and current_music_player.playing:
  			var fade_out_tween = create_tween()
  			fade_out_tween.tween_property(current_music_player, "volume_db", MIN_VOLUME_DB, fade_in)
  			fade_out_tween.tween_callback(func(): current_music_player.stop())
  
  	# Update current player reference
  	current_music_player = player
  
  	var track_name = stream.resource_path.get_file()
  	emit_signal("music_started", track_name)
  
  func stop_music(fade_out: float = DEFAULT_FADE_DURATION):
  	if not current_music_player or not current_music_player.playing:
  		return
  
  	if fade_out > 0:
  		var tween = create_tween()
  		tween.tween_property(current_music_player, "volume_db", MIN_VOLUME_DB, fade_out)
  		tween.tween_callback(func():
  			current_music_player.stop()
  			current_music_track = null
  			emit_signal("music_stopped")
  		)
  	else:
  		current_music_player.stop()
  		current_music_track = null
  		emit_signal("music_stopped")
  
  func pause_music():
  	if current_music_player and current_music_player.playing:
  		current_music_player.stream_paused = true
  
  func resume_music():
  	if current_music_player and current_music_player.stream_paused:
  		current_music_player.stream_paused = false
  
  func is_music_playing() -> bool:
  	return current_music_player != null and current_music_player.playing
  
  func fade_music(to_volume_db: float, duration: float = DEFAULT_FADE_DURATION):
  	if not current_music_player or not current_music_player.playing:
  		return
  
  	var from_volume = current_music_player.volume_db
  
  	var tween = create_tween()
  	tween.tween_property(current_music_player, "volume_db", to_volume_db, duration)
  	tween.tween_callback(func(): emit_signal("music_faded", from_volume, to_volume_db))
  
  # SFX playback
  func play_sfx(stream: AudioStream, volume_db: float = 0.0, pitch_scale: float = 1.0, bus: String = SFX_BUS) -> AudioStreamPlayer:
  	if not stream:
  		push_error("Cannot play null SFX stream")
  		return null
  
  	# Get or create an available SFX player
  	var sfx_player = _get_available_sfx_player(bus)
  
  	# Set up the player
  	sfx_player.stream = stream
  	sfx_player.volume_db = volume_db
  	sfx_player.pitch_scale = pitch_scale
  	sfx_player.play()
  
  	var sfx_name = stream.resource_path.get_file()
  	emit_signal("sfx_played", sfx_name)
  
  	return sfx_player
  
  func play_sfx_at_position(stream: AudioStream, position: Vector2, volume_db: float = 0.0,
  						pitch_scale: float = 1.0, bus: String = SFX_BUS,
  						falloff: float = 1.0, max_distance: float = 2000) -> AudioStreamPlayer2D:
  	if not stream:
  		push_error("Cannot play positional SFX with null stream")
  		return null
  
  	# Create a temporary 2D audio player
  	var sfx_player = AudioStreamPlayer2D.new()
  	sfx_player.name = "TempSFX2D_" + str(randi())
  	sfx_player.stream = stream
  	sfx_player.volume_db = volume_db
  	sfx_player.pitch_scale = pitch_scale
  	sfx_player.bus = bus
  	sfx_player.position = position
  	sfx_player.max_distance = max_distance
  	sfx_player.attenuation = falloff
  
  	# Add to tree temporarily
  	add_child(sfx_player)
  	sfx_player.play()
  
  	# Connect to finished to auto-remove
  	sfx_player.finished.connect(func(): sfx_player.queue_free())
  
  	var sfx_name = stream.resource_path.get_file()
  	emit_signal("sfx_played", sfx_name)
  
  	return sfx_player
  
  func play_ui_sound(stream: AudioStream, volume_db: float = 0.0) -> AudioStreamPlayer:
  	return play_sfx(stream, volume_db, 1.0, UI_BUS)
  
  func play_voice(stream: AudioStream, volume_db: float = 0.0) -> AudioStreamPlayer:
  	return play_sfx(stream, volume_db, 1.0, VOICE_BUS)
  
  # Volume control
  func set_volume(bus_name: String, volume_db: float) -> bool:
  	var bus_idx = AudioServer.get_bus_index(bus_name)
  	if bus_idx < 0:
  		push_error("Audio bus not found: " + bus_name)
  		return false
  
  	var clamped_volume = clamp(volume_db, MIN_VOLUME_DB, MAX_VOLUME_DB)
  	AudioServer.set_bus_volume_db(bus_idx, clamped_volume)
  	return true
  
  func get_volume(bus_name: String) -> float:
  	var bus_idx = AudioServer.get_bus_index(bus_name)
  	if bus_idx < 0:
  		push_error("Audio bus not found: " + bus_name)
  		return 0.0
  
  	return AudioServer.get_bus_volume_db(bus_idx)
  
  func set_mute(bus_name: String, mute: bool) -> bool:
  	var bus_idx = AudioServer.get_bus_index(bus_name)
  	if bus_idx < 0:
  		push_error("Audio bus not found: " + bus_name)
  		return false
  
  	AudioServer.set_bus_mute(bus_idx, mute)
  	return true
  
  func is_muted(bus_name: String) -> bool:
  	var bus_idx = AudioServer.get_bus_index(bus_name)
  	if bus_idx < 0:
  		push_error("Audio bus not found: " + bus_name)
  		return false
  
  	return AudioServer.is_bus_mute(bus_idx)
  
  # Stream loading helper
  func load_stream(path: String) -> AudioStream:
  	# Check cache first
  	if stream_cache.has(path):
  		return stream_cache[path]
  
  	# Load the stream
  	var stream = load(path)
  	if stream is AudioStream:
  		stream_cache[path] = stream
  		return stream
  
  	push_error("Failed to load audio stream: " + path)
  	return null
  
  # Preload a collection of audio streams
  func preload_streams(paths: Array) -> void:
  	for path in paths:
  		load_stream(path)
  
  # Save and load audio settings
  func save_audio_settings() -> bool:
  	var config = ConfigFile.new()
  
  	# Save volumes
  	for bus_name in [MASTER_BUS, MUSIC_BUS, SFX_BUS, UI_BUS, VOICE_BUS]:
  		var bus_idx = AudioServer.get_bus_index(bus_name)
  		if bus_idx >= 0:
  			config.set_value("volume", bus_name, AudioServer.get_bus_volume_db(bus_idx))
  			config.set_value("mute", bus_name, AudioServer.is_bus_mute(bus_idx))
  
  	# Save the config
  	var err = config.save("user://audio_settings.cfg")
  	return err == OK
  
  func _load_audio_settings() -> bool:
  	var config = ConfigFile.new()
  	var err = config.load("user://audio_settings.cfg")
  
  	if err != OK:
  		# Create default settings
  		for bus_name in [MASTER_BUS, MUSIC_BUS, SFX_BUS, UI_BUS, VOICE_BUS]:
  			set_volume(bus_name, 0.0)
  			set_mute(bus_name, false)
  		return false
  
  	# Load volumes
  	for bus_name in [MASTER_BUS, MUSIC_BUS, SFX_BUS, UI_BUS, VOICE_BUS]:
  		var volume = config.get_value("volume", bus_name, 0.0)
  		var muted = config.get_value("mute", bus_name, false)
  
  		set_volume(bus_name, volume)
  		set_mute(bus_name, muted)
  
  	return true
  
  # Private utility functions
  func _get_unused_music_player() -> AudioStreamPlayer:
  	for player in music_players:
  		if player != current_music_player or not player.playing:
  			return player
  
  	# All players are in use, create a new one
  	var player = AudioStreamPlayer.new()
  	player.name = "MusicPlayer_" + str(music_players.size())
  	player.bus = MUSIC_BUS
  	add_child(player)
  	music_players.append(player)
  	player.finished.connect(_on_music_finished.bind(player))
  
  	return player
  
  func _get_available_sfx_player(bus: String = SFX_BUS) -> AudioStreamPlayer:
  	# Check for existing player in the bus category
  	if not sfx_players.has(bus):
  		sfx_players[bus] = []
  
  	var bus_players = sfx_players[bus]
  
  	# Look for an available player
  	for player in bus_players:
  		if not player.playing:
  			return player
  
  	# Create a new player
  	var player = AudioStreamPlayer.new()
  	player.name = "SFXPlayer_" + bus + "_" + str(bus_players.size())
  	player.bus = bus
  	add_child(player)
  	bus_players.append(player)
  
  	return player
  
  func _on_music_finished(player):
  	if player == current_music_player:
  		emit_signal("music_finished")
  
  		# Check if we have a looping track
  		if current_music_track:
  			var is_looping = false
  			if current_music_track is AudioStreamMP3 or current_music_track is AudioStreamOggVorbis:
  				is_looping = current_music_track.loop
  
  			if is_looping:
  				# Restart the track
  				player.play()
  
  # Legacy API for backward compatibility
  func play_track(audio_stream: AudioStream):
  	play_music(audio_stream)
  
  func stop_track():
  	stop_music()
  
  func is_playing() -> bool:
  	return is_music_playing()

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\autoload\constants.gd:
========================================
  extends Node
  
  ## Global constants for The Little Saint game
  
  # Game States
  enum GameState {
  	MENU,           # In main menu
  	PLAYING,        # Actively playing
  	PAUSED,         # Game paused
  	GAME_OVER,      # Player died or level failed
  	CUTSCENE,       # In a cutscene
  	DIALOGUE,       # In dialogue
  	LOADING         # Loading screen
  }
  
  # Player Movement
  const PLAYER_DEFAULT_SPEED: float = 200.0
  const PLAYER_DEFAULT_JUMP_VELOCITY: float = -250.0
  const PLAYER_DEFAULT_FLY_VELOCITY: float = -150.0
  const PLAYER_DEFAULT_GRAVITY: float = 300.0
  const PLAYER_MAX_JUMPS: int = 2
  
  # Player Status
  const PLAYER_DEFAULT_MAX_HEALTH: float = 3.0
  const PLAYER_INVULNERABILITY_TIME: float = 1.0
  const PLAYER_DEFAULT_FLY_TIME: float = 4.0
  
  # File Paths
  const SETTINGS_FILE_PATH: String = "user://settings.cfg"
  const SAVE_FILE_PATH: String = "user://save_data.tres"
  const OUTFIT_FILE_PATH: String = "user://outfits.tres"
  const FAVORITES_FILE_PATH: String = "user://favorites.cfg"
  
  # Config Sections
  const SECTION_SETTINGS: String = "settings"
  const SECTION_PLAYER: String = "player"
  const SECTION_OUTFITS: String = "outfits"
  const SECTION_FAVORITES: String = "favorites"
  
  # Physics
  const DEFAULT_GRAVITY: float = 980.0
  
  # Animation
  const ANIMATION_IDLE: String = "idle"
  const ANIMATION_WALKING: String = "walking"
  const ANIMATION_ATTACK: String = "walking6"  # Current attack animation
  const ANIMATION_HURT: String = "hurt"
  const ANIMATION_DEATH: String = "dead"
  const ANIMATION_JUMP: String = "animation4"  # May need to be updated
  
  # Layers
  enum Layer {
  	PLAYER = 1,
  	PORTS = 2,
  	ITEM = 3,
  	ENEMY = 4
  }
  
  # Input Action Names
  const INPUT_RIGHT: String = "right"
  const INPUT_LEFT: String = "left"
  const INPUT_UP: String = "up"
  const INPUT_DOWN: String = "down"
  const INPUT_ATTACK: String = "attack"
  const INPUT_DEFEND: String = "defend"
  const INPUT_MENU: String = "Menu"
  
  # Scene paths
  const MAIN_MENU_SCENE: String = "res://scenes/ui/main_menu/main_menu.tscn"
  const ADVENTURE_LEVEL_SCENE: String = "res://scenes/levels/adventure_mode/adventure_level.tscn"
  const SETTINGS_MENU_SCENE: String = "res://scenes/ui/settings/settings_menu.tscn"
  const CUSTOMIZER_SCENE: String = "res://scenes/ui/character_customizer/customizer.tscn"
  const AUDIO_SETTINGS_SCENE: String = "res://scenes/ui/settings/audio_settings.tscn"
  
  # Debug
  const DEBUG_ENABLED: bool = false

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\autoload\game_manager.gd:
========================================
  extends Node
  
  ## Game Manager handles game state, scene transitions, and global events
  ## Serves as the central controller for the game
  
  # Game state
  var current_state: Constants.GameState = Constants.GameState.MENU
  var previous_state: Constants.GameState = Constants.GameState.MENU
  
  # Player reference
  var player = null
  
  # Current level
  var current_level: String = ""
  var current_level_node = null
  var next_level: String = ""
  
  # Game progress
  var collected_coins: int = 0
  var unlocked_levels: Array = []
  var completed_quests: Array = []
  
  # Resource preloading
  var resource_preloader = null
  var is_preloading: bool = false
  var preload_progress: float = 0.0
  
  # Events
  signal state_changed(new_state, old_state)
  signal level_started(level_name)
  signal level_completed(level_name)
  signal player_died()
  signal coin_collected(total_coins)
  signal game_saved()
  signal game_loaded()
  signal resources_loading_progress(progress, total)
  signal resources_loaded()
  
  # Initialization
  func _ready():
  	process_mode = Node.PROCESS_MODE_ALWAYS # Game manager should run even when paused
  	print("Game Manager initialized")
  
  	# Initialize the resource preloader
  	resource_preloader = GameResourcePreloader.new()
  	resource_preloader.name = "GameResourcePreloader"
  	add_child(resource_preloader)
  
  	# Connect resource preloader signals
  	resource_preloader.loading_progress.connect(_on_loading_progress)
  	resource_preloader.all_resources_loaded.connect(_on_all_resources_loaded)
  
  # State management
  func change_state(new_state: Constants.GameState) -> void:
  	if new_state == current_state:
  		return
  
  	previous_state = current_state
  	current_state = new_state
  
  	match new_state:
  		Constants.GameState.PAUSED:
  			get_tree().paused = true
  		Constants.GameState.PLAYING, Constants.GameState.MENU:
  			get_tree().paused = false
  		Constants.GameState.LOADING:
  			# Loading state is handled by the loading screen
  			pass
  
  	emit_signal("state_changed", current_state, previous_state)
  	print("Game state changed to: ", Constants.GameState.keys()[current_state])
  
  func is_state(state: Constants.GameState) -> bool:
  	return current_state == state
  
  func resume_previous_state() -> void:
  	change_state(previous_state)
  
  # Resource preloading
  func preload_resources_for_level(level_name: String) -> void:
  	if is_preloading:
  		push_warning("Already preloading resources!")
  		return
  
  	# Enter loading state
  	change_state(Constants.GameState.LOADING)
  	is_preloading = true
  	preload_progress = 0.0
  
  	# Start preloading
  	var success = resource_preloader.preload_level_resources(level_name)
  	if success:
  		resource_preloader.load_queued_resources()
  	else:
  		# No specific resources to preload, just continue
  		is_preloading = false
  		_finish_level_change()
  
  func _on_loading_progress(loaded: int, total: int) -> void:
  	preload_progress = float(loaded) / max(total, 1)
  	emit_signal("resources_loading_progress", loaded, total)
  
  func _on_all_resources_loaded() -> void:
  	is_preloading = false
  	emit_signal("resources_loaded")
  
  	# Continue with level change if we were changing levels
  	if next_level != "":
  		_finish_level_change()
  
  # Scene management with preloading
  func change_scene(scene_path: String) -> void:
  	# Store the next level path
  	next_level = scene_path
  
  	# Clear any popups or overlays
  	if PopupManager:
  		PopupManager.close_all_dialogs()
  
  	# Store reference to current level if it's a level scene
  	if scene_path.begins_with("res://scenes/levels/"):
  		current_level = scene_path
  
  		# Extract level name for preloading
  		var level_name = scene_path.get_file().get_basename()
  		preload_resources_for_level(level_name)
  	else:
  		# If it's not a level, just preload based on the scene name
  		var scene_name = scene_path.get_file().get_basename()
  		preload_resources_for_level(scene_name)
  
  func _finish_level_change() -> void:
  	if next_level.is_empty():
  		return
  
  	# Actual scene change
  	get_tree().change_scene_to_file(next_level)
  
  	# After scene change, set appropriate state
  	if next_level == Constants.MAIN_MENU_SCENE:
  		change_state(Constants.GameState.MENU)
  	elif next_level.begins_with("res://scenes/levels/"):
  		change_state(Constants.GameState.PLAYING)
  		emit_signal("level_started", next_level)
  
  	# Clear next level
  	var loaded_level = next_level
  	next_level = ""
  
  	# Unload resources from previous level if not needed
  	if resource_preloader and loaded_level != Constants.MAIN_MENU_SCENE:
  		# Keep UI resources but unload previous level resources
  		resource_preloader.unload_unused_resources(["ui", "audio"])
  
  # Level management
  func restart_level() -> void:
  	if current_level:
  		change_scene(current_level)
  
  func go_to_main_menu() -> void:
  	change_scene(Constants.MAIN_MENU_SCENE)
  
  # Save and load through SaveManager
  func save_game() -> void:
  	if SaveManager:
  		SaveManager.save_game()
  		emit_signal("game_saved")
  
  func load_game() -> void:
  	if SaveManager:
  		SaveManager.load_game()
  		emit_signal("game_loaded")
  
  # Player-related functions
  func register_player(player_instance) -> void:
  	player = player_instance
  	print("Player registered with Game Manager")
  
  func collect_coin() -> void:
  	collected_coins += 1
  	emit_signal("coin_collected", collected_coins)
  
  func player_death() -> void:
  	change_state(Constants.GameState.GAME_OVER)
  	emit_signal("player_died")
  
  # Event handling
  func notify_level_completed() -> void:
  	if current_level and not unlocked_levels.has(current_level):
  		unlocked_levels.append(current_level)
  	emit_signal("level_completed", current_level)
  
  # Debug helpers
  func toggle_debug_mode() -> void:
  	get_node("/root").get_tree().get_root().set_debug_enabled(not get_node("/root").get_tree().get_root().is_debug_enabled())
  
  # Resource management helpers
  func get_resource(type: String, id: String) -> Resource:
  	if resource_preloader:
  		return resource_preloader.get_resource(type, id)
  	return null
  
  func has_resource(type: String, id: String) -> bool:
  	if resource_preloader:
  		return resource_preloader.has_resource(type, id)
  	return false
  
  func load_resource(path: String, type: String = "other", id: String = "") -> Resource:
  	if resource_preloader:
  		return resource_preloader.load_resource(path, type, id)
  	return ResourceLoader.load(path)
  
  # System functions
  func quit_game() -> void:
  	save_game()
  	get_tree().quit()
  
  # Input handling
  func _input(event: InputEvent) -> void:
  	if event.is_action_pressed(Constants.INPUT_MENU):
  		if current_state == Constants.GameState.PLAYING:
  			change_state(Constants.GameState.PAUSED)
  		elif current_state == Constants.GameState.PAUSED:
  			change_state(Constants.GameState.PLAYING)
  
  func _notification(what):
  	if what == NOTIFICATION_WM_CLOSE_REQUEST:
  		# Save game before allowing close
  		print("Game closing - saving data...")
  		SaveManager.save_game()
  		SaveManager.save_settings()
  		get_tree().quit()

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\autoload\save_manager.gd:
========================================
  extends Node
  
  ## SaveManager handles all game saving and loading operations
  ## It manages player data, settings, and outfit configurations
  ## Now with auto-save functionality
  
  # Current save data instance
  var current_save_data: SaveData = null
  
  # Auto-save settings
  var auto_save_enabled: bool = false
  var auto_save_interval: float = 300.0  # Default: save every 5 minutes
  var time_since_last_save: float = 0.0
  
  # Signals
  signal save_completed(success, message)
  signal load_completed(success, message)
  signal settings_saved(success)
  signal settings_loaded(success)
  signal outfit_saved(success, outfit_name)
  signal auto_save_performed(success)
  
  # Initialize on ready
  func _ready():
  	print("Save Manager initialized")
  	# Create default save data at startup
  	current_save_data = SaveData.new()
  	# Load settings immediately on startup
  	load_settings()
  	# Initialize auto-save
  	_init_auto_save()
  
  func _process(delta):
  	# Handle auto-save timer
  	if auto_save_enabled:
  		time_since_last_save += delta
  
  		if time_since_last_save >= auto_save_interval:
  			perform_auto_save()
  
  # Initialize auto-save
  func _init_auto_save():
  	# Default is disabled
  	auto_save_enabled = false
  	time_since_last_save = 0.0
  	# Ensure process is called
  	set_process(true)
  
  # Toggle auto-save functionality
  func toggle_auto_save(enabled: bool) -> void:
  	auto_save_enabled = enabled
  	time_since_last_save = 0.0
  	print("Auto-save " + ("enabled" if enabled else "disabled"))
  
  # Set auto-save interval (in seconds)
  func set_auto_save_interval(interval: float) -> void:
  	if interval < 10.0:
  		push_warning("Auto-save interval set too low (< 10 seconds). Using 10 seconds.")
  		auto_save_interval = 10.0
  	else:
  		auto_save_interval = interval
  
  # Perform an auto-save operation
  func perform_auto_save() -> bool:
  	print("Performing auto-save...")
  	time_since_last_save = 0.0
  
  	var success = save_game()
  	emit_signal("auto_save_performed", success)
  	return success
  
  # Save the full game state
  func save_game() -> bool:
  	if not current_save_data:
  		current_save_data = SaveData.new()
  
  	# Update data before saving
  	_update_save_data()
  
  	# Try to save the resource file
  	var dir = DirAccess.open("user://")
  	if not dir:
  		push_error("Failed to open user:// directory")
  		emit_signal("save_completed", false, "Failed to access save directory")
  		return false
  
  	var success = ResourceSaver.save(current_save_data, Constants.SAVE_FILE_PATH)
  
  	if success == OK:
  		print("Game saved successfully to: ", Constants.SAVE_FILE_PATH)
  		emit_signal("save_completed", true, "Game saved successfully")
  		return true
  	else:
  		push_error("Failed to save game. Error code: " + str(success))
  		emit_signal("save_completed", false, "Failed to save game")
  		return false
  
  # Load the full game state
  func load_game() -> bool:
  	if ResourceLoader.exists(Constants.SAVE_FILE_PATH):
  		var loaded_data = ResourceLoader.load(Constants.SAVE_FILE_PATH)
  
  		if loaded_data is SaveData:
  			current_save_data = loaded_data
  
  			# Apply loaded data to game state
  			_apply_save_data()
  
  			print("Game loaded successfully from: ", Constants.SAVE_FILE_PATH)
  			emit_signal("load_completed", true, "Game loaded successfully")
  			return true
  		else:
  			push_error("Loaded resource is not a SaveData resource")
  	else:
  		print("No save file found at: ", Constants.SAVE_FILE_PATH)
  
  	# If we get here, loading failed
  	emit_signal("load_completed", false, "No save data found or data corrupted")
  	return false
  
  # Update the save data with current game state
  func _update_save_data() -> void:
  	# Get player reference from GameManager
  	var player = null
  	if get_node_or_null("/root/Global") and get_node("/root/Global").player:
  		player = get_node("/root/Global").player
  
  	if player:
  		# Update player data
  		current_save_data.health = player.hud.lifes if player.hud else Constants.PLAYER_DEFAULT_MAX_HEALTH
  		current_save_data.coins = player.hud.coins if player.hud else 0
  		current_save_data.player_position = player.global_position
  		current_save_data.current_level = get_node("/root/Global").current_level
  
  		# Update player stats and settings - Use constants rather than hardcoded values
  		current_save_data.player_speed = player.SPEED
  		current_save_data.player_jump_velocity = player.JUMP_VELOCITY
  		current_save_data.player_fly_velocity = player.FLY_VELOCITY
  		current_save_data.player_gravity = player.GRAVITY
  		current_save_data.player_mode = player.mode
  		current_save_data.player_passed_fly_time = player.passed_fly_time
  		current_save_data.player_jump_counter = player.jump_counter
  		current_save_data.player_ready_for_jump = player.ready_for_jump
  		current_save_data.player_allowed_jumps = player.allowed_jumps
  
  		# Get outfit data - ensure we have a deep copy
  		if player.player_outfit:
  			current_save_data.player_outfit = player.player_outfit.duplicate(true)
  
  		# Update timestamp
  		current_save_data.save_date = Time.get_datetime_string_from_system(false, true)
  
  	# Add global game state
  	if get_node_or_null("/root/Global"):
  		current_save_data.collected_coins = get_node("/root/Global").collected_coins
  		current_save_data.unlocked_levels = get_node("/root/Global").unlocked_levels.duplicate()
  		current_save_data.completed_quests = get_node("/root/Global").completed_quests.duplicate()
  
  	# Update playtime
  	current_save_data.playtime_seconds += 1  # Add at least 1 second each time
  
  # Apply loaded save data to the game
  func _apply_save_data() -> void:
  	# Update GameManager data
  	if get_node_or_null("/root/Global"):
  		get_node("/root/Global").collected_coins = current_save_data.collected_coins
  		get_node("/root/Global").unlocked_levels = current_save_data.unlocked_levels.duplicate()
  		get_node("/root/Global").completed_quests = current_save_data.completed_quests.duplicate()
  		get_node("/root/Global").current_level = current_save_data.current_level
  
  	# We will apply player-specific data when the player is instantiated
  	# or when we change to the appropriate scene
  
  # Apply save data to the player (called when player is instantiated)
  func apply_save_data_to_player(player) -> void:
  	if not current_save_data or not player:
  		return
  
  	# Set player stats from constants if they're not valid in save data
  	player.SPEED = current_save_data.player_speed if current_save_data.player_speed > 0 else Constants.PLAYER_DEFAULT_SPEED
  	player.JUMP_VELOCITY = current_save_data.player_jump_velocity if current_save_data.player_jump_velocity < 0 else Constants.PLAYER_DEFAULT_JUMP_VELOCITY
  	player.FLY_VELOCITY = current_save_data.player_fly_velocity if current_save_data.player_fly_velocity < 0 else Constants.PLAYER_DEFAULT_FLY_VELOCITY
  	player.GRAVITY = current_save_data.player_gravity if current_save_data.player_gravity > 0 else Constants.PLAYER_DEFAULT_GRAVITY
  	player.mode = current_save_data.player_mode
  	player.passed_fly_time = current_save_data.player_passed_fly_time
  	player.jump_counter = current_save_data.player_jump_counter
  	player.ready_for_jump = current_save_data.player_ready_for_jump
  	player.allowed_jumps = current_save_data.player_allowed_jumps
  
  	# Apply outfit if available
  	if current_save_data.player_outfit:
  		player.player_outfit = current_save_data.player_outfit.duplicate(true)
  
  		# If there's a resource-based outfit, update that too
  		if player.current_outfit:
  			player.current_outfit.from_dictionary(current_save_data.player_outfit)
  
  	# Set HUD data if available
  	if player.hud:
  		player.hud.lifes = current_save_data.health
  		player.hud.coins = current_save_data.coins
  		player.hud.load_hearts()
  		player.hud._update_coin_display()
  
  # Settings management - Using player defaults from Constants
  func save_settings() -> bool:
  	var config = ConfigFile.new()
  
  	# Get player for current settings
  	var player = null
  	if get_node_or_null("/root/Global") and get_node("/root/Global").player:
  		player = get_node("/root/Global").player
  
  	# Save constant values if player doesn't exist, otherwise save player values
  	if player:
  		# Save player settings
  		config.set_value(Constants.SECTION_SETTINGS, "speed", player.SPEED)
  		config.set_value(Constants.SECTION_SETTINGS, "jump_velocity", player.JUMP_VELOCITY)
  		config.set_value(Constants.SECTION_SETTINGS, "fly_velocity", player.FLY_VELOCITY)
  		config.set_value(Constants.SECTION_SETTINGS, "gravity", player.GRAVITY)
  		config.set_value(Constants.SECTION_SETTINGS, "mode", player.mode)
  		config.set_value(Constants.SECTION_SETTINGS, "passed_fly_time", player.passed_fly_time)
  		config.set_value(Constants.SECTION_SETTINGS, "jump_counter", player.jump_counter)
  		config.set_value(Constants.SECTION_SETTINGS, "ready_for_jump", player.ready_for_jump)
  		config.set_value(Constants.SECTION_SETTINGS, "allowed_jumps", player.allowed_jumps)
  
  		# Save outfit
  		if player.player_outfit:
  			config.set_value(Constants.SECTION_SETTINGS, "outfit", player.player_outfit)
  	else:
  		# If no player exists, use default constants or current save data
  		config.set_value(Constants.SECTION_SETTINGS, "speed", current_save_data.player_speed)
  		config.set_value(Constants.SECTION_SETTINGS, "jump_velocity", current_save_data.player_jump_velocity)
  		config.set_value(Constants.SECTION_SETTINGS, "fly_velocity", current_save_data.player_fly_velocity)
  		config.set_value(Constants.SECTION_SETTINGS, "gravity", current_save_data.player_gravity)
  		config.set_value(Constants.SECTION_SETTINGS, "mode", current_save_data.player_mode)
  		config.set_value(Constants.SECTION_SETTINGS, "passed_fly_time", current_save_data.player_passed_fly_time)
  		config.set_value(Constants.SECTION_SETTINGS, "jump_counter", current_save_data.player_jump_counter)
  		config.set_value(Constants.SECTION_SETTINGS, "ready_for_jump", current_save_data.player_ready_for_jump)
  		config.set_value(Constants.SECTION_SETTINGS, "allowed_jumps", current_save_data.player_allowed_jumps)
  
  		# Save outfit
  		if current_save_data.player_outfit:
  			config.set_value(Constants.SECTION_SETTINGS, "outfit", current_save_data.player_outfit)
  
  	# Save audio settings
  	var master_bus_idx = AudioServer.get_bus_index("Master")
  	config.set_value(Constants.SECTION_SETTINGS, "master_volume", AudioServer.get_bus_volume_db(master_bus_idx))
  	config.set_value(Constants.SECTION_SETTINGS, "master_mute", AudioServer.is_bus_mute(master_bus_idx))
  
  	# Save auto-save settings
  	config.set_value(Constants.SECTION_SETTINGS, "auto_save_enabled", auto_save_enabled)
  	config.set_value(Constants.SECTION_SETTINGS, "auto_save_interval", auto_save_interval)
  
  	# Save the config
  	var err = config.save(Constants.SETTINGS_FILE_PATH)
  	var success = (err == OK)
  
  	if success:
  		print("Settings saved successfully to: ", Constants.SETTINGS_FILE_PATH)
  	else:
  		push_error("Failed to save settings. Error code: " + str(err))
  
  	emit_signal("settings_saved", success)
  	return success
  
  func load_settings() -> bool:
  	var config = ConfigFile.new()
  	var err = config.load(Constants.SETTINGS_FILE_PATH)
  
  	if err != OK:
  		print("No settings file found or error loading settings. Using defaults.")
  		emit_signal("settings_loaded", false)
  		return false
  
  	print("Loading settings from: ", Constants.SETTINGS_FILE_PATH)
  
  	# Create default save data if not already created
  	if not current_save_data:
  		current_save_data = SaveData.new()
  
  	# Load settings into current_save_data for future use
  	current_save_data.player_speed = config.get_value(Constants.SECTION_SETTINGS, "speed", Constants.PLAYER_DEFAULT_SPEED)
  	current_save_data.player_jump_velocity = config.get_value(Constants.SECTION_SETTINGS, "jump_velocity", Constants.PLAYER_DEFAULT_JUMP_VELOCITY)
  	current_save_data.player_fly_velocity = config.get_value(Constants.SECTION_SETTINGS, "fly_velocity", Constants.PLAYER_DEFAULT_FLY_VELOCITY)
  	current_save_data.player_gravity = config.get_value(Constants.SECTION_SETTINGS, "gravity", Constants.PLAYER_DEFAULT_GRAVITY)
  	current_save_data.player_mode = config.get_value(Constants.SECTION_SETTINGS, "mode", "normal")
  	current_save_data.player_passed_fly_time = config.get_value(Constants.SECTION_SETTINGS, "passed_fly_time", 0.0)
  	current_save_data.player_jump_counter = config.get_value(Constants.SECTION_SETTINGS, "jump_counter", 0)
  	current_save_data.player_ready_for_jump = config.get_value(Constants.SECTION_SETTINGS, "ready_for_jump", true)
  	current_save_data.player_allowed_jumps = config.get_value(Constants.SECTION_SETTINGS, "allowed_jumps", Constants.PLAYER_MAX_JUMPS)
  
  	# Load outfit
  	var saved_outfit = config.get_value(Constants.SECTION_SETTINGS, "outfit", null)
  	if saved_outfit:
  		current_save_data.player_outfit = saved_outfit.duplicate(true)
  
  	# Apply audio settings
  	var master_bus_idx = AudioServer.get_bus_index("Master")
  	var volume = config.get_value(Constants.SECTION_SETTINGS, "master_volume", 0.0)
  	var mute = config.get_value(Constants.SECTION_SETTINGS, "master_mute", false)
  
  	AudioServer.set_bus_volume_db(master_bus_idx, volume)
  	AudioServer.set_bus_mute(master_bus_idx, mute)
  
  	# Load auto-save settings
  	auto_save_enabled = config.get_value(Constants.SECTION_SETTINGS, "auto_save_enabled", false)
  	auto_save_interval = config.get_value(Constants.SECTION_SETTINGS, "auto_save_interval", 300.0)
  
  	print("Settings loaded successfully")
  	emit_signal("settings_loaded", true)
  	return true
  
  # Outfit management
  func save_outfit(outfit_config: Dictionary, name: String = "") -> bool:
  	var favorites = load_favorite_outfits()
  
  	if name.is_empty():
  		name = "Outfit " + str(favorites.size() + 1)
  
  	favorites[name] = outfit_config
  
  	var config = ConfigFile.new()
  	config.set_value(Constants.SECTION_FAVORITES, "outfits", favorites)
  	var err = config.save(Constants.FAVORITES_FILE_PATH)
  	var success = (err == OK)
  
  	if success:
  		print("Outfit saved successfully: ", name)
  	else:
  		push_error("Failed to save outfit. Error code: " + str(err))
  
  	emit_signal("outfit_saved", success, name)
  	return success
  
  func load_favorite_outfits() -> Dictionary:
  	var config = ConfigFile.new()
  	var err = config.load(Constants.FAVORITES_FILE_PATH)
  
  	if err == OK:
  		return config.get_value(Constants.SECTION_FAVORITES, "outfits", {})
  	else:
  		return {}
  
  func delete_outfit(name: String) -> bool:
  	var favorites = load_favorite_outfits()
  
  	if not favorites.has(name):
  		return false
  
  	favorites.erase(name)
  
  	var config = ConfigFile.new()
  	config.set_value(Constants.SECTION_FAVORITES, "outfits", favorites)
  	var err = config.save(Constants.FAVORITES_FILE_PATH)
  
  	return (err == OK)
  
  # Helper functions
  func save_exists() -> bool:
  	return ResourceLoader.exists(Constants.SAVE_FILE_PATH)
  
  func clear_save_data() -> void:
  	var dir = DirAccess.open("user://")
  	if dir:
  		if dir.file_exists(Constants.SAVE_FILE_PATH):
  			dir.remove(Constants.SAVE_FILE_PATH)
  			print("Save data cleared")
  	current_save_data = SaveData.new()
  
  # Return a fresh instance of SaveData
  func create_new_save_data() -> SaveData:
  	return SaveData.new()
  
  # Helper method for other scripts to add callback function when save completes
  func connect_save_completed(target: Object, method: String, binds: Array = [], flags: int = 0) -> void:
  	if not is_connected("save_completed", Callable(target, method)):
  		connect("save_completed", Callable(target, method).bind(binds), flags)
  
  # Called when player instance is being initialized
  func _on_player_ready(player) -> void:
  	call_deferred("apply_save_data_to_player", player)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\base_classes\base_enemy.gd:
========================================
  class_name BaseEnemy
  extends CharacterBody2D
  
  ## Base class for all enemies in the game
  
  # Enemy properties
  @export var max_health: float = 100.0
  @export var speed: float = 80.0
  @export var chase_speed: float = 100.0
  @export var attack_damage: float = 10.0
  @export var attack_cooldown: float = 1.0
  @export var detection_radius: float = 200.0
  @export var attack_radius: float = 75.0
  
  # Current state
  var current_health: float
  var is_dead: bool = false
  var is_chasing: bool = false
  var is_attacking: bool = false
  var can_attack: bool = true
  var target = null
  
  # Nodes (to be assigned by extending classes)
  var animated_sprite: AnimatedSprite2D
  var collision_shape: CollisionShape2D
  var hud = null
  
  # Emitted when enemy dies
  signal enemy_died(enemy)
  # Emitted when enemy takes damage
  signal enemy_damaged(enemy, amount)
  
  func _ready():
  	# Initialize health
  	current_health = max_health
  
  	# Set default animation
  	if animated_sprite:
  		animated_sprite.play("idle")
  
  	# Get HUD reference (if needed)
  	hud = get_node_or_null("../../HUD")
  
  func _physics_process(delta):
  	# Apply gravity
  	if not is_on_floor():
  		velocity.y += calculate_gravity() * delta
  
  	# Core movement
  	move_and_slide()
  
  func calculate_gravity():
  	# Can be overridden by child classes
  	return ProjectSettings.get_setting("physics/2d/default_gravity")
  
  func take_damage(amount):
  	if is_dead:
  		return
  
  	current_health -= amount
  	emit_signal("enemy_damaged", self, amount)
  
  	if current_health <= 0:
  		die()
  	else:
  		play_animation("hurt")
  
  func die():
  	is_dead = true
  	is_chasing = false
  	is_attacking = false
  
  	# Disable collision
  	if collision_shape:
  		collision_shape.set_deferred("disabled", true)
  
  	# Play death animation
  	play_animation("death")
  
  	# Emit signal
  	emit_signal("enemy_died", self)
  
  	# Wait for animation to finish before removing
  	await animated_sprite.animation_finished
  	queue_free()
  
  func play_animation(anim_name: String):
  	if animated_sprite and animated_sprite.sprite_frames.has_animation(anim_name):
  		animated_sprite.play(anim_name)
  
  func chase_target(target_node):
  	if is_dead or is_attacking:
  		return
  
  	target = target_node
  	is_chasing = true
  
  	var direction = (target.global_position - global_position).normalized()
  
  	# Face the correct direction
  	if animated_sprite:
  		animated_sprite.flip_h = direction.x > 0
  
  	# Set velocity
  	velocity.x = direction.x * (chase_speed if is_chasing else speed)
  
  	# Play animation
  	play_animation("walk")
  
  func stop_chase():
  	is_chasing = false
  	velocity.x = 0
  	play_animation("idle")
  	target = null
  
  func attack():
  	if is_dead or not can_attack or not target:
  		return
  
  	is_attacking = true
  	can_attack = false
  	velocity.x = 0
  
  	play_animation("attack")
  
  	# Wait for animation to finish
  	await animated_sprite.animation_finished
  
  	is_attacking = false
  
  	# Start cooldown
  	await get_tree().create_timer(attack_cooldown).timeout
  	can_attack = true
  
  # Called when a player or other entity enters detection radius
  func _on_detection_radius_body_entered(body):
  	if body.name == "Player" and not is_dead:
  		chase_target(body)
  
  # Called when a player or other entity exits detection radius
  func _on_detection_radius_body_exited(body):
  	if body.name == "Player":
  		stop_chase()
  
  # Called when a player enters attack range
  func _on_attack_radius_body_entered(body):
  	if body.name == "Player" and not is_dead:
  		is_chasing = false
  		attack()
  
  # Called when a player exits attack range
  func _on_attack_radius_body_exited(body):
  	if body.name == "Player" and not is_dead:
  		is_chasing = true

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\base_classes\base_power_up.gd:
========================================
  class_name BasePowerUp
  extends Area2D
  
  ## Base class for all power-ups in the game
  
  # Power-up properties
  @export var power_up_name: String = "Power Up"
  @export var description: String = "A mysterious power-up"
  @export var icon_texture: Texture2D
  @export var effect_duration: float = 0.0  # 0 means permanent effect
  @export var play_animation: bool = true
  @export var destroy_on_pickup: bool = true
  
  # Animation
  @export var bounce_height: float = 5.0
  @export var bounce_speed: float = 2.0
  @export var rotation_speed: float = 0.0
  
  # Internal variables
  var original_position: Vector2
  var animation_time: float = 0.0
  var player_ref = null
  
  # Signals
  signal power_up_collected(power_up, player)
  signal power_up_effect_started(power_up, player)
  signal power_up_effect_ended(power_up, player)
  
  func _ready():
  	original_position = global_position
  
  	# Set up collision
  	if not has_node("CollisionShape2D"):
  		push_error("Power-up " + name + " has no CollisionShape2D!")
  
  	# Set up sprite/animation if enabled
  	if play_animation and has_node("Sprite2D"):
  		var sprite = get_node("Sprite2D")
  		if icon_texture:
  			sprite.texture = icon_texture
  
  	# Connect signals
  	body_entered.connect(_on_power_up_body_entered)
  
  func _process(delta):
  	if play_animation:
  		animate_power_up(delta)
  
  func animate_power_up(delta):
  	animation_time += delta
  
  	# Bouncing animation
  	if bounce_height > 0:
  		var bounce_offset = sin(animation_time * bounce_speed) * bounce_height
  		global_position.y = original_position.y + bounce_offset
  
  	# Rotation animation
  	if rotation_speed > 0 and has_node("Sprite2D"):
  		var sprite = get_node("Sprite2D")
  		sprite.rotation += rotation_speed * delta
  
  func _on_power_up_body_entered(body):
  	if body.is_in_group("Player") or body.name == "Player":
  		collect_power_up(body)
  
  func collect_power_up(player):
  	# Store reference to player
  	player_ref = player
  
  	# Disable collision
  	set_collision_mask_value(1, false)
  
  	# Emit collected signal
  	emit_signal("power_up_collected", self, player)
  
  	# Play collection animation if available
  	if has_node("AnimationPlayer"):
  		var anim_player = get_node("AnimationPlayer")
  		if anim_player.has_animation("collect"):
  			anim_player.play("collect")
  			await anim_player.animation_finished
  
  	# Apply effect
  	apply_effect(player)
  
  	# Destroy if set
  	if destroy_on_pickup:
  		queue_free()
  
  func apply_effect(player):
  	# Base implementation just emits signal
  	# Override in child classes to implement specific effects
  	emit_signal("power_up_effect_started", self, player)
  
  	# If temporary effect, setup timer to end effect
  	if effect_duration > 0:
  		await get_tree().create_timer(effect_duration).timeout
  		remove_effect(player)
  
  func remove_effect(player):
  	# Override in child classes to implement specific effect removal
  	emit_signal("power_up_effect_ended", self, player)
  
  # Optional methods for child classes to implement
  func get_effect_description() -> String:
  	return description
  
  func get_icon() -> Texture2D:
  	return icon_texture

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\base_classes\base_projectile.gd:
========================================
  class_name BaseProjectile
  extends CharacterBody2D
  
  ## Base class for all projectiles in the game
  ## Now supports object pooling
  
  # Projectile properties
  @export var speed: float = 100.0
  @export var damage: float = 10.0
  @export var lifetime: float = 5.0  # Time before auto-destruction
  @export var gravity_affected: bool = false
  @export var bounce: bool = false
  @export var bounce_factor: float = 0.5  # How much velocity is retained when bouncing
  
  # Internal variables
  var direction: Vector2 = Vector2.ZERO
  var source_node = null  # Who fired this projectile
  var spawn_position: Vector2
  var spawn_rotation: float
  var time_alive: float = 0.0
  var has_hit: bool = false
  var is_from_pool: bool = false  # Whether this projectile came from a pool
  
  # Signals
  signal projectile_hit(projectile, target)
  signal projectile_expired(projectile)
  
  func _ready():
  	# Start lifetime timer
  	if lifetime > 0:
  		get_tree().create_timer(lifetime).timeout.connect(_on_lifetime_expired)
  
  	# Setup animation if available
  	if has_node("AnimatedSprite2D"):
  		var sprite = get_node("AnimatedSprite2D")
  		if sprite.sprite_frames.has_animation("flying"):
  			sprite.play("flying")
  
  func _physics_process(delta):
  	time_alive += delta
  
  	# Apply gravity if enabled
  	if gravity_affected:
  		velocity.y += ProjectSettings.get_setting("physics/2d/default_gravity") * delta
  
  	# Move the projectile
  	var collision = move_and_collide(velocity * delta)
  
  	# Handle collision
  	if collision and not has_hit:
  		_on_collision(collision)
  
  func setup(dir: Vector2, spawn_pos: Vector2, spawn_rot: float = 0.0, source = null):
  	direction = dir.normalized()
  	spawn_position = spawn_pos
  	spawn_rotation = spawn_rot
  	source_node = source
  
  	# Set initial position and rotation
  	global_position = spawn_position
  	global_rotation = spawn_rotation
  
  	# Set initial velocity
  	velocity = direction * speed
  
  	# Reset state
  	has_hit = false
  	time_alive = 0.0
  
  	return self  # For method chaining
  
  func _on_collision(collision):
  	var collider = collision.get_collider()
  
  	# Check if we should bounce
  	if bounce and not (collider.is_in_group("Player") or collider.is_in_group("Enemy")):
  		var reflection = collision.get_remainder().bounce(collision.get_normal())
  		velocity = velocity.bounce(collision.get_normal()) * bounce_factor
  		global_position += reflection
  		return
  
  	has_hit = true
  
  	# Handle different collision types
  	if collider.is_in_group("Player") and source_node != collider:
  		_on_hit_player(collider)
  	elif collider.is_in_group("Enemy") and source_node != collider:
  		_on_hit_enemy(collider)
  	else:
  		_on_hit_environment(collider)
  
  func _on_hit_player(player):
  	emit_signal("projectile_hit", self, player)
  
  	# Apply damage
  	if player.has_method("take_damage"):
  		player.take_damage(damage)
  
  	# Get HUD reference
  	var hud = get_node_or_null("../HUD")
  	if hud and hud.has_method("change_life"):
  		hud.change_life(-damage/100.0)  # Assuming HUD uses 0-1 scale
  
  	# Play hit effect if available
  	play_hit_effect()
  
  	_recycle_or_free()
  
  func _on_hit_enemy(enemy):
  	emit_signal("projectile_hit", self, enemy)
  
  	# Apply damage
  	if enemy.has_method("take_damage"):
  		enemy.take_damage(damage)
  
  	# Play hit effect if available
  	play_hit_effect()
  
  	_recycle_or_free()
  
  func _on_hit_environment(object):
  	emit_signal("projectile_hit", self, object)
  
  	# Play hit effect if available
  	play_hit_effect()
  
  	_recycle_or_free()
  
  func _on_lifetime_expired():
  	if not has_hit:
  		emit_signal("projectile_expired", self)
  		_recycle_or_free()
  
  func play_hit_effect():
  	# If we have an AnimatedSprite2D, try to play the hit animation
  	if has_node("AnimatedSprite2D"):
  		var sprite = get_node("AnimatedSprite2D")
  		if sprite.sprite_frames.has_animation("hit"):
  			# Disconnect from physics process
  			set_physics_process(false)
  
  			# Stop motion
  			velocity = Vector2.ZERO
  
  			# Play hit animation
  			sprite.play("hit")
  
  			# Wait for animation to finish
  			await sprite.animation_finished
  
  # Called when spawned from an object pool
  func _on_spawn_from_pool():
  	is_from_pool = true
  	visible = true
  	set_physics_process(true)
  
  	# Reset state
  	has_hit = false
  	time_alive = 0.0
  
  # Called when returned to an object pool
  func _on_recycle_to_pool():
  	# Reset state
  	has_hit = false
  	time_alive = 0.0
  	velocity = Vector2.ZERO
  	source_node = null
  
  	# Reset animation if needed
  	if has_node("AnimatedSprite2D"):
  		var sprite = get_node("AnimatedSprite2D")
  		if sprite.sprite_frames.has_animation("flying"):
  			sprite.play("flying")
  			sprite.frame = 0
  
  # Either recycle to pool or free based on whether we're using pooling
  func _recycle_or_free():
  	if is_from_pool:
  		# Find the object pool that owns this projectile
  		var scene_root = get_tree().get_root()
  		var pool = null
  
  		# First check if our source has a projectile pool
  		if source_node and source_node.has_node("ProjectilePool"):
  			pool = source_node.get_node("ProjectilePool")
  
  		# Otherwise look in the scene root
  		if not pool:
  			pool = scene_root.find_child("ProjectilePool", true, false)
  
  		if pool and pool is ObjectPool:
  			# Return to pool
  			pool.recycle(self)
  		else:
  			# Fall back to queue_free
  			queue_free()
  	else:
  		# Not from pool, just free it
  		queue_free()

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\characters\character_sprites.gd:
========================================
  class_name CharacterSprites
  extends Node2D
  
  var animation_frames = {
  	"idle": [0, 1, 2, 3, 4, 5, 6, 7],
  	"animation1": [8, 9, 10, 11, 12, 13, 14, 15],
  	"animation2": [16, 17, 18, 19, 20, 21, 22, 23],
  	"walking": [24, 25, 26, 27, 28, 29, 30, 31],
  	"animation4": [32, 33, 34, 35, 36],
  	"animation5": [40, 41, 42, 43, 44],
  	"animation6": [48, 49, 50, 51, 52],
  	"animation7": [56, 57, 58, 59, 60],
  	"animation8": [64, 65, 66, 67, 68],
  	"animation9": [72, 73, 74, 75, 76],
  	"animation10": [80, 81, 82, 83, 84],
  	"animation11": [88, 89, 90, 91, 92],
  	"animation12": [96, 97, 98, 99, 100, 101, 102, 103],
  	"animation13": [104, 105, 106, 107, 108, 109, 110, 111],
  	"animation14": [112, 113, 114, 115, 116, 117, 118, 119],
  	"animation15": [120, 121, 122, 123, 124, 125, 126, 127],
  	"animation16": [128, 129, 130, 131],
  	"animation17": [136, 137, 138, 139],
  	"animation18": [144, 145, 146, 147], #attack knife
  	"animation19": [152, 153, 154, 155],
  	"animation20": [160],
  	"animation21": [168],
  	"animation22": [176],
  	"animation23": [184],
  	"animation24": [192],
  	"animation25": [200],
  	"animation26": [208],
  	"animation27": [216],
  	"dead": [224, 225],
  	"animation29": [232, 233, 234, 235, 236],
  	"walking0": [240, 241, 242, 243, 244],
  	"walking1": [248, 249, 250, 251, 252],
  	"walking2": [256, 257, 258, 259, 260],
  	"walking3": [264, 265, 266, 267, 268],
  	"walking4": [272, 273, 274, 275, 276],
  	"walking5": [280, 281, 282, 283, 284], #attack axe right
  	"walking6": [288, 289, 290, 291, 292], #attack axe left
  	"walking7": [296, 297],
  	"walking8": [304, 305],
  	"walking9": [312, 313],
  	"animation40": [320, 321],
  	"animation41": [328, 329, 330, 331, 332],
  	"animation42": [336, 337, 338, 339, 340],
  	"animation43": [344, 345, 346, 347, 348],
  	"animation44": [352, 353, 354, 355, 356],
  	"animation45": [360, 361, 362, 363, 364],
  	"animation46": [368, 369, 370, 371, 372],
  	"animation47": [376, 377, 378, 379, 380],
  	"animation48": [384, 385, 386, 387, 388],
  	"hurt":        [25*8, 27*8],
  }
  
  var default_outfit = {
  	"beard": 1,
  	"lipstick": 1,
  	"eyes": 1,
  	"shoes": 1,
  	"earrings": 1,
  	"hats": 1,
  	"glasses": 1,
  	"clothes_down": 1,
  	"clothes_up": 1,
  	"clothes_complete": 1,
  	"bodies": 1,
  	"hair": 1
  }

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\characters\player.gd:
========================================
  class_name Player
  extends CharacterBody2D
  
  @export var joystick_right: VirtualJoystick
  @export var debug_mode: bool = false
  
  # Environment variables - use constants from Constants singleton
  var SPEED = Constants.PLAYER_DEFAULT_SPEED
  var JUMP_VELOCITY = Constants.PLAYER_DEFAULT_JUMP_VELOCITY
  var FLY_VELOCITY = Constants.PLAYER_DEFAULT_FLY_VELOCITY
  var GRAVITY = Constants.PLAYER_DEFAULT_GRAVITY
  
  # Character mode variables
  var mode = "normal"
  var passed_fly_time = 0.0
  var jump_counter = 0
  var ready_for_jump = true
  var allowed_jumps = Constants.PLAYER_MAX_JUMPS
  
  # Character health reference
  var hud
  
  # Character design variables
  var player_animations
  var current_animation = Constants.ANIMATION_IDLE
  var player_outfit
  var play_attack_animation = false
  var attack_animation = Constants.ANIMATION_ATTACK
  
  # Resource-based outfit system
  var current_outfit: PlayerOutfitResource = null
  
  # Reference to the state machine
  @onready var state_machine = $StateMachine
  
  func _ready() -> void:
  	# Initialize your global variables here
  	hud = get_node_or_null("../../HUD")
  	player_animations = get_node("character_sprites").animation_frames
  
  	# Initialize outfit with defaults
  	var default_player_outfit = get_node("character_sprites").default_outfit
  	get_node("character_sprites/masks").visible = false
  	player_outfit = default_player_outfit.duplicate(true)
  
  	# Create outfit resource
  	current_outfit = PlayerOutfitResource.new()
  
  	# Register with GameManager
  	if get_node_or_null("/root/Global"):
  		Global.register_player(self)
  
  	# Connect to SaveManager signals
  	if get_node_or_null("/root/SaveManager"):
  		SaveManager.connect("load_completed", Callable(self, "_on_save_loaded"))
  		SaveManager.connect("settings_loaded", Callable(self, "_on_settings_loaded"))
  
  		# Load settings from SaveManager
  		if SaveManager.current_save_data:
  			update_from_save_data()
  
  	if debug_mode:
  		print("Player ready, State Machine initialized")
  		print("Initial player stats: Speed=", SPEED, ", Jump=", JUMP_VELOCITY,
  			  ", Fly=", FLY_VELOCITY, ", Gravity=", GRAVITY)
  
  # Save current player settings
  func save_settings():
  	if get_node_or_null("/root/SaveManager"):
  		SaveManager.save_settings()
  
  # New methods for SaveManager integration
  func _on_save_loaded(success, message):
  	if success:
  		update_from_save_data()
  
  func _on_settings_loaded(success):
  	if success:
  		update_from_save_data()
  
  func update_from_save_data():
  	if not get_node_or_null("/root/SaveManager") or not SaveManager.current_save_data:
  		print("No save data available to update from")
  		return
  
  	var save_data = SaveManager.current_save_data
  
  	# Update movement parameters
  	SPEED = save_data.player_speed
  	JUMP_VELOCITY = save_data.player_jump_velocity
  	FLY_VELOCITY = save_data.player_fly_velocity
  	GRAVITY = save_data.player_gravity
  
  	# Update state
  	mode = save_data.player_mode
  	passed_fly_time = save_data.player_passed_fly_time
  	jump_counter = save_data.player_jump_counter
  	ready_for_jump = save_data.player_ready_for_jump
  	allowed_jumps = save_data.player_allowed_jumps
  
  	# Apply outfit if available
  	if save_data.player_outfit and not save_data.player_outfit.is_empty():
  		# Update resource and dictionary
  		if current_outfit:
  			current_outfit.from_dictionary(save_data.player_outfit)
  		else:
  			current_outfit = PlayerOutfitResource.new().from_dictionary(save_data.player_outfit)
  
  		# Apply current outfit to character
  		player_outfit = save_data.player_outfit.duplicate(true)
  		_update_outfit_visuals()
  
  	if debug_mode:
  		print("Updated player from save data: Speed=", SPEED, ", Jump=", JUMP_VELOCITY)
  		print("Outfit loaded:", player_outfit)
  
  # Update outfit sprite visibility and animations
  func _update_outfit_visuals():
  	for category in player_outfit:
  		if has_node("character_sprites/" + category):
  			var sprite = get_node("character_sprites/" + category)
  			var value = str(player_outfit[category])
  
  			if value == "none":
  				sprite.visible = false
  			else:
  				sprite.visible = true
  				sprite.animation = value
  				sprite.frame = 1
  
  # Helper method to play animations
  func play_animation(anim_name: String):
  	current_animation = anim_name
  
  # Return gravity as a Vector2 to avoid conflicts with PhysicsBody2D
  func calculate_gravity() -> Vector2:
  	return Vector2(0, GRAVITY)
  
  # Keep portal handlers and other methods
  func _on_test_portal_entered(_body):
  	if get_node_or_null("/root/Global"):
  		Global.change_scene(Constants.MAIN_MENU_SCENE)
  	mode = "fly"
  	save_settings()
  
  func _on_elias_portal_entered(_body):
  	print("Elias")
  	save_settings()
  
  func _on_ardit_portal_entered(_body):
  	if get_node_or_null("/root/Global"):
  		Global.change_scene("res://Arrogance.tscn")
  	save_settings()
  
  func _on_sebastian_portal_entered(_body):
  	mode = "normal"
  	if get_node_or_null("/root/Global"):
  		Global.change_scene("res://scenes/levels/sebastian_levels/level_1.tscn")
  	save_settings()
  
  func _on_prince_portal_entered(_body):
  	if get_node_or_null("/root/Global"):
  		Global.change_scene("res://scenes/levels/prince_levels/platform.tscn")
  	save_settings()
  
  func _on_fallzone_body_entered(_body):
  	if get_node_or_null("/root/Global"):
  		Global.change_scene("res://scenes/levels/ardit_levels/arrogance.tscn")
  
  func _on_life_up_body_entered(_body):
  	if hud:
  		hud.change_life(0.25)
  
  func _on_life_down_body_entered(_body):
  	if hud:
  		hud.change_life(-0.25)
  
  func death():
  	$CollisionShape2D.disabled = true
  	current_animation = "dead"
  
  	# Notify GameManager of player death
  	if get_node_or_null("/root/Global"):
  		Global.player_death()
  
  	self.queue_free()
  
  	if get_node_or_null("/root/Global"):
  		Global.go_to_main_menu()
  
  func _on_test_portal_body_entered(_body):
  	if get_node_or_null("/root/Global"):
  		Global.change_scene("res://scenes/levels/adventure_mode/adventure_level.tscn")
  
  # New methods for gameplay enhancement
  func set_movement_mode(new_mode: String) -> void:
  	mode = new_mode
  
  	if new_mode == "fly":
  		passed_fly_time = 0.0
  
  	if debug_mode:
  		print("Movement mode changed to: ", new_mode)
  
  func enable_attack(enable: bool) -> void:
  	play_attack_animation = enable
  
  func set_attack_animation(anim_name: String) -> void:
  	attack_animation = anim_name
  
  func add_extra_jumps(extra_jumps: int) -> void:
  	allowed_jumps += extra_jumps
  
  func take_damage(amount: float) -> void:
  	if hud:
  		hud.change_life(-amount / 100.0)
  
  func bounce() -> void:
  	velocity.y = JUMP_VELOCITY * 0.7 # Less powerful than a regular jump

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\characters\player_camera.gd:
========================================
  class_name PlayerCamera
  extends Camera2D
  
  
  # Called when the node enters the scene tree for the first time.
  func _ready():
  	pass # Replace with function body.
  
  
  # Called every frame. 'delta' is the elapsed time since the previous frame.
  func _process(delta):
  	pass

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\combat\damage_system.gd:
========================================
  class_name DamageSystem
  extends Node
  
  ## A centralized system for calculating and applying damage in the game
  
  # Damage types
  enum DamageType {
  	PHYSICAL,
  	MAGICAL,
  	TRUE      # Ignores defenses
  }
  
  # Hit types
  enum HitType {
  	NORMAL,
  	CRITICAL,
  	MISS
  }
  
  # Damage result structure
  class DamageResult:
  	var damage: float = 0
  	var hit_type: int = HitType.NORMAL
  	var damage_type: int = DamageType.PHYSICAL
  	var source = null
  	var target = null
  
  	func _init(dmg: float, type: int = HitType.NORMAL, dmg_type: int = DamageType.PHYSICAL, src = null, tgt = null):
  		damage = dmg
  		hit_type = type
  		damage_type = dmg_type
  		source = src
  		target = tgt
  
  # Default critical hit modifier
  var critical_multiplier: float = 1.5
  # Base chance for a critical hit (0-1)
  var base_critical_chance: float = 0.1
  # Base chance to miss (0-1)
  var base_miss_chance: float = 0.05
  
  # Signal emitted when damage is calculated
  signal damage_calculated(result: DamageResult)
  # Signal emitted when damage is applied
  signal damage_applied(result: DamageResult)
  # Signal emitted when a lethal hit is dealt
  signal lethal_hit(target, source)
  
  ## Calculate raw damage based on attacker and defender stats
  func calculate_damage(attacker, defender, base_damage: float, damage_type: int = DamageType.PHYSICAL) -> DamageResult:
  	# Get attack power
  	var attack_power = base_damage
  	if attacker.has_method("get_attack_power"):
  		attack_power = attacker.get_attack_power()
  	elif "attack_damage" in attacker:
  		attack_power = attacker.attack_damage
  
  	# Get defense
  	var defense = 0
  	if defender.has_method("get_defense"):
  		defense = defender.get_defense()
  	elif "defense" in defender:
  		defense = defender.defense
  
  	# Determine hit type (miss, normal, critical)
  	var hit_type = HitType.NORMAL
  	var hit_chance = randf()
  
  	# Check for miss
  	var miss_chance = base_miss_chance
  	if defender.has_method("get_dodge_chance"):
  		miss_chance += defender.get_dodge_chance()
  
  	if hit_chance < miss_chance:
  		hit_type = HitType.MISS
  		attack_power = 0
  	else:
  		# Check for critical hit
  		var crit_chance = base_critical_chance
  		if attacker.has_method("get_critical_chance"):
  			crit_chance += attacker.get_critical_chance()
  
  		if hit_chance > (1.0 - crit_chance):
  			hit_type = HitType.CRITICAL
  			attack_power *= critical_multiplier
  
  	# Calculate damage based on type
  	var final_damage = attack_power
  
  	match damage_type:
  		DamageType.PHYSICAL:
  			# Physical damage reduced by defense
  			final_damage = max(0, attack_power - defense)
  		DamageType.MAGICAL:
  			# Magical damage, different formula
  			var magic_defense = defense * 0.5  # Example: magic defense is half of physical
  			final_damage = max(0, attack_power - magic_defense)
  		DamageType.TRUE:
  			# True damage ignores defense
  			final_damage = attack_power
  
  	# Create the damage result
  	var result = DamageResult.new(final_damage, hit_type, damage_type, attacker, defender)
  
  	# Emit signal
  	emit_signal("damage_calculated", result)
  
  	return result
  
  ## Apply calculated damage to the target
  func apply_damage(result: DamageResult) -> bool:
  	if result.hit_type == HitType.MISS:
  		# Missed attack
  		if result.target.has_method("on_damage_missed"):
  			result.target.on_damage_missed(result)
  		return false
  
  	# Apply damage to the target
  	var was_lethal = false
  
  	if result.target.has_method("take_damage"):
  		was_lethal = result.target.take_damage(result.damage)
  	elif "current_health" in result.target:
  		result.target.current_health -= result.damage
  		if result.target.current_health <= 0:
  			was_lethal = true
  
  	# Emit the damage applied signal
  	emit_signal("damage_applied", result)
  
  	# Handle lethal hit
  	if was_lethal:
  		emit_signal("lethal_hit", result.target, result.source)
  
  	return was_lethal
  
  ## Process a direct attack from attacker to defender
  func process_attack(attacker, defender, base_damage: float, damage_type: int = DamageType.PHYSICAL) -> bool:
  	var result = calculate_damage(attacker, defender, base_damage, damage_type)
  	return apply_damage(result)
  
  ## Helper function to get the appropriate text for a hit type
  func get_hit_text(hit_type: int) -> String:
  	match hit_type:
  		HitType.MISS:
  			return "Miss"
  		HitType.CRITICAL:
  			return "Critical"
  		_:
  			return "Hit"

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\combat\hit_effect.gd:
========================================
  class_name HitEffect
  extends Node2D
  
  ## Visual and audio effects for combat hits
  ## Creates temporary visual effects at hit locations
  
  # Effect properties
  @export var lifetime: float = 0.5
  @export var scale_multiplier: float = 1.0
  @export var effect_color: Color = Color(1, 1, 1, 1)
  @export var hit_sound: AudioStream = null
  @export var hit_sound_volume: float = 0.0  # in dB
  
  # Effect type
  enum HitEffectType {
  	NORMAL,
  	CRITICAL,
  	BLOCK,
  	HEAL,
  	MAGIC
  }
  
  @export var effect_type: HitEffectType = HitEffectType.NORMAL
  
  # Animation properties
  @export var animation_speed: float = 1.0
  @export var sprite_frames: SpriteFrames = null
  
  # Animation node
  var animated_sprite: AnimatedSprite2D = null
  
  # Whether audio has been played
  var audio_played: bool = false
  
  # Signal when effect is finished
  signal effect_finished()
  
  # Initialize the hit effect
  func _ready():
  	# Create animated sprite if not already a child
  	if not has_node("AnimatedSprite2D"):
  		animated_sprite = AnimatedSprite2D.new()
  		animated_sprite.name = "AnimatedSprite2D"
  		add_child(animated_sprite)
  	else:
  		animated_sprite = $AnimatedSprite2D
  
  	# Set up animation
  	if sprite_frames:
  		animated_sprite.sprite_frames = sprite_frames
  
  	# Apply settings
  	animated_sprite.modulate = effect_color
  	scale = Vector2(scale_multiplier, scale_multiplier)
  	animated_sprite.speed_scale = animation_speed
  
  	# Determine which animation to play
  	var anim_name = "normal" # Default animation
  	match effect_type:
  		HitEffectType.CRITICAL:
  			anim_name = "critical"
  		HitEffectType.BLOCK:
  			anim_name = "block"
  		HitEffectType.HEAL:
  			anim_name = "heal"
  		HitEffectType.MAGIC:
  			anim_name = "magic"
  
  	# Check if animation exists
  	if animated_sprite.sprite_frames and animated_sprite.sprite_frames.has_animation(anim_name):
  		animated_sprite.play(anim_name)
  	else:
  		# Use first available animation
  		var animations = animated_sprite.sprite_frames.get_animation_names()
  		if animations.size() > 0:
  			animated_sprite.play(animations[0])
  
  	# Play hit sound
  	if hit_sound and not audio_played:
  		var audio_player = AudioStreamPlayer.new()
  		audio_player.stream = hit_sound
  		audio_player.volume_db = hit_sound_volume
  		audio_player.name = "HitSound"
  		add_child(audio_player)
  		audio_player.play()
  		audio_player.finished.connect(func(): audio_player.queue_free())
  		audio_played = true
  
  	# Connect to animation finished
  	animated_sprite.animation_finished.connect(_on_animation_finished)
  
  	# Set up backup timeout
  	var timer = Timer.new()
  	timer.wait_time = lifetime
  	timer.one_shot = true
  	timer.name = "LifetimeTimer"
  	add_child(timer)
  	timer.timeout.connect(_on_timeout)
  	timer.start()
  
  # Process function for manual animation logic if needed
  func _process(delta):
  	# Add optional particle effects or additional animations
  	pass
  
  # Create and play a one-shot hit effect at a position
  static func create_hit_effect(
  	effect_scene: PackedScene,
  	position: Vector2,
  	type: HitEffectType = HitEffectType.NORMAL,
  	parent: Node = null
  ) -> HitEffect:
  	# Instance the effect
  	var effect_instance = effect_scene.instantiate()
  
  	# Set effect properties
  	effect_instance.global_position = position
  	effect_instance.effect_type = type
  
  	# Find parent to add to
  	var target_parent = parent
  	if not target_parent:
  		target_parent = Engine.get_main_loop().current_scene
  
  	# Add to scene
  	target_parent.add_child(effect_instance)
  
  	return effect_instance
  
  # Animation finished handler
  func _on_animation_finished():
  	queue_free()
  	emit_signal("effect_finished")
  
  # Backup timeout handler (in case animation doesn't finish)
  func _on_timeout():
  	queue_free()
  	emit_signal("effect_finished")
  
  # Apply a screen shake effect
  func apply_screen_shake(camera: Camera2D, intensity: float = 5.0, duration: float = 0.2) -> void:
  	if camera:
  		var original_offset = camera.offset
  
  		# Create a tween for the shake
  		var tween = create_tween()
  
  		# Add multiple shake steps
  		var shake_steps = 10
  		var time_per_step = duration / shake_steps
  
  		for i in range(shake_steps):
  			var random_offset = Vector2(
  				randf_range(-intensity, intensity),
  				randf_range(-intensity, intensity)
  			)
  
  			# Reduce intensity over time
  			random_offset *= 1.0 - (float(i) / shake_steps)
  
  			tween.tween_property(camera, "offset", original_offset + random_offset, time_per_step)
  
  		# Reset to original position
  		tween.tween_property(camera, "offset", original_offset, time_per_step)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\enemies\ardit_enemy.gd:
========================================
  class_name ArditEnemy
  extends BaseEnemy
  
  ## Simple patrol enemy that walks back and forth
  
  @export var patrol_distance: float = 100.0
  @export var direction: int = 1  # 1 = right, -1 = left
  
  @onready var ray_cast_right: RayCast2D = $RayCastRight
  @onready var ray_cast_left: RayCast2D = $RayCastLeft
  
  var start_position: Vector2
  var is_patrolling: bool = true
  
  func _ready():
  	# Set base enemy properties
  	max_health = 50.0
  	speed = 60.0
  	chase_speed = 80.0
  	attack_damage = 15.0
  	attack_cooldown = 1.0
  
  	# Set references
  	animated_sprite = $AnimatedSprite2D
  	collision_shape = $CollisionShape2D
  
  	# Store starting position for patrol
  	start_position = global_position
  
  	# Initialize raycasts if not already set
  	if not ray_cast_right:
  		ray_cast_right = $RayCastRight if has_node("RayCastRight") else null
  
  	if not ray_cast_left:
  		ray_cast_left = $RayCastLeft if has_node("RayCastLeft") else null
  
  	# Call parent ready method
  	super._ready()
  
  	# Start patrol behavior
  	play_animation("walk")
  
  func _physics_process(delta):
  	# Call parent implementation for gravity and movement
  	super._physics_process(delta)
  
  	# Handle patrol logic if not chasing or attacking
  	if is_patrolling and not is_chasing and not is_attacking and not is_dead:
  		patrol()
  
  func patrol():
  	# Check wall collisions
  	if ray_cast_right and ray_cast_right.is_colliding():
  		direction = -1
  		animated_sprite.flip_h = false
  	elif ray_cast_left and ray_cast_left.is_colliding():
  		direction = 1
  		animated_sprite.flip_h = true
  
  	# Check patrol distance limits
  	if abs(global_position.x - start_position.x) > patrol_distance:
  		direction *= -1
  		animated_sprite.flip_h = direction > 0
  
  	# Set movement velocity
  	velocity.x = direction * speed
  
  	# Play walk animation
  	play_animation("walk")
  
  func chase_target(target_node):
  	# Stop patrolling when chasing
  	is_patrolling = false
  
  	# Call parent implementation
  	super.chase_target(target_node)
  
  func stop_chase():
  	# Resume patrolling when chase ends
  	is_patrolling = true
  
  	# Call parent implementation
  	super.stop_chase()
  
  # Overridden to properly handle player jumping on enemy
  func _on_top_checker_body_entered(body):
  	if body.name == "Player" and not is_dead:
  		# Player jumped on top, take damage
  		take_damage(current_health)  # Instant kill when jumped on
  
  		# Give player an upward boost if it has the method
  		if body.has_method("bounce"):
  			body.bounce()

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\enemies\behaviors\attack_behavior.gd:
========================================
  class_name AttackBehavior
  extends Node
  
  ## A modular component for enemy attack behavior
  
  # Attack types
  enum AttackType {
  	MELEE,    # Close range attack
  	RANGED,   # Projectile attack
  	AREA      # Area of effect attack
  }
  
  # The type of attack
  @export var attack_type: AttackType = AttackType.MELEE
  # Base damage for the attack
  @export var base_damage: float = 10.0
  # Cooldown between attacks (seconds)
  @export var cooldown: float = 1.0
  # Range at which attack can be performed
  @export var attack_range: float = 50.0
  # For ranged attacks, the projectile scene
  @export var projectile_scene: PackedScene = null
  # For area attacks, the area shape
  @export var area_shape: Shape2D = null
  # For area attacks, the area size
  @export var area_size: Vector2 = Vector2(100, 100)
  # Animation to play when attacking
  @export var attack_animation: String = "attack"
  # Whether to face the target when attacking
  @export var face_target: bool = true
  # For ranged attacks, the spawn offset
  @export var projectile_spawn_offset: Vector2 = Vector2(0, 0)
  # Path to the animated sprite (if not direct child)
  @export var animated_sprite_path: String = "AnimatedSprite2D"
  # Whether this attack is currently available
  @export var can_attack: bool = true
  
  # Reference to the character this behavior belongs to
  var character = null
  # Current attack target
  var target = null
  # Current cooldown timer
  var cooldown_timer: float = 0.0
  # Reference to the damage system (optional)
  var damage_system = null
  
  # Signals
  signal attack_started(target)
  signal attack_finished(target, hit)
  signal attack_cooldown_started(time)
  signal attack_cooldown_finished()
  
  func _ready():
  	# Get the owner character (parent node)
  	character = get_parent()
  
  	# Try to get damage system reference
  	damage_system = get_node_or_null("/root/DamageSystem")
  
  func _process(delta):
  	# Handle cooldown
  	if not can_attack:
  		cooldown_timer -= delta
  		if cooldown_timer <= 0:
  			can_attack = true
  			emit_signal("attack_cooldown_finished")
  
  ## Check if a target is in attack range
  func is_target_in_range(check_target) -> bool:
  	if not check_target:
  		return false
  
  	var distance = character.global_position.distance_to(check_target.global_position)
  	return distance <= attack_range
  
  ## Set a new attack target
  func set_target(new_target):
  	target = new_target
  
  ## Perform an attack against the current target
  func attack() -> bool:
  	if not can_attack or not target:
  		return false
  
  	if not is_target_in_range(target):
  		return false
  
  	# Face the target if enabled
  	if face_target:
  		_face_target(target)
  
  	# Play attack animation
  	if character.has_method("play_animation"):
  		character.play_animation(attack_animation)
  	elif character.has_node(animated_sprite_path):
  		var sprite = character.get_node(animated_sprite_path)
  		if sprite.has_method("play"):
  			sprite.play(attack_animation)
  
  	emit_signal("attack_started", target)
  
  	# Handle different attack types
  	var hit = false
  
  	match attack_type:
  		AttackType.MELEE:
  			hit = _perform_melee_attack()
  		AttackType.RANGED:
  			hit = _perform_ranged_attack()
  		AttackType.AREA:
  			# This is a coroutine, so we need to use await
  			hit = await _perform_area_attack()
  
  	# Start cooldown
  	can_attack = false
  	cooldown_timer = cooldown
  	emit_signal("attack_cooldown_started", cooldown)
  
  	# Wait for animation to finish
  	if character.has_node(animated_sprite_path):
  		var sprite = character.get_node(animated_sprite_path)
  		await sprite.animation_finished
  	else:
  		await get_tree().create_timer(0.5).timeout
  
  	emit_signal("attack_finished", target, hit)
  	return hit
  
  ## Perform a melee attack
  func _perform_melee_attack() -> bool:
  	# If we have a damage system, use it
  	if damage_system:
  		return damage_system.process_attack(character, target, base_damage)
  
  	# Otherwise use direct damage application
  	if target.has_method("take_damage"):
  		target.take_damage(base_damage)
  		return true
  	elif "current_health" in target:
  		target.current_health -= base_damage
  		return true
  
  	return false
  
  ## Perform a ranged attack by spawning a projectile
  func _perform_ranged_attack() -> bool:
  	if not projectile_scene:
  		push_error("Projectile scene is not set for ranged attack!")
  		return false
  
  	# Get spawn position
  	var spawn_pos = character.global_position + projectile_spawn_offset
  
  	# Get direction to target
  	var direction = (target.global_position - spawn_pos).normalized()
  
  	# Check if we have an object pool
  	var projectile_pool = character.get_node_or_null("ProjectilePool")
  
  	if projectile_pool and projectile_pool is ObjectPool:
  		# Get a projectile from the pool
  		var projectile = projectile_pool.get_object()
  		if projectile:
  			if projectile.has_method("setup"):
  				projectile.setup(direction, spawn_pos, character.global_rotation, character)
  			return true
  	else:
  		# Create a new projectile
  		var projectile = projectile_scene.instantiate()
  		get_tree().get_root().add_child(projectile)
  
  		if projectile.has_method("setup"):
  			projectile.setup(direction, spawn_pos, character.global_rotation, character)
  		elif "direction" in projectile:
  			projectile.direction = direction
  			projectile.global_position = spawn_pos
  			projectile.source_node = character
  
  		return true
  
  	return false
  
  ## Perform an area attack affecting all targets in an area
  func _perform_area_attack() -> bool:
  	var hit_something = false
  
  	# Create area for attack
  	var area = Area2D.new()
  	var collision_shape = CollisionShape2D.new()
  
  	# Configure shape
  	if area_shape:
  		collision_shape.shape = area_shape
  	else:
  		# Default to rectangle
  		var rect_shape = RectangleShape2D.new()
  		rect_shape.size = area_size
  		collision_shape.shape = rect_shape
  
  	area.add_child(collision_shape)
  	character.add_child(area)
  
  	# Check for bodies in the area
  	await get_tree().process_frame
  	var bodies = area.get_overlapping_bodies()
  
  	for body in bodies:
  		if body != character and body.is_in_group("damageable"):
  			# If we have a damage system, use it
  			if damage_system:
  				damage_system.process_attack(character, body, base_damage)
  			# Otherwise use direct damage application
  			elif body.has_method("take_damage"):
  				body.take_damage(base_damage)
  			elif "current_health" in body:
  				body.current_health -= base_damage
  
  			hit_something = true
  
  	# Clean up
  	area.queue_free()
  	return hit_something
  
  ## Face the character towards the target
  func _face_target(face_target):
  	if not face_target:
  		return
  
  	var direction = (face_target.global_position - character.global_position).normalized()
  
  	# Handle sprite flipping
  	var sprite = character.get_node_or_null(animated_sprite_path)
  	if sprite and "flip_h" in sprite:
  		sprite.flip_h = direction.x < 0

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\enemies\behaviors\chase_behavior.gd:
========================================
  class_name ChaseBehavior
  extends Node
  
  ## A modular component for enemy chase behavior
  
  # Reference to the character this behavior belongs to
  var character = null
  # The target being chased
  var target = null
  # Speed while chasing
  @export var chase_speed: float = 100.0
  # Maximum chase distance before giving up
  @export var max_chase_distance: float = 300.0
  # Minimum distance to maintain from target
  @export var min_distance: float = 10.0
  # Whether to use prediction for moving targets
  @export var use_prediction: bool = false
  # How far ahead to predict target movement (0-1)
  @export var prediction_factor: float = 0.5
  # Whether to check for line of sight
  @export var check_line_of_sight: bool = true
  # Collision layer to check for line of sight (walls, obstacles)
  @export_flags_2d_physics var line_of_sight_mask: int = 1
  # Animation to play while chasing
  @export var chase_animation: String = "walk"
  # Path to the animated sprite (if not direct child)
  @export var animated_sprite_path: String = "AnimatedSprite2D"
  # Whether the chase is currently active
  @export var is_active: bool = false
  
  # Last known position of the target
  var last_known_position: Vector2 = Vector2.ZERO
  # Direction to the target
  var chase_direction: Vector2 = Vector2.ZERO
  # Time spent chasing without line of sight
  var lost_sight_time: float = 0.0
  # Maximum time to chase without line of sight
  @export var max_lost_sight_time: float = 2.0
  
  # Signals
  signal chase_started(target)
  signal chase_ended()
  signal chase_target_reached(target)
  signal target_lost()
  signal line_of_sight_lost()
  signal line_of_sight_regained()
  
  func _ready():
  	# Get the owner character (parent node)
  	character = get_parent()
  
  func _physics_process(delta):
  	if not is_active or not target:
  		return
  
  	if not is_instance_valid(target):
  		end_chase()
  		return
  
  	# Get positions
  	var character_pos = character.global_position
  	var target_pos = target.global_position
  
  	# Check max chase distance
  	var distance_to_target = character_pos.distance_to(target_pos)
  	if distance_to_target > max_chase_distance:
  		emit_signal("target_lost")
  		end_chase()
  		return
  
  	# Check line of sight if needed
  	var has_line_of_sight = true
  	if check_line_of_sight:
  		has_line_of_sight = _check_line_of_sight(target)
  
  		if not has_line_of_sight:
  			lost_sight_time += delta
  			if lost_sight_time > max_lost_sight_time:
  				emit_signal("target_lost")
  				end_chase()
  				return
  		else:
  			if lost_sight_time > 0:
  				emit_signal("line_of_sight_regained")
  			lost_sight_time = 0
  			last_known_position = target_pos
  
  	# Calculate target position (with prediction if enabled)
  	var chase_target_pos = target_pos
  	if use_prediction and "velocity" in target and target.velocity.length() > 0:
  		chase_target_pos += target.velocity * prediction_factor
  
  	# Calculate direction and distance
  	chase_direction = (chase_target_pos - character_pos).normalized()
  
  	# Check if we've reached minimum distance
  	if distance_to_target <= min_distance:
  		emit_signal("chase_target_reached", target)
  		if "velocity" in character:
  			character.velocity.x = 0
  		return
  
  	# Apply movement
  	if "velocity" in character:
  		character.velocity.x = chase_direction.x * chase_speed
  
  	# Update animation and facing
  	_update_animation(chase_direction)
  
  ## Start chasing a target
  func start_chase(new_target) -> bool:
  	if not new_target:
  		return false
  
  	target = new_target
  	is_active = true
  	lost_sight_time = 0
  	last_known_position = target.global_position
  
  	emit_signal("chase_started", target)
  	return true
  
  ## End the current chase
  func end_chase():
  	if is_active:
  		emit_signal("chase_ended")
  
  	is_active = false
  	target = null
  	lost_sight_time = 0
  
  	# Stop movement
  	if "velocity" in character:
  		character.velocity.x = 0
  
  ## Check if the character has line of sight to the target
  func _check_line_of_sight(check_target) -> bool:
  	if not check_target:
  		return false
  
  	var space_state = character.get_world_2d().direct_space_state
  	var params = PhysicsRayQueryParameters2D.new()
  	params.from = character.global_position
  	params.to = check_target.global_position
  	params.collision_mask = line_of_sight_mask
  	params.exclude = [character]
  
  	var result = space_state.intersect_ray(params)
  
  	if result and result.collider != check_target:
  		if lost_sight_time == 0:
  			emit_signal("line_of_sight_lost")
  		return false
  	return true
  
  ## Get the current distance to the target
  func get_distance_to_target() -> float:
  	if not target:
  		return INF
  	return character.global_position.distance_to(target.global_position)
  
  ## Update character animation and direction based on movement
  func _update_animation(direction: Vector2):
  	# Play chase animation
  	if character.has_method("play_animation"):
  		character.play_animation(chase_animation)
  
  	# Handle sprite flipping
  	var sprite = character.get_node_or_null(animated_sprite_path)
  	if sprite and "flip_h" in sprite:
  		sprite.flip_h = direction.x < 0

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\enemies\behaviors\patrol_behavior.gd:
========================================
  class_name PatrolBehavior
  extends Node
  
  ## A modular component for enemy patrol behavior
  
  # Patrol modes
  enum PatrolMode {
  	BACK_AND_FORTH,  # Move between start and end points
  	LOOP,            # Move in a loop through all points
  	RANDOM           # Choose random points to patrol to
  }
  
  # Patrol points - Vector2 positions for the patrol path
  @export var patrol_points: Array[Vector2] = []
  # Current patrol mode
  @export var mode: PatrolMode = PatrolMode.BACK_AND_FORTH
  # Speed while patrolling
  @export var patrol_speed: float = 60.0
  # Wait time at each patrol point (seconds)
  @export var wait_time: float = 1.0
  # Whether to use global coordinates or local coordinates
  @export var use_global_coordinates: bool = true
  # Whether the enemy should flip when changing direction
  @export var flip_on_direction_change: bool = true
  # Flip method (sprite or node)
  @export var flip_method: String = "sprite" # "sprite" or "node"
  # Whether patrol is currently active
  @export var is_active: bool = true
  
  # Reference to the owner character
  var character = null
  # Current target patrol point index
  var current_point_index: int = 0
  # Direction of travel for back-and-forth mode (1 = forwards, -1 = backwards)
  var travel_direction: int = 1
  # Whether we're currently waiting at a patrol point
  var is_waiting: bool = false
  # Wait timer
  var wait_timer: float = 0.0
  # Path to the animated sprite (if not direct child)
  @export var animated_sprite_path: String = "AnimatedSprite2D"
  # Animation to play while patrolling
  @export var patrol_animation: String = "walk"
  
  # Signals
  signal point_reached(point_index)
  signal patrol_completed()
  signal direction_changed(new_direction)
  
  func _ready():
  	# Get the owner character (parent node)
  	character = get_parent()
  
  	# Initialize with first patrol point if available
  	if patrol_points.size() > 0:
  		current_point_index = 0
  	else:
  		# Add the character's current position as the first patrol point
  		if use_global_coordinates:
  			patrol_points.append(character.global_position)
  		else:
  			patrol_points.append(character.position)
  
  func _physics_process(delta):
  	if not is_active or patrol_points.size() < 2:
  		return
  
  	if is_waiting:
  		# Handle waiting at patrol points
  		wait_timer -= delta
  		if wait_timer <= 0:
  			is_waiting = false
  			_move_to_next_point()
  		return
  
  	# Get current target point
  	var target_position = patrol_points[current_point_index]
  	if use_global_coordinates:
  		target_position = target_position
  
  	# Get current position
  	var current_position = character.global_position if use_global_coordinates else character.position
  
  	# Check if we've reached the target point
  	var distance_to_target = current_position.distance_to(target_position)
  	if distance_to_target < 10.0:  # Within 10 pixels considered as "reached"
  		_on_point_reached()
  		return
  
  	# Move towards the target point
  	var direction = (target_position - current_position).normalized()
  
  	# Apply movement
  	if "velocity" in character:
  		character.velocity.x = direction.x * patrol_speed
  
  	# Handle animation and flipping
  	_update_animation(direction)
  
  ## Start patrolling
  func start():
  	is_active = true
  	is_waiting = false
  
  ## Stop patrolling
  func stop():
  	is_active = false
  	if "velocity" in character:
  		character.velocity.x = 0
  
  ## Add a new patrol point
  func add_patrol_point(point: Vector2):
  	patrol_points.append(point)
  
  ## Clear all patrol points
  func clear_patrol_points():
  	patrol_points.clear()
  	current_point_index = 0
  
  ## Set new patrol points
  func set_patrol_points(points: Array[Vector2]):
  	patrol_points = points
  	current_point_index = 0
  
  ## Set the patrol mode
  func set_patrol_mode(new_mode: PatrolMode):
  	mode = new_mode
  
  ## Get the current patrol target position
  func get_current_target() -> Vector2:
  	if patrol_points.size() > current_point_index:
  		return patrol_points[current_point_index]
  	return Vector2.ZERO
  
  ## Called when a patrol point is reached
  func _on_point_reached():
  	emit_signal("point_reached", current_point_index)
  
  	# Start waiting
  	is_waiting = true
  	wait_timer = wait_time
  
  	# Stop horizontal movement
  	if "velocity" in character:
  		character.velocity.x = 0
  
  ## Move to the next patrol point based on the patrol mode
  func _move_to_next_point():
  	match mode:
  		PatrolMode.BACK_AND_FORTH:
  			# Change direction at endpoints
  			if current_point_index == patrol_points.size() - 1:
  				travel_direction = -1
  				emit_signal("direction_changed", travel_direction)
  			elif current_point_index == 0:
  				travel_direction = 1
  				emit_signal("direction_changed", travel_direction)
  
  			current_point_index += travel_direction
  
  		PatrolMode.LOOP:
  			# Move to next point, wrap around to beginning
  			current_point_index = (current_point_index + 1) % patrol_points.size()
  
  			if current_point_index == 0:
  				emit_signal("patrol_completed")
  
  		PatrolMode.RANDOM:
  			# Choose a random point different from the current one
  			var new_index = current_point_index
  			while new_index == current_point_index and patrol_points.size() > 1:
  				new_index = randi() % patrol_points.size()
  			current_point_index = new_index
  
  ## Update character animation and direction based on movement
  func _update_animation(direction: Vector2):
  	# Play patrol animation
  	if character.has_method("play_animation"):
  		character.play_animation(patrol_animation)
  
  	# Handle flipping
  	if flip_on_direction_change:
  		var sprite = null
  
  		if flip_method == "sprite":
  			sprite = character.get_node_or_null(animated_sprite_path)
  			if sprite and "flip_h" in sprite:
  				sprite.flip_h = direction.x < 0
  		elif flip_method == "node":
  			# Flip the entire character node
  			character.scale.x = abs(character.scale.x) * sign(direction.x)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\enemies\goblin_archer.gd:
========================================
  class_name GoblinArcher
  extends BaseEnemy
  
  ## Goblin Archer - Ranged enemy that attacks with arrows/rocks
  
  @export var projectile_scene: PackedScene
  @export var quiver_size: int = 5  # How many arrows before needing to reload
  @export var reload_time: float = 1.5
  @export var attack_delay: float = 0.5  # Time before arrow is fired after attack animation starts
  
  var arrows_remaining: int
  var is_reloading: bool = false
  
  func _ready():
  	# Set base enemy properties
  	max_health = 70.0
  	speed = 60.0
  	chase_speed = 80.0
  	attack_damage = 8.0
  	attack_cooldown = 0.7
  
  	# Initialize archer specific properties
  	arrows_remaining = quiver_size
  
  	# Set references
  	animated_sprite = $AnimatedSprite2D
  	collision_shape = $CollisionShape2D
  
  	# Call parent ready method
  	super._ready()
  
  func attack():
  	if is_dead or not can_attack or not target or is_reloading:
  		return
  
  	# Check if we need to reload
  	if arrows_remaining <= 0:
  		reload()
  		return
  
  	is_attacking = true
  	can_attack = false
  	velocity.x = 0
  
  	play_animation("attack")
  
  	# Wait for the right animation frame to spawn projectile
  	await get_tree().create_timer(attack_delay).timeout
  
  	# Spawn projectile if we still have a target
  	if target and not is_dead:
  		spawn_projectile()
  		arrows_remaining -= 1
  
  	# Wait for animation to finish
  	await animated_sprite.animation_finished
  
  	is_attacking = false
  
  	# Start cooldown
  	await get_tree().create_timer(attack_cooldown).timeout
  	can_attack = true
  
  func reload():
  	is_reloading = true
  
  	# Play reload animation if available, otherwise just idle
  	if animated_sprite.sprite_frames.has_animation("reload"):
  		play_animation("reload")
  	else:
  		play_animation("idle")
  
  	# Wait for reload time
  	await get_tree().create_timer(reload_time).timeout
  
  	# Refill quiver
  	arrows_remaining = quiver_size
  	is_reloading = false
  
  func spawn_projectile():
  	# Make sure we have a projectile scene
  	if not projectile_scene:
  		projectile_scene = load("res://scenes/core/projectiles/rock.tscn")
  
  	# Create projectile instance
  	var instance = projectile_scene.instantiate()
  
  	# Get direction to target
  	var direction = (target.global_position - global_position).normalized()
  
  	# Setup the projectile
  	if instance is BaseProjectile:
  		instance.setup(
  			direction,
  			global_position,
  			global_rotation,
  			self
  		)
  	else:
  		# Legacy fallback for existing implementation
  		instance.direction = direction
  		instance.spawn_position = global_position
  		instance.spawn_rotation = global_rotation
  
  	# Add projectile to the main scene
  	var main = get_node("../../")
  	main.add_child(instance)
  
  # Connection to detection radius (override parent implementation)
  func _on_detection_radius_3_body_entered(body):
  	if body.name == "Player" and not is_dead:
  		chase_target(body)
  
  func _on_detection_radius_3_body_exited(body):
  	if body.name == "Player":
  		stop_chase()
  
  # Connection to attack zone (override parent implementation)
  func _on_attack_radius_3_body_entered(body):
  	if body.name == "Player":
  		is_chasing = false
  		attack()
  
  		# Setup continuous attack if in range
  		var attack_timer = func():
  			while is_attacking == false and can_attack and not is_dead and body and is_instance_valid(body):
  				attack()
  				await get_tree().create_timer(0.1).timeout
  
  		attack_timer.call()
  
  func _on_attack_radius_3_body_exited(body):
  	if body.name == "Player":
  		is_chasing = true
  		chase_target(body)
  
  # Connection to death zone (override parent implementation)
  func _on_death_radius_3_body_entered(body):
  	if body.name == "Player":
  		take_damage(current_health)  # Instant death

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\enemies\goblin_mage.gd:
========================================
  class_name GoblinMage
  extends BaseEnemy
  
  ## Goblin Mage - Ranged magical enemy that attacks with spell projectiles
  
  @export var projectile_scene: PackedScene
  @export var mana: float = 100.0
  @export var mana_regen_rate: float = 5.0
  @export var spell_mana_cost: float = 20.0
  @export var attack_delay: float = 1.0
  
  var current_mana: float
  var can_cast: bool = true
  
  func _ready():
  	# Set base enemy properties
  	max_health = 60.0
  	speed = 40.0
  	chase_speed = 50.0
  	attack_damage = 15.0
  	attack_cooldown = 3.0
  
  	# Initialize goblin mage specific properties
  	current_mana = mana
  
  	# Set references
  	animated_sprite = $AnimatedSprite2D
  	collision_shape = $CollisionShape2D
  
  	# Call parent ready method
  	super._ready()
  
  func _process(delta):
  	# Regenerate mana
  	if current_mana < mana:
  		current_mana = min(current_mana + mana_regen_rate * delta, mana)
  
  func attack():
  	if is_dead or not can_attack or not target or current_mana < spell_mana_cost:
  		return
  
  	is_attacking = true
  	can_attack = false
  	velocity.x = 0
  
  	play_animation("attack")
  
  	# Wait for the right animation frame to spawn projectile
  	await get_tree().create_timer(attack_delay).timeout
  
  	# Spawn projectile if we still have a target
  	if target and not is_dead:
  		spawn_projectile()
  
  	# Wait for animation to finish
  	await animated_sprite.animation_finished
  
  	is_attacking = false
  
  	# Start cooldown
  	await get_tree().create_timer(attack_cooldown).timeout
  	can_attack = true
  
  func spawn_projectile():
  	# Make sure we have a projectile scene
  	if not projectile_scene:
  		projectile_scene = load("res://scenes/core/projectiles/mage_ball.tscn")
  
  	# Create projectile instance
  	var instance = projectile_scene.instantiate()
  
  	# Get direction to target
  	var direction = (target.global_position - global_position).normalized()
  
  	# Setup the projectile
  	if instance is BaseProjectile:
  		instance.setup(
  			direction,
  			global_position,
  			global_rotation,
  			self
  		)
  	else:
  		# Legacy fallback for existing implementation
  		instance.direction = direction
  		instance.spawn_position = global_position
  		instance.spawn_rotation = global_rotation
  
  	# Add projectile to the main scene
  	var main = get_node("../../")
  	main.add_child(instance)
  
  	# Consume mana
  	current_mana -= spell_mana_cost
  
  # Connection to detection radius (override parent implementation)
  func _on_detection_radius_2_body_entered(body):
  	if body.name == "Player" and not is_dead:
  		chase_target(body)
  
  func _on_detection_radius_2_body_exited(body):
  	if body.name == "Player":
  		stop_chase()
  
  # Connection to attack zone (override parent implementation)
  func _on_attackzone_2_body_entered(body):
  	if body.name == "Player":
  		is_chasing = false
  		attack()
  
  func _on_attackzone_2_body_exited(body):
  	if body.name == "Player":
  		is_chasing = true
  		chase_target(body)
  
  # Connection to death zone (override parent implementation)
  func _on_death_zone_2_body_entered(body):
  	if body.name == "Player":
  		take_damage(current_health)  # Instant death

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\enemies\goblin_melee.gd:
========================================
  class_name GoblinMelee
  extends BaseEnemy
  
  ## Goblin Melee - Close combat enemy that attacks directly
  
  @export var rage_threshold: float = 0.3  # Percentage of health that triggers rage mode
  @export var rage_speed_multiplier: float = 1.5
  @export var rage_damage_multiplier: float = 1.2
  
  var is_enraged: bool = false
  var base_speed: float
  var base_chase_speed: float
  var base_attack_damage: float
  
  func _ready():
  	# Set base enemy properties
  	max_health = 100.0
  	speed = 80.0
  	chase_speed = 100.0
  	attack_damage = 20.0
  	attack_cooldown = 1.0
  
  	# Store base values for rage mode
  	base_speed = speed
  	base_chase_speed = chase_speed
  	base_attack_damage = attack_damage
  
  	# Set references
  	animated_sprite = $AnimatedSprite2D
  	collision_shape = $CollisionShape2D
  
  	# Call parent ready method
  	super._ready()
  
  func take_damage(amount):
  	super.take_damage(amount)
  
  	# Check if we should enter rage mode
  	if not is_enraged and current_health <= max_health * rage_threshold:
  		enter_rage_mode()
  
  func enter_rage_mode():
  	is_enraged = true
  
  	# Increase stats
  	speed = base_speed * rage_speed_multiplier
  	chase_speed = base_chase_speed * rage_speed_multiplier
  	attack_damage = base_attack_damage * rage_damage_multiplier
  
  	# Visual indication of rage if available
  	if animated_sprite.sprite_frames.has_animation("rage"):
  		animated_sprite.play("rage")
  
  	# Play a sound if available
  	if has_node("AudioStreamPlayer"):
  		var audio = get_node("AudioStreamPlayer")
  		audio.play()
  
  func attack():
  	if is_dead or not can_attack or not target:
  		return
  
  	is_attacking = true
  	can_attack = false
  	velocity.x = 0
  
  	# Use rage attack animation if available and enraged
  	if is_enraged and animated_sprite.sprite_frames.has_animation("rage_attack"):
  		play_animation("rage_attack")
  	else:
  		play_animation("attack")
  
  	# Apply damage to player
  	if target.has_method("take_damage"):
  		target.take_damage(attack_damage)
  
  	# Update HUD
  	if hud and hud.has_method("change_life"):
  		hud.change_life(-attack_damage/100.0)  # Assuming health is on 0-1 scale for HUD
  
  	# Wait for animation to finish
  	await animated_sprite.animation_finished
  
  	is_attacking = false
  
  	# Start cooldown
  	await get_tree().create_timer(attack_cooldown).timeout
  	can_attack = true
  
  # Connection to detection radius (override parent implementation)
  func _on_detection_radius_body_entered(body):
  	if body.name == "Player" and not is_dead:
  		chase_target(body)
  
  func _on_detection_radius_body_exited(body):
  	if body.name == "Player":
  		stop_chase()
  
  # Connection to attack zone (override parent implementation)
  func _on_attackzone_body_entered(body):
  	if body.name == "Player":
  		is_chasing = false
  		attack()
  
  func _on_attackzone_body_exited(body):
  	if body.name == "Player":
  		is_chasing = true
  		chase_target(body)
  
  # Connection to death zone (override parent implementation)
  func _on_deathzone_body_entered(body):
  	if body.name == "Player":
  		take_damage(current_health)  # Instant death

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\enemies\prince_enemy.gd:
========================================
  class_name PrinceEnemy
  extends BaseEnemy
  
  ## Simple patrol enemy that walks back and forth (used in prince levels)
  
  @export var direction: int = 1  # 1 = right, -1 = left
  @export var damage_on_touch: float = 10.0  # Damage dealt when touching player
  
  @onready var ray_cast_right: RayCast2D = $RayCastRight
  @onready var ray_cast_left: RayCast2D = $RayCastLeft
  
  var start_position: Vector2
  var is_patrolling: bool = true
  
  func _ready():
  	# Set base enemy properties
  	max_health = 40.0
  	speed = 60.0
  	chase_speed = speed  # Same as normal speed since this enemy doesn't chase
  	attack_damage = damage_on_touch
  
  	# Set references
  	animated_sprite = $AnimatedSprite2D
  	collision_shape = $CollisionShape2D
  
  	# Store starting position
  	start_position = global_position
  
  	# Initialize raycasts if not already set
  	if not ray_cast_right:
  		ray_cast_right = $RayCastRight if has_node("RayCastRight") else null
  
  	if not ray_cast_left:
  		ray_cast_left = $RayCastLeft if has_node("RayCastLeft") else null
  
  	# Call parent ready method
  	super._ready()
  
  	# Start patrol behavior
  	play_animation("walk")
  
  func _physics_process(delta):
  	# Call parent implementation for gravity and movement
  	super._physics_process(delta)
  
  	# Handle patrol logic if not chasing or attacking
  	if is_patrolling and not is_dead:
  		patrol()
  
  func patrol():
  	# Check wall collisions
  	if ray_cast_right and ray_cast_right.is_colliding():
  		direction = -1
  		animated_sprite.flip_h = false
  	elif ray_cast_left and ray_cast_left.is_colliding():
  		direction = 1
  		animated_sprite.flip_h = true
  
  	# Set movement velocity
  	velocity.x = direction * speed
  
  	# Play walk animation
  	play_animation("walk")
  
  # Override to handle damage-on-touch behavior
  func _on_body_entered(body):
  	if body.name == "Player" and not is_dead:
  		# Deal damage to player
  		if body.has_method("take_damage"):
  			body.take_damage(damage_on_touch)
  
  		# Update HUD
  		if hud and hud.has_method("change_life"):
  			hud.change_life(-damage_on_touch/100.0)  # Assuming health is on 0-1 scale for HUD

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\items\coins.gd:
========================================
  class_name Coins
  extends Area2D
  
  signal coin_collected
  
  
  
  func _on_coins_body_entered(body):
  	get_parent().get_node("HUD").coin_collected()
  	$AnimationPlayer.play("bounce")
  	set_collision_mask_value(1,false)
  
  
  func _on_animation_player_animation_finished(anim_name):
  	queue_free()

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\items\elixir.gd:
========================================
  class_name Elixir
  extends BasePowerUp
  
  ## Power-up that gives the player temporary flying ability via a magical elixir
  
  func _ready():
  	# Set power-up properties
  	power_up_name = "Magic Elixir"
  	description = "Grants temporary flying ability"
  	effect_duration = 20.0  # 20 seconds of flight
  	destroy_on_pickup = true
  
  	# Set animation properties (optional: tweak to differentiate visually from Angel Wings)
  	bounce_height = 6.0
  	bounce_speed = 2.0
  	rotation_speed = 1.0
  
  	# Call parent ready method
  	super._ready()
  
  func apply_effect(player):
  	# Call the parent implementation for signals
  	super.apply_effect(player)
  
  	# Set the player's movement mode
  	if player.has_method("set_movement_mode"):
  		player.set_movement_mode("fly")
  	else:
  		player.mode = "fly"
  
  	print("Player gained flight ability via Elixir")
  
  	# Update the Elixir fill in HUD
  	var hud = get_tree().get_root().find_child("HUD", true, false)
  	if hud:
  		hud.collect_softpower()  # This will add 25% elixir
  
  	# Show notification to player
  	var popup_manager = get_node_or_null("/root/PopupManager")
  	if popup_manager:
  		popup_manager.info("Elixir Power", "You've drunk the magic elixir! You can fly for " + str(effect_duration) + " seconds.")
  
  	# Add a visible timer to the HUD if available
  	if hud and hud.has_method("show_ability_timer"):
  		hud.show_ability_timer("Flight", effect_duration)
  
  func remove_effect(player):
  	# Set the player's movement mode back to normal
  	if player.has_method("set_movement_mode"):
  		player.set_movement_mode("normal")
  	else:
  		player.mode = "normal"
  
  	player.passed_fly_time = 0.0
  
  	# Let the player know the effect has ended
  	var popup_manager = get_node_or_null("/root/PopupManager")
  	if popup_manager:
  		popup_manager.info("Elixir Expired", "The elixir's magic has worn off. You can't fly anymore.")
  
  	super.remove_effect(player)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\items\power_attack.gd:
========================================
  class_name PowerAttack
  extends BasePowerUp
  
  ## Power-up that gives the player an axe attack ability
  
  func _ready():
  	# Set power-up properties
  	power_up_name = "Battle Axe"
  	description = "Grants the ability to attack with a powerful axe"
  	destroy_on_pickup = true
  
  	# Set animation properties
  	bounce_height = 5.0
  	bounce_speed = 2.0
  	rotation_speed = 1.0
  
  	# Call parent ready method
  	super._ready()
  
  func apply_effect(player):
  	# Call the parent implementation for signals
  	super.apply_effect(player)
  
  	# Set the player's attack animation
  	if player.has_method("set_attack_animation"):
  		player.set_attack_animation("walking6")
  	else:
  		# Fallback for current implementation
  		player.attack_animation = "walking6"
  
  	# Enable attack ability if player has the method
  	if player.has_method("enable_attack"):
  		player.enable_attack(true)
  
  	print("Player gained axe attack ability")
  
  	# Show notification to player
  	var popup_manager = get_node_or_null("/root/PopupManager")
  	if popup_manager:
  		popup_manager.info("New Ability", "You've acquired a battle axe! Press the attack button to use it.")

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\items\power_fly.gd:
========================================
  class_name PowerFly
  extends BasePowerUp
  
  ## Power-up that gives the player temporary flying ability
  
  func _ready():
  	# Set power-up properties
  	power_up_name = "Angel Wings"
  	description = "Grants temporary flying ability"
  	effect_duration = 20.0  # 20 seconds of flight
  	destroy_on_pickup = true
  
  	# Set animation properties
  	bounce_height = 8.0
  	bounce_speed = 1.5
  	rotation_speed = 0.5
  
  	# Call parent ready method
  	super._ready()
  
  func apply_effect(player):
  	# Call the parent implementation for signals
  	super.apply_effect(player)
  
  	# Set the player's movement mode
  	if player.has_method("set_movement_mode"):
  		player.set_movement_mode("fly")
  	else:
  		# Fallback for current implementation
  		player.mode = "fly"
  
  	print("Player gained flight ability")
  
  	# Show notification to player
  	var popup_manager = get_node_or_null("/root/PopupManager")
  	if popup_manager:
  		popup_manager.info("New Ability", "You've acquired angel wings! You can now fly for " + str(effect_duration) + " seconds.")
  
  	# Add a visible timer to the HUD if available
  	var hud = get_node_or_null("../../HUD")
  	if hud and hud.has_method("show_ability_timer"):
  		hud.show_ability_timer("Flight", effect_duration)
  
  func remove_effect(player):
  	# Set the player's movement mode back to normal
  	if player.has_method("set_movement_mode"):
  		player.set_movement_mode("normal")
  	else:
  		# Fallback for current implementation
  		player.mode = "normal"
  
  	# Reset player's flight timer
  	player.passed_fly_time = 0.0
  
  	# Let the player know the effect has ended
  	var popup_manager = get_node_or_null("/root/PopupManager")
  	if popup_manager:
  		popup_manager.info("Ability Expired", "Your angel wings have disappeared.")
  
  	# Call the parent implementation for signals
  	super.remove_effect(player)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\items\power_jump.gd:
========================================
  class_name PowerJump
  extends BasePowerUp
  
  ## Power-up that gives the player double jump ability
  
  @export var extra_jumps: int = 1  # How many extra jumps to grant
  
  func _ready():
  	# Set power-up properties
  	power_up_name = "Feather Boots"
  	description = "Grants the ability to double jump"
  	destroy_on_pickup = true
  
  	# Set animation properties
  	bounce_height = 10.0
  	bounce_speed = 3.0
  	rotation_speed = 0.0
  
  	# Call parent ready method
  	super._ready()
  
  func apply_effect(player):
  	# Call the parent implementation for signals
  	super.apply_effect(player)
  
  	# Increase player's allowed jumps
  	if player.has_method("add_extra_jumps"):
  		player.add_extra_jumps(extra_jumps)
  	else:
  		# Fallback for current implementation
  		player.allowed_jumps += extra_jumps
  
  	# Set the player's movement mode to normal (in case they were flying)
  	if player.has_method("set_movement_mode"):
  		player.set_movement_mode("normal")
  	else:
  		# Fallback for current implementation
  		player.mode = "normal"
  
  	print("Player gained double jump ability")
  
  	# Show notification to player
  	var popup_manager = get_node_or_null("/root/PopupManager")
  	if popup_manager:
  		if extra_jumps == 1:
  			popup_manager.info("New Ability", "You've acquired Feather Boots! You can now double jump in mid-air.")
  		else:
  			popup_manager.info("New Ability", "You've acquired Feather Boots! You can now perform " + str(extra_jumps + 1) + " jumps in a row.")

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\projectiles\mage_ball.gd:
========================================
  class_name MageBall
  extends BaseProjectile
  
  ## Magical projectile used by mage enemies
  ## Now supports object pooling
  
  @export var particle_effect: PackedScene
  @export var hit_sound: AudioStream
  var particles_list = []  # To track spawned particles for cleanup
  
  func _ready():
  	# Set projectile properties
  	speed = 50.0
  	damage = 10.0
  	lifetime = 5.0
  	gravity_affected = false
  
  	# Call parent ready method
  	super._ready()
  
  	# Set up animation
  	if has_node("Ball"):
  		$Ball.play("flying")
  
  func _physics_process(delta):
  	# Implement base projectile physics
  	super._physics_process(delta)
  
  	# Add magical effect (optional particle trail)
  	if particle_effect and randf() < 0.3 and visible:  # 30% chance per frame
  		var particles = particle_effect.instantiate()
  		particles.global_position = global_position
  		get_tree().current_scene.add_child(particles)
  		particles.emitting = true
  
  		# Track spawned particles for cleanup
  		particles_list.append(particles)
  
  		# Auto-remove particles after their lifetime
  		get_tree().create_timer(particles.lifetime).timeout.connect(func():
  			if is_instance_valid(particles):
  				particles.queue_free()
  				particles_list.erase(particles)
  		)
  
  func _on_hit_player(player):
  	# Call parent implementation
  	super._on_hit_player(player)
  
  	# Add magical effect (status effect, screen shake, etc.)
  	var hud = get_node_or_null("../HUD")
  	if hud and hud.has_method("change_life"):
  		hud.change_life(-damage/100.0)  # Assuming HUD uses 0-1 scale
  
  	# Play hit sound
  	if hit_sound:
  		var audio_player = AudioStreamPlayer.new()
  		audio_player.stream = hit_sound
  		audio_player.volume_db = -10.0
  		get_tree().current_scene.add_child(audio_player)
  		audio_player.play()
  
  		# Auto-remove audio player after sound finishes
  		audio_player.finished.connect(func():
  			audio_player.queue_free()
  		)
  
  # Override to clean up particles when recycled
  func _on_recycle_to_pool():
  	super._on_recycle_to_pool()
  
  	# Clean up any remaining particle effects
  	for particle in particles_list:
  		if is_instance_valid(particle):
  			particle.queue_free()
  
  	particles_list.clear()
  
  # Connect the hit zone to our hit methods if we have one
  func _on_hit_zone_body_entered(body):
  	if body.name == "Player":
  		_on_hit_player(body)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\projectiles\rock.gd:
========================================
  class_name Rock
  extends BaseProjectile
  
  ## Rock projectile used by archer enemies
  ## Now supports object pooling
  
  @export var bounce_count: int = 1  # How many times the rock can bounce
  @export var hit_sound: AudioStream
  
  var bounces_remaining: int = 0
  
  func _ready():
  	# Set projectile properties
  	speed = 120.0
  	damage = 8.0
  	lifetime = 5.0
  	gravity_affected = true
  	bounce = true
  	bounce_factor = 0.6
  
  	# Set remaining bounces
  	bounces_remaining = bounce_count
  
  	# Call parent ready method
  	super._ready()
  
  	# Set up animation
  	if has_node("rock"):
  		$rock.play("flying")
  
  func setup(dir: Vector2, spawn_pos: Vector2, spawn_rot: float = 0.0, source = null):
  	# Call parent setup
  	super.setup(dir, spawn_pos, spawn_rot, source)
  
  	# Reset bounce count
  	bounces_remaining = bounce_count
  
  	return self
  
  func _on_collision(collision):
  	var collider = collision.get_collider()
  
  	# Check if we should bounce
  	if bounce and bounces_remaining > 0 and not collider.is_in_group("Player") and not collider.is_in_group("Enemy"):
  		bounces_remaining -= 1
  
  		var reflection = collision.get_remainder().bounce(collision.get_normal())
  		velocity = velocity.bounce(collision.get_normal()) * bounce_factor
  		global_position += reflection
  
  		# Play bounce sound if available
  		if hit_sound:
  			var audio_player = AudioStreamPlayer.new()
  			audio_player.stream = hit_sound
  			audio_player.volume_db = -15.0
  			get_tree().current_scene.add_child(audio_player)
  			audio_player.play()
  
  			# Auto-remove audio player after sound finishes
  			audio_player.finished.connect(func():
  				audio_player.queue_free()
  			)
  
  		return
  
  	# If no more bounces or hit player/enemy, use default behavior
  	has_hit = true
  
  	# Handle different collision types
  	if collider.is_in_group("Player") and source_node != collider:
  		_on_hit_player(collider)
  	elif collider.is_in_group("Enemy") and source_node != collider:
  		_on_hit_enemy(collider)
  	else:
  		_on_hit_environment(collider)
  
  func _on_hit_player(player):
  	# Call parent implementation
  	super._on_hit_player(player)
  
  	# Update HUD
  	var hud = get_node_or_null("../HUD")
  	if hud and hud.has_method("change_life"):
  		hud.change_life(-damage/100.0)  # Assuming HUD uses 0-1 scale
  
  # Reset state when recycled to pool
  func _on_recycle_to_pool():
  	super._on_recycle_to_pool()
  
  	# Reset bounce count
  	bounces_remaining = bounce_count
  
  # Connect the hit zone to our hit methods if we have one
  func _on_hit_zone_body_entered(body):
  	if body.name == "Player":
  		_on_hit_player(body)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\enemy_states\enemy_idle_state.gd:
========================================
  class_name EnemyIdleState
  extends State
  
  ## Enemy idle state - when the enemy is standing still
  
  @export var idle_animation: String = "idle"
  @export var idle_min_time: float = 1.0
  @export var idle_max_time: float = 3.0
  
  var idle_timer: float = 0.0
  var idle_duration: float = 0.0
  var target = null
  
  func enter():
  	# Play idle animation
  	play_animation(idle_animation)
  
  	# Reset horizontal velocity
  	var velocity = get_velocity()
  	velocity.x = 0
  	set_velocity(velocity)
  
  	# Set random idle duration
  	idle_duration = randf_range(idle_min_time, idle_max_time)
  	idle_timer = 0.0
  
  func physics_process(delta: float):
  	# Apply gravity
  	var velocity = get_velocity()
  	var gravity = owner_node.get_gravity() if owner_node.has_method("get_gravity") else 980.0
  
  	velocity.y += gravity * delta
  	set_velocity(velocity)
  
  	# Handle movement for character body
  	if owner_node.has_method("move_and_slide"):
  		owner_node.move_and_slide()
  
  	# Update idle timer
  	idle_timer += delta
  
  func get_next_state() -> String:
  	# Check if there's a player in detection range
  	target = get_owner_property("target")
  	if target != null:
  		return "Chase"
  
  	# Check if idle time has elapsed - transition to patrol
  	if idle_timer >= idle_duration:
  		return "Patrol"
  
  	# No transition, stay in idle
  	return ""
  
  # Used by enemies to find nearby player
  func check_for_player():
  	var detection_radius = get_owner_property("detection_radius")
  	if not detection_radius:
  		return null
  
  	var space_state = owner_node.get_world_2d().direct_space_state
  	var player_detection_shape = CircleShape2D.new()
  	player_detection_shape.radius = detection_radius
  
  	var query = PhysicsShapeQueryParameters2D.new()
  	query.set_shape(player_detection_shape)
  	query.transform = Transform2D(0, owner_node.global_position)
  	query.collision_mask = 1  # Player layer
  
  	var results = space_state.intersect_shape(query)
  
  	for result in results:
  		var collider = result.collider
  		if collider.name == "Player":
  			return collider
  
  	return null

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\player_states\player_attack_state.gd:
========================================
  class_name PlayerAttackState
  extends PlayerBaseState
  
  var attack_timer: float = 0.0
  var attack_duration: float = 0.5  # Duration of the attack animation
  
  func enter():
      player.current_animation = player.attack_animation
      player.play_attack_animation = true
      attack_timer = 0.0
  
      # Optionally play attack sound
      # if player.has_node("AttackSound"):
      #     player.get_node("AttackSound").play()
  
  func physics_process(delta: float):
      # Apply gravity
      var velocity = get_velocity()
      velocity.y += player.GRAVITY * delta
  
      # Reduce movement during attack (optional)
      velocity.x = move_toward(velocity.x, 0, 20)
  
      set_velocity(velocity)
  
      # Handle movement for character body
      player.move_and_slide()
  
      # Update attack timer
      attack_timer += delta
  
      # Update outfit
      update_outfit()
  
  func get_next_state() -> String:
      # Check state transitions
      var life_state = check_life()
      if life_state:
          return life_state
  
      # Return to appropriate state after attack finishes
      if attack_timer >= attack_duration:
          player.play_attack_animation = false
  
          if player.is_on_floor():
              var x_input = Input.get_axis("left", "right")
              if x_input != 0:
                  return "PlayerWalkState"
              else:
                  return "PlayerIdleState"
          else:
              return "PlayerFallState"
  
      # Stay in attack state
      return ""
  
  func handle_input(event: InputEvent):
      check_menu_input(event)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\player_states\player_base_state.gd:
========================================
  class_name PlayerBaseState
  extends State
  
  # Base functions shared by all player states
  var player: Player
  
  func _ready():
  	# Set player reference during initialization
  	player = owner_node as Player
  
  # Function to update the outfit based on the current state
  func update_outfit():
  	var player_outfit = player.player_outfit
  	var player_animations = player.player_animations
  	var current_animation = player.current_animation
  
  	for outfit in player_outfit:
  		var animated_sprite = player.get_node("character_sprites/" + outfit)
  		var selected_outfit = player_outfit[outfit]
  
  		if str(selected_outfit) == "none":
  			animated_sprite.visible = false
  		else:
  			animated_sprite.visible = true
  			animated_sprite.play(str(selected_outfit))
  			animated_sprite.speed_scale = 2.0
  
  			# Set direction based on movement
  			var x_input = Input.get_axis("left", "right")
  			if x_input != 0:
  				animated_sprite.flip_h = x_input > 0
  
  			# Frame management
  			if current_animation in player_animations:
  				if animated_sprite.frame < player_animations[current_animation][0] or animated_sprite.frame >= player_animations[current_animation][-1]:
  					animated_sprite.frame = player_animations[current_animation][0]
  
  # Function to check life and handle death
  func check_life():
  	# Check for player health in the HUD
  	if player.hud:
  		var health_value = 0
  
  		# Try to get health using the current API or the legacy API
  		if "current_health" in player.hud:
  			health_value = player.hud.current_health
  		elif "lifes" in player.hud:
  			health_value = player.hud.lifes
  
  		if health_value <= 0:
  			return "PlayerDeathState"
  
  	return ""
  
  # Function to check menu input
  func check_menu_input(event):
  	if event is InputEvent and event.is_action_pressed("Menu"):
  		get_tree().change_scene_to_file("res://scenes/ui/main_menu/main_menu.tscn")
  		if player.has_method("save_settings"):
  			player.save_settings()

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\player_states\player_death_state.gd:
========================================
  class_name PlayerDeathState
  extends PlayerBaseState
  
  var death_timer: float = 0.0
  var death_duration: float = 1.5  # Duration before scene transition
  
  func enter():
      player.current_animation = "death"
      player.get_node("CollisionShape2D").disabled = true
      death_timer = 0.0
  
  func physics_process(delta: float):
      # Update death animation timer
      death_timer += delta
  
      # Update outfit
      update_outfit()
  
  func get_next_state() -> String:
      # Scene transition after death animation
      if death_timer >= death_duration:
          player.queue_free()
          get_tree().change_scene_to_file("res://scenes/ui/main_menu/main_menu.tscn")
  
      # Stay in death state
      return ""

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\player_states\player_fall_state.gd:
========================================
  class_name PlayerFallState
  extends PlayerBaseState
  
  func enter():
  	# player.current_animation = "idle"  # You may want a falling animation
  
  	# Mark as not ready for jump
  	if player.jump_counter == 0:
  		player.ready_for_jump = false
  
  func physics_process(delta: float):
  	# Apply gravity
  	var velocity = get_velocity()
  	velocity.y += player.GRAVITY * delta
  
  	# Read the input
  	var x_input = Input.get_axis("left", "right")
  	var y_input = Input.get_axis("down", "up")
  
  	# Apply horizontal movement
  	if x_input != 0:
  		velocity.x = x_input * player.SPEED
  		player.current_animation = "walking"
  	else:
  		velocity.x = move_toward(velocity.x, 0, 30)
  
  	# Check for double jump if allowed
  	if y_input > 0.4 && player.jump_counter < player.allowed_jumps && player.ready_for_jump:
  		velocity.y = player.JUMP_VELOCITY * y_input
  		player.jump_counter += 1
  		player.ready_for_jump = false
  	elif y_input < 0.4:
  		player.ready_for_jump = true
  
  	set_velocity(velocity)
  
  	# Handle movement for character body
  	player.move_and_slide()
  
  	# Update outfit
  	update_outfit()
  
  func get_next_state() -> String:
  	# Check state transitions
  	var life_state = check_life()
  	if life_state:
  		return life_state
  
  	# Check for attack input
  	if Input.is_action_just_pressed("attack"):
  		return "PlayerAttackState"
  
  	# Check for fly mode
  	if player.mode == "fly":
  		return "PlayerFlyState"
  
  	# Landing transition
  	if player.is_on_floor():
  		player.jump_counter = 0
  		player.ready_for_jump = true
  		player.passed_fly_time = 0.0
  
  		# Check if still moving
  		var x_input = Input.get_axis("left", "right")
  		if x_input != 0:
  			return "PlayerWalkState"
  		else:
  			return "PlayerIdleState"
  
  	# Double jump transition
  	var y_input = Input.get_axis("down", "up")
  	if y_input > 0.4 && player.jump_counter < player.allowed_jumps && player.ready_for_jump:
  		return "PlayerJumpState"
  
  	# Stay in fall state
  	return ""
  
  func handle_input(event: InputEvent):
  	check_menu_input(event)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\player_states\player_fly_state.gd:
========================================
  class_name PlayerFlyState
  extends PlayerBaseState
  
  var elixir_drain_timer: float = 0.0
  var drain_interval: float = 3.0  # Drain every 5 seconds
  var drain_amount: float = 0.25   # Drain 25% each time
  
  func enter():
  	player.current_animation = "idle"  # You may want a specific fly animation
  	elixir_drain_timer = 0.0  # Reset timer on state entry
  
  func physics_process(delta: float):
  	# Apply gravity
  	var velocity = get_velocity()
  	velocity.y += player.GRAVITY * delta
  
  	# Read inputs
  	var x_input = Input.get_axis("left", "right")
  	var y_input = Input.get_axis("down", "up")
  
  	# Apply horizontal movement
  	if x_input != 0:
  		velocity.x = x_input * player.SPEED
  	else:
  		velocity.x = move_toward(velocity.x, 0, 30)
  
  	# Update fly time counter
  	if player.passed_fly_time < 4:
  		player.passed_fly_time += delta
  		if y_input != 0:
  			velocity.y = player.FLY_VELOCITY * y_input
  
  	# Handle elixir drain
  	elixir_drain_timer += delta
  	if elixir_drain_timer >= drain_interval:
  		elixir_drain_timer = 0.0  # Reset timer
  		player.hud.use_softpower()
  
  	if player.hud.elixir_fill_level <= 0:
  		player.mode = "normal"
  
  
  
  	set_velocity(velocity)
  
  	# Handle movement for character body
  	player.move_and_slide()
  
  	# Update outfit
  	update_outfit()
  
  func get_next_state() -> String:
  	# Check state transitions
  	var life_state = check_life()
  	if life_state:
  		return life_state
  
  	# Check for attack input
  	if Input.is_action_just_pressed("attack"):
  		return "PlayerAttackState"
  
  	# Check elixir level - transition to fall if empty
  	if player.hud.elixir_fill_level <= 0:
  		player.passed_fly_time = 0.0  # Reset fly time
  		return "PlayerFallState"
  
  	# Landing transition
  	if player.is_on_floor():
  		player.jump_counter = 0
  		player.ready_for_jump = true
  		player.passed_fly_time = 0.0
  
  		# Check movement direction after landing
  		var x_input = Input.get_axis("left", "right")
  		if x_input != 0:
  			return "PlayerWalkState"
  		else:
  			return "PlayerIdleState"
  
  	# Time limit check
  	if player.passed_fly_time >= 4:
  		return "PlayerFallState"
  
  	# Stay in fly state
  	return ""
  
  func handle_input(event: InputEvent):
  	check_menu_input(event)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\player_states\player_hurt_state.gd:
========================================
  class_name PlayerHurtState
  extends PlayerBaseState

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\player_states\player_idle_state.gd:
========================================
  class_name PlayerIdleState
  extends PlayerBaseState
  
  func enter():
  	player.current_animation = "idle"
  	# Reset horizontal velocity
  	var velocity = get_velocity()
  	velocity.x = 0
  	set_velocity(velocity)
  
  	if player.debug_mode:
  		print("Entered Idle State")
  
  func physics_process(delta: float):
  	# Apply gravity
  	var velocity = get_velocity()
  	velocity.y += player.GRAVITY * delta
  	set_velocity(velocity)
  
  	# Handle movement for character body
  	player.move_and_slide()
  
  	# Update outfit
  	update_outfit()
  
  func get_next_state() -> String:
  	# Check for death
  	var life_state = check_life()
  	if life_state != "":
  		return life_state
  
  	# Check input for state transitions
  	var x_input = Input.get_axis("left", "right")
  	var y_input = Input.get_axis("down", "up")
  
  	# Check for attack
  	if Input.is_action_just_pressed("attack"):
  		return "PlayerAttackState"
  
  	# Check for movement
  	if x_input != 0:
  		return "PlayerWalkState"
  
  	# Check for jumping
  	if y_input > 0.4 and player.is_on_floor():
  		return "PlayerJumpState"
  
  	# Check for falling
  	if !player.is_on_floor():
  		return "PlayerFallState"
  
  	# No transition
  	return ""
  
  func handle_input(event: InputEvent):
  	check_menu_input(event)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\player_states\player_jump_state.gd:
========================================
  # Fix for player_jump_state.gd - Correct class name
  class_name PlayerJumpState
  extends PlayerBaseState
  
  func enter():
  	# player.current_animation = "idle"  # You may want to use a jump animation
  
  	# Apply initial jump velocity
  	var velocity = get_velocity()
  	var y_input = Input.get_axis("down", "up")
  	velocity.y = player.JUMP_VELOCITY * y_input
  	set_velocity(velocity)
  
  	# Update jump counter
  	player.jump_counter += 1
  	player.ready_for_jump = false
  
  	if player.debug_mode:
  		print("Entered Jump State")
  
  func physics_process(delta: float):
  	# Apply gravity
  	var velocity = get_velocity()
  	velocity.y += player.GRAVITY * delta
  
  	# Read horizontal input
  	var x_input = Input.get_axis("left", "right")
  
  	# Apply horizontal movement
  	if x_input != 0:
  		velocity.x = x_input * player.SPEED
  		player.current_animation = "walking"
  	else:
  		velocity.x = move_toward(velocity.x, 0, 30)
  
  	set_velocity(velocity)
  
  	# Handle movement for character body
  	player.move_and_slide()
  
  	# Reset jump readiness when input is released
  	var y_input = Input.get_axis("down", "up")
  	if y_input < 0.4:
  		player.ready_for_jump = true
  
  	# Update outfit
  	update_outfit()
  
  func get_next_state() -> String:
  	# Check state transitions
  	var life_state = check_life()
  	if life_state:
  		return life_state
  
  	# Check for attack input
  	if Input.is_action_just_pressed("attack"):
  		return "PlayerAttackState"
  
  	# Fly state transition
  	if player.mode == "fly":
  		return "PlayerFlyState"
  
  	# Landing transition
  	if player.is_on_floor():
  		player.jump_counter = 0
  		player.ready_for_jump = true
  
  		# Check if still moving
  		var x_input = Input.get_axis("left", "right")
  		if x_input != 0:
  			return "PlayerWalkState"
  		else:
  			return "PlayerIdleState"
  
  	# Falling transition
  	if get_velocity().y > 0:
  		return "PlayerFallState"
  
  	# Stay in jump state
  	return ""
  
  func handle_input(event: InputEvent):
  	check_menu_input(event)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\player_states\player_walk_state.gd:
========================================
  class_name PlayerWalkState
  extends PlayerBaseState
  
  func enter():
  	player.current_animation = "walking"  # Walk animation
  
  	if player.debug_mode:
  		print("Entered Walk State")
  
  func physics_process(delta: float):
  	# Apply gravity
  	var velocity = get_velocity()
  	velocity.y += player.GRAVITY * delta
  
  	# Read the input
  	var x_input = Input.get_axis("left", "right")
  
  	# Apply horizontal movement
  	if x_input != 0:
  		velocity.x = x_input * player.SPEED
  	else:
  		velocity.x = move_toward(velocity.x, 0, 30)
  
  	set_velocity(velocity)
  
  	# Handle movement for character body
  	player.move_and_slide()
  
  	# Update outfit
  	update_outfit()
  
  func get_next_state() -> String:
  	# Check for death
  	var life_state = check_life()
  	if life_state != "":
  		return life_state
  
  	# Check for attack
  	if Input.is_action_just_pressed("attack"):
  		return "PlayerAttackState"
  
  	# Read inputs
  	var x_input = Input.get_axis("left", "right")
  	var y_input = Input.get_axis("down", "up")
  
  	# Stop walking
  	if x_input == 0:
  		return "PlayerIdleState"
  
  	# Jump while moving
  	if y_input > 0.4 and player.is_on_floor():
  		return "PlayerJumpState"
  
  	# Fall transition
  	if !player.is_on_floor():
  		return "PlayerFallState"
  
  	# Stay in walk state
  	return ""
  
  func handle_input(event: InputEvent):
  	check_menu_input(event)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\state.gd:
========================================
  class_name State
  extends Node
  
  ## Base class for all states in a state machine
  
  # Reference to the state machine
  var state_machine: StateMachine = null
  
  # Reference to the owner node
  var owner_node: Node = null
  
  # State parameters (can be extended by child classes)
  var parameters: Dictionary = {}
  
  
  # Called when entering this state
  func enter():
  	pass
  
  # Called when exiting this state
  func exit():
  	pass
  
  # Called during _process
  func process(delta: float):
  	pass
  
  # Called during _physics_process
  func physics_process(delta: float):
  	pass
  
  # Called during _input
  func handle_input(event: InputEvent):
  	pass
  
  # Override this to determine the next state to transition to
  func get_next_state() -> String:
  	return ""
  
  # Utility functions that can be used by derived states
  
  # Check if a condition is true
  func condition_met(condition_name: String) -> bool:
  	if owner_node.has_method("check_condition"):
  		return owner_node.check_condition(condition_name)
  	return false
  
  # Get a value from the owner
  func get_owner_property(property_name: String):
  	if owner_node and property_name in owner_node:
  		return owner_node.get(property_name)
  	return null
  
  # Set a value on the owner
  func set_owner_property(property_name: String, value):
  	if owner_node and property_name in owner_node:
  		owner_node.set(property_name, value)
  
  # Helper to check if owner is on floor (for platformers)
  func is_on_floor() -> bool:
  	if owner_node.has_method("is_on_floor"):
  		return owner_node.is_on_floor()
  	return false
  
  # Helper to get owner velocity (for physics bodies)
  func get_velocity() -> Vector2:
  	if "velocity" in owner_node:
  		return owner_node.velocity
  	return Vector2.ZERO
  
  # Helper to set owner velocity (for physics bodies)
  func set_velocity(value: Vector2):
  	if "velocity" in owner_node:
  		owner_node.velocity = value
  
  # Helper to play animations
  func play_animation(anim_name: String):
  	if owner_node.has_method("play_animation"):
  		owner_node.play_animation(anim_name)
  	elif owner_node.has_node("AnimatedSprite2D"):
  		var sprite = owner_node.get_node("AnimatedSprite2D")
  		if sprite.sprite_frames.has_animation(anim_name):
  			sprite.play(anim_name)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\state_machine.gd:
========================================
  class_name StateMachine
  extends Node
  
  ## A finite state machine implementation for Godot 4.x
  
  # Current active state
  var current_state: State = null
  
  # Dictionary of available states
  var states: Dictionary = {}
  
  # The owner node that this state machine controls
  var owner_node: Node = null
  
  # Debug mode flag
  @export var debug_mode: bool = true
  
  # Signal emitted when state changes
  signal state_changed(from_state, to_state)
  
  func _ready():
  	owner_node = get_parent()
  
  	# Register all child states
  	for child in get_children():
  		if child is State:
  			register_state(child)
  
  	# Initialize the first state
  	if states.size() > 0:
  		var initial_state = states.values()[0]
  		change_state(initial_state.name)
  
  func _process(delta):
  	if current_state != null:
  		# Call the current state's process method
  		current_state.process(delta)
  
  		# Check for state transitions
  		var next_state = current_state.get_next_state()
  		if next_state != null and next_state != "" and states.has(next_state):
  			change_state(next_state)
  
  func _physics_process(delta):
  	if current_state != null:
  		# Call the current state's physics_process method
  		current_state.physics_process(delta)
  
  func _input(event):
  	if current_state != null:
  		# Call the current state's input method
  		current_state.handle_input(event)
  
  func register_state(state: State):
  	# Add to states dictionary
  	states[state.name] = state
  
  	# Set the state machine reference
  	state.state_machine = self
  
  	# Set the owner reference
  	state.owner_node = owner_node
  
  	# Specifically initialize player references for PlayerBaseState instances
  	if state is PlayerBaseState:
  		state.player = owner_node
  
  	if debug_mode:
  		print("Registered state: ", state.name)
  
  func change_state(new_state_name: String):
  	if not states.has(new_state_name):
  		push_error("State '" + new_state_name + "' not found in state machine!")
  		return
  
  	var from_state = current_state.name if current_state else "None"
  
  	if current_state != null:
  		if debug_mode:
  			print("Exiting state: ", current_state.name)
  		current_state.exit()
  
  	var next_state = states[new_state_name]
  	current_state = next_state
  
  	# Make sure the player reference is properly set before entering the state
  	if current_state is PlayerBaseState and current_state.player == null:
  		current_state.player = owner_node
  
  	if debug_mode:
  		print("Entering state: ", current_state.name)
  
  	current_state.enter()
  
  	# Emit state change signal
  	emit_signal("state_changed", from_state, new_state_name)
  
  func get_current_state() -> String:
  	if current_state != null:
  		return current_state.name
  	return "None"
  
  # Add a new state at runtime
  func add_state(state: State):
  	register_state(state)
  
  # Remove a state at runtime
  func remove_state(state_name: String):
  	if states.has(state_name):
  		states.erase(state_name)
  	else:
  		push_error("Tried to remove non-existent state: " + state_name)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\levels\base_level.gd:
========================================
  class_name BaseLevel
  extends Node2D
  
  var boss_music = load("res://assets/audio/music/Tracks/the-epic-2-by-rafael-krux(chosic.com).mp3")
  # Called when the node enters the scene tree for the first time.
  func _ready():
  	AudioManager.play_track(boss_music)
  
  # Called every frame. 'delta' is the elapsed time since the previous frame.
  func _process(_delta):
  	pass

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\resources\player_outfit_resource.gd:
========================================
  class_name PlayerOutfitResource
  extends Resource
  
  ## Resource-based outfit system for The Little Saint
  ## Provides structured way to store and manage player appearance
  
  # Outfit components
  @export var beard: String = "none"
  @export var lipstick: String = "none"
  @export var eyes: String = "1"
  @export var shoes: String = "1"
  @export var earrings: String = "none"
  @export var hat: String = "none"
  @export var glasses: String = "none"
  @export var clothes_down: String = "1"
  @export var clothes_up: String = "1"
  @export var clothes_complete: String = "none"
  @export var body: String = "1"
  @export var hair: String = "1"
  
  # Outfit metadata
  @export var outfit_name: String = "Default Outfit"
  @export var is_favorite: bool = false
  @export var creation_date: String = ""
  
  # Initialize with default values
  func _init():
  	creation_date = Time.get_datetime_string_from_system(false, true)
  
  # Convert to dictionary format (for backwards compatibility)
  func to_dictionary() -> Dictionary:
  	return {
  		"beard": beard,
  		"lipstick": lipstick,
  		"eyes": eyes,
  		"shoes": shoes,
  		"earrings": earrings,
  		"hats": hat,
  		"glasses": glasses,
  		"clothes_down": clothes_down,
  		"clothes_up": clothes_up,
  		"clothes_complete": clothes_complete,
  		"bodies": body,
  		"hair": hair
  	}
  
  # Create from dictionary (for backwards compatibility)
  func from_dictionary(dict: Dictionary) -> PlayerOutfitResource:
  	beard = str(dict.get("beard", "none"))
  	lipstick = str(dict.get("lipstick", "none"))
  	eyes = str(dict.get("eyes", "1"))
  	shoes = str(dict.get("shoes", "1"))
  	earrings = str(dict.get("earrings", "none"))
  	hat = str(dict.get("hats", "none"))
  	glasses = str(dict.get("glasses", "none"))
  	clothes_down = str(dict.get("clothes_down", "1"))
  	clothes_up = str(dict.get("clothes_up", "1"))
  	clothes_complete = str(dict.get("clothes_complete", "none"))
  	body = str(dict.get("bodies", "1"))
  	hair = str(dict.get("hair", "1"))
  	return self
  
  # Check if a component is visible
  func is_visible(component: String) -> bool:
  	match component:
  		"beard", "lipstick", "earrings", "hat", "glasses", "clothes_complete":
  			return get(component) != "none"
  		_:
  			return true
  
  # Check if this is a complete outfit (has all required elements)
  func is_complete() -> bool:
  	return body != "none" and eyes != "none"
  
  # Reset to default values
  func reset() -> void:
  	beard = "none"
  	lipstick = "none"
  	eyes = "1"
  	shoes = "1"
  	earrings = "none"
  	hat = "none"
  	glasses = "none"
  	clothes_down = "1"
  	clothes_up = "1"
  	clothes_complete = "none"
  	body = "1"
  	hair = "1"
  	outfit_name = "Default Outfit"
  	is_favorite = false
  	creation_date = Time.get_datetime_string_from_system(false, true)
  
  # Create a randomized outfit
  func randomize_outfit() -> PlayerOutfitResource:
  	# Use true randomization
  	randomize()
  
  	# Always set essential parts
  	body = str(randi_range(1, 10))  # Assuming there are 10 body options
  	eyes = str(randi_range(1, 14))  # Assuming there are 14 eye options
  
  	# Randomly decide for all other parts
  	beard = _random_part(["none", "1", "2", "3"], 0.7)  # 70% chance for none
  	lipstick = _random_part(["none", "1", "2", "3"], 0.8)  # 80% chance for none
  	shoes = str(randi_range(1, 10))  # Assuming there are 10 shoe options
  	earrings = _random_part(["none", "1", "2", "3"], 0.8)  # 80% chance for none
  	hat = _random_part(["none", "1", "2", "3", "4"], 0.6)  # 60% chance for none
  	glasses = _random_part(["none", "1", "2"], 0.9)  # 90% chance for none
  
  	# Either use separate top/bottom or complete outfit
  	if randf() > 0.3:  # 70% chance for separate clothes
  		clothes_down = str(randi_range(1, 10))
  		clothes_up = str(randi_range(1, 10))
  		clothes_complete = "none"
  	else:  # 30% chance for complete outfit
  		clothes_down = "none"
  		clothes_up = "none"
  		clothes_complete = str(randi_range(1, 5))  # Assuming there are 5 complete outfit options
  
  	# Hair is important for character look
  	hair = str(randi_range(1, 14))  # Assuming there are 14 hair options
  
  	outfit_name = "Random Outfit"
  	creation_date = Time.get_datetime_string_from_system(false, true)
  
  	return self
  
  # Helper for randomizing parts with "none" option
  func _random_part(options: Array, none_chance: float) -> String:
  	if randf() < none_chance:
  		return "none"
  
  	var valid_options = options.duplicate()
  	valid_options.erase("none")
  	return valid_options[randi() % valid_options.size()]
  
  # Create a duplicate of this outfit
  func duplicate_outfit() -> PlayerOutfitResource:
  	var new_outfit = PlayerOutfitResource.new()
  	new_outfit.beard = beard
  	new_outfit.lipstick = lipstick
  	new_outfit.eyes = eyes
  	new_outfit.shoes = shoes
  	new_outfit.earrings = earrings
  	new_outfit.hat = hat
  	new_outfit.glasses = glasses
  	new_outfit.clothes_down = clothes_down
  	new_outfit.clothes_up = clothes_up
  	new_outfit.clothes_complete = clothes_complete
  	new_outfit.body = body
  	new_outfit.hair = hair
  	new_outfit.outfit_name = outfit_name + " (Copy)"
  	new_outfit.is_favorite = is_favorite
  	new_outfit.creation_date = Time.get_datetime_string_from_system(false, true)
  	return new_outfit
  
  # Create a new default outfit resource
  static func create_default() -> PlayerOutfitResource:
  	return PlayerOutfitResource.new()
  
  # Check for equality with another outfit
  func equals(other: PlayerOutfitResource) -> bool:
  	return (
  		beard == other.beard and
  		lipstick == other.lipstick and
  		eyes == other.eyes and
  		shoes == other.shoes and
  		earrings == other.earrings and
  		hat == other.hat and
  		glasses == other.glasses and
  		clothes_down == other.clothes_down and
  		clothes_up == other.clothes_up and
  		clothes_complete == other.clothes_complete and
  		body == other.body and
  		hair == other.hair
  	)
  
  # Apply this outfit to character sprites
  func apply_to_sprites(character_sprites: Node2D) -> void:
  	var outfit_dict = to_dictionary()
  
  	for category in outfit_dict:
  		if character_sprites.has_node(category):
  			var sprite = character_sprites.get_node(category)
  			var value = outfit_dict[category]
  
  			if value == "none":
  				sprite.visible = false
  			else:
  				sprite.visible = true
  				sprite.animation = value
  				sprite.frame = 1

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\character_customizer\customizer_controller.gd:
========================================
  class_name CustomizerController
  # UI.gd
  extends Control
  
  # Spieler-Outfit-Eigenschaften
  var body
  var player_outfit
  var selected_outfit_category = ""
  var player_animations
  var options_per_category = {}
  var has_unsaved_changes = false  # Neue Variable für ungespeicherte Änderungen
  
  # Resource-basiertes Outfit System
  var current_outfit_resource: PlayerOutfitResource = null
  
  # Signal für Debugging
  signal debug_message(message)
  
  func _ready():
  	randomize() # Initialisiere den Zufallsgenerator
  	get_node("character_sprites/masks").visible = false
  	player_outfit = get_node("character_sprites").default_outfit
  	player_animations = get_node("character_sprites").animation_frames
  
  	# Create outfit resource
  	current_outfit_resource = PlayerOutfitResource.new()
  
  	# Connect to PopupManager
  	PopupManager.dialog_confirmed.connect(_on_dialog_confirmed)
  
  	# UI-Elemente für jede Outfit-Kategorie erstellen
  	setup_outfit_categories()
  
  	# Versuche, gespeicherte Outfits zu laden
  	load_saved_outfit()
  
  	# Bei Programmstart gibt es keine ungespeicherten Änderungen
  	has_unsaved_changes = false
  
  # Erstellt UI-Elemente für alle Outfit-Kategorien
  func setup_outfit_categories():
  	for category in player_outfit:
  		var category_button = Button.new()
  		var items_container = ScrollContainer.new()
  		var item_container_grid = GridContainer.new()
  
  		# Kategorie-Button einrichten
  		category_button.text = category
  		category_button.pressed.connect(_on_category_button_pressed.bind(category))
  		$Outfit_Category_Picker/GridContainer.add_child(category_button)
  
  		# Container für Items einrichten
  		items_container.size = Vector2(620, 400)
  		items_container.position = Vector2(600, 200)
  		items_container.add_child(item_container_grid)
  		items_container.name = category
  		add_child(items_container)
  		items_container.hide()
  
  		# Grid für Items einrichten
  		item_container_grid.columns = 6
  		var current_item = 0
  		var button_size = Vector2(100, 100)
  
  		# Leeren Button für optionale Kategorien hinzufügen
  		if category != "bodies":
  			var empty_button = Button.new()
  			empty_button.custom_minimum_size = button_size
  			empty_button.pressed.connect(_on_item_button_pressed.bind("none"))
  			item_container_grid.add_child(empty_button)
  
  			var animated_sprite = get_node("character_sprites/" + category)
  			animated_sprite.visible = false
  			player_outfit[category] = "none"
  
  		# Alle verfügbaren Items für diese Kategorie hinzufügen
  		while true:
  			current_item += 1
  			var texture = get_node("character_sprites/"+category).sprite_frames.get_frame_texture(str(current_item), 1)
  			if texture == null:
  				break
  
  			var item_texture = TextureRect.new()
  			item_texture.texture = texture
  			item_texture.custom_minimum_size = button_size
  			item_texture.stretch_mode = TextureRect.STRETCH_KEEP_ASPECT_CENTERED
  
  			var item_button = Button.new()
  			item_button.custom_minimum_size = button_size
  			item_button.add_child(item_texture)
  			item_button.pressed.connect(_on_item_button_pressed.bind(str(current_item)))
  			item_container_grid.add_child(item_button)
  
  		options_per_category[category] = current_item - 1
  
  # Aktualisiert die Animations-Frames basierend auf dem gewählten Outfit
  func _process(_delta):
  	for outfit in player_outfit:
  		var animated_sprite = get_node("character_sprites/" + outfit)
  		animated_sprite.animation = player_outfit[outfit]
  		animated_sprite.frame = 1
  
  # Wird aufgerufen, wenn ein Item ausgewählt wird
  func _on_item_button_pressed(item):
  	var animated_sprite = get_node("character_sprites/" + selected_outfit_category)
  	var old_value = player_outfit[selected_outfit_category]
  	var new_value = str(item)
  
  	if new_value == "none":
  		animated_sprite.visible = false
  	else:
  		animated_sprite.visible = true
  
  	# Setze has_unsaved_changes nur, wenn sich etwas geändert hat
  	if old_value != new_value:
  		player_outfit[selected_outfit_category] = new_value
  		has_unsaved_changes = true
  
  		# Update outfit resource
  		if selected_outfit_category == "bodies":
  			current_outfit_resource.body = new_value
  		elif selected_outfit_category == "hats":
  			current_outfit_resource.hat = new_value
  		elif current_outfit_resource.get(selected_outfit_category) != null:
  			current_outfit_resource.set(selected_outfit_category, new_value)
  	else:
  		player_outfit[selected_outfit_category] = new_value
  
  # Wird aufgerufen, wenn eine Kategorie ausgewählt wird
  func _on_category_button_pressed(category):
  	if selected_outfit_category:
  		get_node(selected_outfit_category).hide()
  	get_node(category).show()
  	selected_outfit_category = category
  
  # Generiert ein zufälliges Outfit
  func _random_button_pressed():
  	current_outfit_resource.randomize_outfit()
  	var outfit_dict = current_outfit_resource.to_dictionary()
  	var had_changes = false
  
  	# Update the player_outfit from the resource
  	for category in outfit_dict:
  		if player_outfit.has(category):
  			var new_value = outfit_dict[category]
  			if player_outfit[category] != new_value:
  				player_outfit[category] = new_value
  				had_changes = true
  
  			# Update sprite visibility
  			var animated_sprite = get_node("character_sprites/" + category)
  			if new_value == "none":
  				animated_sprite.visible = false
  			else:
  				animated_sprite.visible = true
  
  	if had_changes:
  		has_unsaved_changes = true
  
  # Speichert das aktuelle Outfit
  func _save_button_pressed():
  	# Update the outfit resource
  	current_outfit_resource.from_dictionary(player_outfit)
  	current_outfit_resource.outfit_name = "Last Saved Outfit"
  
  	# Save to both the favorites and the player's current outfit
  	SaveManager.save_outfit(player_outfit, "Last Saved Outfit")
  
  	# Ensure the current save data has the outfit
  	if SaveManager.current_save_data:
  		SaveManager.current_save_data.player_outfit = player_outfit.duplicate(true)
  
  	# Save both settings and game data
  	SaveManager.save_settings()
  	SaveManager.save_game()  # Add this line to ensure full game save
  
  	has_unsaved_changes = false
  	show_message("Outfit erfolgreich gespeichert!", Color(0.3, 1, 0.3, 1))
  
  # Setzt alle optionalen Teile des Outfits zurück
  func _reset_button_pressed():
  	# Use the resource method to reset
  	current_outfit_resource.reset()
  	var outfit_dict = current_outfit_resource.to_dictionary()
  	var had_changes = false
  
  	# Apply the reset to player_outfit
  	for category in outfit_dict:
  		if player_outfit.has(category) and category != "bodies":
  			var animated_sprite = get_node("character_sprites/" + category)
  			animated_sprite.visible = false
  
  			if player_outfit[category] != "none":
  				player_outfit[category] = "none"
  				had_changes = true
  
  	if had_changes:
  		has_unsaved_changes = true
  
  	show_message("Outfit zurückgesetzt!", Color(0.3, 0.7, 1, 1))
  
  # Hilfsfunktion zum Anzeigen von Nachrichten
  func show_message(text, color = Color(1, 1, 1, 1)):
  	if has_node("save_feedback"):
  		var label = get_node("save_feedback")
  		label.text = text
  		label.modulate = color
  
  		# Timer zum Ausblenden nach 2 Sekunden
  		get_tree().create_timer(2.0).timeout.connect(func():
  			if has_node("save_feedback"):
  				get_node("save_feedback").text = ""
  		)
  
  # Lädt das gespeicherte Outfit, falls vorhanden
  func load_saved_outfit():
  	# First try to load from current save data
  	if SaveManager.current_save_data and SaveManager.current_save_data.player_outfit:
  		var saved_outfit = SaveManager.current_save_data.player_outfit
  
  		# Log for debugging
  		print("Loading outfit from save data: ", saved_outfit)
  
  		# Update the outfit resource
  		current_outfit_resource.from_dictionary(saved_outfit)
  
  		# Update the UI
  		for category in saved_outfit:
  			if player_outfit.has(category):
  				var outfit_value = str(saved_outfit[category])
  				player_outfit[category] = outfit_value
  
  				# Update visibility
  				var animated_sprite = get_node("character_sprites/" + category)
  				if outfit_value == "none":
  					animated_sprite.visible = false
  				else:
  					animated_sprite.visible = true
  
  		print("Outfit loaded successfully")
  	else:
  		print("No saved outfit found in save data")
  
  
  func _on_back_pressed() -> void:
  	if has_unsaved_changes:
  		PopupManager.confirm(
  			"Nicht gespeicherte Änderungen",
  			"Du hast nicht gespeicherte Änderungen. Möchtest du wirklich ohne Speichern zurückkehren?",
  			"Abbrechen",
  			"Zurück",
  			"back_confirmation"
  		)
  	else:
  		get_tree().change_scene_to_file("res://scenes/ui/settings/settings_menu.tscn")
  
  func _on_dialog_confirmed(dialog_id):
  	if dialog_id == "back_confirmation":
  		get_tree().change_scene_to_file("res://scenes/ui/settings/settings_menu.tscn")

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\character_customizer\outfit_showcase.gd:
========================================
  class_name OutfitShowcase
  # outfit_showcase.gd
  extends Control
  
  var current_outfits = {}
  var preview_container
  var outfit_grid
  var back_button
  var outfit_name_field
  var save_button
  var delete_button
  var preview_helper
  
  func _ready():
  	preview_helper = load("res://scripts/ui/character_customizer/preview_helper.gd").new()
  	add_child(preview_helper)
  
  	# UI erstellen
  	setup_ui()
  
  	# Gespeicherte Outfits laden
  	load_saved_outfits()
  
  func setup_ui():
  	# Container für die Vorschau
  	preview_container = ScrollContainer.new()
  	preview_container.position = Vector2(50, 50)
  	preview_container.size = Vector2(900, 400)
  	add_child(preview_container)
  
  	# Grid für Outfit-Vorschaubilder
  	outfit_grid = GridContainer.new()
  	outfit_grid.columns = 4
  	preview_container.add_child(outfit_grid)
  
  	# Textfeld für Outfit-Namen
  	var name_label = Label.new()
  	name_label.text = "Outfit-Name:"
  	name_label.position = Vector2(50, 470)
  	add_child(name_label)
  
  	outfit_name_field = LineEdit.new()
  	outfit_name_field.position = Vector2(150, 470)
  	outfit_name_field.size = Vector2(300, 30)
  	outfit_name_field.placeholder_text = "Mein cooles Outfit"
  	add_child(outfit_name_field)
  
  	# Save-Button
  	save_button = Button.new()
  	save_button.text = "Speichern"
  	save_button.position = Vector2(470, 470)
  	save_button.size = Vector2(120, 30)
  	save_button.pressed.connect(_on_save_pressed)
  	add_child(save_button)
  
  	# Delete-Button
  	delete_button = Button.new()
  	delete_button.text = "Löschen"
  	delete_button.position = Vector2(600, 470)
  	delete_button.size = Vector2(120, 30)
  	delete_button.pressed.connect(_on_delete_pressed)
  	add_child(delete_button)
  
  	# Back-Button
  	back_button = Button.new()
  	back_button.text = "Zurück"
  	back_button.position = Vector2(400, 550)
  	back_button.size = Vector2(200, 40)
  	back_button.pressed.connect(_on_back_pressed)
  	add_child(back_button)
  
  # Lädt alle gespeicherten Outfits und zeigt sie an
  func load_saved_outfits():
  	current_outfits = preview_helper.load_favorites()
  
  	# UI aktualisieren
  	update_showcase()
  
  # Aktualisiert die Anzeige der Outfits
  func update_showcase():
  	# Alle vorherigen Kinder entfernen
  	for child in outfit_grid.get_children():
  		outfit_grid.remove_child(child)
  		child.queue_free()
  
  	# Aktuelle Outfit-Liste durchgehen
  	for outfit_name in current_outfits:
  		var outfit_config = current_outfits[outfit_name]
  
  		# Container für jedes Outfit
  		var outfit_container = VBoxContainer.new()
  		outfit_grid.add_child(outfit_container)
  
  		# Vorschaubild generieren
  		var preview_image = await preview_helper.generate_outfit_preview(
  			get_node("/root/Main/character_sprites"),
  			outfit_config
  		)
  
  		# TextureRect für das Vorschaubild
  		var preview_rect = TextureRect.new()
  		var image_texture = ImageTexture.create_from_image(preview_image)
  		preview_rect.texture = image_texture
  		preview_rect.custom_minimum_size = Vector2(200, 200)
  		preview_rect.stretch_mode = TextureRect.STRETCH_KEEP_ASPECT_CENTERED
  		outfit_container.add_child(preview_rect)
  
  		# Label für den Namen
  		var name_label = Label.new()
  		name_label.text = outfit_name
  		name_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
  		outfit_container.add_child(name_label)
  
  		# Button zum Laden dieses Outfits
  		var load_button = Button.new()
  		load_button.text = "Laden"
  		load_button.pressed.connect(_on_load_outfit_pressed.bind(outfit_name))
  		outfit_container.add_child(load_button)
  
  # Event-Handler
  
  func _on_save_pressed():
  	var current_outfit = get_node("/root/Main").get_current_outfit()
  	var name = outfit_name_field.text
  
  	if name.empty():
  		name = "Outfit " + str(current_outfits.size() + 1)
  
  	# Outfit zu Favoriten hinzufügen
  	preview_helper.save_to_favorites(current_outfit, name)
  
  	# Liste aktualisieren
  	load_saved_outfits()
  
  func _on_delete_pressed():
  	var name = outfit_name_field.text
  	if current_outfits.has(name):
  		current_outfits.erase(name)
  
  		# Aktualisierte Liste speichern
  		var config = ConfigFile.new()
  		config.set_value("favorites", "outfits", current_outfits)
  		config.save("user://favorites.cfg")
  
  		# UI aktualisieren
  		update_showcase()
  
  func _on_load_outfit_pressed(outfit_name):
  	var outfit_config = current_outfits[outfit_name]
  	get_node("/root/Main").apply_outfit(outfit_config)
  
  	# Eingabefeld aktualisieren
  	outfit_name_field.text = outfit_name
  
  func _on_back_pressed():
  	get_tree().change_scene_to_file("res://scenes/ui/character_customizer/customizer.tscn")

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\character_customizer\preview_helper.gd:
========================================
  class_name PreviewHelper
  # preview_helper.gd
  # Diese Datei enthält Hilfsfunktionen für die Vorschau im Character-Customizer
  
  extends Node
  
  # Cache für Outfit-Vorschaubilder
  var preview_cache = {}
  
  # Generiert ein Vorschaubild für ein komplettes Outfit
  # Kann verwendet werden, um mehrere Outfits nebeneinander anzuzeigen
  func generate_outfit_preview(character_sprites, outfit_config):
  	var viewport = SubViewport.new()
  	viewport.size = Vector2i(128, 128)
  	viewport.transparent_bg = true
  	viewport.render_target_update_mode = SubViewport.UPDATE_ONCE
  
  	var sprites_instance = character_sprites.duplicate()
  	viewport.add_child(sprites_instance)
  
  	# Positioniere die Sprites in der Mitte des Viewports
  	sprites_instance.position = Vector2(64, 64)
  	sprites_instance.scale = Vector2(4, 4)
  
  	# Setze das Outfit gemäß der Konfiguration
  	for category in outfit_config:
  		if sprites_instance.has_node(category):
  			var sprite = sprites_instance.get_node(category)
  			if str(outfit_config[category]) == "none":
  				sprite.visible = false
  			else:
  				sprite.visible = true
  				sprite.animation = str(outfit_config[category])
  				sprite.frame = 1
  
  	# Rendern und Vorschaubild zurückgeben
  	await get_tree().process_frame
  	await get_tree().process_frame
  
  	var texture = viewport.get_texture()
  	var image = texture.get_image()
  
  	# Viewport und Duplikat aufräumen
  	viewport.remove_child(sprites_instance)
  	sprites_instance.queue_free()
  	viewport.queue_free()
  
  	return image
  
  # Speichert ein Outfit in einem gesonderten Bereich für Favoriten
  func save_to_favorites(outfit_config, name = ""):
  	var favorites = load_favorites()
  
  	if name.empty():
  		name = "Outfit " + str(favorites.size() + 1)
  
  	favorites[name] = outfit_config
  
  	var config = ConfigFile.new()
  	config.set_value("favorites", "outfits", favorites)
  	var err = config.save("user://favorites.cfg")
  
  	return err == OK
  
  # Lädt alle gespeicherten Favoriten
  func load_favorites():
  	var config = ConfigFile.new()
  	var err = config.load("user://favorites.cfg")
  
  	if err == OK:
  		return config.get_value("favorites", "outfits", {})
  	else:
  		return {}
  
  # Konvertiert ein Outfit in ein exportierbares Format (z.B. JSON)
  func export_outfit_to_json(outfit_config):
  	return JSON.stringify(outfit_config)
  
  # Importiert ein Outfit aus einem exportierten Format
  func import_outfit_from_json(json_string):
  	var json = JSON.new()
  	var error = json.parse(json_string)
  	if error == OK:
  		return json.get_data()
  	else:
  		return null

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\controls\attack_button.gd:
========================================
  class_name AttackButton
  extends Button
  
  
  @onready var attack = $"."
  
  func _ready():
  	attack.modulate = Color(2, 2, 2, 0.5)
  
  
  func _on_button_up():
  	attack.modulate = Color(2, 2, 2, 0.5)
  	Input.action_release("attack")
  
  
  func _on_button_down():
  	attack.modulate = Color(1.0, 1.0, 1.0, 0.5)
  	Input.action_press("attack")

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\controls\defend_button.gd:
========================================
  class_name DefendButton
  extends Button
  
  
  @onready var defend = $"."
  
  func _ready():
  	defend.modulate = Color(2, 2, 2, 0.5)
  
  
  func _on_button_up():
  	defend.modulate = Color(2, 2, 2, 0.5)
  	Input.action_release("defend")
  
  func _on_button_down():
  	defend.modulate = Color(1.0, 1.0, 1.0, 0.5)
  	Input.action_press("defend")
  

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\dialogs\popup_dialog.gd:
========================================
  class_name PopupDialog
  extends CanvasLayer
  
  # Signal, wenn der primäre (rechte) Button gedrückt wird
  signal confirmed
  # Signal, wenn der sekundäre (linke) Button gedrückt wird
  signal canceled
  
  # UI-Elemente
  var dimmer
  var dialog_panel
  var title_label
  var message_label
  var button_container
  var cancel_button
  var confirm_button
  
  # Standardwerte
  var _title_text = "Bestätigung"
  var _message_text = "Möchtest du fortfahren?"
  var _cancel_text = "Abbrechen"
  var _confirm_text = "Bestätigen"
  var _confirm_color = Color(0.7, 0.2, 0.2, 1)  # Rot
  var _auto_hide = true
  
  func _init():
  	# Erstelle alle UI-Elemente programmatisch
  	_create_ui()
  
  func _ready():
  	# Bei Start nicht anzeigen
  	hide()
  
  	# Verbinde Button-Signale
  	cancel_button.pressed.connect(_on_cancel_pressed)
  	confirm_button.pressed.connect(_on_confirm_pressed)
  
  # Erstellt die komplette UI-Struktur
  func _create_ui():
  	# Dimmer (Hintergrund-Verdunkelung)
  	dimmer = ColorRect.new()
  	dimmer.name = "Dimmer"
  	dimmer.color = Color(0, 0, 0, 0.6)  # Halbtransparentes Schwarz
  	add_child(dimmer)
  
  	# DialogPanel
  	dialog_panel = Panel.new()
  	dialog_panel.name = "DialogPanel"
  
  	# Panel-Design
  	var panel_style = StyleBoxFlat.new()
  	panel_style.bg_color = Color(0.12, 0.12, 0.15, 1.0)
  	panel_style.border_width_left = 2
  	panel_style.border_width_top = 2
  	panel_style.border_width_right = 2
  	panel_style.border_width_bottom = 2
  	panel_style.border_color = Color(0.6, 0.6, 1.0, 0.7)
  	panel_style.corner_radius_top_left = 15
  	panel_style.corner_radius_top_right = 15
  	panel_style.corner_radius_bottom_left = 15
  	panel_style.corner_radius_bottom_right = 15
  	panel_style.shadow_color = Color(0, 0, 0, 0.3)
  	panel_style.shadow_size = 8
  	dialog_panel.add_theme_stylebox_override("panel", panel_style)
  	dimmer.add_child(dialog_panel)
  
  	# Titel
  	title_label = Label.new()
  	title_label.name = "Title"
  	title_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
  	title_label.add_theme_font_size_override("font_size", 24)
  	title_label.add_theme_color_override("font_color", Color(1, 1, 1, 1))
  	dialog_panel.add_child(title_label)
  
  	# Nachricht
  	message_label = Label.new()
  	message_label.name = "Message"
  	message_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
  	message_label.autowrap_mode = TextServer.AUTOWRAP_WORD_SMART
  	message_label.add_theme_font_size_override("font_size", 18)
  	message_label.add_theme_color_override("font_color", Color(0.9, 0.9, 0.9, 1))
  	dialog_panel.add_child(message_label)
  
  	# Buttons-Container
  	button_container = HBoxContainer.new()
  	button_container.name = "ButtonContainer"
  	button_container.alignment = BoxContainer.ALIGNMENT_CENTER
  	button_container.add_theme_constant_override("separation", 20)
  	dialog_panel.add_child(button_container)
  
  	# Button-Style vorbereiten
  	var button_style_normal = StyleBoxFlat.new()
  	button_style_normal.bg_color = Color(0.2, 0.2, 0.25, 1)
  	button_style_normal.border_width_left = 0
  	button_style_normal.border_width_top = 0
  	button_style_normal.border_width_right = 0
  	button_style_normal.border_width_bottom = 0
  	button_style_normal.corner_radius_top_left = 8
  	button_style_normal.corner_radius_top_right = 8
  	button_style_normal.corner_radius_bottom_left = 8
  	button_style_normal.corner_radius_bottom_right = 8
  
  	var button_style_hover = StyleBoxFlat.new()
  	button_style_hover.bg_color = Color(0.25, 0.25, 0.3, 1)
  	button_style_hover.border_width_left = 0
  	button_style_hover.border_width_top = 0
  	button_style_hover.border_width_right = 0
  	button_style_hover.border_width_bottom = 0
  	button_style_hover.corner_radius_top_left = 8
  	button_style_hover.corner_radius_top_right = 8
  	button_style_hover.corner_radius_bottom_left = 8
  	button_style_hover.corner_radius_bottom_right = 8
  
  	var button_style_pressed = StyleBoxFlat.new()
  	button_style_pressed.bg_color = Color(0.15, 0.15, 0.2, 1)
  	button_style_pressed.border_width_left = 0
  	button_style_pressed.border_width_top = 0
  	button_style_pressed.border_width_right = 0
  	button_style_pressed.border_width_bottom = 0
  	button_style_pressed.corner_radius_top_left = 8
  	button_style_pressed.corner_radius_top_right = 8
  	button_style_pressed.corner_radius_bottom_left = 8
  	button_style_pressed.corner_radius_bottom_right = 8
  
  	# Abbrechen-Button
  	cancel_button = Button.new()
  	cancel_button.name = "CancelButton"
  	cancel_button.add_theme_font_size_override("font_size", 18)
  	cancel_button.add_theme_stylebox_override("normal", button_style_normal.duplicate())
  	cancel_button.add_theme_stylebox_override("hover", button_style_hover.duplicate())
  	cancel_button.add_theme_stylebox_override("pressed", button_style_pressed.duplicate())
  	button_container.add_child(cancel_button)
  
  	# Bestätigen-Button
  	confirm_button = Button.new()
  	confirm_button.name = "ConfirmButton"
  	confirm_button.add_theme_font_size_override("font_size", 18)
  
  	# Rote Button-Stile
  	var confirm_style_normal = button_style_normal.duplicate()
  	confirm_style_normal.bg_color = Color(0.7, 0.2, 0.2, 1)
  	var confirm_style_hover = button_style_hover.duplicate()
  	confirm_style_hover.bg_color = Color(0.8, 0.3, 0.3, 1)
  	var confirm_style_pressed = button_style_pressed.duplicate()
  	confirm_style_pressed.bg_color = Color(0.6, 0.15, 0.15, 1)
  
  	confirm_button.add_theme_stylebox_override("normal", confirm_style_normal)
  	confirm_button.add_theme_stylebox_override("hover", confirm_style_hover)
  	confirm_button.add_theme_stylebox_override("pressed", confirm_style_pressed)
  	button_container.add_child(confirm_button)
  
  # Setzt Text-Inhalte und Farben
  func setup(title: String = "", message: String = "",
  		   cancel_text: String = "", confirm_text: String = "",
  		   confirm_button_color: Color = Color(0.7, 0.2, 0.2, 1)):
  
  	# Setze nur nicht-leere Werte
  	if title:
  		_title_text = title
  	if message:
  		_message_text = message
  	if cancel_text:
  		_cancel_text = cancel_text
  	if confirm_text:
  		_confirm_text = confirm_text
  
  	_confirm_color = confirm_button_color
  
  	return self  # Für Methoden-Verkettung
  
  # Einstellen, ob das Popup sich automatisch schließen soll
  func set_auto_hide(value: bool):
  	_auto_hide = value
  	return self  # Für Methoden-Verkettung
  
  # Zeigt den Dialog an
  func popup():
  	# Fenstergröße aktualisieren
  	var viewport_size = get_viewport().get_visible_rect().size
  	dimmer.size = viewport_size
  
  	var dialog_width = min(500, viewport_size.x * 0.8)
  	var dialog_height = 230
  	dialog_panel.size = Vector2(dialog_width, dialog_height)
  	dialog_panel.position = (viewport_size - dialog_panel.size) / 2
  	dialog_panel.pivot_offset = dialog_panel.size / 2
  
  	# Layout aktualisieren
  	title_label.position = Vector2(0, 20)
  	title_label.size = Vector2(dialog_width, 30)
  
  	message_label.position = Vector2(20, 60)
  	message_label.size = Vector2(dialog_width - 40, 60)
  
  	button_container.position = Vector2(20, dialog_height - 80)
  	button_container.size = Vector2(dialog_width - 40, 60)
  
  	cancel_button.custom_minimum_size = Vector2(dialog_width * 0.35, 60)
  	confirm_button.custom_minimum_size = Vector2(dialog_width * 0.35, 60)
  
  	# Aktualisiere UI
  	title_label.text = _title_text
  	message_label.text = _message_text
  	cancel_button.text = _cancel_text
  	confirm_button.text = _confirm_text
  
  	# Setze Button-Farbe
  	var normal_style = confirm_button.get_theme_stylebox("normal").duplicate()
  	var hover_style = confirm_button.get_theme_stylebox("hover").duplicate()
  	var pressed_style = confirm_button.get_theme_stylebox("pressed").duplicate()
  
  	normal_style.bg_color = _confirm_color
  	hover_style.bg_color = _confirm_color.lightened(0.1)
  	pressed_style.bg_color = _confirm_color.darkened(0.1)
  
  	confirm_button.add_theme_stylebox_override("normal", normal_style)
  	confirm_button.add_theme_stylebox_override("hover", hover_style)
  	confirm_button.add_theme_stylebox_override("pressed", pressed_style)
  
  	# Dialog anzeigen mit Animation
  	show()
  	dimmer.modulate = Color(1, 1, 1, 0)
  
  	var tween = create_tween()
  	tween.tween_property(dimmer, "modulate", Color(1, 1, 1, 1), 0.3).set_ease(Tween.EASE_OUT)
  
  	# Dialog-Panel Animation (Skalierung)
  	dialog_panel.scale = Vector2(0.9, 0.9)
  	tween.parallel().tween_property(dialog_panel, "scale", Vector2(1, 1), 0.3).set_ease(Tween.EASE_OUT)
  
  	return self  # Für Methoden-Verkettung
  
  # Schließt den Dialog
  func close():
  	var tween = create_tween()
  	tween.tween_property(dimmer, "modulate", Color(1, 1, 1, 0), 0.2).set_ease(Tween.EASE_IN)
  	tween.parallel().tween_property(dialog_panel, "scale", Vector2(0.9, 0.9), 0.2).set_ease(Tween.EASE_IN)
  
  	# Warte auf das Ende der Animation
  	await tween.finished
  	hide()
  
  # Button-Handling
  func _on_cancel_pressed():
  	emit_signal("canceled")
  	if _auto_hide:
  		close()
  
  func _on_confirm_pressed():
  	emit_signal("confirmed")
  	if _auto_hide:
  		close()

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\dialogs\popup_manager.gd:
========================================
  extends Node
  
  # Signal, dass ein zuvor erstellter Dialog bestätigt wurde
  signal dialog_confirmed(dialog_id: String)
  # Signal, dass ein zuvor erstellter Dialog abgebrochen wurde
  signal dialog_canceled(dialog_id: String)
  
  # Speichert alle aktiven Popups
  var _active_popups = {}
  
  # Zeigt eine einfache Bestätigungsabfrage
  func confirm(title: String, message: String,
  			 cancel_text: String = "Abbrechen", confirm_text: String = "Bestätigen",
  			 dialog_id: String = "") -> String:
  
  	# Generiere eine eindeutige ID, falls keine angegeben wurde
  	var id = dialog_id if dialog_id else _generate_id()
  
  	# Erstelle und zeige das Popup an
  	var popup = _create_popup()
  	popup.setup(title, message, cancel_text, confirm_text)
  
  	# Verbinde Signale, um weiterzuleiten
  	popup.confirmed.connect(func():
  		emit_signal("dialog_confirmed", id)
  		_active_popups.erase(id)
  	)
  	popup.canceled.connect(func():
  		emit_signal("dialog_canceled", id)
  		_active_popups.erase(id)
  	)
  
  	# Speichere das Popup für spätere Referenz
  	_active_popups[id] = popup
  
  	# Zeige das Popup an
  	popup.popup()
  
  	return id
  
  # Zeigt einen Warnungs-Dialog
  func warning(title: String, message: String, button_text: String = "OK") -> String:
  	var id = _generate_id()
  	var popup = _create_popup()
  
  	# Stelle Warnungs-Dialog ein
  	popup.setup(
  		title,
  		message,
  		"", # Kein Abbrechen-Button
  		button_text,
  		Color(0.9, 0.6, 0.1, 1) # Orange für Warnungen
  	)
  
  	# Verbinde Signale
  	popup.confirmed.connect(func():
  		emit_signal("dialog_confirmed", id)
  		_active_popups.erase(id)
  	)
  
  	# Verstecke den Abbrechen-Button
  	popup.cancel_button.visible = false
  
  	# Speichere und zeige an
  	_active_popups[id] = popup
  	popup.popup()
  
  	return id
  
  # Zeigt einen Fehler-Dialog
  func error(title: String, message: String, button_text: String = "OK") -> String:
  	var id = _generate_id()
  	var popup = _create_popup()
  
  	# Stelle Fehler-Dialog ein
  	popup.setup(
  		title,
  		message,
  		"", # Kein Abbrechen-Button
  		button_text,
  		Color(0.8, 0.1, 0.1, 1) # Rot für Fehler
  	)
  
  	# Verbinde Signale
  	popup.confirmed.connect(func():
  		emit_signal("dialog_confirmed", id)
  		_active_popups.erase(id)
  	)
  
  	# Verstecke den Abbrechen-Button
  	popup.cancel_button.visible = false
  
  	# Speichere und zeige an
  	_active_popups[id] = popup
  	popup.popup()
  
  	return id
  
  # Zeigt eine Info-Nachricht
  func info(title: String, message: String, button_text: String = "OK") -> String:
  	var id = _generate_id()
  	var popup = _create_popup()
  
  	# Stelle Info-Dialog ein
  	popup.setup(
  		title,
  		message,
  		"", # Kein Abbrechen-Button
  		button_text,
  		Color(0.2, 0.6, 0.8, 1) # Blau für Info
  	)
  
  	# Verbinde Signale
  	popup.confirmed.connect(func():
  		emit_signal("dialog_confirmed", id)
  		_active_popups.erase(id)
  	)
  
  	# Verstecke den Abbrechen-Button
  	popup.cancel_button.visible = false
  
  	# Speichere und zeige an
  	_active_popups[id] = popup
  	popup.popup()
  
  	return id
  
  # Schließt einen bestimmten Dialog
  func close_dialog(dialog_id: String) -> bool:
  	if _active_popups.has(dialog_id):
  		_active_popups[dialog_id].close()
  		_active_popups.erase(dialog_id)
  		return true
  	return false
  
  # Schließt alle aktiven Dialoge
  func close_all_dialogs():
  	for id in _active_popups:
  		_active_popups[id].close()
  	_active_popups.clear()
  
  # Erstellt eine neue Popup-Instanz
  func _create_popup():
  	var popup_script = load("res://scripts/ui/dialogs/popup_dialog.gd")
  	# Hier ist die Korrektur: Wir erstellen einen CanvasLayer statt eines Node
  	var popup_instance = CanvasLayer.new()
  	popup_instance.set_script(popup_script)
  	add_child(popup_instance)
  	return popup_instance
  
  # Generiert eine eindeutige ID für Dialoge
  func _generate_id() -> String:
  	return "dialog_" + str(randi())

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\hud\hud_controller.gd:
========================================
  class_name HUDController
  extends CanvasLayer
  
  ## A modular HUD manager that handles in-game UI elements
  ## Supports various gameplay elements like health, coins, and power-ups
  
  # Health system variables
  @export var max_health: float = 3.0
  @export var initial_health: float = 3.0
  var current_health: float = 3.0
  
  # Legacy properties and accessor methods
  func get_lifes() -> float:
  	return current_health
  
  func set_lifes(value: float) -> void:
  	current_health = value
  	_update_health_display()
  
  # Make sure legacy code can access lifes directly
  var lifes: float:
  	get: return get_lifes()
  	set(value): set_lifes(value)
  
  # Currency/Collectible tracking
  var coins: int = 0
  
  # Power-up and ability tracking
  var elixir_fill_level: float = 0.0
  var active_power_ups: Array = []
  var power_up_timers: Dictionary = {}
  
  # HUD Components reference
  @onready var health_display = $HeartsFull
  @onready var coins_label = $LabelCoinSum
  @onready var elixir_container = $bottle
  @onready var elixir_fill = $elixir
  
  # Optional components
  @onready var objective_display = $ObjectiveTracker if has_node("ObjectiveTracker") else null
  @onready var ability_timer_display = $AbilityTimer if has_node("AbilityTimer") else null
  
  # Notification components
  @onready var notification_container = $NotificationContainer if has_node("NotificationContainer") else null
  
  # UI Theme reference
  var ui_theme = null
  
  # Signals
  signal health_changed(new_health, max_health)
  signal coins_changed(new_amount)
  signal elixir_changed(new_level)
  signal power_up_activated(power_up_name, duration)
  signal power_up_deactivated(power_up_name)
  signal objective_updated(objective_id, progress, total)
  signal notification_shown(message, type)
  
  func _ready():
  	# Initialize health display
  	current_health = initial_health
  	lifes = current_health  # Update legacy property
  
  	if health_display:
  		_update_health_display()
  
  	# Initialize coins display
  	if coins_label:
  		coins_label.text = str(coins)
  
  	# Initialize elixir display
  	if elixir_container and elixir_fill:
  		set_elixir_fill(elixir_fill_level)
  
  	# Get UI theme if available
  	ui_theme = get_node_or_null("/root/UITheme")
  	if ui_theme:
  		_apply_theme()
  		ui_theme.theme_changed.connect(_on_theme_changed)
  
  	# Connect to game manager if available
  	var game_manager = get_node_or_null("/root/Global")
  	if game_manager:
  		game_manager.coin_collected.connect(_on_global_coin_collected)
  		game_manager.state_changed.connect(_on_game_state_changed)
  
  func _process(delta):
  	# Update power-up timers
  	for power_up_name in power_up_timers.keys():
  		var timer_data = power_up_timers[power_up_name]
  		timer_data.time_remaining -= delta
  
  		# Update UI timer if available
  		if ability_timer_display:
  			ability_timer_display.update_timer(power_up_name, timer_data.time_remaining, timer_data.duration)
  
  		# Check if power-up has expired
  		if timer_data.time_remaining <= 0:
  			_on_power_up_expired(power_up_name)
  
  # Health Management
  func set_max_health(new_max: float) -> void:
  	max_health = max(1.0, new_max)
  	current_health = min(current_health, max_health)
  	_update_health_display()
  	emit_signal("health_changed", current_health, max_health)
  
  func change_health(amount: float) -> void:
  	var old_health = current_health
  	current_health = clamp(current_health + amount, 0, max_health)
  
  	if current_health != old_health:
  		_update_health_display()
  		emit_signal("health_changed", current_health, max_health)
  
  		# Handle death
  		if current_health <= 0:
  			_on_player_death()
  		# Handle healing effects
  		elif amount > 0:
  			_show_healing_effect()
  		# Handle damage effects
  		elif amount < 0:
  			_show_damage_effect()
  
  func _update_health_display() -> void:
  	if health_display:
  		# Scale heart display based on current health
  		health_display.size.x = (current_health / max_health) * health_display.texture.get_width()
  
  # Coin Management
  func add_coins(amount: int = 1) -> void:
  	coins += amount
  	if coins_label:
  		coins_label.text = str(coins)
  	emit_signal("coins_changed", coins)
  
  	# Show collection effect
  	if amount > 0:
  		_show_coin_collect_effect()
  
  func set_coins(amount: int) -> void:
  	coins = max(0, amount)
  	if coins_label:
  		coins_label.text = str(coins)
  	emit_signal("coins_changed", coins)
  
  # Elixir/Power Meter Management
  func set_elixir_fill(fill_level: float) -> void:
  	elixir_fill_level = clamp(fill_level, 0.0, 1.0)
  
  	if elixir_fill and elixir_container:
  		# Update the visual representation
  		_update_elixir_display()
  
  	emit_signal("elixir_changed", elixir_fill_level)
  
  func update_elixir_fill(amount: float) -> void:
  	set_elixir_fill(elixir_fill_level + amount)
  
  func collect_softpower(amount: float = 0.25) -> void:
  	update_elixir_fill(amount)
  	# Show collection effect
  	_show_elixir_collect_effect()
  
  func use_softpower(amount: float = 0.25) -> bool:
  	if elixir_fill_level >= amount:
  		update_elixir_fill(-amount)
  		return true
  	return false
  
  func _update_elixir_display() -> void:
  	var elixir = elixir_fill
  	var bottle = elixir_container
  
  	# Enable region clipping for partial display
  	elixir.region_enabled = true
  
  	# Get texture size (unscaled)
  	var tex_size = elixir.texture.get_size()
  
  	# Calculate visible height based on fill level
  	var visible_height = tex_size.y * elixir_fill_level
  
  	# Set the region rect (clip from bottom)
  	elixir.region_rect = Rect2(
  		Vector2(0, tex_size.y - visible_height),
  		Vector2(tex_size.x, visible_height)
  	)
  
  	# Position the fill inside the bottle
  	var bottle_texture_size = bottle.texture.get_size()
  	var elixir_texture_size = elixir.texture.get_size()
  
  	var bottle_scale = bottle.scale
  	var elixir_scale = elixir.scale
  
  	var bottle_size = bottle_texture_size.y * bottle_scale.y
  	var elixir_size = visible_height * elixir_scale.y
  
  	# Center the elixir horizontally and position it at the bottom of bottle
  	elixir.position.x = bottle.position.x
  	elixir.position.y = bottle.position.y + ((bottle_size - elixir_size) / 2)
  
  # Power-up Management
  func activate_power_up(name: String, duration: float = 0.0) -> void:
  	# Add to active power-ups
  	if not active_power_ups.has(name):
  		active_power_ups.append(name)
  
  	# Set up timer if it has a duration
  	if duration > 0:
  		power_up_timers[name] = {
  			"duration": duration,
  			"time_remaining": duration
  		}
  
  		# Show timer UI if available
  		if ability_timer_display:
  			ability_timer_display.show_timer(name, duration)
  
  	emit_signal("power_up_activated", name, duration)
  
  	# Show activation effect
  	_show_power_up_effect(name)
  
  func deactivate_power_up(name: String) -> void:
  	if active_power_ups.has(name):
  		active_power_ups.erase(name)
  
  	if power_up_timers.has(name):
  		power_up_timers.erase(name)
  
  		# Hide timer UI if available
  		if ability_timer_display:
  			ability_timer_display.hide_timer(name)
  
  	emit_signal("power_up_deactivated", name)
  
  func has_power_up(name: String) -> bool:
  	return active_power_ups.has(name)
  
  func get_power_up_remaining_time(name: String) -> float:
  	if power_up_timers.has(name):
  		return power_up_timers[name].time_remaining
  	return 0.0
  
  func _on_power_up_expired(name: String) -> void:
  	deactivate_power_up(name)
  	_show_power_up_expiry_effect(name)
  
  # Objective System
  func update_objective(objective_id: String, progress: int, total: int, description: String = "") -> void:
  	if objective_display:
  		objective_display.update_objective(objective_id, progress, total, description)
  
  	emit_signal("objective_updated", objective_id, progress, total)
  
  func complete_objective(objective_id: String) -> void:
  	if objective_display:
  		objective_display.complete_objective(objective_id)
  
  	emit_signal("objective_updated", objective_id, 1, 1)
  
  	# Show completion effect
  	_show_objective_complete_effect()
  
  func add_objective(objective_id: String, description: String, total: int = 1) -> void:
  	if objective_display:
  		objective_display.add_objective(objective_id, description, total)
  
  	emit_signal("objective_updated", objective_id, 0, total)
  
  	# Show new objective effect
  	_show_new_objective_effect()
  
  # Notification System
  func show_notification(message: String, type: String = "info", duration: float = 3.0) -> void:
  	if notification_container:
  		notification_container.show_notification(message, type, duration)
  
  	emit_signal("notification_shown", message, type)
  
  # Visual Effects
  func _show_damage_effect() -> void:
  	# Simple screen flash for now
  	var canvas_modulate = get_node_or_null("DamageEffect")
  	if canvas_modulate:
  		var tween = create_tween()
  		canvas_modulate.color = Color(1, 0, 0, 0.3)
  		canvas_modulate.visible = true
  		tween.tween_property(canvas_modulate, "color:a", 0.0, 0.5)
  		tween.tween_callback(func(): canvas_modulate.visible = false)
  
  func _show_healing_effect() -> void:
  	# Simple green flash for healing
  	var canvas_modulate = get_node_or_null("HealEffect")
  	if canvas_modulate:
  		var tween = create_tween()
  		canvas_modulate.color = Color(0, 1, 0, 0.3)
  		canvas_modulate.visible = true
  		tween.tween_property(canvas_modulate, "color:a", 0.0, 0.5)
  		tween.tween_callback(func(): canvas_modulate.visible = false)
  
  func _show_coin_collect_effect() -> void:
  	# Animate the coin counter
  	if coins_label:
  		var tween = create_tween()
  		tween.tween_property(coins_label, "modulate", Color(1, 1, 0, 1), 0.1)
  		tween.tween_property(coins_label, "modulate", Color(1, 1, 1, 1), 0.2)
  
  func _show_elixir_collect_effect() -> void:
  	# Flash the elixir
  	if elixir_fill:
  		var tween = create_tween()
  		tween.tween_property(elixir_fill, "modulate", Color(1.5, 1.5, 1.5, 1), 0.1)
  		tween.tween_property(elixir_fill, "modulate", Color(1, 1, 1, 1), 0.2)
  
  func _show_power_up_effect(power_up_name: String) -> void:
  	# This could be customized per power-up
  	show_notification("Power-up activated: " + power_up_name, "power_up")
  
  func _show_power_up_expiry_effect(power_up_name: String) -> void:
  	show_notification("Power-up expired: " + power_up_name, "warning")
  
  func _show_objective_complete_effect() -> void:
  	show_notification("Objective completed!", "success")
  
  func _show_new_objective_effect() -> void:
  	show_notification("New objective added", "info")
  
  # Theme management
  func _apply_theme() -> void:
  	if ui_theme:
  		# Apply theme to various HUD elements
  		if coins_label:
  			coins_label.add_theme_color_override("font_color", ui_theme.get_color("accent"))
  
  		# Add more theme customizations as needed
  		pass
  
  func _on_theme_changed(theme_name: String) -> void:
  	_apply_theme()
  
  # Event handlers
  func _on_player_death() -> void:
  	var game_manager = get_node_or_null("/root/Global")
  	if game_manager:
  		game_manager.player_death()
  
  func _on_global_coin_collected(_total_coins) -> void:
  	# Update HUD to match global state
  	set_coins(get_node("/root/Global").collected_coins)
  
  func _on_game_state_changed(new_state, _old_state) -> void:
  	# Adjust HUD visibility based on game state
  	if new_state == Constants.GameState.PAUSED:
  		# Find the container to adjust visibility
  		var container = get_node_or_null("Container")
  		if container:
  			container.modulate.a = 0.5
  	else:
  		var container = get_node_or_null("Container")
  		if container:
  			container.modulate.a = 1.0
  
  # Legacy API for backward compatibility
  func change_life(amount: float) -> void:
  	change_health(amount)
  
  func load_hearts() -> void:
  	_update_health_display()
  
  func coin_collected() -> void:
  	add_coins(1)
  
  func _update_coin_display() -> void:
  	if coins_label:
  		coins_label.text = str(coins)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\hud\objective_tracker.gd:
========================================
  class_name ObjectiveTracker
  extends Control
  
  ## A UI component for tracking and displaying game objectives
  ## Supports multiple objectives with progress tracking
  
  # UI components
  @onready var objectives_container = $ObjectivesContainer
  @onready var objective_template = $ObjectiveTemplate
  
  # Data structure for tracking objectives
  var objectives = {}
  
  # Optional theme reference
  var ui_theme = null
  
  # Signals
  signal objective_added(objective_id, description, total)
  signal objective_updated(objective_id, progress, total)
  signal objective_completed(objective_id)
  signal all_objectives_completed()
  
  func _ready():
  	# Hide the template
  	if objective_template:
  		objective_template.visible = false
  
  	# Try to get UI theme
  	ui_theme = get_node_or_null("/root/UITheme")
  	if ui_theme:
  		ui_theme.theme_changed.connect(_on_theme_changed)
  		_apply_theme()
  
  # Add a new objective to track
  func add_objective(objective_id: String, description: String, total: int = 1) -> bool:
  	if objectives.has(objective_id):
  		push_warning("Objective already exists: " + objective_id)
  		return false
  
  	# Create new objective data
  	objectives[objective_id] = {
  		"description": description,
  		"progress": 0,
  		"total": total,
  		"completed": false,
  		"ui_element": null
  	}
  
  	# Create UI element
  	_create_objective_ui(objective_id)
  
  	emit_signal("objective_added", objective_id, description, total)
  	return true
  
  # Update an objective's progress
  func update_objective(objective_id: String, progress: int, total: int = -1, description: String = "") -> bool:
  	if not objectives.has(objective_id):
  		push_warning("Cannot update non-existent objective: " + objective_id)
  		return false
  
  	var objective = objectives[objective_id]
  
  	# Update the progress
  	objective.progress = progress
  
  	# Update total if specified
  	if total > 0:
  		objective.total = total
  
  	# Update description if provided
  	if description != "":
  		objective.description = description
  
  	# Check if newly completed
  	var newly_completed = false
  	if progress >= objective.total and not objective.completed:
  		objective.completed = true
  		newly_completed = true
  
  	# Update UI
  	_update_objective_ui(objective_id)
  
  	# Handle completion
  	if newly_completed:
  		emit_signal("objective_completed", objective_id)
  		_check_all_objectives_completed()
  	else:
  		emit_signal("objective_updated", objective_id, progress, objective.total)
  
  	return true
  
  # Mark an objective as complete
  func complete_objective(objective_id: String) -> bool:
  	if not objectives.has(objective_id):
  		push_warning("Cannot complete non-existent objective: " + objective_id)
  		return false
  
  	var objective = objectives[objective_id]
  
  	# Check if already completed
  	if objective.completed:
  		return true
  
  	# Set as completed
  	objective.progress = objective.total
  	objective.completed = true
  
  	# Update UI
  	_update_objective_ui(objective_id)
  
  	emit_signal("objective_completed", objective_id)
  	_check_all_objectives_completed()
  
  	return true
  
  # Remove an objective
  func remove_objective(objective_id: String) -> bool:
  	if not objectives.has(objective_id):
  		push_warning("Cannot remove non-existent objective: " + objective_id)
  		return false
  
  	var objective = objectives[objective_id]
  
  	# Remove UI element if it exists
  	if objective.ui_element and is_instance_valid(objective.ui_element):
  		objective.ui_element.queue_free()
  
  	# Remove from tracking
  	objectives.erase(objective_id)
  
  	return true
  
  # Clear all objectives
  func clear_all_objectives() -> void:
  	# Remove all UI elements
  	for objective_id in objectives:
  		var objective = objectives[objective_id]
  		if objective.ui_element and is_instance_valid(objective.ui_element):
  			objective.ui_element.queue_free()
  
  	# Clear the tracking dictionary
  	objectives.clear()
  
  # Check if all objectives are completed
  func are_all_objectives_completed() -> bool:
  	if objectives.size() == 0:
  		return false
  
  	for objective_id in objectives:
  		if not objectives[objective_id].completed:
  			return false
  
  	return true
  
  # Check if a specific objective exists
  func has_objective(objective_id: String) -> bool:
  	return objectives.has(objective_id)
  
  # Check if a specific objective is completed
  func is_objective_completed(objective_id: String) -> bool:
  	if not objectives.has(objective_id):
  		return false
  	return objectives[objective_id].completed
  
  # Get objective progress
  func get_objective_progress(objective_id: String) -> Dictionary:
  	if not objectives.has(objective_id):
  		return {}
  
  	var objective = objectives[objective_id]
  	return {
  		"progress": objective.progress,
  		"total": objective.total,
  		"completed": objective.completed
  	}
  
  # Create UI for a new objective
  func _create_objective_ui(objective_id: String) -> void:
  	if not objective_template or not objectives_container:
  		push_error("Objective tracker UI components not found")
  		return
  
  	var objective = objectives[objective_id]
  
  	# Create from template
  	var new_objective_ui = objective_template.duplicate()
  	new_objective_ui.name = "Objective_" + objective_id
  	new_objective_ui.visible = true
  	objectives_container.add_child(new_objective_ui)
  
  	# Set initial content
  	var description_label = new_objective_ui.get_node_or_null("Description")
  	var progress_label = new_objective_ui.get_node_or_null("Progress")
  	var progress_bar = new_objective_ui.get_node_or_null("ProgressBar")
  
  	if description_label:
  		description_label.text = objective.description
  
  	if progress_label:
  		if objective.total > 1:
  			progress_label.text = str(objective.progress) + " / " + str(objective.total)
  		else:
  			progress_label.visible = false
  
  	if progress_bar:
  		if objective.total > 1:
  			progress_bar.max_value = objective.total
  			progress_bar.value = objective.progress
  		else:
  			progress_bar.visible = false
  
  	# Store the UI reference
  	objective.ui_element = new_objective_ui
  
  	# Apply theme
  	if ui_theme:
  		_apply_theme_to_objective(new_objective_ui, objective.completed)
  
  # Update UI for an existing objective
  func _update_objective_ui(objective_id: String) -> void:
  	if not objectives.has(objective_id):
  		return
  
  	var objective = objectives[objective_id]
  	var ui_element = objective.ui_element
  
  	if not ui_element or not is_instance_valid(ui_element):
  		return
  
  	# Update content
  	var description_label = ui_element.get_node_or_null("Description")
  	var progress_label = ui_element.get_node_or_null("Progress")
  	var progress_bar = ui_element.get_node_or_null("ProgressBar")
  	var completed_icon = ui_element.get_node_or_null("CompletedIcon")
  
  	if description_label:
  		description_label.text = objective.description
  
  	if progress_label:
  		if objective.total > 1:
  			progress_label.text = str(objective.progress) + " / " + str(objective.total)
  			progress_label.visible = true
  		else:
  			progress_label.visible = false
  
  	if progress_bar:
  		if objective.total > 1:
  			progress_bar.max_value = objective.total
  			progress_bar.value = objective.progress
  			progress_bar.visible = true
  		else:
  			progress_bar.visible = false
  
  	if completed_icon:
  		completed_icon.visible = objective.completed
  
  	# Apply theme with completion state
  	if ui_theme:
  		_apply_theme_to_objective(ui_element, objective.completed)
  
  	# Apply completed styling
  	if objective.completed:
  		# Visual indication of completion
  		if description_label:
  			description_label.modulate = Color(0.7, 1.0, 0.7)  # Slight green tint
  
  		# Add completion animation if needed
  		if not ui_element.has_meta("completion_animated"):
  			var tween = create_tween()
  			tween.tween_property(ui_element, "modulate", Color(1.5, 1.5, 1.5), 0.2)
  			tween.tween_property(ui_element, "modulate", Color(1, 1, 1), 0.3)
  			ui_element.set_meta("completion_animated", true)
  
  # Check if all objectives are completed and emit signal if so
  func _check_all_objectives_completed() -> void:
  	if are_all_objectives_completed():
  		emit_signal("all_objectives_completed")
  
  # Apply theme to the entire tracker
  func _apply_theme() -> void:
  	if not ui_theme:
  		return
  
  	# Apply to container background if needed
  	var panel = get_node_or_null("Background")
  	if panel and panel is Panel:
  		var style = ui_theme.create_panel_style("background", "", "small", 0)
  		panel.add_theme_stylebox_override("panel", style)
  
  	# Apply to all objective UI elements
  	for objective_id in objectives:
  		var objective = objectives[objective_id]
  		if objective.ui_element and is_instance_valid(objective.ui_element):
  			_apply_theme_to_objective(objective.ui_element, objective.completed)
  
  # Apply theme to a specific objective UI element
  func _apply_theme_to_objective(ui_element: Control, is_completed: bool) -> void:
  	if not ui_theme:
  		return
  
  	var description_label = ui_element.get_node_or_null("Description")
  	var progress_label = ui_element.get_node_or_null("Progress")
  	var progress_bar = ui_element.get_node_or_null("ProgressBar")
  
  	if description_label:
  		var color = ui_theme.get_color("success") if is_completed else ui_theme.get_color("foreground")
  		description_label.add_theme_color_override("font_color", color)
  
  	if progress_label:
  		progress_label.add_theme_color_override("font_color", ui_theme.get_color("secondary"))
  
  	if progress_bar:
  		# Style the progress bar
  		var fg_stylebox = StyleBoxFlat.new()
  		fg_stylebox.bg_color = ui_theme.get_color("primary")
  		fg_stylebox.corner_radius_top_left = ui_theme.get_corner_radius("small")
  		fg_stylebox.corner_radius_top_right = ui_theme.get_corner_radius("small")
  		fg_stylebox.corner_radius_bottom_left = ui_theme.get_corner_radius("small")
  		fg_stylebox.corner_radius_bottom_right = ui_theme.get_corner_radius("small")
  
  		var bg_stylebox = fg_stylebox.duplicate()
  		bg_stylebox.bg_color = ui_theme.get_color("background").lightened(0.1)
  
  		progress_bar.add_theme_stylebox_override("fill", fg_stylebox)
  		progress_bar.add_theme_stylebox_override("background", bg_stylebox)
  
  # Handle theme changes
  func _on_theme_changed(_theme_name) -> void:
  	_apply_theme()

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\main_menu\camera.gd:
========================================
  class_name Camera
  extends Camera2D
  
  
  # Called when the node enters the scene tree for the first time.
  func _ready():
  	pass # Replace with function body.
  
  
  # Called every frame. 'delta' is the elapsed time since the previous frame.
  func _process(delta):
  	pass

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\main_menu\customizer_button.gd:
========================================
  class_name CustomizerButton
  extends Button
  
  
  # Called when the node enters the scene tree for the first time.
  func _ready():
  	pass # Replace with function body.
  
  
  # Called every frame. 'delta' is the elapsed time since the previous frame.
  func _process(delta):
  	pass

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\main_menu\main_menu.gd:
========================================
  class_name MainMenu
  extends Node2D
  
  
  func _on_exit_button_pressed():
  	get_tree().quit()
  
  
  func _on_settings_button_pressed():
  	get_tree().change_scene_to_file("res://scenes/ui/settings/settings_menu.tscn")
  
  
  func _on_start_button_pressed():
  	get_tree().change_scene_to_file("res://scenes/levels/adventure_mode/base_level.tscn")

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\main_menu\menu_buttons.gd:
========================================
  class_name MenuButtons
  extends Button
  
  
  # Called when the node enters the scene tree for the first time.
  func _ready():
  	pass # Replace with function body.
  
  
  # Called every frame. 'delta' is the elapsed time since the previous frame.
  func _process(_delta):
  	pass

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\main_menu\start_background.gd:
========================================
  class_name StartBackground
  extends ParallaxBackground
  
  var scrolling_speed = 50
  # Called every frame. 'delta' is the elapsed time since the previous frame.
  func _process(delta):
  	scroll_offset.x -= scrolling_speed * delta

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\settings\audio_settings.gd:
========================================
  class_name AudioSettings
  extends Node2D
  
  
  # Called when the node enters the scene tree for the first time.
  func _ready():
  	pass # Replace with function body.
  
  
  # Called every frame. 'delta' is the elapsed time since the previous frame.
  func _process(delta):
  	pass
  
  
  func _on_back_button_pressed():
  	get_tree().change_scene_to_file("res://scenes/ui/settings/settings_menu.tscn")
  
  var master_bus = AudioServer.get_bus_index("Master")
  
  
  func _on_h_slider_value_changed(value):
  	AudioServer.set_bus_volume_db(master_bus, value)
  
  	if value == -30:
  		AudioServer.set_bus_mute(master_bus, true)
  	else:
  		AudioServer.set_bus_mute(master_bus, false)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\settings\settings_menu.gd:
========================================
  class_name SettingsMenu
  extends Node2D
  
  "res://scripts/ui/settings/settings_menu.gd"
  # Called when the node enters the scene tree for the first time.
  func _ready():
  	pass # Replace with function body.
  
  
  # Called every frame. 'delta' is the elapsed time since the previous frame.
  func _process(delta):
  	pass
  
  
  func _on_back_button_pressed():
  	get_tree().change_scene_to_file("res://scenes/ui/main_menu/main_menu.tscn")
  
  
  func _on_audio_button_pressed():
  	get_tree().change_scene_to_file("res://scenes/ui/settings/audio_settings.tscn")
  
  
  func _on_customizer_button_pressed():
  	get_tree().change_scene_to_file("res://scenes/ui/character_customizer/customizer.tscn")

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\utils\game_resource_preloader.gd:
========================================
  class_name GameResourcePreloader
  extends Node
  
  ## A utility class for preloading and managing game resources
  ## Helps improve loading times by caching frequently used resources
  
  # Resource cache organized by type and ID
  var _cache = {
  	"scenes": {},
  	"textures": {},
  	"audio": {},
  	"fonts": {},
  	"materials": {},
  	"animations": {},
  	"other": {}
  }
  
  # Signal emitted when a resource is loaded
  signal resource_loaded(type, id, resource)
  # Signal emitted when all queued resources are loaded
  signal all_resources_loaded()
  # Signal emitted on loading progress update
  signal loading_progress(progress, total)
  
  # Queue of resources to load
  var _load_queue = []
  # Count of loaded resources
  var _loaded_count = 0
  # Whether we're currently loading resources
  var _is_loading = false
  # Progress interval for emitting loading_progress signals
  var _progress_interval = 0.1
  var _last_progress_time = 0
  
  ## Initialize with default resources to preload
  func _ready():
  	# Nothing to preload by default
  	pass
  
  ## Add a resource to the preload queue
  func queue_resource(path: String, type: String = "other", id: String = ""):
  	if id == "":
  		id = path.get_file().get_basename()
  
  	# Check if already in cache
  	if has_resource(type, id):
  		return true
  
  	# Add to queue
  	_load_queue.append({
  		"path": path,
  		"type": type,
  		"id": id
  	})
  
  	return true
  
  ## Start loading all queued resources
  func load_queued_resources(use_thread: bool = true):
  	if _is_loading:
  		return false
  
  	if _load_queue.size() == 0:
  		emit_signal("all_resources_loaded")
  		return true
  
  	_is_loading = true
  	_loaded_count = 0
  	_last_progress_time = Time.get_ticks_msec() / 1000.0
  
  	if use_thread:
  		_start_threaded_loading()
  	else:
  		_start_immediate_loading()
  
  	return true
  
  ## Load a single resource immediately
  func load_resource(path: String, type: String = "other", id: String = "") -> Resource:
  	if id == "":
  		id = path.get_file().get_basename()
  
  	# Check if already in cache
  	if has_resource(type, id):
  		return get_resource(type, id)
  
  	# Load and cache
  	var resource = ResourceLoader.load(path)
  	if resource:
  		_cache_resource(resource, type, id)
  		emit_signal("resource_loaded", type, id, resource)
  		return resource
  
  	push_error("Failed to load resource: " + path)
  	return null
  
  ## Check if a resource is in the cache
  func has_resource(type: String, id: String) -> bool:
  	if not _cache.has(type):
  		return false
  	return _cache[type].has(id)
  
  ## Get a resource from the cache
  func get_resource(type: String, id: String) -> Resource:
  	if not has_resource(type, id):
  		push_error("Resource not found in cache: " + type + "/" + id)
  		return null
  
  	return _cache[type][id]
  
  ## Clear the cache for a specific type
  func clear_cache(type: String = ""):
  	if type == "":
  		# Clear all caches
  		for t in _cache:
  			_cache[t].clear()
  	elif _cache.has(type):
  		_cache[type].clear()
  
  ## Clear the load queue
  func clear_queue():
  	_load_queue.clear()
  	_loaded_count = 0
  	_is_loading = false
  
  ## Get cache statistics
  func get_cache_stats() -> Dictionary:
  	var stats = {}
  
  	for type in _cache:
  		stats[type] = _cache[type].size()
  
  	stats["total"] = 0
  	for type in stats:
  		stats["total"] += stats[type]
  
  	return stats
  
  ## Process loading queue in the main thread (immediate)
  func _start_immediate_loading():
  	for resource_info in _load_queue:
  		var resource = ResourceLoader.load(resource_info.path)
  		if resource:
  			_cache_resource(resource, resource_info.type, resource_info.id)
  			_loaded_count += 1
  
  			# Emit progress signal at intervals
  			var current_time = Time.get_ticks_msec() / 1000.0
  			if current_time - _last_progress_time >= _progress_interval:
  				_last_progress_time = current_time
  				emit_signal("loading_progress", _loaded_count, _load_queue.size())
  
  			emit_signal("resource_loaded", resource_info.type, resource_info.id, resource)
  		else:
  			push_error("Failed to load resource: " + resource_info.path)
  
  	_load_queue.clear()
  	_is_loading = false
  	emit_signal("loading_progress", _loaded_count, _loaded_count)
  	emit_signal("all_resources_loaded")
  
  ## Process loading queue in a background thread
  func _start_threaded_loading():
  	# Create a new thread for loading
  	var thread = Thread.new()
  	thread.start(Callable(self, "_threaded_loading"))
  
  	# Thread cleanup will happen in _threaded_loading
  
  ## Thread function for background loading
  func _threaded_loading():
  	var total = _load_queue.size()
  
  	for resource_info in _load_queue:
  		var path = resource_info.path
  		var type = resource_info.type
  		var id = resource_info.id
  
  		# Use ResourceLoader.load_threaded_request to start loading
  		ResourceLoader.load_threaded_request(path)
  
  		# Poll until loading completes
  		var status = ResourceLoader.load_threaded_get_status(path)
  		while status == ResourceLoader.THREAD_LOAD_IN_PROGRESS:
  			OS.delay_msec(10) # Small delay to prevent high CPU usage
  			status = ResourceLoader.load_threaded_get_status(path)
  
  		# Process the result
  		if status == ResourceLoader.THREAD_LOAD_LOADED:
  			var resource = ResourceLoader.load_threaded_get(path)
  			if resource:
  				# Use call_deferred to update the cache on the main thread
  				call_deferred("_cache_resource", resource, type, id)
  				_loaded_count += 1
  
  				# Emit signals on the main thread
  				var progress_data = {"count": _loaded_count, "total": total}
  				call_deferred("_emit_loading_progress", progress_data)
  				call_deferred("_emit_resource_loaded", type, id, resource)
  			else:
  				push_error("Failed to load threaded resource: " + path)
  		else:
  			push_error("Failed to load threaded resource: " + path + ", status: " + str(status))
  
  	# Clear queue and emit completion on the main thread
  	call_deferred("_finish_loading")
  
  	# Thread cleanup happens automatically in Godot 4.x
  
  ## Safely emit loading progress signal from thread
  func _emit_loading_progress(data: Dictionary):
  	var current_time = Time.get_ticks_msec() / 1000.0
  	if current_time - _last_progress_time >= _progress_interval:
  		_last_progress_time = current_time
  		emit_signal("loading_progress", data.count, data.total)
  
  ## Safely emit resource loaded signal from thread
  func _emit_resource_loaded(type: String, id: String, resource: Resource):
  	emit_signal("resource_loaded", type, id, resource)
  
  ## Finish loading process
  func _finish_loading():
  	_load_queue.clear()
  	_is_loading = false
  	emit_signal("loading_progress", _loaded_count, _loaded_count)
  	emit_signal("all_resources_loaded")
  
  ## Add a resource to the cache
  func _cache_resource(resource: Resource, type: String, id: String):
  	# Create the type category if it doesn't exist
  	if not _cache.has(type):
  		_cache[type] = {}
  
  	# Cache the resource
  	_cache[type][id] = resource
  
  ## Preload common resources for a specific level or scene
  func preload_level_resources(level_name: String) -> bool:
  	# This method should be customized per game to preload
  	# appropriate resources for each level
  	match level_name:
  		"main_menu":
  			queue_resource("res://scenes/ui/main_menu/main_menu.tscn", "scenes", "main_menu")
  			# Add UI elements, backgrounds, etc.
  			return true
  
  		"adventure_level":
  			queue_resource("res://scenes/levels/adventure_mode/adventure_level.tscn", "scenes", "adventure_level")
  			# Add player, enemies, items, etc.
  			return true
  
  		_:
  			push_warning("No preload configuration for level: " + level_name)
  			return false
  
  	return false
  
  ## Unload resources that are not needed for the current scene
  func unload_unused_resources(keep_types: Array = []):
  	var stats_before = get_cache_stats()
  
  	# Keep all resources of specified types
  	for type in _cache:
  		if type in keep_types:
  			continue
  
  		# Clear this type of resources
  		_cache[type].clear()
  
  	var stats_after = get_cache_stats()
  	print("Unloaded resources - Before: ", stats_before.total, ", After: ", stats_after.total)
  
  	# Force garbage collection
  	ResourceLoader.load_threaded_request("res://")
  	ResourceLoader.load_threaded_get_status("res://")

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\utils\killzone.gd:
========================================
  class_name Killzone
  extends Area2D
  
  @onready var timer = $Timer
  
  func _on_body_entered(body):
  	print("you died!")
  	Engine.time_scale = 0.5
  	body.get_node("CollisionShape2D").queue_free()
  	timer.start()
  
  
  
  func _on_timer_timeout():
  	Engine.time_scale = 1.0
  	get_tree().reload_current_scene()

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\utils\object_pool.gd:
========================================
  class_name ObjectPool
  extends Node
  
  ## A generic object pooling system for reusing objects instead of creating and destroying them
  
  # The scene to create objects from
  var scene: PackedScene
  # Maximum number of objects to keep in the pool (0 = unlimited)
  var max_size: int = 0
  # Container for inactive objects
  var inactive_objects: Array = []
  # Container to track all spawned objects (both active and inactive)
  var all_objects: Array = []
  # Whether to automatically resize the pool as needed
  var auto_resize: bool = true
  # Parent node for spawned objects
  var parent_node: Node = null
  
  # Signal emitted when an object is taken from the pool
  signal object_spawned(object)
  # Signal emitted when an object is returned to the pool
  signal object_recycled(object)
  
  ## Create a new object pool with the specified scene
  func _init(object_scene: PackedScene, pool_size: int = 10, auto_resize_pool: bool = true):
  	scene = object_scene
  	max_size = pool_size
  	auto_resize = auto_resize_pool
  
  	# Pre-populate the pool with objects
  	for i in range(pool_size):
  		var obj = _create_object()
  		inactive_objects.append(obj)
  		all_objects.append(obj)
  
  ## Set the parent node for all pooled objects
  func set_parent(parent: Node):
  	parent_node = parent
  
  	# Reparent existing objects
  	for obj in all_objects:
  		if obj.get_parent():
  			obj.get_parent().remove_child(obj)
  		parent_node.add_child(obj)
  
  ## Get an object from the pool, or create a new one if the pool is empty
  func get_object() -> Node:
  	var obj = null
  
  	if inactive_objects.size() > 0:
  		# Take an object from the inactive pool
  		obj = inactive_objects.pop_back()
  	elif auto_resize:
  		# Create a new object if we're allowed to resize the pool
  		obj = _create_object()
  		all_objects.append(obj)
  	else:
  		push_error("Object pool is empty and auto-resize is disabled!")
  		return null
  
  	if obj.has_method("_on_spawn_from_pool"):
  		obj._on_spawn_from_pool()
  
  	# Ensure the object is visible and active
  	obj.visible = true
  	obj.process_mode = Node.PROCESS_MODE_INHERIT
  
  	emit_signal("object_spawned", obj)
  	return obj
  
  ## Return an object to the pool for reuse
  func recycle(obj: Node) -> void:
  	if not all_objects.has(obj):
  		push_error("Attempted to recycle an object that wasn't created by this pool!")
  		return
  
  	# Make sure it's not already in the inactive pool
  	if inactive_objects.has(obj):
  		return
  
  	# Prepare the object for recycling
  	if obj.has_method("_on_recycle_to_pool"):
  		obj._on_recycle_to_pool()
  
  	# Hide and disable the object
  	obj.visible = false
  	obj.process_mode = Node.PROCESS_MODE_DISABLED
  
  	# Add to inactive pool, respecting max size
  	if max_size <= 0 or inactive_objects.size() < max_size:
  		inactive_objects.append(obj)
  	else:
  		# If the pool is full, destroy the object
  		all_objects.erase(obj)
  		obj.queue_free()
  
  	emit_signal("object_recycled", obj)
  
  ## Clear the entire pool, freeing all objects
  func clear_pool() -> void:
  	for obj in all_objects:
  		obj.queue_free()
  
  	inactive_objects.clear()
  	all_objects.clear()
  
  ## Resize the pool to the specified size
  func resize(new_size: int) -> void:
  	if new_size < 0:
  		push_error("Cannot resize pool to negative size!")
  		return
  
  	if new_size < inactive_objects.size():
  		# Need to shrink the pool
  		while inactive_objects.size() > new_size:
  			var obj = inactive_objects.pop_back()
  			all_objects.erase(obj)
  			obj.queue_free()
  	else:
  		# Need to grow the pool
  		for i in range(new_size - inactive_objects.size()):
  			var obj = _create_object()
  			inactive_objects.append(obj)
  			all_objects.append(obj)
  
  	max_size = new_size
  
  ## Get the current number of active objects
  func active_count() -> int:
  	return all_objects.size() - inactive_objects.size()
  
  ## Get the current number of inactive objects
  func inactive_count() -> int:
  	return inactive_objects.size()
  
  ## Get the total number of objects managed by this pool
  func total_count() -> int:
  	return all_objects.size()
  
  ## Create a new object and set it up for the pool
  func _create_object() -> Node:
  	var obj = scene.instantiate()
  
  	# Set up parent if specified
  	if parent_node:
  		parent_node.add_child(obj)
  
  	# Hide and disable by default
  	obj.visible = false
  	obj.process_mode = Node.PROCESS_MODE_DISABLED
  
  	return obj

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\utils\save_data.gd:
========================================
  class_name SaveData
  extends Resource
  
  ## Data structure for saved games in The Little Saint
  ## Stores player stats, game progress, and settings
  
  # Version for compatibility checks
  @export var save_version: int = 1
  
  # Save metadata
  @export var save_date: String = ""
  @export var playtime_seconds: int = 0
  
  # Player position and level
  @export var player_position: Vector2 = Vector2.ZERO
  @export var current_level: String = ""
  
  # Player stats
  @export var health: float = 3.0
  @export var coins: int = 0
  @export var player_speed: float = Constants.PLAYER_DEFAULT_SPEED
  @export var player_jump_velocity: float = Constants.PLAYER_DEFAULT_JUMP_VELOCITY
  @export var player_fly_velocity: float = Constants.PLAYER_DEFAULT_FLY_VELOCITY
  @export var player_gravity: float = Constants.PLAYER_DEFAULT_GRAVITY
  
  # Player state
  @export var player_mode: String = "normal"
  @export var player_passed_fly_time: float = 0.0
  @export var player_jump_counter: int = 0
  @export var player_ready_for_jump: bool = true
  @export var player_allowed_jumps: int = 1
  
  # Player appearance
  @export var player_outfit: Dictionary = {}
  
  # Game progress
  @export var collected_coins: int = 0
  @export var unlocked_levels: Array = []
  @export var completed_quests: Array = []
  
  # Initialize with default values
  func _init():
  	save_date = Time.get_datetime_string_from_system(false, true)
  
  	# Set default player outfit if none exists
  	if player_outfit.is_empty():
  		# Create a default outfit
  		player_outfit = {
  			"beard": "none",
  			"lipstick": "none",
  			"eyes": "1",
  			"shoes": "1",
  			"earrings": "none",
  			"hats": "none",
  			"glasses": "none",
  			"clothes_down": "1",
  			"clothes_up": "1",
  			"clothes_complete": "none",
  			"bodies": "1",
  			"hair": "1"
  		}
  
  # Validate the save data to ensure it's not corrupted
  func validate() -> bool:
  	# Basic validation to ensure critical fields are present
  	if player_speed <= 0 or player_gravity <= 0:
  		return false
  
  	# Check that outfit dictionary has expected keys
  	var required_outfit_keys = [
  		"beard", "lipstick", "eyes", "shoes", "earrings",
  		"hats", "glasses", "clothes_down", "clothes_up",
  		"clothes_complete", "bodies", "hair"
  	]
  
  	for key in required_outfit_keys:
  		if not player_outfit.has(key):
  			return false
  
  	return true
  
  # Create a dictionary representation of the save data for debug purposes
  func to_dict() -> Dictionary:
  	return {
  		"save_version": save_version,
  		"save_date": save_date,
  		"playtime_seconds": playtime_seconds,
  		"player_position": {"x": player_position.x, "y": player_position.y},
  		"current_level": current_level,
  		"health": health,
  		"coins": coins,
  		"player_speed": player_speed,
  		"player_jump_velocity": player_jump_velocity,
  		"player_fly_velocity": player_fly_velocity,
  		"player_gravity": player_gravity,
  		"player_mode": player_mode,
  		"player_passed_fly_time": player_passed_fly_time,
  		"player_jump_counter": player_jump_counter,
  		"player_ready_for_jump": player_ready_for_jump,
  		"player_allowed_jumps": player_allowed_jumps,
  		"player_outfit": player_outfit,
  		"collected_coins": collected_coins,
  		"unlocked_levels": unlocked_levels,
  		"completed_quests": completed_quests
  	}
  
  # Return a string representation for debugging
  func _to_string() -> String:
  	return JSON.stringify(to_dict(), "\t")
  
  # Update playtime
  func update_playtime(seconds_to_add: int) -> void:
  	playtime_seconds += seconds_to_add
  
  # Get formatted playtime as string
  func get_playtime_string() -> String:
  	var hours = playtime_seconds / 3600
  	var minutes = (playtime_seconds % 3600) / 60
  	var seconds = playtime_seconds % 60
  
  	return "%02d:%02d:%02d" % [hours, minutes, seconds]
  
  # Create a deep copy of this save data
  func duplicate_data() -> SaveData:
  	var new_data = SaveData.new()
  
  	new_data.save_version = save_version
  	new_data.save_date = save_date
  	new_data.playtime_seconds = playtime_seconds
  	new_data.player_position = player_position
  	new_data.current_level = current_level
  	new_data.health = health
  	new_data.coins = coins
  	new_data.player_speed = player_speed
  	new_data.player_jump_velocity = player_jump_velocity
  	new_data.player_fly_velocity = player_fly_velocity
  	new_data.player_gravity = player_gravity
  	new_data.player_mode = player_mode
  	new_data.player_passed_fly_time = player_passed_fly_time
  	new_data.player_jump_counter = player_jump_counter
  	new_data.player_ready_for_jump = player_ready_for_jump
  	new_data.player_allowed_jumps = player_allowed_jumps
  	new_data.player_outfit = player_outfit.duplicate(true)
  	new_data.collected_coins = collected_coins
  	new_data.unlocked_levels = unlocked_levels.duplicate()
  	new_data.completed_quests = completed_quests.duplicate()
  
  	return new_data
  
  # Create a new save with default values
  static func create_new_save() -> SaveData:
  	var save = SaveData.new()
  	save.save_date = Time.get_datetime_string_from_system(false, true)
  	return save

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\utils\ui_theme.gd:
========================================
  class_name UITheme
  extends Node
  
  ## A central manager for UI themes and styling across the game
  ## Handles theme properties, color palettes, and consistent UI elements
  
  # Current theme name
  var current_theme: String = "default"
  
  # Available themes
  var available_themes: Array = ["default", "dark", "light", "custom"]
  
  # Color palettes for each theme
  var theme_colors = {
  	"default": {
  		"background": Color("#1f1f1f"),
  		"foreground": Color("#ffffff"),
  		"primary": Color("#e7896a"),      # Clay/terracotta color from your game
  		"secondary": Color("#4aa8d8"),    # Blue accent
  		"accent": Color("#a8d84a"),       # Green accent
  		"error": Color("#d84a4a"),        # Red for errors/warnings
  		"success": Color("#4ad84a"),      # Green for success
  		"warning": Color("#d8d84a"),      # Yellow for warnings
  		"disabled": Color("#7f7f7f"),     # Gray for disabled elements
  		"transparent": Color(0, 0, 0, 0)  # Fully transparent
  	},
  	"dark": {
  		"background": Color("#121212"),
  		"foreground": Color("#f0f0f0"),
  		"primary": Color("#d87a5f"),      # Darker clay color
  		"secondary": Color("#3a8ab8"),    # Darker blue
  		"accent": Color("#8ab83a"),       # Darker green
  		"error": Color("#b83a3a"),        # Darker red
  		"success": Color("#3ab83a"),      # Darker green
  		"warning": Color("#b8b83a"),      # Darker yellow
  		"disabled": Color("#5f5f5f"),     # Darker gray
  		"transparent": Color(0, 0, 0, 0)
  	},
  	"light": {
  		"background": Color("#f5f5f5"),
  		"foreground": Color("#202020"),
  		"primary": Color("#ff9478"),      # Lighter clay color
  		"secondary": Color("#78c4ff"),    # Lighter blue
  		"accent": Color("#c4ff78"),       # Lighter green
  		"error": Color("#ff7878"),        # Lighter red
  		"success": Color("#78ff78"),      # Lighter green
  		"warning": Color("#ffff78"),      # Lighter yellow
  		"disabled": Color("#a0a0a0"),     # Lighter gray
  		"transparent": Color(0, 0, 0, 0)
  	},
  	"custom": {
  		# Will be populated from user settings
  	}
  }
  
  # Font sizes for different UI elements
  var font_sizes = {
  	"small": 12,
  	"regular": 16,
  	"large": 20,
  	"title": 24,
  	"heading": 32
  }
  
  # Margin and padding sizes
  var spacing = {
  	"tiny": 2,
  	"small": 4,
  	"regular": 8,
  	"large": 16,
  	"xlarge": 24
  }
  
  # Corner radius for UI elements
  var corner_radius = {
  	"none": 0,
  	"small": 4,
  	"regular": 8,
  	"large": 16,
  	"pill": 9999  # Very large value for pill shape
  }
  
  # Animation durations
  var animation_durations = {
  	"fast": 0.1,
  	"regular": 0.3,
  	"slow": 0.5
  }
  
  # Default fonts
  var fonts = {
  	"regular": null,
  	"bold": null,
  	"title": null,
  	"monospace": null
  }
  
  # Signal emitted when theme changes
  signal theme_changed(theme_name)
  
  # Initialize the theme system
  func _ready():
  	# Load fonts
  	_load_fonts()
  
  	# Try to load user theme preferences
  	_load_theme_preferences()
  
  	print("UI Theme Manager initialized with theme: ", current_theme)
  
  # Set the active theme
  func set_theme(theme_name: String) -> bool:
  	if theme_name in available_themes:
  		current_theme = theme_name
  		emit_signal("theme_changed", theme_name)
  		return true
  	return false
  
  # Get a color from the current theme
  func get_color(color_name: String) -> Color:
  	if theme_colors.has(current_theme) and theme_colors[current_theme].has(color_name):
  		return theme_colors[current_theme][color_name]
  
  	# Fallback to default theme
  	if theme_colors["default"].has(color_name):
  		return theme_colors["default"][color_name]
  
  	# Ultimate fallback
  	push_warning("Color not found: " + color_name)
  	return Color.WHITE
  
  # Get a font size
  func get_font_size(size_name: String) -> int:
  	if font_sizes.has(size_name):
  		return font_sizes[size_name]
  
  	push_warning("Font size not found: " + size_name)
  	return font_sizes["regular"]
  
  # Get spacing value
  func get_spacing(spacing_name: String) -> int:
  	if spacing.has(spacing_name):
  		return spacing[spacing_name]
  
  	push_warning("Spacing not found: " + spacing_name)
  	return spacing["regular"]
  
  # Get corner radius
  func get_corner_radius(radius_name: String) -> int:
  	if corner_radius.has(radius_name):
  		return corner_radius[radius_name]
  
  	push_warning("Corner radius not found: " + radius_name)
  	return corner_radius["regular"]
  
  # Get animation duration
  func get_animation_duration(duration_name: String) -> float:
  	if animation_durations.has(duration_name):
  		return animation_durations[duration_name]
  
  	push_warning("Animation duration not found: " + duration_name)
  	return animation_durations["regular"]
  
  # Get a font
  func get_font(font_name: String) -> Font:
  	if fonts.has(font_name) and fonts[font_name] != null:
  		return fonts[font_name]
  
  	push_warning("Font not found: " + font_name)
  	return fonts["regular"] if fonts["regular"] != null else null
  
  # Create a panel style with theme colors
  func create_panel_style(
  	bg_color_name: String = "background",
  	border_color_name: String = "",
  	radius_name: String = "regular",
  	border_width: int = 0
  ) -> StyleBoxFlat:
  	var style = StyleBoxFlat.new()
  
  	# Set background color
  	style.bg_color = get_color(bg_color_name)
  
  	# Set corner radius
  	var radius = get_corner_radius(radius_name)
  	style.corner_radius_top_left = radius
  	style.corner_radius_top_right = radius
  	style.corner_radius_bottom_left = radius
  	style.corner_radius_bottom_right = radius
  
  	# Set border if requested
  	if border_color_name != "" and border_width > 0:
  		style.border_width_left = border_width
  		style.border_width_top = border_width
  		style.border_width_right = border_width
  		style.border_width_bottom = border_width
  		style.border_color = get_color(border_color_name)
  
  	return style
  
  # Create a button style with normal, hover, pressed states
  func create_button_style(
  	normal_color_name: String = "primary",
  	hover_color_name: String = "",
  	pressed_color_name: String = "",
  	disabled_color_name: String = "disabled",
  	radius_name: String = "regular",
  	border_width: int = 0
  ) -> Dictionary:
  	# Get the normal color
  	var normal_color = get_color(normal_color_name)
  
  	# Calculate derived colors or get specified colors
  	var hover_color: Color
  	var pressed_color: Color
  
  	if hover_color_name == "":
  		hover_color = normal_color.lightened(0.1)
  	else:
  		hover_color = get_color(hover_color_name)
  
  	if pressed_color_name == "":
  		pressed_color = normal_color.darkened(0.1)
  	else:
  		pressed_color = get_color(pressed_color_name)
  
  	# Create styles for each state
  	var normal_style = create_panel_style(normal_color_name, "", radius_name, border_width)
  
  	var hover_style = normal_style.duplicate()
  	hover_style.bg_color = hover_color
  
  	var pressed_style = normal_style.duplicate()
  	pressed_style.bg_color = pressed_color
  
  	var disabled_style = normal_style.duplicate()
  	disabled_style.bg_color = get_color(disabled_color_name)
  
  	return {
  		"normal": normal_style,
  		"hover": hover_style,
  		"pressed": pressed_style,
  		"disabled": disabled_style
  	}
  
  # Apply theme to a control
  func apply_theme_to_control(control: Control, theme_preset: String = "default") -> void:
  	match theme_preset:
  		"default":
  			_apply_default_theme(control)
  		"button":
  			_apply_button_theme(control)
  		"panel":
  			_apply_panel_theme(control)
  		"label":
  			_apply_label_theme(control)
  		_:
  			push_warning("Unknown theme preset: " + theme_preset)
  			_apply_default_theme(control)
  
  # Set custom theme colors
  func set_custom_colors(colors: Dictionary) -> void:
  	for color_name in colors:
  		if color_name in theme_colors["custom"]:
  			theme_colors["custom"][color_name] = colors[color_name]
  
  	# Ensure all colors are defined
  	for color_name in theme_colors["default"]:
  		if not theme_colors["custom"].has(color_name):
  			theme_colors["custom"][color_name] = theme_colors["default"][color_name]
  
  	# If custom theme is current, notify of change
  	if current_theme == "custom":
  		emit_signal("theme_changed", current_theme)
  
  # Save theme preferences
  func save_theme_preferences() -> bool:
  	var config = ConfigFile.new()
  
  	# Store current theme
  	config.set_value("theme", "current_theme", current_theme)
  
  	# Store custom theme colors
  	config.set_value("theme", "custom_colors", theme_colors["custom"])
  
  	# Store font sizes
  	config.set_value("theme", "font_sizes", font_sizes)
  
  	# Save the config
  	var err = config.save("user://theme_settings.cfg")
  	return err == OK
  
  # Load the fonts
  func _load_fonts() -> void:
  	var default_font = load("res://assets/fonts/general/default_font.tres") if ResourceLoader.exists("res://assets/fonts/general/default_font.tres") else null
  
  	fonts["regular"] = default_font
  	fonts["bold"] = load("res://assets/fonts/general/default_font_bold.tres") if ResourceLoader.exists("res://assets/fonts/general/default_font_bold.tres") else default_font
  	fonts["title"] = load("res://assets/fonts/special/copyduck/Copyduck.ttf") if ResourceLoader.exists("res://assets/fonts/special/copyduck/Copyduck.ttf") else default_font
  	fonts["monospace"] = load("res://assets/fonts/general/default_mono.tres") if ResourceLoader.exists("res://assets/fonts/general/default_mono.tres") else default_font
  
  # Load theme preferences from config
  func _load_theme_preferences() -> void:
  	var config = ConfigFile.new()
  	var err = config.load("user://theme_settings.cfg")
  
  	if err == OK:
  		# Load current theme
  		var saved_theme = config.get_value("theme", "current_theme", "default")
  		if saved_theme in available_themes:
  			current_theme = saved_theme
  
  		# Load custom colors
  		var saved_colors = config.get_value("theme", "custom_colors", {})
  		for color_name in saved_colors:
  			theme_colors["custom"][color_name] = saved_colors[color_name]
  
  		# Load font sizes
  		var saved_font_sizes = config.get_value("theme", "font_sizes", {})
  		for size_name in saved_font_sizes:
  			font_sizes[size_name] = saved_font_sizes[size_name]
  	else:
  		# If no config exists, initialize custom theme with default colors
  		theme_colors["custom"] = theme_colors["default"].duplicate()
  
  # Apply default theme to a control
  func _apply_default_theme(control: Control) -> void:
  	var theme_override = Theme.new()
  
  	# Set default font
  	if fonts["regular"]:
  		theme_override.default_font = fonts["regular"]
  		theme_override.default_font_size = get_font_size("regular")
  
  	# Set default colors
  	theme_override.set_color("font_color", "Label", get_color("foreground"))
  	theme_override.set_color("font_focus_color", "Label", get_color("primary"))
  
  	control.theme = theme_override
  
  # Apply button theme
  func _apply_button_theme(button: Control) -> void:
  	if not button is Button:
  		push_warning("Cannot apply button theme to non-Button control")
  		return
  
  	# Apply default theme first
  	_apply_default_theme(button)
  
  	# Create button styles
  	var styles = create_button_style()
  
  	# Apply button styles
  	button.add_theme_stylebox_override("normal", styles["normal"])
  	button.add_theme_stylebox_override("hover", styles["hover"])
  	button.add_theme_stylebox_override("pressed", styles["pressed"])
  	button.add_theme_stylebox_override("disabled", styles["disabled"])
  
  	# Set colors
  	button.add_theme_color_override("font_color", get_color("foreground"))
  	button.add_theme_color_override("font_focus_color", get_color("foreground"))
  	button.add_theme_color_override("font_disabled_color", get_color("disabled"))
  
  	# Set font
  	if fonts["bold"]:
  		button.add_theme_font_override("font", fonts["bold"])
  
  # Apply panel theme
  func _apply_panel_theme(panel: Control) -> void:
  	if not panel is Panel:
  		push_warning("Cannot apply panel theme to non-Panel control")
  		return
  
  	# Apply default theme first
  	_apply_default_theme(panel)
  
  	# Create panel style
  	var style = create_panel_style("background", "foreground", "regular", 1)
  
  	# Apply panel style
  	panel.add_theme_stylebox_override("panel", style)
  
  # Apply label theme
  func _apply_label_theme(label: Control) -> void:
  	if not label is Label:
  		push_warning("Cannot apply label theme to non-Label control")
  		return
  
  	# Apply default theme first
  	_apply_default_theme(label)
  
  	# Set colors
  	label.add_theme_color_override("font_color", get_color("foreground"))
  	label.add_theme_color_override("font_shadow_color", get_color("background"))
  
  	# Set font
  	label.add_theme_font_override("font", fonts["regular"])
  	label.add_theme_font_size_override("font_size", get_font_size("regular"))
