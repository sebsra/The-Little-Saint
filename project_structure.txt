PROJECT STRUCTURE FOR: c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint
==================================================

[DIR] .git (skipped)
[DIR] .godot (skipped)
[DIR] .vscode (skipped)
[DIR] Artefakte
  - # Refactoring TODO List.md
- README.md
[DIR] addons
  [DIR] virtual_joystick
    [DIR] previews
    [DIR] test
      - player.gd
      - test.tscn
    [DIR] textures
    - virtual_joystick.gd
    - virtual_joystick_instantiator.gd
    - virtual_joystick_plugin.gd
    - virtual_joystick_scene.tscn
[DIR] assets
  [DIR] audio
    [DIR] music
      [DIR] Tracks
    [DIR] sfx
  [DIR] fonts
    [DIR] general
    [DIR] special
      [DIR] copyduck
        - More Info.txt
  [DIR] sprites
    [DIR] characters
      [DIR] acc
      [DIR] characters
      [DIR] clothes
      [DIR] eyes
      [DIR] greyscale
        [DIR] acc
          [DIR] acc
          [DIR] modular
        [DIR] character
          [DIR] without
        [DIR] clothes
          [DIR] clothes
          [DIR] modular
        [DIR] eyes
        [DIR] hair
        - info.txt
        [DIR] tools
      [DIR] hair
      - info.txt
      - list.txt
      [DIR] separate
        [DIR] axe
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
          [DIR] tool
          [DIR] without
        [DIR] block
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
          [DIR] tool
          [DIR] without
        [DIR] carry
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
        [DIR] die
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
        [DIR] fish
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
          [DIR] tool
          [DIR] without
        [DIR] hoe
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
          [DIR] tool
          [DIR] without
        [DIR] hurt
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
        [DIR] jump
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
        [DIR] pickaxe
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
          [DIR] tool
          [DIR] without
        [DIR] pickup
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
        [DIR] sword
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
          [DIR] tool
          [DIR] without
        [DIR] walk
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
        [DIR] water
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
          [DIR] tool
          [DIR] without
    [DIR] enemies
      [DIR] 1 Bat
      [DIR] 2 Goblin_Mage
      [DIR] 3 Goblin_Melee
      [DIR] 4 Goblin_Range
      [DIR] 5 Small_Mushroom
      [DIR] 6 Big_Mushroom
    [DIR] environment
      [DIR] craftpix-896753-village-pixel-art-environment-assets-pack
        - License.txt
        [DIR] PNG
          [DIR] Objects
          [DIR] Tiles
        - readme.txt
      [DIR] craftpix-net-352322-nature-pixel-art-environment-free-assets-pack
        - License.txt
        [DIR] PNG
          [DIR] Objects
          [DIR] Tiles
        - readme.txt
      [DIR] craftpix-net-481981-free-summer-pixel-art-backgrounds
        - License.txt
        [DIR] PNG
          [DIR] summer 1
          [DIR] summer 2
          [DIR] summer 3
          [DIR] summer 4
          [DIR] summer5
          [DIR] summer6
          [DIR] summer7
          [DIR] summer8
        - readme.txt
      [DIR] craftpix-net-965049-free-industrial-zone-tileset-pixel-art
        [DIR] 1 Tiles
        [DIR] 2 Background
        [DIR] 3 Objects
        [DIR] 4 Animated objects
        - Font.txt
        - license.txt
      [DIR] peasant's_house
        [DIR] Peasant's_House
          [DIR] Door_Animation
            [DIR] Door_Animation-FrameByFrame
          [DIR] House_in_the_middle
            [DIR] Door_Animation
            [DIR] Window_Animation
          [DIR] Peasant's_House-NoAnimation
          - README.txt
          [DIR] Window_Animation
            [DIR] Window_Animation-FrameByFrame
      [DIR] sunny-land-files
        [DIR] Sunny-land-files
          [DIR] Graphical Assets
            [DIR] environment
              [DIR] Background
              [DIR] Props
            [DIR] sprites
              [DIR] cherry
              [DIR] eagle
              [DIR] enemy-death
              [DIR] frog
                [DIR] idle
                [DIR] jump
              [DIR] gem
              [DIR] item-feedback
              [DIR] opossum
              [DIR] player
                [DIR] climb
                [DIR] crouch
                [DIR] hurt
                [DIR] idle
                [DIR] jump
                [DIR] run
            [DIR] spritesheets
          - public-license.txt
    [DIR] items
    [DIR] ui
    [DIR] unsorted
      [DIR] Audio
        [DIR] Tracks
      [DIR] Bushes
      [DIR] Character v.2
        [DIR] acc
        [DIR] characters
        [DIR] clothes
        [DIR] eyes
        [DIR] greyscale
          [DIR] acc
            [DIR] acc
            [DIR] modular
          [DIR] character
            [DIR] without
          [DIR] clothes
            [DIR] clothes
            [DIR] modular
          [DIR] eyes
          [DIR] hair
          [DIR] tools
        [DIR] hair
        [DIR] separate
          [DIR] axe
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
            [DIR] tool
            [DIR] without
          [DIR] block
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
            [DIR] tool
            [DIR] without
          [DIR] carry
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
          [DIR] die
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
          [DIR] fish
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
            [DIR] tool
            [DIR] without
          [DIR] hoe
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
            [DIR] tool
            [DIR] without
          [DIR] hurt
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
          [DIR] jump
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
          [DIR] pickaxe
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
            [DIR] tool
            [DIR] without
          [DIR] pickup
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
          [DIR] sword
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
            [DIR] tool
            [DIR] without
          [DIR] walk
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
          [DIR] water
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
            [DIR] tool
            [DIR] without
      [DIR] Font
      [DIR] Fonts
        [DIR] copyduck
      - License.txt
      [DIR] Monsters
        [DIR] 1 Bat
        [DIR] 2 Goblin_Mage
        [DIR] 3 Goblin_Melee
        [DIR] 4 Goblin_Range
        [DIR] 5 Small_Mushroom
        [DIR] 6 Big_Mushroom
        [DIR] PSD
      [DIR] Peasant's_House
        [DIR] Peasant's_House
          [DIR] Door_Animation
            [DIR] Door_Animation-FrameByFrame
          [DIR] House_in_the_middle
            [DIR] Door_Animation
            [DIR] Window_Animation
          [DIR] Peasant's_House-NoAnimation
          [DIR] Window_Animation
            [DIR] Window_Animation-FrameByFrame
      [DIR] Sunny-land-files
        [DIR] Sunny-land-files
          [DIR] Graphical Assets
            [DIR] Aseprite
            [DIR] GIF Previews
              [DIR] FX
              [DIR] eagle
              [DIR] frog
              [DIR] items
              [DIR] opossum
              [DIR] player
            [DIR] PSD
              [DIR] MISC
              [DIR] environment
              [DIR] sprites
                [DIR] FX
                [DIR] eagle
                [DIR] frog
                [DIR] items
                [DIR] opossum
                [DIR] player
            [DIR] environment
              [DIR] Background
              [DIR] Props
            [DIR] sprites
              [DIR] cherry
              [DIR] eagle
              [DIR] enemy-death
              [DIR] frog
                [DIR] idle
                [DIR] jump
              [DIR] gem
              [DIR] item-feedback
              [DIR] opossum
              [DIR] player
                [DIR] climb
                [DIR] crouch
                [DIR] hurt
                [DIR] idle
                [DIR] jump
                [DIR] run
            [DIR] spritesheets
      [DIR] craftpix-896753-village-pixel-art-environment-assets-pack
        [DIR] PNG
          [DIR] Objects
          [DIR] Tiles
        [DIR] Village_PixelArt_Environment.unitypackage
      [DIR] craftpix-net-352322-nature-pixel-art-environment-free-assets-pack
        [DIR] PNG
          [DIR] Objects
          [DIR] Tiles
      [DIR] craftpix-net-481981-free-summer-pixel-art-backgrounds
        [DIR] PNG
          [DIR] summer 1
          [DIR] summer 2
          [DIR] summer 3
          [DIR] summer 4
          [DIR] summer5
          [DIR] summer6
          [DIR] summer7
          [DIR] summer8
        [DIR] PSD
      [DIR] craftpix-net-965049-free-industrial-zone-tileset-pixel-art
        [DIR] 1 Tiles
        [DIR] 2 Background
        [DIR] 3 Objects
        [DIR] 4 Animated objects
        [DIR] PSD
      [DIR] princefotos
  [DIR] tilemaps
[DIR] config
[DIR] docs
- get_structure.py
- project.godot
- project_structure.txt
[DIR] scenes
  [DIR] common
    [DIR] enemies
    [DIR] items
  [DIR] core
    [DIR] character
      - character_sprites.tscn
      - player.tscn
    [DIR] enemies
      - ardit_enemy.tscn
      - goblin_archer.tscn
      - goblin_mage.tscn
      - goblin_melee.tscn
      - prince_enemy.tscn
    [DIR] items
      - coins.tscn
      - elixir.tscn
      - killzone.tscn
      - power_attack.tscn
      - power_fly.tscn
      - power_jump.tscn
    [DIR] projectiles
      - mage_ball.tscn
      - rock.tscn
  [DIR] levels
    [DIR] adventure_mode
      - adventure_level.tscn
      - base_level.tscn
    [DIR] ardit_levels
      [DIR] Egypt
      [DIR] Free
        [DIR] Background
        [DIR] Items
          [DIR] Boxes
            [DIR] Box1
            [DIR] Box2
            [DIR] Box3
          [DIR] Checkpoints
            [DIR] Checkpoint
            [DIR] End
            [DIR] Start
          [DIR] Fruits
        [DIR] Main Characters
          [DIR] Mask Dude
          [DIR] Ninja Frog
          [DIR] Pink Man
          [DIR] Virtual Guy
        [DIR] Menu
          [DIR] Buttons
          [DIR] Levels
          [DIR] Text
        [DIR] Other
        [DIR] Terrain
        [DIR] Traps
          [DIR] Arrow
          [DIR] Blocks
          [DIR] Falling Platforms
          [DIR] Fan
          [DIR] Fire
          [DIR] Platforms
          [DIR] Rock Head
          [DIR] Sand Mud Ice
          [DIR] Saw
          [DIR] Spike Head
          [DIR] Spiked Ball
          [DIR] Spikes
          [DIR] Trampoline
      [DIR] Free Version
        [DIR] Tiles
      [DIR] [Free-Version] The Lost Tomb - [24x24] Dungeon Asset pack
      - arrogance.tscn
      [DIR] egyptian-game-ui-frames-assets
      [DIR] enemy1
    [DIR] prince_levels
      [DIR] Scriptprince
      [DIR] Tiles
        [DIR] fourSeasonsPlatformer
          - - READ ME -.txt
          [DIR] background_
          [DIR] foreground_
          [DIR] midground_
          [DIR] objects_
      - game_prince.tscn
      - platform.tscn
    [DIR] sebastian_levels
      - level_1.tscn
  [DIR] managers
    - audio_manager.tscn
  [DIR] ui
    [DIR] character_customizer
      - customizer.tscn
      - outfit_showcase.tscn
    [DIR] controls
      - gui.tscn
      - joystick.tscn
    [DIR] dialogs
      - popup_dialog.tscn
    [DIR] hud
      - hud.tscn
    [DIR] loading_screen
    [DIR] main_menu
      - main_menu.tscn
      - start_background.tscn
    [DIR] settings
      - audio_settings.tscn
      - settings_menu.tscn
[DIR] scripts
  [DIR] autoload
    - audio_manager.gd
    - constants.gd
    - game_manager.gd
    - save_manager.gd
  [DIR] core
    [DIR] base_classes
      - base_enemy.gd
      - base_power_up.gd
      - base_projectile.gd
    [DIR] characters
      - character_sprites.gd
      - player.gd
      - player_camera.gd
    [DIR] enemies
      - ardit_enemy.gd
      - goblin_archer.gd
      - goblin_mage.gd
      - goblin_melee.gd
      - prince_enemy.gd
    [DIR] items
      - coins.gd
      - elixir.gd
      - power_attack.gd
      - power_fly.gd
      - power_jump.gd
    [DIR] projectiles
      - mage_ball.gd
      - rock.gd
    [DIR] state_machine
      [DIR] enemy_states
        - enemy_idle_state.gd
      [DIR] player_states
        - player_attack_state.gd
        - player_base_state.gd
        - player_death_state.gd
        - player_fall_state.gd
        - player_fly_state.gd
        - player_hurt_state.gd
        - player_idle_state.gd
        - player_jump_state.gd
        - player_walk_state.gd
      - state.gd
      - state_machine.gd
  [DIR] levels
    - base_level.gd
  [DIR] resources
    - player_outfit_resource.gd
  [DIR] ui
    [DIR] character_customizer
      - customizer_controller.gd
      - outfit_showcase.gd
      - preview_helper.gd
    [DIR] controls
      - attack_button.gd
      - defend_button.gd
    [DIR] dialogs
      - popup_dialog.gd
      - popup_manager.gd
    [DIR] hud
      - hud_controller.gd
    [DIR] main_menu
      - camera.gd
      - customizer_button.gd
      - main_menu.gd
      - menu_buttons.gd
      - start_background.gd
    [DIR] settings
      - audio_settings.gd
      - settings_menu.gd
  [DIR] utils
    - killzone.gd
    - save_data.gd

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\Artefakte\# Refactoring TODO List.md:
========================================
  # The Little Saint - Adjusted Refactoring Plan
  
  Based on your current project state, I've adjusted the refactoring plan for the remaining tasks (19-75). I've observed that you've successfully implemented:
  
  - Base classes (BaseEnemy, BasePowerUp, BaseProjectile)
  - State machine framework
  - Player and enemy state classes
  - Modified existing scripts to work with the new architecture
  
  Here's the adjusted plan with proper sequencing to prevent duplicate file modifications:
  
  ## Phase 1: Core Infrastructure & Game Management (Foundation
   First)
  
  1. [NEW] `scripts/utils/constants.gd` (Task 68) - Create global constants file for game settings
  2. [MODIFY] `scripts/autoload/game_manager.gd` (Task 19) - Develop the empty manager with:
     - Game state tracking (menu, playing, paused, game over)
     - Scene management functionality
     - Global event handling
  3. [NEW] `scripts/autoload/save_manager.gd` (Task 22) - Create dedicated save manager that:
     - Handles saving/loading player data
     - Manages outfit configurations
     - Includes error handling and validation
  4. [NEW] `scripts/utils/save_data.gd` (Task 23) - Create data structure for saved games
  5. [NEW] `scripts/resources/player_outfit_resource.gd` (Task 31) - Create resource-based outfit system
  
  ## Phase 2: Player System Enhancements (Building on State Machine)
  
  6. [MODIFY] `scripts/core/characters/player.gd` (Tasks 25, 26, 63) - Complete refactoring by:
     - Integrating with SaveManager (replace ConfigFile usage)
     - Optimizing signal connections
     - Ensuring proper state machine integration
  7. [MODIFY] `scripts/ui/character_customizer/customizer_controller.gd` (Tasks 24, 32) - Improve by:
     - Using SaveManager instead of ConfigFile
     - Implementing resource-based outfit system
  8. [MODIFY] `scripts/ui/character_customizer/preview_helper.gd` (Task 34) - Optimize preview generation
  9. [MODIFY] `scripts/ui/character_customizer/outfit_showcase.gd` (Task 33) - Improve UI feedback
  
  ## Phase 3: UI Framework & Dialog Enhancements
  
  10. [NEW] `scripts/ui/theme/ui_theme.gd` (Task 45) - Create consistent UI theme
  11. [MODIFY] `scripts/ui/dialogs/popup_dialog.gd` (Task 54) - Enhance with animations and polish
  12. [NEW] `scripts/ui/dialogs/conversation_system.gd` (Task 55) - Create NPC conversation system
  13. [NEW] `scripts/ui/dialogs/dialog_tree.gd` (Task 56) - Implement branching dialogs
  14. [NEW] `scripts/ui/components/button_with_sound.gd` (Task 47) - Create button with sound effects
  15. [NEW] `scripts/ui/transitions/screen_transition.gd` (Task 48) - Create screen transition effects
  
  ## Phase 4: HUD & User Experience
  
  16. [MODIFY] `scripts/ui/hud/hud_controller.gd` (Tasks 44, 50) - Enhance with:
      - Improved health display
      - Better damage feedback
      - Animations for UI changes
  17. [NEW] `scripts/ui/hud/mini_map.gd` (Task 51) - Add mini-map component
  18. [NEW] `scripts/ui/hud/objective_tracker.gd` (Task 52) - Add objective tracking
  19. [MODIFY] `scenes/ui/hud/hud.tscn` (Task 53) - Update with new components
  20. [MODIFY] `scenes/ui/main_menu/main_menu.tscn` (Task 49) - Update with new UI components
  
  ## Phase 5: Combat System & Enemy Behaviors
  
  21. [NEW] `scripts/core/combat/damage_system.gd` (Task 41) - Create system for damage handling
  22. [NEW] `scripts/core/combat/hit_effect.gd` (Task 42) - Create visual effects for hits
  23. [NEW] `scripts/core/combat/screen_shake.gd` (Task 43) - Add screen shake effect
  24. [NEW] `scripts/core/enemies/behaviors/patrol_behavior.gd` (Task 35) - Create modular patrol behavior
  25. [NEW] `scripts/core/enemies/behaviors/chase_behavior.gd` (Task 36) - Create modular chase behavior
  26. [NEW] `scripts/core/enemies/behaviors/attack_behavior.gd` (Task 37) - Create modular attack behavior
  27. [NEW] `scripts/core/enemies/behaviors/ranged_attack.gd` (Task 38) - Create ranged attack component
  28. [NEW] `scripts/core/enemies/behaviors/melee_attack.gd` (Task 39) - Create melee attack component
  29. [NEW] `scripts/managers/enemy_manager.gd` (Task 40) - Create manager for enemy spawning and waves
  
  ## Phase 6: Performance Optimization & Resource Management
  
  30. [NEW] `scripts/utils/resource_preloader.gd` (Task 58) - Create resource preloading manager
  31. [NEW] `scripts/utils/object_pool.gd` (Task 59) - Implement object pooling system
  32. [NEW] `scripts/utils/performance_monitor.gd` (Task 64) - Add monitoring capabilities
  33. [MODIFY] `scripts/core/projectiles/mage_ball.gd` (Task 60) - Use object pooling
  34. [MODIFY] `scripts/core/projectiles/rock.gd` (Task 61) - Use object pooling
  
  ## Phase 7: Audio System Enhancements
  
  35. [MODIFY] `scripts/autoload/audio_manager.gd` (Task 72) - Expand with:
      - Audio categories (Music, SFX, UI, Ambient)
      - Volume control
      - Sound effect management
  36. [NEW] `scripts/audio/adaptive_music_system.gd` (Task 73) - Create dynamic music system
  37. [NEW] `scripts/audio/sound_effect.gd` (Task 74) - Create enhanced sound effect class
  38. [MODIFY] `scenes/managers/audio_manager.tscn` (Task 75) - Update with new audio buses
  
  ## Phase 8: Development Tools & Documentation
  
  39. [NEW] `scripts/utils/debug_console.gd` (Task 65) - Implement in-game debug console
  40. [NEW] `scripts/utils/performance_display.gd` (Task 66) - Add FPS and memory display
  41. [NEW] `scripts/utils/cheat_system.gd` (Task 67) - Add cheat code functionality
  42. [NEW] `docs/code_standards.md` (Task 70) - Create coding standards document
  43. [NEW] `docs/architecture.md` (Task 71) - Document project architecture
  44. [REVIEW] (Task 62) - Optimize heavy processing in _process methods
  45. [REVIEW] (Task 69) - Standardize class_name usage across all scripts
  
  ## Implementation Strategy
  
  1. **Focus on core infrastructure first** - Ensure the game manager, event system, and save system are robust before moving on.
  2. **Implement one phase at a time** - Complete each phase before moving to the next to maintain code stability.
  3. **Test frequently** - Run the game after each significant change to catch issues early.
  4. **Document as you go** - Update documentation in parallel with code changes.
  5. **Leverage state machine** - Use the existing state machine for new behaviors instead of creating parallel systems.
  
  ## Priority Order
  
  If you need to prioritize certain improvements:
  
  1. Game Manager & Save System (Phase 1)
  2. UI Framework & HUD Improvements (Phases 3 & 4)
  3. Combat System & Enemy Behaviors (Phase 5)
  4. Audio System Enhancements (Phase 7)
  5. Performance Optimization (Phase 6)
  6. Development Tools (Phase 8)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\README.md:
========================================
  # Godot Virtual Joystick
  
  <img src="addons/virtual_joystick/previews/icon.png" width="200">
  
  A simple virtual joystick for touchscreens, with useful options.
  
  GitHub Page: https://github.com/MarcoFazioRandom/Virtual-Joystick-Godot
  
  Godot Engine: https://godotengine.org
  
  ## PREVIEWS:
  
  <img src="addons/virtual_joystick/previews/preview1.png" width="300">    <img src="addons/virtual_joystick/previews/preview2.png" width="300">
  
  Easy to use:
  
  ```GDScript
  extends Sprite2D
  
  @export var speed : float = 100
  
  @export var joystick_left : VirtualJoystick
  
  @export var joystick_right : VirtualJoystick
  
  var move_vector := Vector2.ZERO
  
  func _process(delta: float) -> void:
  	## Movement using the joystick output:
  #	if joystick_left and joystick_left.is_pressed:
  #		position += joystick_left.output * speed * delta
  
  	## Movement using Input functions:
  	move_vector = Vector2.ZERO
  	move_vector = Input.get_vector("ui_left","ui_right","ui_up","ui_down")
  	position += move_vector * speed * delta
  
  	# Rotation:
  	if joystick_right and joystick_right.is_pressed:
  		rotation = joystick_right.output.angle()
  ```
  
  
  ## OPTIONS:
  
  - Joystick mode:
  	- Fixed: The joystick doesn't move.
  	- Dynamic: Every time the joystick area is pressed, the joystick position is set on the touched position.
  	- Following: When the finger moves outside the joystick area, the joystick will follow it.
  
  - Dead zone size: If the tip is inside this range the output is zero.
  
  - Clamp zone size: The max distance the tip can reach.
  
  - Visibility mode:
  	- always: Always visible.
  	- touchscreen only: Visible on touch screens only (will hide if the device has not a touchscreen).
  	- when_touched: Visible only when touched.
  
  - Use input actions: if true the joystick will trigger the input actions created in Project -> Project Settings -> Input Map
  
  ## HELP:
  - The Control parent of the joystick is the area in which the joystick can move in Dynamic mode.
  - For moving the joystick inside his area, select it, right click, turn on "Editable Children" and then change the position of the Base node.
  - With "Editable Children" turned on you can also edit the joystick textures and colors.
  - Create a CanvasLayer node and name it "UI", it'll contain all the UI elements, then add the Joystick scene as a child of the UI node and move it where you prefer.
  - An example scene is provided in the "Test" folder.
  
  ## FAQ
  ### Multitouch doesn't work / can't use two joystick at the same time:
  In Godot, the input events from the mouse don't support multitouch, so make sure to have this configuration:
  Project -> Project Settings -> General -> Input Devices
  "emulate touch from mouse" ON
  "emulate mouse from touch" OFF
  
  ### The joystick doesn't work when using Input.get_vector():
  ⚠ **This has been fixed in Godot Engine!**
  Unfortunately, this a bug in the Godot engine, so the only solution for now is using Input.get_axis:
  This doesn't work:
  ```gdscript
  input_vector := Input.get_vector("ui_left","ui_right","ui_up","ui_down")
  ```
  This works:
  ```gdscript
  input_vector := Vector2.ZERO
  input_vector.x = Input.get_axis("ui_left", "ui_right")
  input_vector.y = Input.get_axis("ui_up", "ui_down")
  ```

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\addons\virtual_joystick\test\player.gd:
========================================
  extends Sprite2D
  
  @export var speed : float = 100
  
  @export var joystick_left : VirtualJoystick
  
  @export var joystick_right : VirtualJoystick
  
  var move_vector := Vector2.ZERO
  
  func _process(delta: float) -> void:
  	## Movement using the joystick output:
  #	if joystick_left and joystick_left.is_pressed:
  #		position += joystick_left.output * speed * delta
  
  	## Movement using Input functions:
  	move_vector = Vector2.ZERO
  	move_vector = Input.get_vector("ui_left","ui_right","ui_up","ui_down")
  	position += move_vector * speed * delta
  
  	# Rotation:
  	if joystick_right and joystick_right.is_pressed:
  		rotation = joystick_right.output.angle()

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\addons\virtual_joystick\virtual_joystick.gd:
========================================
  class_name VirtualJoystick
  
  extends Control
  
  ## A simple virtual joystick for touchscreens, with useful options.
  ## Github: https://github.com/MarcoFazioRandom/Virtual-Joystick-Godot
  
  # EXPORTED VARIABLE
  
  ## The color of the button when the joystick is pressed.
  @export var pressed_color := Color.GRAY
  
  ## If the input is inside this range, the output is zero.
  @export_range(0, 200, 1) var deadzone_size : float = 10
  
  ## The max distance the tip can reach.
  @export_range(0, 500, 1) var clampzone_size : float = 75
  
  enum Joystick_mode {
  	FIXED, ## The joystick doesn't move.
  	DYNAMIC, ## Every time the joystick area is pressed, the joystick position is set on the touched position.
  	FOLLOWING ## When the finger moves outside the joystick area, the joystick will follow it.
  }
  
  ## If the joystick stays in the same position or appears on the touched position when touch is started
  @export var joystick_mode := Joystick_mode.FIXED
  
  enum Visibility_mode {
  	ALWAYS, ## Always visible
  	TOUCHSCREEN_ONLY, ## Visible on touch screens only
  	WHEN_TOUCHED ## Visible only when touched
  }
  
  ## If the joystick is always visible, or is shown only if there is a touchscreen
  @export var visibility_mode := Visibility_mode.ALWAYS
  
  ## If true, the joystick uses Input Actions (Project -> Project Settings -> Input Map)
  @export var use_input_actions := true
  
  @export var action_left := "ui_left"
  @export var action_right := "ui_right"
  @export var action_up := "ui_up"
  @export var action_down := "ui_down"
  
  # PUBLIC VARIABLES
  
  ## If the joystick is receiving inputs.
  var is_pressed := false
  
  # The joystick output.
  var output := Vector2.ZERO
  
  # PRIVATE VARIABLES
  
  var _touch_index : int = -1
  
  @onready var _base := $Base
  @onready var _tip := $Base/Tip
  
  @onready var _base_default_position : Vector2 = _base.position
  @onready var _tip_default_position : Vector2 = _tip.position
  
  @onready var _default_color : Color = _tip.modulate
  
  # FUNCTIONS
  
  func _ready() -> void:
  	if ProjectSettings.get_setting("input_devices/pointing/emulate_mouse_from_touch"):
  		printerr("The Project Setting 'emulate_mouse_from_touch' should be set to False")
  	if not ProjectSettings.get_setting("input_devices/pointing/emulate_touch_from_mouse"):
  		printerr("The Project Setting 'emulate_touch_from_mouse' should be set to True")
  
  	if not DisplayServer.is_touchscreen_available() and visibility_mode == Visibility_mode.TOUCHSCREEN_ONLY :
  		hide()
  
  	if visibility_mode == Visibility_mode.WHEN_TOUCHED:
  		hide()
  
  func _input(event: InputEvent) -> void:
  	if event is InputEventScreenTouch:
  		if event.pressed:
  			if _is_point_inside_joystick_area(event.position) and _touch_index == -1:
  				if joystick_mode == Joystick_mode.DYNAMIC or joystick_mode == Joystick_mode.FOLLOWING or (joystick_mode == Joystick_mode.FIXED and _is_point_inside_base(event.position)):
  					if joystick_mode == Joystick_mode.DYNAMIC or joystick_mode == Joystick_mode.FOLLOWING:
  						_move_base(event.position)
  					if visibility_mode == Visibility_mode.WHEN_TOUCHED:
  						show()
  					_touch_index = event.index
  					_tip.modulate = pressed_color
  					_update_joystick(event.position)
  					get_viewport().set_input_as_handled()
  		elif event.index == _touch_index:
  			_reset()
  			if visibility_mode == Visibility_mode.WHEN_TOUCHED:
  				hide()
  			get_viewport().set_input_as_handled()
  	elif event is InputEventScreenDrag:
  		if event.index == _touch_index:
  			_update_joystick(event.position)
  			get_viewport().set_input_as_handled()
  
  func _move_base(new_position: Vector2) -> void:
  	_base.global_position = new_position - _base.pivot_offset * get_global_transform_with_canvas().get_scale()
  
  func _move_tip(new_position: Vector2) -> void:
  	_tip.global_position = new_position - _tip.pivot_offset * _base.get_global_transform_with_canvas().get_scale()
  
  func _is_point_inside_joystick_area(point: Vector2) -> bool:
  	var x: bool = point.x >= global_position.x and point.x <= global_position.x + (size.x * get_global_transform_with_canvas().get_scale().x)
  	var y: bool = point.y >= global_position.y and point.y <= global_position.y + (size.y * get_global_transform_with_canvas().get_scale().y)
  	return x and y
  
  func _get_base_radius() -> Vector2:
  	return _base.size * _base.get_global_transform_with_canvas().get_scale() / 2
  
  func _is_point_inside_base(point: Vector2) -> bool:
  	var _base_radius = _get_base_radius()
  	var center : Vector2 = _base.global_position + _base_radius
  	var vector : Vector2 = point - center
  	if vector.length_squared() <= _base_radius.x * _base_radius.x:
  		return true
  	else:
  		return false
  
  func _update_joystick(touch_position: Vector2) -> void:
  	var _base_radius = _get_base_radius()
  	var center : Vector2 = _base.global_position + _base_radius
  	var vector : Vector2 = touch_position - center
  	vector = vector.limit_length(clampzone_size)
  
  	if joystick_mode == Joystick_mode.FOLLOWING and touch_position.distance_to(center) > clampzone_size:
  		_move_base(touch_position - vector)
  
  	_move_tip(center + vector)
  
  	if vector.length_squared() > deadzone_size * deadzone_size:
  		is_pressed = true
  		output = (vector - (vector.normalized() * deadzone_size)) / (clampzone_size - deadzone_size)
  	else:
  		is_pressed = false
  		output = Vector2.ZERO
  
  	if use_input_actions:
  		if output.x > 0:
  			Input.action_release(action_left)
  			Input.action_press(action_right, output.x)
  		else:
  			Input.action_release(action_right)
  			Input.action_press(action_left, -output.x)
  
  		if output.y > 0:
  			Input.action_release(action_up)
  			Input.action_press(action_down, output.y)
  		else:
  			Input.action_release(action_down)
  			Input.action_press(action_up, -output.y)
  
  func _reset():
  	is_pressed = false
  	output = Vector2.ZERO
  	_touch_index = -1
  	_tip.modulate = _default_color
  	_base.position = _base_default_position
  	_tip.position = _tip_default_position
  	if use_input_actions:
  		for action in [action_left, action_right, action_down, action_up]:
  			Input.action_release(action)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\addons\virtual_joystick\virtual_joystick_instantiator.gd:
========================================
  @tool
  extends Control
  
  var scene
  
  func _enter_tree():
  	scene = preload("res://addons/virtual_joystick/virtual_joystick_scene.tscn").instantiate()
  	add_child(scene)
  
  	if ProjectSettings.get_setting("input_devices/pointing/emulate_mouse_from_touch"):
  		printerr("The Project Setting 'emulate_mouse_from_touch' should be set to False")
  	if not ProjectSettings.get_setting("input_devices/pointing/emulate_touch_from_mouse"):
  		printerr("The Project Setting 'emulate_touch_from_mouse' should be set to True")
  
  
  func _exit_tree():
  	scene.free()

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\addons\virtual_joystick\virtual_joystick_plugin.gd:
========================================
  @tool
  extends EditorPlugin
  
  
  func _enter_tree():
  	add_custom_type("Virtual Joystick", "Control", preload("virtual_joystick_instantiator.gd"), preload("virtual_joystick_icon.png"))
  
  
  func _exit_tree():
  	remove_custom_type("Virtual Joystick")

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\fonts\special\copyduck\More Info.txt:
========================================
  First of All,
  
  Thank you for download my product.
  This product 100% free for personal use & commercial use
  
  File include :
  
  1. Copyduck.ttf
  2. Copyduck.otf
  
  More Info :
  khurasantype@gmail.com
  
  For Donation:
  paypal.me/khurasantype
  
  My OnlineShop:
  https://www.creativefabrica.com/ref/53/
  
  My Portofolio:
  https://www.behance.net/khurasan
  
  My web:
  www.khurasanstudio.com
  www.mbkaos.com

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\sprites\characters\greyscale\info.txt:
========================================
  
  How to use modular clothing
  
  Use basic_grey (clothes) as base and add the detail (modular) you want:
  	floral, overalls, sailor, skull, sporty, stripe
  
  "button_grey" works for clown outfit and pumpkin outfit
  
  "shoes_grey" works for all outfits besides "witch_grey"
  
  "gloves_grey" works for clown, pumpkin and spooky
  
  
  Modular hair
  
  Use "braids_tie_grey" on top of braids to adjust color of hair ties
  

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\sprites\characters\info.txt:
========================================
  
  GRID SIZE 32x32
  CELL SIZE MERGED: 256x1568
  
  WALK FR: 100
  Cell Size: 256x128
  
  JUMP FR: 100; 200; 100; 120; 100
  Cell Size: 160x128
  
  PICK UP FR: 150; 150; 100; 100; 150
  Cell Size: 160x128
  
  CARRY FR:100
  Cell Size: 256x128
  (char moved  up 1px)
  
  SWORD FR: 100; 200; 80; 100
  Cell Size: 128x128
  
  BLOCK Cell Size: 32x128
  
  HURT Cell Size: 32x128
  
  DIE FR: 500
  Cell Size: 64x32
  
  PICKAXE/ AXE FR: 100; 100; 250; 60; 100
  Cell Size: 160x128
  
  WATER FR: 300; 600
  Cell Size: 64x128
  (char moved up 5 px)
  
  HOE FR: 200; 150; 200; 200; 200
  Cell Size: 160x128
  (down: char moved up 8 px; left/right char moved up 1 px)
  
  FISHING L/R FR: 100; 100; 250; 60; 100
  FISHING U/D FR: 100; 250; 60; 100; 100
  Cell Size: 160x128
  (char moved up 4 px)
  
  LAYERS
  1. Characters
  2. Eyes ->Blush/Lipstick
  3. Clothes: Shirt -> Pants -> Shoes
  4. Hair
  5. Accessories Beard -> Glasses -> Hat
  
  
  
  
  
  
  
  
  
  

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\sprites\characters\list.txt:
========================================
  
  HAIR
  1. Black
  2. Blonde
  3. Brown
  4. Brown Light
  5. Copper
  6. Emerald
  7. Green
  8. Grey
  9. Lilac
  10. Navy
  11. Pink
  12. Purple
  13. Red
  14. Turquoise
  
  Clothes:
  1. Black
  2. Blue
  3. Blue Light
  4. Brown
  5. Green
  6. Green Light
  7. Pink
  8. Purple
  9. Red
  10. White/Grey
  
  Eyes:
  1. Black
  2. Blue
  3. Blue Light
  4. Brown
  5. Brown Dark
  6. Brown Light
  7. Green
  8. Green Dark
  9. Green Light
  10. Grey
  11. Grey Light
  12. Pink
  13. Pink Light
  14. Red
  
  Lipstick and Blush are sorted from light to dark.
  
  

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\sprites\environment\craftpix-896753-village-pixel-art-environment-assets-pack\License.txt:
========================================
  https://craftpix.net/file-licenses/

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\sprites\environment\craftpix-896753-village-pixel-art-environment-assets-pack\readme.txt:
========================================
  Font that was used for the background of the preview:
  https://www.dafont.com/pixellari.font

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\sprites\environment\craftpix-net-352322-nature-pixel-art-environment-free-assets-pack\License.txt:
========================================
  https://craftpix.net/file-licenses/

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\sprites\environment\craftpix-net-352322-nature-pixel-art-environment-free-assets-pack\readme.txt:
========================================
  Font that was used for the background of the preview:
  https://www.dafont.com/pixellari.font

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\sprites\environment\craftpix-net-481981-free-summer-pixel-art-backgrounds\License.txt:
========================================
  https://craftpix.net/file-licenses/

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\sprites\environment\craftpix-net-481981-free-summer-pixel-art-backgrounds\readme.txt:
========================================
  Font that was used for the background of the preview:
  https://www.dafont.com/digital-disco.font

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\sprites\environment\craftpix-net-965049-free-industrial-zone-tileset-pixel-art\Font.txt:
========================================
  Future Millennium
  https://www.dafont.com/futuremillennium.font

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\sprites\environment\craftpix-net-965049-free-industrial-zone-tileset-pixel-art\license.txt:
========================================
  https://craftpix.net/file-licenses/

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\sprites\environment\peasant's_house\Peasant's_House\README.txt:
========================================
  THIS MATERIAL IS COMPLETELY FREE, AND YOU CAN FIND IT ON MY PAGE "https://ericksazevedo.itch.io/". IF YOU PAID FOR THIS MATERIAL, DEMAND A REFUND!
  
  I'm glad you chose my art for your project, I hope it proves to be very useful to you.
  
  INTRODUTION
  
  My name is Ericks Azevedo. I created this artwork for study purposes and in the hope that it will be useful for other people's projects. If you're interested in more art, take a look at my page "https://ericksazevedo.itch.io/". I'll be regularly posting new art there whenever possible
  
  LICENSES
  
  * You can use the artwork in both free and commercial projects, as long as you give me credit. For that purpose, use my Instagram profile "@ericks.azevedo".
  * You can edit the images as you prefer; for this purpose, I'm providing the files in .aseprite format.
  * Selling these assets is not allowed, even if modifications have been made.
  
  INSTRUCTIONS
  
  * In each folder, you will find two ways to import your files: one using image sequences and the other with individual frames. Both methods have their own .aseprite file, in case you want to make modifications.
  * Pay attention to the "House_in_the_middle" folder. Inside it, you will find the images split in half, both for the door animation and the window animation. Both of them have the same sprite size, so you just need to overlay one onto the other. I organized it this way because the window and the door have different animation timings, and one is a loop while the other is not.
  
  If you want to support my work, please follow my page on itch.io ;)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\sprites\environment\sunny-land-files\Sunny-land-files\public-license.txt:
========================================
  Artwork created by Luis Zuno @ansimuz
  
  License for Everyone.
  
  Public domain and free to use on whatever you want, personal or commercial. Credit is not required but appreciated.
  
  Get more Free Assetslike these at: ansimuz.itch.io
  or at my patreon page: patreon.com/ansimuz
  
  

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\sprites\unsorted\License.txt:
========================================
  https://craftpix.net/file-licenses/

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\project.godot:
========================================
  ; Engine configuration file.
  ; It's best edited using the editor UI and not directly,
  ; since the parameters that go here are not all obvious.
  ;
  ; Format:
  ;   [section] ; section goes between []
  ;   param=value ; assign values to parameters
  
  config_version=5
  
  [application]
  
  config/name="The Little Saint"
  run/main_scene="uid://dh7t0n4nj8w4o"
  config/features=PackedStringArray("4.4", "Mobile")
  
  [autoload]
  
  Constants="*res://scripts/autoload/constants.gd"
  AudioManager="*res://scripts/autoload/audio_manager.gd"
  SaveManager="*res://scripts/autoload/save_manager.gd"
  Global="*res://scripts/autoload/game_manager.gd"
  PopupManager="*res://scripts/ui/dialogs/popup_manager.gd"
  
  [display]
  
  window/size/viewport_width=1280
  window/size/viewport_height=720
  window/stretch/mode="canvas_items"
  window/stretch/aspect="expand"
  
  [input]
  
  right={
  "deadzone": 0.5,
  "events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":68,"key_label":0,"unicode":100,"location":0,"echo":false,"script":null)
  , Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194321,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
  ]
  }
  left={
  "deadzone": 0.5,
  "events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":65,"key_label":0,"unicode":97,"location":0,"echo":false,"script":null)
  , Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194319,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
  ]
  }
  up={
  "deadzone": 0.5,
  "events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":87,"key_label":0,"unicode":119,"location":0,"echo":false,"script":null)
  , Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194320,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
  ]
  }
  down={
  "deadzone": 0.5,
  "events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":83,"key_label":0,"unicode":115,"location":0,"echo":false,"script":null)
  , Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194322,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
  ]
  }
  attack={
  "deadzone": 0.5,
  "events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":85,"physical_keycode":0,"key_label":0,"unicode":117,"location":0,"echo":false,"script":null)
  ]
  }
  defend={
  "deadzone": 0.5,
  "events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":73,"physical_keycode":0,"key_label":0,"unicode":105,"location":0,"echo":false,"script":null)
  ]
  }
  Menu={
  "deadzone": 0.5,
  "events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194305,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
  ]
  }
  
  [input_devices]
  
  pointing/emulate_touch_from_mouse=true
  pointing/emulate_mouse_from_touch=false
  
  [layer_names]
  
  2d_physics/layer_1="player"
  2d_physics/layer_2="ports"
  2d_physics/layer_3="item"
  2d_physics/layer_4="enemy"
  
  [physics]
  
  2d/physics_engine="GodotPhysics2D"
  
  [rendering]
  
  textures/canvas_textures/default_texture_filter=0
  renderer/rendering_method="mobile"
  environment/defaults/default_clear_color=Color(0, 0, 0, 1)

[Skipped c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scenes\core\character\character_sprites.tscn: File too large (25611 KB)]

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scenes\levels\prince_levels\Tiles\fourSeasonsPlatformer\- READ ME -.txt:
========================================
  
                                                                - READ ME -
  
  Thank you for using the fourSeasonsPlatformer_ [tileset]...part of the fourSeasonPlatformer_ series' of assets on itch.io!
  
  Stuff to know - Tilesets
  
  - Each tile is 16x16 pixels...although some objects/structures/terrain are 16x32/32x16/32x32...[e.g. trees, beehives, big terrain tile]
  - The blackout_ tileset is designed to black out the spaces between tiles [optional]
  
  Stuff to know - Animations
  
  - coin_ animation is 12 frames
  - each eventBlock_ animation is 14 frames [6 animations total]
  - each foreground animation is 8 frames
  
  If you have any questions or requests you can contact me at analogstudios.inc@gmail.com
  
  
  
  
  
  

[Skipped c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scenes\levels\prince_levels\game_prince.tscn: File too large (148 KB)]

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\autoload\audio_manager.gd:
========================================
  extends Node
  
  @export var autoplay: bool = false
  @export var default_stream: AudioStream = null
  
  var audio_player: AudioStreamPlayer
  var current_track: AudioStream = null
  
  func _ready():
  	# Initialize the AudioStreamPlayer
  	audio_player = AudioStreamPlayer.new()
  	audio_player.name = "AudioStreamPlayer"
  	add_child(audio_player)
  
  	# Connect the finished signal to handle when music ends
  	audio_player.finished.connect(_on_audio_finished)
  
  	# Autoplay if enabled
  	if autoplay and default_stream:
  		play_track(default_stream)
  
  func play_track(audio_stream: AudioStream):
  	if audio_stream != current_track:
  		audio_player.stop()
  		audio_player.stream = audio_stream
  		audio_player.play()
  		current_track = audio_stream
  	elif not audio_player.playing:
  		audio_player.play()
  
  func stop_track():
  	audio_player.stop()
  
  func is_playing() -> bool:
  	return audio_player.playing
  
  func _on_audio_finished():
  	current_track = null  # Reset track when finished

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\autoload\constants.gd:
========================================
  extends Node
  
  ## Global constants for The Little Saint game
  
  # Game States
  enum GameState {
  	MENU,           # In main menu
  	PLAYING,        # Actively playing
  	PAUSED,         # Game paused
  	GAME_OVER,      # Player died or level failed
  	CUTSCENE,       # In a cutscene
  	DIALOGUE,       # In dialogue
  	LOADING         # Loading screen
  }
  
  # Player Movement
  const PLAYER_DEFAULT_SPEED: float = 200.0
  const PLAYER_DEFAULT_JUMP_VELOCITY: float = -250.0
  const PLAYER_DEFAULT_FLY_VELOCITY: float = -150.0
  const PLAYER_DEFAULT_GRAVITY: float = 300.0
  const PLAYER_MAX_JUMPS: int = 2
  
  # Player Status
  const PLAYER_DEFAULT_MAX_HEALTH: float = 3.0
  const PLAYER_INVULNERABILITY_TIME: float = 1.0
  const PLAYER_DEFAULT_FLY_TIME: float = 4.0
  
  # File Paths
  const SETTINGS_FILE_PATH: String = "user://settings.cfg"
  const SAVE_FILE_PATH: String = "user://save_data.tres"
  const OUTFIT_FILE_PATH: String = "user://outfits.tres"
  const FAVORITES_FILE_PATH: String = "user://favorites.cfg"
  
  # Config Sections
  const SECTION_SETTINGS: String = "settings"
  const SECTION_PLAYER: String = "player"
  const SECTION_OUTFITS: String = "outfits"
  const SECTION_FAVORITES: String = "favorites"
  
  # Physics
  const DEFAULT_GRAVITY: float = 980.0
  
  # Animation
  const ANIMATION_IDLE: String = "idle"
  const ANIMATION_WALKING: String = "walking"
  const ANIMATION_ATTACK: String = "walking6"  # Current attack animation
  const ANIMATION_HURT: String = "hurt"
  const ANIMATION_DEATH: String = "dead"
  const ANIMATION_JUMP: String = "animation4"  # May need to be updated
  
  # Layers
  enum Layer {
  	PLAYER = 1,
  	PORTS = 2,
  	ITEM = 3,
  	ENEMY = 4
  }
  
  # Input Action Names
  const INPUT_RIGHT: String = "right"
  const INPUT_LEFT: String = "left"
  const INPUT_UP: String = "up"
  const INPUT_DOWN: String = "down"
  const INPUT_ATTACK: String = "attack"
  const INPUT_DEFEND: String = "defend"
  const INPUT_MENU: String = "Menu"
  
  # Scene paths
  const MAIN_MENU_SCENE: String = "res://scenes/ui/main_menu/main_menu.tscn"
  const ADVENTURE_LEVEL_SCENE: String = "res://scenes/levels/adventure_mode/adventure_level.tscn"
  const SETTINGS_MENU_SCENE: String = "res://scenes/ui/settings/settings_menu.tscn"
  const CUSTOMIZER_SCENE: String = "res://scenes/ui/character_customizer/customizer.tscn"
  const AUDIO_SETTINGS_SCENE: String = "res://scenes/ui/settings/audio_settings.tscn"
  
  # Debug
  const DEBUG_ENABLED: bool = false

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\autoload\game_manager.gd:
========================================
  extends Node
  
  ## Game Manager handles game state, scene transitions, and global events
  ## Serves as the central controller for the game
  
  # Game state
  var current_state: Constants.GameState = Constants.GameState.MENU
  var previous_state: Constants.GameState = Constants.GameState.MENU
  
  # Player reference
  var player = null
  
  # Current level
  var current_level: String = ""
  var current_level_node = null
  
  # Game progress
  var collected_coins: int = 0
  var unlocked_levels: Array = []
  var completed_quests: Array = []
  
  # Events
  signal state_changed(new_state, old_state)
  signal level_started(level_name)
  signal level_completed(level_name)
  signal player_died()
  signal coin_collected(total_coins)
  signal game_saved()
  signal game_loaded()
  
  # Initialization
  func _ready():
  	process_mode = Node.PROCESS_MODE_ALWAYS # Game manager should run even when paused
  	print("Game Manager initialized")
  
  # State management
  func change_state(new_state: Constants.GameState) -> void:
  	if new_state == current_state:
  		return
  
  	previous_state = current_state
  	current_state = new_state
  
  	match new_state:
  		Constants.GameState.PAUSED:
  			get_tree().paused = true
  		Constants.GameState.PLAYING, Constants.GameState.MENU:
  			get_tree().paused = false
  
  	emit_signal("state_changed", current_state, previous_state)
  	print("Game state changed to: ", Constants.GameState.keys()[current_state])
  
  func is_state(state: Constants.GameState) -> bool:
  	return current_state == state
  
  func resume_previous_state() -> void:
  	change_state(previous_state)
  
  # Scene management
  func change_scene(scene_path: String) -> void:
  	call_deferred("_deferred_change_scene", scene_path)
  
  func _deferred_change_scene(scene_path: String) -> void:
  	# Clear any popups or overlays
  	if PopupManager:
  		PopupManager.close_all_dialogs()
  
  	# Store reference to current level if it's a level scene
  	if scene_path.begins_with("res://scenes/levels/"):
  		current_level = scene_path
  
  	# Transition animation could be added here
  	get_tree().change_scene_to_file(scene_path)
  
  	# After scene change, set appropriate state
  	if scene_path == Constants.MAIN_MENU_SCENE:
  		change_state(Constants.GameState.MENU)
  	elif scene_path.begins_with("res://scenes/levels/"):
  		change_state(Constants.GameState.PLAYING)
  		emit_signal("level_started", scene_path)
  
  # Level management
  func restart_level() -> void:
  	if current_level:
  		change_scene(current_level)
  
  func go_to_main_menu() -> void:
  	change_scene(Constants.MAIN_MENU_SCENE)
  
  # Save and load through SaveManager
  func save_game() -> void:
  	if SaveManager:
  		SaveManager.save_game()
  		emit_signal("game_saved")
  
  func load_game() -> void:
  	if SaveManager:
  		SaveManager.load_game()
  		emit_signal("game_loaded")
  
  # Player-related functions
  func register_player(player_instance) -> void:
  	player = player_instance
  	print("Player registered with Game Manager")
  
  func collect_coin() -> void:
  	collected_coins += 1
  	emit_signal("coin_collected", collected_coins)
  
  func player_death() -> void:
  	change_state(Constants.GameState.GAME_OVER)
  	emit_signal("player_died")
  
  # Event handling
  func notify_level_completed() -> void:
  	if current_level and not unlocked_levels.has(current_level):
  		unlocked_levels.append(current_level)
  	emit_signal("level_completed", current_level)
  
  # Debug helpers
  func toggle_debug_mode() -> void:
  	get_node("/root").get_tree().get_root().set_debug_enabled(not get_node("/root").get_tree().get_root().is_debug_enabled())
  
  # System functions
  func quit_game() -> void:
  	save_game()
  	get_tree().quit()
  
  # Input handling
  func _input(event: InputEvent) -> void:
  	if event.is_action_pressed(Constants.INPUT_MENU):
  		if current_state == Constants.GameState.PLAYING:
  			change_state(Constants.GameState.PAUSED)
  		elif current_state == Constants.GameState.PAUSED:
  			change_state(Constants.GameState.PLAYING)
  
  func _notification(what):
  	if what == NOTIFICATION_WM_CLOSE_REQUEST:
  		# Save game before allowing close
  		print("Game closing - saving data...")
  		SaveManager.save_game()
  		SaveManager.save_settings()
  		get_tree().quit()

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\autoload\save_manager.gd:
========================================
  extends Node
  
  ## SaveManager handles all game saving and loading operations
  ## It manages player data, settings, and outfit configurations
  
  # Current save data instance
  var current_save_data: SaveData = null
  
  # Signals
  signal save_completed(success, message)
  signal load_completed(success, message)
  signal settings_saved(success)
  signal settings_loaded(success)
  signal outfit_saved(success, outfit_name)
  
  # Initialize on ready
  func _ready():
  	print("Save Manager initialized")
  	# Create default save data at startup
  	current_save_data = SaveData.new()
  	# Load settings immediately on startup
  	load_settings()
  
  # Save the full game state
  func save_game() -> bool:
  	if not current_save_data:
  		current_save_data = SaveData.new()
  
  	# Update data before saving
  	_update_save_data()
  
  	# Try to save the resource file
  	var dir = DirAccess.open("user://")
  	if not dir:
  		push_error("Failed to open user:// directory")
  		emit_signal("save_completed", false, "Failed to access save directory")
  		return false
  
  	var success = ResourceSaver.save(current_save_data, Constants.SAVE_FILE_PATH)
  
  	if success == OK:
  		print("Game saved successfully to: ", Constants.SAVE_FILE_PATH)
  		emit_signal("save_completed", true, "Game saved successfully")
  		return true
  	else:
  		push_error("Failed to save game. Error code: " + str(success))
  		emit_signal("save_completed", false, "Failed to save game")
  		return false
  
  # Load the full game state
  func load_game() -> bool:
  	if ResourceLoader.exists(Constants.SAVE_FILE_PATH):
  		var loaded_data = ResourceLoader.load(Constants.SAVE_FILE_PATH)
  
  		if loaded_data is SaveData:
  			current_save_data = loaded_data
  
  			# Apply loaded data to game state
  			_apply_save_data()
  
  			print("Game loaded successfully from: ", Constants.SAVE_FILE_PATH)
  			emit_signal("load_completed", true, "Game loaded successfully")
  			return true
  		else:
  			push_error("Loaded resource is not a SaveData resource")
  	else:
  		print("No save file found at: ", Constants.SAVE_FILE_PATH)
  
  	# If we get here, loading failed
  	emit_signal("load_completed", false, "No save data found or data corrupted")
  	return false
  
  # Update the save data with current game state
  func _update_save_data() -> void:
  	# Get player reference from GameManager
  	var player = null
  	if get_node_or_null("/root/Global") and get_node("/root/Global").player:
  		player = get_node("/root/Global").player
  
  	if player:
  		# Update player data
  		current_save_data.health = player.hud.lifes if player.hud else Constants.PLAYER_DEFAULT_MAX_HEALTH
  		current_save_data.coins = player.hud.coins if player.hud else 0
  		current_save_data.player_position = player.global_position
  		current_save_data.current_level = get_node("/root/Global").current_level
  
  		# Update player stats and settings - Use constants rather than hardcoded values
  		current_save_data.player_speed = player.SPEED
  		current_save_data.player_jump_velocity = player.JUMP_VELOCITY
  		current_save_data.player_fly_velocity = player.FLY_VELOCITY
  		current_save_data.player_gravity = player.GRAVITY
  		current_save_data.player_mode = player.mode
  		current_save_data.player_passed_fly_time = player.passed_fly_time
  		current_save_data.player_jump_counter = player.jump_counter
  		current_save_data.player_ready_for_jump = player.ready_for_jump
  		current_save_data.player_allowed_jumps = player.allowed_jumps
  
  		# Get outfit data - ensure we have a deep copy
  		if player.player_outfit:
  			current_save_data.player_outfit = player.player_outfit.duplicate(true)
  
  		# Update timestamp
  		current_save_data.save_date = Time.get_datetime_string_from_system(false, true)
  
  	# Add global game state
  	if get_node_or_null("/root/Global"):
  		current_save_data.collected_coins = get_node("/root/Global").collected_coins
  		current_save_data.unlocked_levels = get_node("/root/Global").unlocked_levels.duplicate()
  		current_save_data.completed_quests = get_node("/root/Global").completed_quests.duplicate()
  
  # Apply loaded save data to the game
  func _apply_save_data() -> void:
  	# Update GameManager data
  	if get_node_or_null("/root/Global"):
  		get_node("/root/Global").collected_coins = current_save_data.collected_coins
  		get_node("/root/Global").unlocked_levels = current_save_data.unlocked_levels.duplicate()
  		get_node("/root/Global").completed_quests = current_save_data.completed_quests.duplicate()
  		get_node("/root/Global").current_level = current_save_data.current_level
  
  	# We will apply player-specific data when the player is instantiated
  	# or when we change to the appropriate scene
  
  # Apply save data to the player (called when player is instantiated)
  func apply_save_data_to_player(player) -> void:
  	if not current_save_data or not player:
  		return
  
  	# Set player stats from constants if they're not valid in save data
  	player.SPEED = current_save_data.player_speed if current_save_data.player_speed > 0 else Constants.PLAYER_DEFAULT_SPEED
  	player.JUMP_VELOCITY = current_save_data.player_jump_velocity if current_save_data.player_jump_velocity < 0 else Constants.PLAYER_DEFAULT_JUMP_VELOCITY
  	player.FLY_VELOCITY = current_save_data.player_fly_velocity if current_save_data.player_fly_velocity < 0 else Constants.PLAYER_DEFAULT_FLY_VELOCITY
  	player.GRAVITY = current_save_data.player_gravity if current_save_data.player_gravity > 0 else Constants.PLAYER_DEFAULT_GRAVITY
  	player.mode = current_save_data.player_mode
  	player.passed_fly_time = current_save_data.player_passed_fly_time
  	player.jump_counter = current_save_data.player_jump_counter
  	player.ready_for_jump = current_save_data.player_ready_for_jump
  	player.allowed_jumps = current_save_data.player_allowed_jumps
  
  	# Apply outfit if available
  	if current_save_data.player_outfit:
  		player.player_outfit = current_save_data.player_outfit.duplicate(true)
  
  		# If there's a resource-based outfit, update that too
  		if player.current_outfit:
  			player.current_outfit.from_dictionary(current_save_data.player_outfit)
  
  	# Set HUD data if available
  	if player.hud:
  		player.hud.lifes = current_save_data.health
  		player.hud.coins = current_save_data.coins
  		player.hud.load_hearts()
  		player.hud._update_coin_display()
  
  # Settings management - Using player defaults from Constants
  func save_settings() -> bool:
  	var config = ConfigFile.new()
  
  	# Get player for current settings
  	var player = null
  	if get_node_or_null("/root/Global") and get_node("/root/Global").player:
  		player = get_node("/root/Global").player
  
  	# Save constant values if player doesn't exist, otherwise save player values
  	if player:
  		# Save player settings
  		config.set_value(Constants.SECTION_SETTINGS, "speed", player.SPEED)
  		config.set_value(Constants.SECTION_SETTINGS, "jump_velocity", player.JUMP_VELOCITY)
  		config.set_value(Constants.SECTION_SETTINGS, "fly_velocity", player.FLY_VELOCITY)
  		config.set_value(Constants.SECTION_SETTINGS, "gravity", player.GRAVITY)
  		config.set_value(Constants.SECTION_SETTINGS, "mode", player.mode)
  		config.set_value(Constants.SECTION_SETTINGS, "passed_fly_time", player.passed_fly_time)
  		config.set_value(Constants.SECTION_SETTINGS, "jump_counter", player.jump_counter)
  		config.set_value(Constants.SECTION_SETTINGS, "ready_for_jump", player.ready_for_jump)
  		config.set_value(Constants.SECTION_SETTINGS, "allowed_jumps", player.allowed_jumps)
  
  		# Save outfit
  		if player.player_outfit:
  			config.set_value(Constants.SECTION_SETTINGS, "outfit", player.player_outfit)
  	else:
  		# If no player exists, use default constants or current save data
  		config.set_value(Constants.SECTION_SETTINGS, "speed", current_save_data.player_speed)
  		config.set_value(Constants.SECTION_SETTINGS, "jump_velocity", current_save_data.player_jump_velocity)
  		config.set_value(Constants.SECTION_SETTINGS, "fly_velocity", current_save_data.player_fly_velocity)
  		config.set_value(Constants.SECTION_SETTINGS, "gravity", current_save_data.player_gravity)
  		config.set_value(Constants.SECTION_SETTINGS, "mode", current_save_data.player_mode)
  		config.set_value(Constants.SECTION_SETTINGS, "passed_fly_time", current_save_data.player_passed_fly_time)
  		config.set_value(Constants.SECTION_SETTINGS, "jump_counter", current_save_data.player_jump_counter)
  		config.set_value(Constants.SECTION_SETTINGS, "ready_for_jump", current_save_data.player_ready_for_jump)
  		config.set_value(Constants.SECTION_SETTINGS, "allowed_jumps", current_save_data.player_allowed_jumps)
  
  		# Save outfit
  		if current_save_data.player_outfit:
  			config.set_value(Constants.SECTION_SETTINGS, "outfit", current_save_data.player_outfit)
  
  	# Save audio settings
  	var master_bus_idx = AudioServer.get_bus_index("Master")
  	config.set_value(Constants.SECTION_SETTINGS, "master_volume", AudioServer.get_bus_volume_db(master_bus_idx))
  	config.set_value(Constants.SECTION_SETTINGS, "master_mute", AudioServer.is_bus_mute(master_bus_idx))
  
  	# Save the config
  	var err = config.save(Constants.SETTINGS_FILE_PATH)
  	var success = (err == OK)
  
  	if success:
  		print("Settings saved successfully to: ", Constants.SETTINGS_FILE_PATH)
  	else:
  		push_error("Failed to save settings. Error code: " + str(err))
  
  	emit_signal("settings_saved", success)
  	return success
  
  func load_settings() -> bool:
  	var config = ConfigFile.new()
  	var err = config.load(Constants.SETTINGS_FILE_PATH)
  
  	if err != OK:
  		print("No settings file found or error loading settings. Using defaults.")
  		emit_signal("settings_loaded", false)
  		return false
  
  	print("Loading settings from: ", Constants.SETTINGS_FILE_PATH)
  
  	# Create default save data if not already created
  	if not current_save_data:
  		current_save_data = SaveData.new()
  
  	# Load settings into current_save_data for future use
  	current_save_data.player_speed = config.get_value(Constants.SECTION_SETTINGS, "speed", Constants.PLAYER_DEFAULT_SPEED)
  	current_save_data.player_jump_velocity = config.get_value(Constants.SECTION_SETTINGS, "jump_velocity", Constants.PLAYER_DEFAULT_JUMP_VELOCITY)
  	current_save_data.player_fly_velocity = config.get_value(Constants.SECTION_SETTINGS, "fly_velocity", Constants.PLAYER_DEFAULT_FLY_VELOCITY)
  	current_save_data.player_gravity = config.get_value(Constants.SECTION_SETTINGS, "gravity", Constants.PLAYER_DEFAULT_GRAVITY)
  	current_save_data.player_mode = config.get_value(Constants.SECTION_SETTINGS, "mode", "normal")
  	current_save_data.player_passed_fly_time = config.get_value(Constants.SECTION_SETTINGS, "passed_fly_time", 0.0)
  	current_save_data.player_jump_counter = config.get_value(Constants.SECTION_SETTINGS, "jump_counter", 0)
  	current_save_data.player_ready_for_jump = config.get_value(Constants.SECTION_SETTINGS, "ready_for_jump", true)
  	current_save_data.player_allowed_jumps = config.get_value(Constants.SECTION_SETTINGS, "allowed_jumps", Constants.PLAYER_MAX_JUMPS)
  
  	# Load outfit
  	var saved_outfit = config.get_value(Constants.SECTION_SETTINGS, "outfit", null)
  	if saved_outfit:
  		current_save_data.player_outfit = saved_outfit.duplicate(true)
  
  	# Apply audio settings
  	var master_bus_idx = AudioServer.get_bus_index("Master")
  	var volume = config.get_value(Constants.SECTION_SETTINGS, "master_volume", 0.0)
  	var mute = config.get_value(Constants.SECTION_SETTINGS, "master_mute", false)
  
  	AudioServer.set_bus_volume_db(master_bus_idx, volume)
  	AudioServer.set_bus_mute(master_bus_idx, mute)
  
  	print("Settings loaded successfully")
  	emit_signal("settings_loaded", true)
  	return true
  
  # Outfit management
  func save_outfit(outfit_config: Dictionary, name: String = "") -> bool:
  	var favorites = load_favorite_outfits()
  
  	if name.is_empty():
  		name = "Outfit " + str(favorites.size() + 1)
  
  	favorites[name] = outfit_config
  
  	var config = ConfigFile.new()
  	config.set_value(Constants.SECTION_FAVORITES, "outfits", favorites)
  	var err = config.save(Constants.FAVORITES_FILE_PATH)
  	var success = (err == OK)
  
  	if success:
  		print("Outfit saved successfully: ", name)
  	else:
  		push_error("Failed to save outfit. Error code: " + str(err))
  
  	emit_signal("outfit_saved", success, name)
  	return success
  
  func load_favorite_outfits() -> Dictionary:
  	var config = ConfigFile.new()
  	var err = config.load(Constants.FAVORITES_FILE_PATH)
  
  	if err == OK:
  		return config.get_value(Constants.SECTION_FAVORITES, "outfits", {})
  	else:
  		return {}
  
  func delete_outfit(name: String) -> bool:
  	var favorites = load_favorite_outfits()
  
  	if not favorites.has(name):
  		return false
  
  	favorites.erase(name)
  
  	var config = ConfigFile.new()
  	config.set_value(Constants.SECTION_FAVORITES, "outfits", favorites)
  	var err = config.save(Constants.FAVORITES_FILE_PATH)
  
  	return (err == OK)
  
  # Helper functions
  func save_exists() -> bool:
  	return ResourceLoader.exists(Constants.SAVE_FILE_PATH)
  
  func clear_save_data() -> void:
  	var dir = DirAccess.open("user://")
  	if dir:
  		if dir.file_exists(Constants.SAVE_FILE_PATH):
  			dir.remove(Constants.SAVE_FILE_PATH)
  			print("Save data cleared")
  	current_save_data = SaveData.new()
  
  # Return a fresh instance of SaveData
  func create_new_save_data() -> SaveData:
  	return SaveData.new()
  
  # Helper method for other scripts to add callback function when save completes
  func connect_save_completed(target: Object, method: String, binds: Array = [], flags: int = 0) -> void:
  	if not is_connected("save_completed", Callable(target, method)):
  		connect("save_completed", Callable(target, method).bind(binds), flags)
  
  # Called when player instance is being initialized
  func _on_player_ready(player) -> void:
  	call_deferred("apply_save_data_to_player", player)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\base_classes\base_enemy.gd:
========================================
  class_name BaseEnemy
  extends CharacterBody2D
  
  ## Base class for all enemies in the game
  
  # Enemy properties
  @export var max_health: float = 100.0
  @export var speed: float = 80.0
  @export var chase_speed: float = 100.0
  @export var attack_damage: float = 10.0
  @export var attack_cooldown: float = 1.0
  @export var detection_radius: float = 200.0
  @export var attack_radius: float = 75.0
  
  # Current state
  var current_health: float
  var is_dead: bool = false
  var is_chasing: bool = false
  var is_attacking: bool = false
  var can_attack: bool = true
  var target = null
  
  # Nodes (to be assigned by extending classes)
  var animated_sprite: AnimatedSprite2D
  var collision_shape: CollisionShape2D
  var hud = null
  
  # Emitted when enemy dies
  signal enemy_died(enemy)
  # Emitted when enemy takes damage
  signal enemy_damaged(enemy, amount)
  
  func _ready():
  	# Initialize health
  	current_health = max_health
  
  	# Set default animation
  	if animated_sprite:
  		animated_sprite.play("idle")
  
  	# Get HUD reference (if needed)
  	hud = get_node_or_null("../../HUD")
  
  func _physics_process(delta):
  	# Apply gravity
  	if not is_on_floor():
  		velocity.y += calculate_gravity() * delta
  
  	# Core movement
  	move_and_slide()
  
  func calculate_gravity():
  	# Can be overridden by child classes
  	return ProjectSettings.get_setting("physics/2d/default_gravity")
  
  func take_damage(amount):
  	if is_dead:
  		return
  
  	current_health -= amount
  	emit_signal("enemy_damaged", self, amount)
  
  	if current_health <= 0:
  		die()
  	else:
  		play_animation("hurt")
  
  func die():
  	is_dead = true
  	is_chasing = false
  	is_attacking = false
  
  	# Disable collision
  	if collision_shape:
  		collision_shape.set_deferred("disabled", true)
  
  	# Play death animation
  	play_animation("death")
  
  	# Emit signal
  	emit_signal("enemy_died", self)
  
  	# Wait for animation to finish before removing
  	await animated_sprite.animation_finished
  	queue_free()
  
  func play_animation(anim_name: String):
  	if animated_sprite and animated_sprite.sprite_frames.has_animation(anim_name):
  		animated_sprite.play(anim_name)
  
  func chase_target(target_node):
  	if is_dead or is_attacking:
  		return
  
  	target = target_node
  	is_chasing = true
  
  	var direction = (target.global_position - global_position).normalized()
  
  	# Face the correct direction
  	if animated_sprite:
  		animated_sprite.flip_h = direction.x > 0
  
  	# Set velocity
  	velocity.x = direction.x * (chase_speed if is_chasing else speed)
  
  	# Play animation
  	play_animation("walk")
  
  func stop_chase():
  	is_chasing = false
  	velocity.x = 0
  	play_animation("idle")
  	target = null
  
  func attack():
  	if is_dead or not can_attack or not target:
  		return
  
  	is_attacking = true
  	can_attack = false
  	velocity.x = 0
  
  	play_animation("attack")
  
  	# Wait for animation to finish
  	await animated_sprite.animation_finished
  
  	is_attacking = false
  
  	# Start cooldown
  	await get_tree().create_timer(attack_cooldown).timeout
  	can_attack = true
  
  # Called when a player or other entity enters detection radius
  func _on_detection_radius_body_entered(body):
  	if body.name == "Player" and not is_dead:
  		chase_target(body)
  
  # Called when a player or other entity exits detection radius
  func _on_detection_radius_body_exited(body):
  	if body.name == "Player":
  		stop_chase()
  
  # Called when a player enters attack range
  func _on_attack_radius_body_entered(body):
  	if body.name == "Player" and not is_dead:
  		is_chasing = false
  		attack()
  
  # Called when a player exits attack range
  func _on_attack_radius_body_exited(body):
  	if body.name == "Player" and not is_dead:
  		is_chasing = true

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\base_classes\base_power_up.gd:
========================================
  class_name BasePowerUp
  extends Area2D
  
  ## Base class for all power-ups in the game
  
  # Power-up properties
  @export var power_up_name: String = "Power Up"
  @export var description: String = "A mysterious power-up"
  @export var icon_texture: Texture2D
  @export var effect_duration: float = 0.0  # 0 means permanent effect
  @export var play_animation: bool = true
  @export var destroy_on_pickup: bool = true
  
  # Animation
  @export var bounce_height: float = 5.0
  @export var bounce_speed: float = 2.0
  @export var rotation_speed: float = 0.0
  
  # Internal variables
  var original_position: Vector2
  var animation_time: float = 0.0
  var player_ref = null
  
  # Signals
  signal power_up_collected(power_up, player)
  signal power_up_effect_started(power_up, player)
  signal power_up_effect_ended(power_up, player)
  
  func _ready():
  	original_position = global_position
  
  	# Set up collision
  	if not has_node("CollisionShape2D"):
  		push_error("Power-up " + name + " has no CollisionShape2D!")
  
  	# Set up sprite/animation if enabled
  	if play_animation and has_node("Sprite2D"):
  		var sprite = get_node("Sprite2D")
  		if icon_texture:
  			sprite.texture = icon_texture
  
  	# Connect signals
  	body_entered.connect(_on_power_up_body_entered)
  
  func _process(delta):
  	if play_animation:
  		animate_power_up(delta)
  
  func animate_power_up(delta):
  	animation_time += delta
  
  	# Bouncing animation
  	if bounce_height > 0:
  		var bounce_offset = sin(animation_time * bounce_speed) * bounce_height
  		global_position.y = original_position.y + bounce_offset
  
  	# Rotation animation
  	if rotation_speed > 0 and has_node("Sprite2D"):
  		var sprite = get_node("Sprite2D")
  		sprite.rotation += rotation_speed * delta
  
  func _on_power_up_body_entered(body):
  	if body.is_in_group("Player") or body.name == "Player":
  		collect_power_up(body)
  
  func collect_power_up(player):
  	# Store reference to player
  	player_ref = player
  
  	# Disable collision
  	set_collision_mask_value(1, false)
  
  	# Emit collected signal
  	emit_signal("power_up_collected", self, player)
  
  	# Play collection animation if available
  	if has_node("AnimationPlayer"):
  		var anim_player = get_node("AnimationPlayer")
  		if anim_player.has_animation("collect"):
  			anim_player.play("collect")
  			await anim_player.animation_finished
  
  	# Apply effect
  	apply_effect(player)
  
  	# Destroy if set
  	if destroy_on_pickup:
  		queue_free()
  
  func apply_effect(player):
  	# Base implementation just emits signal
  	# Override in child classes to implement specific effects
  	emit_signal("power_up_effect_started", self, player)
  
  	# If temporary effect, setup timer to end effect
  	if effect_duration > 0:
  		await get_tree().create_timer(effect_duration).timeout
  		remove_effect(player)
  
  func remove_effect(player):
  	# Override in child classes to implement specific effect removal
  	emit_signal("power_up_effect_ended", self, player)
  
  # Optional methods for child classes to implement
  func get_effect_description() -> String:
  	return description
  
  func get_icon() -> Texture2D:
  	return icon_texture

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\base_classes\base_projectile.gd:
========================================
  class_name BaseProjectile
  extends CharacterBody2D
  
  ## Base class for all projectiles in the game
  
  # Projectile properties
  @export var speed: float = 100.0
  @export var damage: float = 10.0
  @export var lifetime: float = 5.0  # Time before auto-destruction
  @export var gravity_affected: bool = false
  @export var bounce: bool = false
  @export var bounce_factor: float = 0.5  # How much velocity is retained when bouncing
  
  # Internal variables
  var direction: Vector2 = Vector2.ZERO
  var source_node = null  # Who fired this projectile
  var spawn_position: Vector2
  var spawn_rotation: float
  var time_alive: float = 0.0
  var has_hit: bool = false
  
  # Signals
  signal projectile_hit(projectile, target)
  signal projectile_expired(projectile)
  
  func _ready():
  	# Start lifetime timer
  	if lifetime > 0:
  		get_tree().create_timer(lifetime).timeout.connect(_on_lifetime_expired)
  
  	# Set initial position and rotation
  	global_position = spawn_position
  	global_rotation = spawn_rotation
  
  	# Setup animation if available
  	if has_node("AnimatedSprite2D"):
  		var sprite = get_node("AnimatedSprite2D")
  		if sprite.sprite_frames.has_animation("flying"):
  			sprite.play("flying")
  
  func _physics_process(delta):
  	time_alive += delta
  
  	# Apply gravity if enabled
  	if gravity_affected:
  		velocity.y += ProjectSettings.get_setting("physics/2d/default_gravity") * delta
  
  	# Move the projectile
  	var collision = move_and_collide(velocity * delta)
  
  	# Handle collision
  	if collision and not has_hit:
  		_on_collision(collision)
  
  func setup(dir: Vector2, spawn_pos: Vector2, spawn_rot: float = 0.0, source = null):
  	direction = dir.normalized()
  	spawn_position = spawn_pos
  	spawn_rotation = spawn_rot
  	source_node = source
  
  	# Set initial velocity
  	velocity = direction * speed
  
  	return self  # For method chaining
  
  func _on_collision(collision):
  	var collider = collision.get_collider()
  
  	# Check if we should bounce
  	if bounce and not (collider.is_in_group("Player") or collider.is_in_group("Enemy")):
  		var reflection = collision.get_remainder().bounce(collision.get_normal())
  		velocity = velocity.bounce(collision.get_normal()) * bounce_factor
  		global_position += reflection
  		return
  
  	has_hit = true
  
  	# Handle different collision types
  	if collider.is_in_group("Player") and source_node != collider:
  		_on_hit_player(collider)
  	elif collider.is_in_group("Enemy") and source_node != collider:
  		_on_hit_enemy(collider)
  	else:
  		_on_hit_environment(collider)
  
  func _on_hit_player(player):
  	emit_signal("projectile_hit", self, player)
  
  	# Apply damage
  	if player.has_method("take_damage"):
  		player.take_damage(damage)
  
  	# Get HUD reference
  	var hud = get_node_or_null("../HUD")
  	if hud and hud.has_method("change_life"):
  		hud.change_life(-damage/100.0)  # Assuming HUD uses 0-1 scale
  
  	# Play hit effect if available
  	play_hit_effect()
  
  	queue_free()
  
  func _on_hit_enemy(enemy):
  	emit_signal("projectile_hit", self, enemy)
  
  	# Apply damage
  	if enemy.has_method("take_damage"):
  		enemy.take_damage(damage)
  
  	# Play hit effect if available
  	play_hit_effect()
  
  	queue_free()
  
  func _on_hit_environment(object):
  	emit_signal("projectile_hit", self, object)
  
  	# Play hit effect if available
  	play_hit_effect()
  
  	queue_free()
  
  func _on_lifetime_expired():
  	if not has_hit:
  		emit_signal("projectile_expired", self)
  		queue_free()
  
  func play_hit_effect():
  	# If we have an AnimatedSprite2D, try to play the hit animation
  	if has_node("AnimatedSprite2D"):
  		var sprite = get_node("AnimatedSprite2D")
  		if sprite.sprite_frames.has_animation("hit"):
  			# Disconnect from physics process
  			set_physics_process(false)
  
  			# Stop motion
  			velocity = Vector2.ZERO
  
  			# Play hit animation
  			sprite.play("hit")
  
  			# Wait for animation to finish
  			await sprite.animation_finished

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\characters\character_sprites.gd:
========================================
  class_name CharacterSprites
  extends Node2D
  
  var animation_frames = {
  	"idle": [0, 1, 2, 3, 4, 5, 6, 7],
  	"animation1": [8, 9, 10, 11, 12, 13, 14, 15],
  	"animation2": [16, 17, 18, 19, 20, 21, 22, 23],
  	"walking": [24, 25, 26, 27, 28, 29, 30, 31],
  	"animation4": [32, 33, 34, 35, 36],
  	"animation5": [40, 41, 42, 43, 44],
  	"animation6": [48, 49, 50, 51, 52],
  	"animation7": [56, 57, 58, 59, 60],
  	"animation8": [64, 65, 66, 67, 68],
  	"animation9": [72, 73, 74, 75, 76],
  	"animation10": [80, 81, 82, 83, 84],
  	"animation11": [88, 89, 90, 91, 92],
  	"animation12": [96, 97, 98, 99, 100, 101, 102, 103],
  	"animation13": [104, 105, 106, 107, 108, 109, 110, 111],
  	"animation14": [112, 113, 114, 115, 116, 117, 118, 119],
  	"animation15": [120, 121, 122, 123, 124, 125, 126, 127],
  	"animation16": [128, 129, 130, 131],
  	"animation17": [136, 137, 138, 139],
  	"animation18": [144, 145, 146, 147], #attack knife
  	"animation19": [152, 153, 154, 155],
  	"animation20": [160],
  	"animation21": [168],
  	"animation22": [176],
  	"animation23": [184],
  	"animation24": [192],
  	"animation25": [200],
  	"animation26": [208],
  	"animation27": [216],
  	"dead": [224, 225],
  	"animation29": [232, 233, 234, 235, 236],
  	"walking0": [240, 241, 242, 243, 244],
  	"walking1": [248, 249, 250, 251, 252],
  	"walking2": [256, 257, 258, 259, 260],
  	"walking3": [264, 265, 266, 267, 268],
  	"walking4": [272, 273, 274, 275, 276],
  	"walking5": [280, 281, 282, 283, 284], #attack axe right
  	"walking6": [288, 289, 290, 291, 292], #attack axe left
  	"walking7": [296, 297],
  	"walking8": [304, 305],
  	"walking9": [312, 313],
  	"animation40": [320, 321],
  	"animation41": [328, 329, 330, 331, 332],
  	"animation42": [336, 337, 338, 339, 340],
  	"animation43": [344, 345, 346, 347, 348],
  	"animation44": [352, 353, 354, 355, 356],
  	"animation45": [360, 361, 362, 363, 364],
  	"animation46": [368, 369, 370, 371, 372],
  	"animation47": [376, 377, 378, 379, 380],
  	"animation48": [384, 385, 386, 387, 388],
  	"hurt":        [25*8, 27*8],
  }
  
  var default_outfit = {
  	"beard": 1,
  	"lipstick": 1,
  	"eyes": 1,
  	"shoes": 1,
  	"earrings": 1,
  	"hats": 1,
  	"glasses": 1,
  	"clothes_down": 1,
  	"clothes_up": 1,
  	"clothes_complete": 1,
  	"bodies": 1,
  	"hair": 1
  }

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\characters\player.gd:
========================================
  class_name Player
  extends CharacterBody2D
  
  @export var joystick_right: VirtualJoystick
  @export var debug_mode: bool = false
  
  # Environment variables - use constants from Constants singleton
  var SPEED = Constants.PLAYER_DEFAULT_SPEED
  var JUMP_VELOCITY = Constants.PLAYER_DEFAULT_JUMP_VELOCITY
  var FLY_VELOCITY = Constants.PLAYER_DEFAULT_FLY_VELOCITY
  var GRAVITY = Constants.PLAYER_DEFAULT_GRAVITY
  
  # Character mode variables
  var mode = "normal"
  var passed_fly_time = 0.0
  var jump_counter = 0
  var ready_for_jump = true
  var allowed_jumps = Constants.PLAYER_MAX_JUMPS
  
  # Character health reference
  var hud
  
  # Character design variables
  var player_animations
  var current_animation = Constants.ANIMATION_IDLE
  var player_outfit
  var play_attack_animation = false
  var attack_animation = Constants.ANIMATION_ATTACK
  
  # Resource-based outfit system
  var current_outfit: PlayerOutfitResource = null
  
  # Reference to the state machine
  @onready var state_machine = $StateMachine
  
  func _ready() -> void:
  	# Initialize your global variables here
  	hud = get_node_or_null("../../HUD")
  	player_animations = get_node("character_sprites").animation_frames
  
  	# Initialize outfit with defaults
  	var default_player_outfit = get_node("character_sprites").default_outfit
  	get_node("character_sprites/masks").visible = false
  	player_outfit = default_player_outfit.duplicate(true)
  
  	# Create outfit resource
  	current_outfit = PlayerOutfitResource.new()
  
  	# Register with GameManager
  	if get_node_or_null("/root/Global"):
  		Global.register_player(self)
  
  	# Connect to SaveManager signals
  	if get_node_or_null("/root/SaveManager"):
  		SaveManager.connect("load_completed", Callable(self, "_on_save_loaded"))
  		SaveManager.connect("settings_loaded", Callable(self, "_on_settings_loaded"))
  
  		# Load settings from SaveManager
  		if SaveManager.current_save_data:
  			update_from_save_data()
  
  	if debug_mode:
  		print("Player ready, State Machine initialized")
  		print("Initial player stats: Speed=", SPEED, ", Jump=", JUMP_VELOCITY,
  			  ", Fly=", FLY_VELOCITY, ", Gravity=", GRAVITY)
  
  # Save current player settings
  func save_settings():
  	if get_node_or_null("/root/SaveManager"):
  		SaveManager.save_settings()
  
  # New methods for SaveManager integration
  func _on_save_loaded(success, message):
  	if success:
  		update_from_save_data()
  
  func _on_settings_loaded(success):
  	if success:
  		update_from_save_data()
  
  func update_from_save_data():
  	if not get_node_or_null("/root/SaveManager") or not SaveManager.current_save_data:
  		print("No save data available to update from")
  		return
  
  	var save_data = SaveManager.current_save_data
  
  	# Update movement parameters
  	SPEED = save_data.player_speed
  	JUMP_VELOCITY = save_data.player_jump_velocity
  	FLY_VELOCITY = save_data.player_fly_velocity
  	GRAVITY = save_data.player_gravity
  
  	# Update state
  	mode = save_data.player_mode
  	passed_fly_time = save_data.player_passed_fly_time
  	jump_counter = save_data.player_jump_counter
  	ready_for_jump = save_data.player_ready_for_jump
  	allowed_jumps = save_data.player_allowed_jumps
  
  	# Apply outfit if available
  	if save_data.player_outfit and not save_data.player_outfit.is_empty():
  		# Update resource and dictionary
  		if current_outfit:
  			current_outfit.from_dictionary(save_data.player_outfit)
  		else:
  			current_outfit = PlayerOutfitResource.new().from_dictionary(save_data.player_outfit)
  
  		# Apply current outfit to character
  		player_outfit = save_data.player_outfit.duplicate(true)
  		_update_outfit_visuals()
  
  	if debug_mode:
  		print("Updated player from save data: Speed=", SPEED, ", Jump=", JUMP_VELOCITY)
  		print("Outfit loaded:", player_outfit)
  
  # Update outfit sprite visibility and animations
  func _update_outfit_visuals():
  	for category in player_outfit:
  		if has_node("character_sprites/" + category):
  			var sprite = get_node("character_sprites/" + category)
  			var value = str(player_outfit[category])
  
  			if value == "none":
  				sprite.visible = false
  			else:
  				sprite.visible = true
  				sprite.animation = value
  				sprite.frame = 1
  
  # Helper method to play animations
  func play_animation(anim_name: String):
  	current_animation = anim_name
  
  # Return gravity as a Vector2 to avoid conflicts with PhysicsBody2D
  func calculate_gravity() -> Vector2:
  	return Vector2(0, GRAVITY)
  
  # Keep portal handlers and other methods
  func _on_test_portal_entered(_body):
  	if get_node_or_null("/root/Global"):
  		Global.change_scene(Constants.MAIN_MENU_SCENE)
  	mode = "fly"
  	save_settings()
  
  func _on_elias_portal_entered(_body):
  	print("Elias")
  	save_settings()
  
  func _on_ardit_portal_entered(_body):
  	if get_node_or_null("/root/Global"):
  		Global.change_scene("res://Arrogance.tscn")
  	save_settings()
  
  func _on_sebastian_portal_entered(_body):
  	mode = "normal"
  	if get_node_or_null("/root/Global"):
  		Global.change_scene("res://scenes/levels/sebastian_levels/level_1.tscn")
  	save_settings()
  
  func _on_prince_portal_entered(_body):
  	if get_node_or_null("/root/Global"):
  		Global.change_scene("res://scenes/levels/prince_levels/platform.tscn")
  	save_settings()
  
  func _on_fallzone_body_entered(_body):
  	if get_node_or_null("/root/Global"):
  		Global.change_scene("res://scenes/levels/ardit_levels/arrogance.tscn")
  
  func _on_life_up_body_entered(_body):
  	if hud:
  		hud.change_life(0.25)
  
  func _on_life_down_body_entered(_body):
  	if hud:
  		hud.change_life(-0.25)
  
  func death():
  	$CollisionShape2D.disabled = true
  	current_animation = "dead"
  
  	# Notify GameManager of player death
  	if get_node_or_null("/root/Global"):
  		Global.player_death()
  
  	self.queue_free()
  
  	if get_node_or_null("/root/Global"):
  		Global.go_to_main_menu()
  
  func _on_test_portal_body_entered(_body):
  	if get_node_or_null("/root/Global"):
  		Global.change_scene("res://scenes/levels/adventure_mode/adventure_level.tscn")
  
  # New methods for gameplay enhancement
  func set_movement_mode(new_mode: String) -> void:
  	mode = new_mode
  
  	if new_mode == "fly":
  		passed_fly_time = 0.0
  
  	if debug_mode:
  		print("Movement mode changed to: ", new_mode)
  
  func enable_attack(enable: bool) -> void:
  	play_attack_animation = enable
  
  func set_attack_animation(anim_name: String) -> void:
  	attack_animation = anim_name
  
  func add_extra_jumps(extra_jumps: int) -> void:
  	allowed_jumps += extra_jumps
  
  func take_damage(amount: float) -> void:
  	if hud:
  		hud.change_life(-amount / 100.0)
  
  func bounce() -> void:
  	velocity.y = JUMP_VELOCITY * 0.7 # Less powerful than a regular jump

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\characters\player_camera.gd:
========================================
  class_name PlayerCamera
  extends Camera2D
  
  
  # Called when the node enters the scene tree for the first time.
  func _ready():
  	pass # Replace with function body.
  
  
  # Called every frame. 'delta' is the elapsed time since the previous frame.
  func _process(delta):
  	pass

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\enemies\ardit_enemy.gd:
========================================
  class_name ArditEnemy
  extends BaseEnemy
  
  ## Simple patrol enemy that walks back and forth
  
  @export var patrol_distance: float = 100.0
  @export var direction: int = 1  # 1 = right, -1 = left
  
  @onready var ray_cast_right: RayCast2D = $RayCastRight
  @onready var ray_cast_left: RayCast2D = $RayCastLeft
  
  var start_position: Vector2
  var is_patrolling: bool = true
  
  func _ready():
  	# Set base enemy properties
  	max_health = 50.0
  	speed = 60.0
  	chase_speed = 80.0
  	attack_damage = 15.0
  	attack_cooldown = 1.0
  
  	# Set references
  	animated_sprite = $AnimatedSprite2D
  	collision_shape = $CollisionShape2D
  
  	# Store starting position for patrol
  	start_position = global_position
  
  	# Initialize raycasts if not already set
  	if not ray_cast_right:
  		ray_cast_right = $RayCastRight if has_node("RayCastRight") else null
  
  	if not ray_cast_left:
  		ray_cast_left = $RayCastLeft if has_node("RayCastLeft") else null
  
  	# Call parent ready method
  	super._ready()
  
  	# Start patrol behavior
  	play_animation("walk")
  
  func _physics_process(delta):
  	# Call parent implementation for gravity and movement
  	super._physics_process(delta)
  
  	# Handle patrol logic if not chasing or attacking
  	if is_patrolling and not is_chasing and not is_attacking and not is_dead:
  		patrol()
  
  func patrol():
  	# Check wall collisions
  	if ray_cast_right and ray_cast_right.is_colliding():
  		direction = -1
  		animated_sprite.flip_h = false
  	elif ray_cast_left and ray_cast_left.is_colliding():
  		direction = 1
  		animated_sprite.flip_h = true
  
  	# Check patrol distance limits
  	if abs(global_position.x - start_position.x) > patrol_distance:
  		direction *= -1
  		animated_sprite.flip_h = direction > 0
  
  	# Set movement velocity
  	velocity.x = direction * speed
  
  	# Play walk animation
  	play_animation("walk")
  
  func chase_target(target_node):
  	# Stop patrolling when chasing
  	is_patrolling = false
  
  	# Call parent implementation
  	super.chase_target(target_node)
  
  func stop_chase():
  	# Resume patrolling when chase ends
  	is_patrolling = true
  
  	# Call parent implementation
  	super.stop_chase()
  
  # Overridden to properly handle player jumping on enemy
  func _on_top_checker_body_entered(body):
  	if body.name == "Player" and not is_dead:
  		# Player jumped on top, take damage
  		take_damage(current_health)  # Instant kill when jumped on
  
  		# Give player an upward boost if it has the method
  		if body.has_method("bounce"):
  			body.bounce()

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\enemies\goblin_archer.gd:
========================================
  class_name GoblinArcher
  extends BaseEnemy
  
  ## Goblin Archer - Ranged enemy that attacks with arrows/rocks
  
  @export var projectile_scene: PackedScene
  @export var quiver_size: int = 5  # How many arrows before needing to reload
  @export var reload_time: float = 1.5
  @export var attack_delay: float = 0.5  # Time before arrow is fired after attack animation starts
  
  var arrows_remaining: int
  var is_reloading: bool = false
  
  func _ready():
  	# Set base enemy properties
  	max_health = 70.0
  	speed = 60.0
  	chase_speed = 80.0
  	attack_damage = 8.0
  	attack_cooldown = 0.7
  
  	# Initialize archer specific properties
  	arrows_remaining = quiver_size
  
  	# Set references
  	animated_sprite = $AnimatedSprite2D
  	collision_shape = $CollisionShape2D
  
  	# Call parent ready method
  	super._ready()
  
  func attack():
  	if is_dead or not can_attack or not target or is_reloading:
  		return
  
  	# Check if we need to reload
  	if arrows_remaining <= 0:
  		reload()
  		return
  
  	is_attacking = true
  	can_attack = false
  	velocity.x = 0
  
  	play_animation("attack")
  
  	# Wait for the right animation frame to spawn projectile
  	await get_tree().create_timer(attack_delay).timeout
  
  	# Spawn projectile if we still have a target
  	if target and not is_dead:
  		spawn_projectile()
  		arrows_remaining -= 1
  
  	# Wait for animation to finish
  	await animated_sprite.animation_finished
  
  	is_attacking = false
  
  	# Start cooldown
  	await get_tree().create_timer(attack_cooldown).timeout
  	can_attack = true
  
  func reload():
  	is_reloading = true
  
  	# Play reload animation if available, otherwise just idle
  	if animated_sprite.sprite_frames.has_animation("reload"):
  		play_animation("reload")
  	else:
  		play_animation("idle")
  
  	# Wait for reload time
  	await get_tree().create_timer(reload_time).timeout
  
  	# Refill quiver
  	arrows_remaining = quiver_size
  	is_reloading = false
  
  func spawn_projectile():
  	# Make sure we have a projectile scene
  	if not projectile_scene:
  		projectile_scene = load("res://scenes/core/projectiles/rock.tscn")
  
  	# Create projectile instance
  	var instance = projectile_scene.instantiate()
  
  	# Get direction to target
  	var direction = (target.global_position - global_position).normalized()
  
  	# Setup the projectile
  	if instance is BaseProjectile:
  		instance.setup(
  			direction,
  			global_position,
  			global_rotation,
  			self
  		)
  	else:
  		# Legacy fallback for existing implementation
  		instance.direction = direction
  		instance.spawn_position = global_position
  		instance.spawn_rotation = global_rotation
  
  	# Add projectile to the main scene
  	var main = get_node("../../")
  	main.add_child(instance)
  
  # Connection to detection radius (override parent implementation)
  func _on_detection_radius_3_body_entered(body):
  	if body.name == "Player" and not is_dead:
  		chase_target(body)
  
  func _on_detection_radius_3_body_exited(body):
  	if body.name == "Player":
  		stop_chase()
  
  # Connection to attack zone (override parent implementation)
  func _on_attack_radius_3_body_entered(body):
  	if body.name == "Player":
  		is_chasing = false
  		attack()
  
  		# Setup continuous attack if in range
  		var attack_timer = func():
  			while is_attacking == false and can_attack and not is_dead and body and is_instance_valid(body):
  				attack()
  				await get_tree().create_timer(0.1).timeout
  
  		attack_timer.call()
  
  func _on_attack_radius_3_body_exited(body):
  	if body.name == "Player":
  		is_chasing = true
  		chase_target(body)
  
  # Connection to death zone (override parent implementation)
  func _on_death_radius_3_body_entered(body):
  	if body.name == "Player":
  		take_damage(current_health)  # Instant death

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\enemies\goblin_mage.gd:
========================================
  class_name GoblinMage
  extends BaseEnemy
  
  ## Goblin Mage - Ranged magical enemy that attacks with spell projectiles
  
  @export var projectile_scene: PackedScene
  @export var mana: float = 100.0
  @export var mana_regen_rate: float = 5.0
  @export var spell_mana_cost: float = 20.0
  @export var attack_delay: float = 1.0
  
  var current_mana: float
  var can_cast: bool = true
  
  func _ready():
  	# Set base enemy properties
  	max_health = 60.0
  	speed = 40.0
  	chase_speed = 50.0
  	attack_damage = 15.0
  	attack_cooldown = 3.0
  
  	# Initialize goblin mage specific properties
  	current_mana = mana
  
  	# Set references
  	animated_sprite = $AnimatedSprite2D
  	collision_shape = $CollisionShape2D
  
  	# Call parent ready method
  	super._ready()
  
  func _process(delta):
  	# Regenerate mana
  	if current_mana < mana:
  		current_mana = min(current_mana + mana_regen_rate * delta, mana)
  
  func attack():
  	if is_dead or not can_attack or not target or current_mana < spell_mana_cost:
  		return
  
  	is_attacking = true
  	can_attack = false
  	velocity.x = 0
  
  	play_animation("attack")
  
  	# Wait for the right animation frame to spawn projectile
  	await get_tree().create_timer(attack_delay).timeout
  
  	# Spawn projectile if we still have a target
  	if target and not is_dead:
  		spawn_projectile()
  
  	# Wait for animation to finish
  	await animated_sprite.animation_finished
  
  	is_attacking = false
  
  	# Start cooldown
  	await get_tree().create_timer(attack_cooldown).timeout
  	can_attack = true
  
  func spawn_projectile():
  	# Make sure we have a projectile scene
  	if not projectile_scene:
  		projectile_scene = load("res://scenes/core/projectiles/mage_ball.tscn")
  
  	# Create projectile instance
  	var instance = projectile_scene.instantiate()
  
  	# Get direction to target
  	var direction = (target.global_position - global_position).normalized()
  
  	# Setup the projectile
  	if instance is BaseProjectile:
  		instance.setup(
  			direction,
  			global_position,
  			global_rotation,
  			self
  		)
  	else:
  		# Legacy fallback for existing implementation
  		instance.direction = direction
  		instance.spawn_position = global_position
  		instance.spawn_rotation = global_rotation
  
  	# Add projectile to the main scene
  	var main = get_node("../../")
  	main.add_child(instance)
  
  	# Consume mana
  	current_mana -= spell_mana_cost
  
  # Connection to detection radius (override parent implementation)
  func _on_detection_radius_2_body_entered(body):
  	if body.name == "Player" and not is_dead:
  		chase_target(body)
  
  func _on_detection_radius_2_body_exited(body):
  	if body.name == "Player":
  		stop_chase()
  
  # Connection to attack zone (override parent implementation)
  func _on_attackzone_2_body_entered(body):
  	if body.name == "Player":
  		is_chasing = false
  		attack()
  
  func _on_attackzone_2_body_exited(body):
  	if body.name == "Player":
  		is_chasing = true
  		chase_target(body)
  
  # Connection to death zone (override parent implementation)
  func _on_death_zone_2_body_entered(body):
  	if body.name == "Player":
  		take_damage(current_health)  # Instant death

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\enemies\goblin_melee.gd:
========================================
  class_name GoblinMelee
  extends BaseEnemy
  
  ## Goblin Melee - Close combat enemy that attacks directly
  
  @export var rage_threshold: float = 0.3  # Percentage of health that triggers rage mode
  @export var rage_speed_multiplier: float = 1.5
  @export var rage_damage_multiplier: float = 1.2
  
  var is_enraged: bool = false
  var base_speed: float
  var base_chase_speed: float
  var base_attack_damage: float
  
  func _ready():
  	# Set base enemy properties
  	max_health = 100.0
  	speed = 80.0
  	chase_speed = 100.0
  	attack_damage = 20.0
  	attack_cooldown = 1.0
  
  	# Store base values for rage mode
  	base_speed = speed
  	base_chase_speed = chase_speed
  	base_attack_damage = attack_damage
  
  	# Set references
  	animated_sprite = $AnimatedSprite2D
  	collision_shape = $CollisionShape2D
  
  	# Call parent ready method
  	super._ready()
  
  func take_damage(amount):
  	super.take_damage(amount)
  
  	# Check if we should enter rage mode
  	if not is_enraged and current_health <= max_health * rage_threshold:
  		enter_rage_mode()
  
  func enter_rage_mode():
  	is_enraged = true
  
  	# Increase stats
  	speed = base_speed * rage_speed_multiplier
  	chase_speed = base_chase_speed * rage_speed_multiplier
  	attack_damage = base_attack_damage * rage_damage_multiplier
  
  	# Visual indication of rage if available
  	if animated_sprite.sprite_frames.has_animation("rage"):
  		animated_sprite.play("rage")
  
  	# Play a sound if available
  	if has_node("AudioStreamPlayer"):
  		var audio = get_node("AudioStreamPlayer")
  		audio.play()
  
  func attack():
  	if is_dead or not can_attack or not target:
  		return
  
  	is_attacking = true
  	can_attack = false
  	velocity.x = 0
  
  	# Use rage attack animation if available and enraged
  	if is_enraged and animated_sprite.sprite_frames.has_animation("rage_attack"):
  		play_animation("rage_attack")
  	else:
  		play_animation("attack")
  
  	# Apply damage to player
  	if target.has_method("take_damage"):
  		target.take_damage(attack_damage)
  
  	# Update HUD
  	if hud and hud.has_method("change_life"):
  		hud.change_life(-attack_damage/100.0)  # Assuming health is on 0-1 scale for HUD
  
  	# Wait for animation to finish
  	await animated_sprite.animation_finished
  
  	is_attacking = false
  
  	# Start cooldown
  	await get_tree().create_timer(attack_cooldown).timeout
  	can_attack = true
  
  # Connection to detection radius (override parent implementation)
  func _on_detection_radius_body_entered(body):
  	if body.name == "Player" and not is_dead:
  		chase_target(body)
  
  func _on_detection_radius_body_exited(body):
  	if body.name == "Player":
  		stop_chase()
  
  # Connection to attack zone (override parent implementation)
  func _on_attackzone_body_entered(body):
  	if body.name == "Player":
  		is_chasing = false
  		attack()
  
  func _on_attackzone_body_exited(body):
  	if body.name == "Player":
  		is_chasing = true
  		chase_target(body)
  
  # Connection to death zone (override parent implementation)
  func _on_deathzone_body_entered(body):
  	if body.name == "Player":
  		take_damage(current_health)  # Instant death

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\enemies\prince_enemy.gd:
========================================
  class_name PrinceEnemy
  extends BaseEnemy
  
  ## Simple patrol enemy that walks back and forth (used in prince levels)
  
  @export var direction: int = 1  # 1 = right, -1 = left
  @export var damage_on_touch: float = 10.0  # Damage dealt when touching player
  
  @onready var ray_cast_right: RayCast2D = $RayCastRight
  @onready var ray_cast_left: RayCast2D = $RayCastLeft
  
  var start_position: Vector2
  var is_patrolling: bool = true
  
  func _ready():
  	# Set base enemy properties
  	max_health = 40.0
  	speed = 60.0
  	chase_speed = speed  # Same as normal speed since this enemy doesn't chase
  	attack_damage = damage_on_touch
  
  	# Set references
  	animated_sprite = $AnimatedSprite2D
  	collision_shape = $CollisionShape2D
  
  	# Store starting position
  	start_position = global_position
  
  	# Initialize raycasts if not already set
  	if not ray_cast_right:
  		ray_cast_right = $RayCastRight if has_node("RayCastRight") else null
  
  	if not ray_cast_left:
  		ray_cast_left = $RayCastLeft if has_node("RayCastLeft") else null
  
  	# Call parent ready method
  	super._ready()
  
  	# Start patrol behavior
  	play_animation("walk")
  
  func _physics_process(delta):
  	# Call parent implementation for gravity and movement
  	super._physics_process(delta)
  
  	# Handle patrol logic if not chasing or attacking
  	if is_patrolling and not is_dead:
  		patrol()
  
  func patrol():
  	# Check wall collisions
  	if ray_cast_right and ray_cast_right.is_colliding():
  		direction = -1
  		animated_sprite.flip_h = false
  	elif ray_cast_left and ray_cast_left.is_colliding():
  		direction = 1
  		animated_sprite.flip_h = true
  
  	# Set movement velocity
  	velocity.x = direction * speed
  
  	# Play walk animation
  	play_animation("walk")
  
  # Override to handle damage-on-touch behavior
  func _on_body_entered(body):
  	if body.name == "Player" and not is_dead:
  		# Deal damage to player
  		if body.has_method("take_damage"):
  			body.take_damage(damage_on_touch)
  
  		# Update HUD
  		if hud and hud.has_method("change_life"):
  			hud.change_life(-damage_on_touch/100.0)  # Assuming health is on 0-1 scale for HUD

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\items\coins.gd:
========================================
  class_name Coins
  extends Area2D
  
  signal coin_collected
  
  
  
  func _on_coins_body_entered(body):
  	get_parent().get_node("HUD").coin_collected()
  	$AnimationPlayer.play("bounce")
  	set_collision_mask_value(1,false)
  
  
  func _on_animation_player_animation_finished(anim_name):
  	queue_free()

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\items\elixir.gd:
========================================
  class_name Elixir
  extends BasePowerUp
  
  ## Power-up that gives the player temporary flying ability via a magical elixir
  
  func _ready():
  	# Set power-up properties
  	power_up_name = "Magic Elixir"
  	description = "Grants temporary flying ability"
  	effect_duration = 20.0  # 20 seconds of flight
  	destroy_on_pickup = true
  
  	# Set animation properties (optional: tweak to differentiate visually from Angel Wings)
  	bounce_height = 6.0
  	bounce_speed = 2.0
  	rotation_speed = 1.0
  
  	# Call parent ready method
  	super._ready()
  
  func apply_effect(player):
  	# Call the parent implementation for signals
  	super.apply_effect(player)
  
  	# Set the player's movement mode
  	if player.has_method("set_movement_mode"):
  		player.set_movement_mode("fly")
  	else:
  		player.mode = "fly"
  
  	print("Player gained flight ability via Elixir")
  
  	# Update the Elixir fill in HUD
  	var hud = get_tree().get_root().find_child("HUD", true, false)
  	if hud:
  		hud.collect_softpower()  # This will add 25% elixir
  
  	# Show notification to player
  	var popup_manager = get_node_or_null("/root/PopupManager")
  	if popup_manager:
  		popup_manager.info("Elixir Power", "You've drunk the magic elixir! You can fly for " + str(effect_duration) + " seconds.")
  
  	# Add a visible timer to the HUD if available
  	if hud and hud.has_method("show_ability_timer"):
  		hud.show_ability_timer("Flight", effect_duration)
  
  func remove_effect(player):
  	# Set the player's movement mode back to normal
  	if player.has_method("set_movement_mode"):
  		player.set_movement_mode("normal")
  	else:
  		player.mode = "normal"
  
  	player.passed_fly_time = 0.0
  
  	# Let the player know the effect has ended
  	var popup_manager = get_node_or_null("/root/PopupManager")
  	if popup_manager:
  		popup_manager.info("Elixir Expired", "The elixir's magic has worn off. You can't fly anymore.")
  
  	super.remove_effect(player)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\items\power_attack.gd:
========================================
  class_name PowerAttack
  extends BasePowerUp
  
  ## Power-up that gives the player an axe attack ability
  
  func _ready():
  	# Set power-up properties
  	power_up_name = "Battle Axe"
  	description = "Grants the ability to attack with a powerful axe"
  	destroy_on_pickup = true
  
  	# Set animation properties
  	bounce_height = 5.0
  	bounce_speed = 2.0
  	rotation_speed = 1.0
  
  	# Call parent ready method
  	super._ready()
  
  func apply_effect(player):
  	# Call the parent implementation for signals
  	super.apply_effect(player)
  
  	# Set the player's attack animation
  	if player.has_method("set_attack_animation"):
  		player.set_attack_animation("walking6")
  	else:
  		# Fallback for current implementation
  		player.attack_animation = "walking6"
  
  	# Enable attack ability if player has the method
  	if player.has_method("enable_attack"):
  		player.enable_attack(true)
  
  	print("Player gained axe attack ability")
  
  	# Show notification to player
  	var popup_manager = get_node_or_null("/root/PopupManager")
  	if popup_manager:
  		popup_manager.info("New Ability", "You've acquired a battle axe! Press the attack button to use it.")

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\items\power_fly.gd:
========================================
  class_name PowerFly
  extends BasePowerUp
  
  ## Power-up that gives the player temporary flying ability
  
  func _ready():
  	# Set power-up properties
  	power_up_name = "Angel Wings"
  	description = "Grants temporary flying ability"
  	effect_duration = 20.0  # 20 seconds of flight
  	destroy_on_pickup = true
  
  	# Set animation properties
  	bounce_height = 8.0
  	bounce_speed = 1.5
  	rotation_speed = 0.5
  
  	# Call parent ready method
  	super._ready()
  
  func apply_effect(player):
  	# Call the parent implementation for signals
  	super.apply_effect(player)
  
  	# Set the player's movement mode
  	if player.has_method("set_movement_mode"):
  		player.set_movement_mode("fly")
  	else:
  		# Fallback for current implementation
  		player.mode = "fly"
  
  	print("Player gained flight ability")
  
  	# Show notification to player
  	var popup_manager = get_node_or_null("/root/PopupManager")
  	if popup_manager:
  		popup_manager.info("New Ability", "You've acquired angel wings! You can now fly for " + str(effect_duration) + " seconds.")
  
  	# Add a visible timer to the HUD if available
  	var hud = get_node_or_null("../../HUD")
  	if hud and hud.has_method("show_ability_timer"):
  		hud.show_ability_timer("Flight", effect_duration)
  
  func remove_effect(player):
  	# Set the player's movement mode back to normal
  	if player.has_method("set_movement_mode"):
  		player.set_movement_mode("normal")
  	else:
  		# Fallback for current implementation
  		player.mode = "normal"
  
  	# Reset player's flight timer
  	player.passed_fly_time = 0.0
  
  	# Let the player know the effect has ended
  	var popup_manager = get_node_or_null("/root/PopupManager")
  	if popup_manager:
  		popup_manager.info("Ability Expired", "Your angel wings have disappeared.")
  
  	# Call the parent implementation for signals
  	super.remove_effect(player)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\items\power_jump.gd:
========================================
  class_name PowerJump
  extends BasePowerUp
  
  ## Power-up that gives the player double jump ability
  
  @export var extra_jumps: int = 1  # How many extra jumps to grant
  
  func _ready():
  	# Set power-up properties
  	power_up_name = "Feather Boots"
  	description = "Grants the ability to double jump"
  	destroy_on_pickup = true
  
  	# Set animation properties
  	bounce_height = 10.0
  	bounce_speed = 3.0
  	rotation_speed = 0.0
  
  	# Call parent ready method
  	super._ready()
  
  func apply_effect(player):
  	# Call the parent implementation for signals
  	super.apply_effect(player)
  
  	# Increase player's allowed jumps
  	if player.has_method("add_extra_jumps"):
  		player.add_extra_jumps(extra_jumps)
  	else:
  		# Fallback for current implementation
  		player.allowed_jumps += extra_jumps
  
  	# Set the player's movement mode to normal (in case they were flying)
  	if player.has_method("set_movement_mode"):
  		player.set_movement_mode("normal")
  	else:
  		# Fallback for current implementation
  		player.mode = "normal"
  
  	print("Player gained double jump ability")
  
  	# Show notification to player
  	var popup_manager = get_node_or_null("/root/PopupManager")
  	if popup_manager:
  		if extra_jumps == 1:
  			popup_manager.info("New Ability", "You've acquired Feather Boots! You can now double jump in mid-air.")
  		else:
  			popup_manager.info("New Ability", "You've acquired Feather Boots! You can now perform " + str(extra_jumps + 1) + " jumps in a row.")

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\projectiles\mage_ball.gd:
========================================
  class_name MageBall
  extends BaseProjectile
  
  ## Magical projectile used by mage enemies
  
  @export var particle_effect: PackedScene
  @export var hit_sound: AudioStream
  
  func _ready():
  	# Set projectile properties
  	speed = 50.0
  	damage = 10.0
  	lifetime = 5.0
  	gravity_affected = false
  
  	# Call parent ready method
  	super._ready()
  
  	# Set up animation
  	if has_node("Ball"):
  		$Ball.play("flying")
  
  func _physics_process(delta):
  	# Implement base projectile physics
  	super._physics_process(delta)
  
  	# Add magical effect (optional particle trail)
  	if particle_effect and randf() < 0.3:  # 30% chance per frame
  		var particles = particle_effect.instantiate()
  		particles.global_position = global_position
  		get_tree().current_scene.add_child(particles)
  		particles.emitting = true
  
  		# Auto-remove particles after their lifetime
  		await get_tree().create_timer(particles.lifetime).timeout
  		if is_instance_valid(particles):
  			particles.queue_free()
  
  func _on_hit_player(player):
  	# Call parent implementation
  	super._on_hit_player(player)
  
  	# Add magical effect (status effect, screen shake, etc.)
  	var hud = get_node_or_null("../HUD")
  	if hud and hud.has_method("change_life"):
  		hud.change_life(-damage/100.0)  # Assuming HUD uses 0-1 scale
  
  	# Play hit sound
  	if hit_sound:
  		var audio_player = AudioStreamPlayer.new()
  		audio_player.stream = hit_sound
  		audio_player.volume_db = -10.0
  		get_tree().current_scene.add_child(audio_player)
  		audio_player.play()
  
  		# Auto-remove audio player after sound finishes
  		await audio_player.finished
  		audio_player.queue_free()
  
  # Connect the hit zone to our hit methods
  func _on_hit_zone_body_entered(body):
  	if body.name == "Player":
  		_on_hit_player(body)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\projectiles\rock.gd:
========================================
  class_name Rock
  extends BaseProjectile
  
  ## Rock projectile used by archer enemies
  
  @export var bounce_count: int = 1  # How many times the rock can bounce
  @export var hit_sound: AudioStream
  
  var bounces_remaining: int = 0
  
  func _ready():
  	# Set projectile properties
  	speed = 120.0
  	damage = 8.0
  	lifetime = 5.0
  	gravity_affected = true
  	bounce = true
  	bounce_factor = 0.6
  
  	# Set remaining bounces
  	bounces_remaining = bounce_count
  
  	# Call parent ready method
  	super._ready()
  
  	# Set up animation
  	if has_node("rock"):
  		$rock.play("flying")
  
  func _on_collision(collision):
  	var collider = collision.get_collider()
  
  	# Check if we should bounce
  	if bounce and bounces_remaining > 0 and not collider.is_in_group("Player") and not collider.is_in_group("Enemy"):
  		bounces_remaining -= 1
  
  		var reflection = collision.get_remainder().bounce(collision.get_normal())
  		velocity = velocity.bounce(collision.get_normal()) * bounce_factor
  		global_position += reflection
  
  		# Play bounce sound if available
  		if hit_sound:
  			var audio_player = AudioStreamPlayer.new()
  			audio_player.stream = hit_sound
  			audio_player.volume_db = -15.0
  			get_tree().current_scene.add_child(audio_player)
  			audio_player.play()
  
  			# Auto-remove audio player after sound finishes
  			await audio_player.finished
  			audio_player.queue_free()
  
  		return
  
  	# If no more bounces or hit player/enemy, use default behavior
  	has_hit = true
  
  	# Handle different collision types
  	if collider.is_in_group("Player") and source_node != collider:
  		_on_hit_player(collider)
  	elif collider.is_in_group("Enemy") and source_node != collider:
  		_on_hit_enemy(collider)
  	else:
  		_on_hit_environment(collider)
  
  func _on_hit_player(player):
  	# Call parent implementation
  	super._on_hit_player(player)
  
  	# Update HUD
  	var hud = get_node_or_null("../HUD")
  	if hud and hud.has_method("change_life"):
  		hud.change_life(-damage/100.0)  # Assuming HUD uses 0-1 scale
  
  # Connect the hit zone to our hit methods
  func _on_hit_zone_body_entered(body):
  	if body.name == "Player":
  		_on_hit_player(body)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\enemy_states\enemy_idle_state.gd:
========================================
  class_name EnemyIdleState
  extends State
  
  ## Enemy idle state - when the enemy is standing still
  
  @export var idle_animation: String = "idle"
  @export var idle_min_time: float = 1.0
  @export var idle_max_time: float = 3.0
  
  var idle_timer: float = 0.0
  var idle_duration: float = 0.0
  var target = null
  
  func enter():
  	# Play idle animation
  	play_animation(idle_animation)
  
  	# Reset horizontal velocity
  	var velocity = get_velocity()
  	velocity.x = 0
  	set_velocity(velocity)
  
  	# Set random idle duration
  	idle_duration = randf_range(idle_min_time, idle_max_time)
  	idle_timer = 0.0
  
  func physics_process(delta: float):
  	# Apply gravity
  	var velocity = get_velocity()
  	var gravity = owner_node.get_gravity() if owner_node.has_method("get_gravity") else 980.0
  
  	velocity.y += gravity * delta
  	set_velocity(velocity)
  
  	# Handle movement for character body
  	if owner_node.has_method("move_and_slide"):
  		owner_node.move_and_slide()
  
  	# Update idle timer
  	idle_timer += delta
  
  func get_next_state() -> String:
  	# Check if there's a player in detection range
  	target = get_owner_property("target")
  	if target != null:
  		return "Chase"
  
  	# Check if idle time has elapsed - transition to patrol
  	if idle_timer >= idle_duration:
  		return "Patrol"
  
  	# No transition, stay in idle
  	return ""
  
  # Used by enemies to find nearby player
  func check_for_player():
  	var detection_radius = get_owner_property("detection_radius")
  	if not detection_radius:
  		return null
  
  	var space_state = owner_node.get_world_2d().direct_space_state
  	var player_detection_shape = CircleShape2D.new()
  	player_detection_shape.radius = detection_radius
  
  	var query = PhysicsShapeQueryParameters2D.new()
  	query.set_shape(player_detection_shape)
  	query.transform = Transform2D(0, owner_node.global_position)
  	query.collision_mask = 1  # Player layer
  
  	var results = space_state.intersect_shape(query)
  
  	for result in results:
  		var collider = result.collider
  		if collider.name == "Player":
  			return collider
  
  	return null

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\player_states\player_attack_state.gd:
========================================
  class_name PlayerAttackState
  extends PlayerBaseState
  
  var attack_timer: float = 0.0
  var attack_duration: float = 0.5  # Duration of the attack animation
  
  func enter():
      player.current_animation = player.attack_animation
      player.play_attack_animation = true
      attack_timer = 0.0
  
      # Optionally play attack sound
      # if player.has_node("AttackSound"):
      #     player.get_node("AttackSound").play()
  
  func physics_process(delta: float):
      # Apply gravity
      var velocity = get_velocity()
      velocity.y += player.GRAVITY * delta
  
      # Reduce movement during attack (optional)
      velocity.x = move_toward(velocity.x, 0, 20)
  
      set_velocity(velocity)
  
      # Handle movement for character body
      player.move_and_slide()
  
      # Update attack timer
      attack_timer += delta
  
      # Update outfit
      update_outfit()
  
  func get_next_state() -> String:
      # Check state transitions
      var life_state = check_life()
      if life_state:
          return life_state
  
      # Return to appropriate state after attack finishes
      if attack_timer >= attack_duration:
          player.play_attack_animation = false
  
          if player.is_on_floor():
              var x_input = Input.get_axis("left", "right")
              if x_input != 0:
                  return "PlayerWalkState"
              else:
                  return "PlayerIdleState"
          else:
              return "PlayerFallState"
  
      # Stay in attack state
      return ""
  
  func handle_input(event: InputEvent):
      check_menu_input(event)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\player_states\player_base_state.gd:
========================================
  class_name PlayerBaseState
  extends State
  
  # Base functions shared by all player states
  var player: Player
  
  func _ready():
  	# Set player reference during initialization
  	player = owner_node as Player
  
  # Function to update the outfit based on the current state
  func update_outfit():
  	var player_outfit = player.player_outfit
  	var player_animations = player.player_animations
  	var current_animation = player.current_animation
  
  	for outfit in player_outfit:
  		var animated_sprite = player.get_node("character_sprites/" + outfit)
  		var selected_outfit = player_outfit[outfit]
  
  		if str(selected_outfit) == "none":
  			animated_sprite.visible = false
  		else:
  			animated_sprite.visible = true
  			animated_sprite.play(str(selected_outfit))
  			animated_sprite.speed_scale = 2.0
  
  			# Set direction based on movement
  			var x_input = Input.get_axis("left", "right")
  			if x_input != 0:
  				animated_sprite.flip_h = x_input > 0
  
  			# Frame management
  			if current_animation in player_animations:
  				if animated_sprite.frame < player_animations[current_animation][0] or animated_sprite.frame >= player_animations[current_animation][-1]:
  					animated_sprite.frame = player_animations[current_animation][0]
  
  # Function to check life and handle death
  func check_life():
  	if player.hud and player.hud.lifes <= 0:
  		return "PlayerDeathState"
  	return ""
  
  # Function to check menu input
  func check_menu_input(event):
  	if event is InputEvent and event.is_action_pressed("Menu"):
  		get_tree().change_scene_to_file("res://scenes/ui/main_menu/main_menu.tscn")
  		if player.has_method("save_settings"):
  			player.save_settings()

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\player_states\player_death_state.gd:
========================================
  class_name PlayerDeathState
  extends PlayerBaseState
  
  var death_timer: float = 0.0
  var death_duration: float = 1.5  # Duration before scene transition
  
  func enter():
      player.current_animation = "death"
      player.get_node("CollisionShape2D").disabled = true
      death_timer = 0.0
  
  func physics_process(delta: float):
      # Update death animation timer
      death_timer += delta
  
      # Update outfit
      update_outfit()
  
  func get_next_state() -> String:
      # Scene transition after death animation
      if death_timer >= death_duration:
          player.queue_free()
          get_tree().change_scene_to_file("res://scenes/ui/main_menu/main_menu.tscn")
  
      # Stay in death state
      return ""

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\player_states\player_fall_state.gd:
========================================
  class_name PlayerFallState
  extends PlayerBaseState
  
  func enter():
  	# player.current_animation = "idle"  # You may want a falling animation
  
  	# Mark as not ready for jump
  	if player.jump_counter == 0:
  		player.ready_for_jump = false
  
  func physics_process(delta: float):
  	# Apply gravity
  	var velocity = get_velocity()
  	velocity.y += player.GRAVITY * delta
  
  	# Read the input
  	var x_input = Input.get_axis("left", "right")
  	var y_input = Input.get_axis("down", "up")
  
  	# Apply horizontal movement
  	if x_input != 0:
  		velocity.x = x_input * player.SPEED
  		player.current_animation = "walking"
  	else:
  		velocity.x = move_toward(velocity.x, 0, 30)
  
  	# Check for double jump if allowed
  	if y_input > 0.4 && player.jump_counter < player.allowed_jumps && player.ready_for_jump:
  		velocity.y = player.JUMP_VELOCITY * y_input
  		player.jump_counter += 1
  		player.ready_for_jump = false
  	elif y_input < 0.4:
  		player.ready_for_jump = true
  
  	set_velocity(velocity)
  
  	# Handle movement for character body
  	player.move_and_slide()
  
  	# Update outfit
  	update_outfit()
  
  func get_next_state() -> String:
  	# Check state transitions
  	var life_state = check_life()
  	if life_state:
  		return life_state
  
  	# Check for attack input
  	if Input.is_action_just_pressed("attack"):
  		return "PlayerAttackState"
  
  	# Check for fly mode
  	if player.mode == "fly":
  		return "PlayerFlyState"
  
  	# Landing transition
  	if player.is_on_floor():
  		player.jump_counter = 0
  		player.ready_for_jump = true
  		player.passed_fly_time = 0.0
  
  		# Check if still moving
  		var x_input = Input.get_axis("left", "right")
  		if x_input != 0:
  			return "PlayerWalkState"
  		else:
  			return "PlayerIdleState"
  
  	# Double jump transition
  	var y_input = Input.get_axis("down", "up")
  	if y_input > 0.4 && player.jump_counter < player.allowed_jumps && player.ready_for_jump:
  		return "PlayerJumpState"
  
  	# Stay in fall state
  	return ""
  
  func handle_input(event: InputEvent):
  	check_menu_input(event)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\player_states\player_fly_state.gd:
========================================
  class_name PlayerFlyState
  extends PlayerBaseState
  
  var elixir_drain_timer: float = 0.0
  var drain_interval: float = 3.0  # Drain every 5 seconds
  var drain_amount: float = 0.25   # Drain 25% each time
  
  func enter():
  	player.current_animation = "idle"  # You may want a specific fly animation
  	elixir_drain_timer = 0.0  # Reset timer on state entry
  
  func physics_process(delta: float):
  	# Apply gravity
  	var velocity = get_velocity()
  	velocity.y += player.GRAVITY * delta
  
  	# Read inputs
  	var x_input = Input.get_axis("left", "right")
  	var y_input = Input.get_axis("down", "up")
  
  	# Apply horizontal movement
  	if x_input != 0:
  		velocity.x = x_input * player.SPEED
  	else:
  		velocity.x = move_toward(velocity.x, 0, 30)
  
  	# Update fly time counter
  	if player.passed_fly_time < 4:
  		player.passed_fly_time += delta
  		if y_input != 0:
  			velocity.y = player.FLY_VELOCITY * y_input
  
  	# Handle elixir drain
  	elixir_drain_timer += delta
  	if elixir_drain_timer >= drain_interval:
  		elixir_drain_timer = 0.0  # Reset timer
  		player.hud.use_softpower()
  
  	if player.hud.elixir_fill_level <= 0:
  		player.mode = "normal"
  
  
  
  	set_velocity(velocity)
  
  	# Handle movement for character body
  	player.move_and_slide()
  
  	# Update outfit
  	update_outfit()
  
  func get_next_state() -> String:
  	# Check state transitions
  	var life_state = check_life()
  	if life_state:
  		return life_state
  
  	# Check for attack input
  	if Input.is_action_just_pressed("attack"):
  		return "PlayerAttackState"
  
  	# Check elixir level - transition to fall if empty
  	if player.hud.elixir_fill_level <= 0:
  		player.passed_fly_time = 0.0  # Reset fly time
  		return "PlayerFallState"
  
  	# Landing transition
  	if player.is_on_floor():
  		player.jump_counter = 0
  		player.ready_for_jump = true
  		player.passed_fly_time = 0.0
  
  		# Check movement direction after landing
  		var x_input = Input.get_axis("left", "right")
  		if x_input != 0:
  			return "PlayerWalkState"
  		else:
  			return "PlayerIdleState"
  
  	# Time limit check
  	if player.passed_fly_time >= 4:
  		return "PlayerFallState"
  
  	# Stay in fly state
  	return ""
  
  func handle_input(event: InputEvent):
  	check_menu_input(event)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\player_states\player_hurt_state.gd:
========================================
  class_name PlayerHurtState
  extends PlayerBaseState

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\player_states\player_idle_state.gd:
========================================
  class_name PlayerIdleState
  extends PlayerBaseState
  
  func enter():
  	player.current_animation = "idle"
  	# Reset horizontal velocity
  	var velocity = get_velocity()
  	velocity.x = 0
  	set_velocity(velocity)
  
  	if player.debug_mode:
  		print("Entered Idle State")
  
  func physics_process(delta: float):
  	# Apply gravity
  	var velocity = get_velocity()
  	velocity.y += player.GRAVITY * delta
  	set_velocity(velocity)
  
  	# Handle movement for character body
  	player.move_and_slide()
  
  	# Update outfit
  	update_outfit()
  
  func get_next_state() -> String:
  	# Check for death
  	var life_state = check_life()
  	if life_state != "":
  		return life_state
  
  	# Check input for state transitions
  	var x_input = Input.get_axis("left", "right")
  	var y_input = Input.get_axis("down", "up")
  
  	# Check for attack
  	if Input.is_action_just_pressed("attack"):
  		return "PlayerAttackState"
  
  	# Check for movement
  	if x_input != 0:
  		return "PlayerWalkState"
  
  	# Check for jumping
  	if y_input > 0.4 and player.is_on_floor():
  		return "PlayerJumpState"
  
  	# Check for falling
  	if !player.is_on_floor():
  		return "PlayerFallState"
  
  	# No transition
  	return ""
  
  func handle_input(event: InputEvent):
  	check_menu_input(event)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\player_states\player_jump_state.gd:
========================================
  # Fix for player_jump_state.gd - Correct class name
  class_name PlayerJumpState
  extends PlayerBaseState
  
  func enter():
  	# player.current_animation = "idle"  # You may want to use a jump animation
  
  	# Apply initial jump velocity
  	var velocity = get_velocity()
  	var y_input = Input.get_axis("down", "up")
  	velocity.y = player.JUMP_VELOCITY * y_input
  	set_velocity(velocity)
  
  	# Update jump counter
  	player.jump_counter += 1
  	player.ready_for_jump = false
  
  	if player.debug_mode:
  		print("Entered Jump State")
  
  func physics_process(delta: float):
  	# Apply gravity
  	var velocity = get_velocity()
  	velocity.y += player.GRAVITY * delta
  
  	# Read horizontal input
  	var x_input = Input.get_axis("left", "right")
  
  	# Apply horizontal movement
  	if x_input != 0:
  		velocity.x = x_input * player.SPEED
  		player.current_animation = "walking"
  	else:
  		velocity.x = move_toward(velocity.x, 0, 30)
  
  	set_velocity(velocity)
  
  	# Handle movement for character body
  	player.move_and_slide()
  
  	# Reset jump readiness when input is released
  	var y_input = Input.get_axis("down", "up")
  	if y_input < 0.4:
  		player.ready_for_jump = true
  
  	# Update outfit
  	update_outfit()
  
  func get_next_state() -> String:
  	# Check state transitions
  	var life_state = check_life()
  	if life_state:
  		return life_state
  
  	# Check for attack input
  	if Input.is_action_just_pressed("attack"):
  		return "PlayerAttackState"
  
  	# Fly state transition
  	if player.mode == "fly":
  		return "PlayerFlyState"
  
  	# Landing transition
  	if player.is_on_floor():
  		player.jump_counter = 0
  		player.ready_for_jump = true
  
  		# Check if still moving
  		var x_input = Input.get_axis("left", "right")
  		if x_input != 0:
  			return "PlayerWalkState"
  		else:
  			return "PlayerIdleState"
  
  	# Falling transition
  	if get_velocity().y > 0:
  		return "PlayerFallState"
  
  	# Stay in jump state
  	return ""
  
  func handle_input(event: InputEvent):
  	check_menu_input(event)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\player_states\player_walk_state.gd:
========================================
  class_name PlayerWalkState
  extends PlayerBaseState
  
  func enter():
  	player.current_animation = "walking"  # Walk animation
  
  	if player.debug_mode:
  		print("Entered Walk State")
  
  func physics_process(delta: float):
  	# Apply gravity
  	var velocity = get_velocity()
  	velocity.y += player.GRAVITY * delta
  
  	# Read the input
  	var x_input = Input.get_axis("left", "right")
  
  	# Apply horizontal movement
  	if x_input != 0:
  		velocity.x = x_input * player.SPEED
  	else:
  		velocity.x = move_toward(velocity.x, 0, 30)
  
  	set_velocity(velocity)
  
  	# Handle movement for character body
  	player.move_and_slide()
  
  	# Update outfit
  	update_outfit()
  
  func get_next_state() -> String:
  	# Check for death
  	var life_state = check_life()
  	if life_state != "":
  		return life_state
  
  	# Check for attack
  	if Input.is_action_just_pressed("attack"):
  		return "PlayerAttackState"
  
  	# Read inputs
  	var x_input = Input.get_axis("left", "right")
  	var y_input = Input.get_axis("down", "up")
  
  	# Stop walking
  	if x_input == 0:
  		return "PlayerIdleState"
  
  	# Jump while moving
  	if y_input > 0.4 and player.is_on_floor():
  		return "PlayerJumpState"
  
  	# Fall transition
  	if !player.is_on_floor():
  		return "PlayerFallState"
  
  	# Stay in walk state
  	return ""
  
  func handle_input(event: InputEvent):
  	check_menu_input(event)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\state.gd:
========================================
  class_name State
  extends Node
  
  ## Base class for all states in a state machine
  
  # Reference to the state machine
  var state_machine: StateMachine = null
  
  # Reference to the owner node
  var owner_node: Node = null
  
  # State parameters (can be extended by child classes)
  var parameters: Dictionary = {}
  
  
  # Called when entering this state
  func enter():
  	pass
  
  # Called when exiting this state
  func exit():
  	pass
  
  # Called during _process
  func process(delta: float):
  	pass
  
  # Called during _physics_process
  func physics_process(delta: float):
  	pass
  
  # Called during _input
  func handle_input(event: InputEvent):
  	pass
  
  # Override this to determine the next state to transition to
  func get_next_state() -> String:
  	return ""
  
  # Utility functions that can be used by derived states
  
  # Check if a condition is true
  func condition_met(condition_name: String) -> bool:
  	if owner_node.has_method("check_condition"):
  		return owner_node.check_condition(condition_name)
  	return false
  
  # Get a value from the owner
  func get_owner_property(property_name: String):
  	if owner_node and property_name in owner_node:
  		return owner_node.get(property_name)
  	return null
  
  # Set a value on the owner
  func set_owner_property(property_name: String, value):
  	if owner_node and property_name in owner_node:
  		owner_node.set(property_name, value)
  
  # Helper to check if owner is on floor (for platformers)
  func is_on_floor() -> bool:
  	if owner_node.has_method("is_on_floor"):
  		return owner_node.is_on_floor()
  	return false
  
  # Helper to get owner velocity (for physics bodies)
  func get_velocity() -> Vector2:
  	if "velocity" in owner_node:
  		return owner_node.velocity
  	return Vector2.ZERO
  
  # Helper to set owner velocity (for physics bodies)
  func set_velocity(value: Vector2):
  	if "velocity" in owner_node:
  		owner_node.velocity = value
  
  # Helper to play animations
  func play_animation(anim_name: String):
  	if owner_node.has_method("play_animation"):
  		owner_node.play_animation(anim_name)
  	elif owner_node.has_node("AnimatedSprite2D"):
  		var sprite = owner_node.get_node("AnimatedSprite2D")
  		if sprite.sprite_frames.has_animation(anim_name):
  			sprite.play(anim_name)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\state_machine.gd:
========================================
  class_name StateMachine
  extends Node
  
  ## A finite state machine implementation for Godot 4.x
  
  # Current active state
  var current_state: State = null
  
  # Dictionary of available states
  var states: Dictionary = {}
  
  # The owner node that this state machine controls
  var owner_node: Node = null
  
  # Debug mode flag
  @export var debug_mode: bool = true
  
  # Signal emitted when state changes
  signal state_changed(from_state, to_state)
  
  func _ready():
  	owner_node = get_parent()
  
  	# Register all child states
  	for child in get_children():
  		if child is State:
  			register_state(child)
  
  	# Initialize the first state
  	if states.size() > 0:
  		var initial_state = states.values()[0]
  		change_state(initial_state.name)
  
  func _process(delta):
  	if current_state != null:
  		# Call the current state's process method
  		current_state.process(delta)
  
  		# Check for state transitions
  		var next_state = current_state.get_next_state()
  		if next_state != null and next_state != "" and states.has(next_state):
  			change_state(next_state)
  
  func _physics_process(delta):
  	if current_state != null:
  		# Call the current state's physics_process method
  		current_state.physics_process(delta)
  
  func _input(event):
  	if current_state != null:
  		# Call the current state's input method
  		current_state.handle_input(event)
  
  func register_state(state: State):
  	# Add to states dictionary
  	states[state.name] = state
  
  	# Set the state machine reference
  	state.state_machine = self
  
  	# Set the owner reference
  	state.owner_node = owner_node
  
  	# Specifically initialize player references for PlayerBaseState instances
  	if state is PlayerBaseState:
  		state.player = owner_node
  
  	if debug_mode:
  		print("Registered state: ", state.name)
  
  func change_state(new_state_name: String):
  	if not states.has(new_state_name):
  		push_error("State '" + new_state_name + "' not found in state machine!")
  		return
  
  	var from_state = current_state.name if current_state else "None"
  
  	if current_state != null:
  		if debug_mode:
  			print("Exiting state: ", current_state.name)
  		current_state.exit()
  
  	var next_state = states[new_state_name]
  	current_state = next_state
  
  	# Make sure the player reference is properly set before entering the state
  	if current_state is PlayerBaseState and current_state.player == null:
  		current_state.player = owner_node
  
  	if debug_mode:
  		print("Entering state: ", current_state.name)
  
  	current_state.enter()
  
  	# Emit state change signal
  	emit_signal("state_changed", from_state, new_state_name)
  
  func get_current_state() -> String:
  	if current_state != null:
  		return current_state.name
  	return "None"
  
  # Add a new state at runtime
  func add_state(state: State):
  	register_state(state)
  
  # Remove a state at runtime
  func remove_state(state_name: String):
  	if states.has(state_name):
  		states.erase(state_name)
  	else:
  		push_error("Tried to remove non-existent state: " + state_name)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\levels\base_level.gd:
========================================
  class_name BaseLevel
  extends Node2D
  
  var boss_music = load("res://assets/audio/music/Tracks/the-epic-2-by-rafael-krux(chosic.com).mp3")
  # Called when the node enters the scene tree for the first time.
  func _ready():
  	AudioManager.play_track(boss_music)
  
  # Called every frame. 'delta' is the elapsed time since the previous frame.
  func _process(_delta):
  	pass

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\resources\player_outfit_resource.gd:
========================================
  class_name PlayerOutfitResource
  extends Resource
  
  ## Resource-based outfit system for The Little Saint
  ## Provides structured way to store and manage player appearance
  
  # Outfit components
  @export var beard: String = "none"
  @export var lipstick: String = "none"
  @export var eyes: String = "1"
  @export var shoes: String = "1"
  @export var earrings: String = "none"
  @export var hat: String = "none"
  @export var glasses: String = "none"
  @export var clothes_down: String = "1"
  @export var clothes_up: String = "1"
  @export var clothes_complete: String = "none"
  @export var body: String = "1"
  @export var hair: String = "1"
  
  # Outfit metadata
  @export var outfit_name: String = "Default Outfit"
  @export var is_favorite: bool = false
  @export var creation_date: String = ""
  
  # Initialize with default values
  func _init():
  	creation_date = Time.get_datetime_string_from_system(false, true)
  
  # Convert to dictionary format (for backwards compatibility)
  func to_dictionary() -> Dictionary:
  	return {
  		"beard": beard,
  		"lipstick": lipstick,
  		"eyes": eyes,
  		"shoes": shoes,
  		"earrings": earrings,
  		"hats": hat,
  		"glasses": glasses,
  		"clothes_down": clothes_down,
  		"clothes_up": clothes_up,
  		"clothes_complete": clothes_complete,
  		"bodies": body,
  		"hair": hair
  	}
  
  # Create from dictionary (for backwards compatibility)
  func from_dictionary(dict: Dictionary) -> PlayerOutfitResource:
  	beard = str(dict.get("beard", "none"))
  	lipstick = str(dict.get("lipstick", "none"))
  	eyes = str(dict.get("eyes", "1"))
  	shoes = str(dict.get("shoes", "1"))
  	earrings = str(dict.get("earrings", "none"))
  	hat = str(dict.get("hats", "none"))
  	glasses = str(dict.get("glasses", "none"))
  	clothes_down = str(dict.get("clothes_down", "1"))
  	clothes_up = str(dict.get("clothes_up", "1"))
  	clothes_complete = str(dict.get("clothes_complete", "none"))
  	body = str(dict.get("bodies", "1"))
  	hair = str(dict.get("hair", "1"))
  	return self
  
  # Check if a component is visible
  func is_visible(component: String) -> bool:
  	match component:
  		"beard", "lipstick", "earrings", "hat", "glasses", "clothes_complete":
  			return get(component) != "none"
  		_:
  			return true
  
  # Check if this is a complete outfit (has all required elements)
  func is_complete() -> bool:
  	return body != "none" and eyes != "none"
  
  # Reset to default values
  func reset() -> void:
  	beard = "none"
  	lipstick = "none"
  	eyes = "1"
  	shoes = "1"
  	earrings = "none"
  	hat = "none"
  	glasses = "none"
  	clothes_down = "1"
  	clothes_up = "1"
  	clothes_complete = "none"
  	body = "1"
  	hair = "1"
  	outfit_name = "Default Outfit"
  	is_favorite = false
  	creation_date = Time.get_datetime_string_from_system(false, true)
  
  # Create a randomized outfit
  func randomize_outfit() -> PlayerOutfitResource:
  	# Use true randomization
  	randomize()
  
  	# Always set essential parts
  	body = str(randi_range(1, 10))  # Assuming there are 10 body options
  	eyes = str(randi_range(1, 14))  # Assuming there are 14 eye options
  
  	# Randomly decide for all other parts
  	beard = _random_part(["none", "1", "2", "3"], 0.7)  # 70% chance for none
  	lipstick = _random_part(["none", "1", "2", "3"], 0.8)  # 80% chance for none
  	shoes = str(randi_range(1, 10))  # Assuming there are 10 shoe options
  	earrings = _random_part(["none", "1", "2", "3"], 0.8)  # 80% chance for none
  	hat = _random_part(["none", "1", "2", "3", "4"], 0.6)  # 60% chance for none
  	glasses = _random_part(["none", "1", "2"], 0.9)  # 90% chance for none
  
  	# Either use separate top/bottom or complete outfit
  	if randf() > 0.3:  # 70% chance for separate clothes
  		clothes_down = str(randi_range(1, 10))
  		clothes_up = str(randi_range(1, 10))
  		clothes_complete = "none"
  	else:  # 30% chance for complete outfit
  		clothes_down = "none"
  		clothes_up = "none"
  		clothes_complete = str(randi_range(1, 5))  # Assuming there are 5 complete outfit options
  
  	# Hair is important for character look
  	hair = str(randi_range(1, 14))  # Assuming there are 14 hair options
  
  	outfit_name = "Random Outfit"
  	creation_date = Time.get_datetime_string_from_system(false, true)
  
  	return self
  
  # Helper for randomizing parts with "none" option
  func _random_part(options: Array, none_chance: float) -> String:
  	if randf() < none_chance:
  		return "none"
  
  	var valid_options = options.duplicate()
  	valid_options.erase("none")
  	return valid_options[randi() % valid_options.size()]
  
  # Create a duplicate of this outfit
  func duplicate_outfit() -> PlayerOutfitResource:
  	var new_outfit = PlayerOutfitResource.new()
  	new_outfit.beard = beard
  	new_outfit.lipstick = lipstick
  	new_outfit.eyes = eyes
  	new_outfit.shoes = shoes
  	new_outfit.earrings = earrings
  	new_outfit.hat = hat
  	new_outfit.glasses = glasses
  	new_outfit.clothes_down = clothes_down
  	new_outfit.clothes_up = clothes_up
  	new_outfit.clothes_complete = clothes_complete
  	new_outfit.body = body
  	new_outfit.hair = hair
  	new_outfit.outfit_name = outfit_name + " (Copy)"
  	new_outfit.is_favorite = is_favorite
  	new_outfit.creation_date = Time.get_datetime_string_from_system(false, true)
  	return new_outfit
  
  # Create a new default outfit resource
  static func create_default() -> PlayerOutfitResource:
  	return PlayerOutfitResource.new()
  
  # Check for equality with another outfit
  func equals(other: PlayerOutfitResource) -> bool:
  	return (
  		beard == other.beard and
  		lipstick == other.lipstick and
  		eyes == other.eyes and
  		shoes == other.shoes and
  		earrings == other.earrings and
  		hat == other.hat and
  		glasses == other.glasses and
  		clothes_down == other.clothes_down and
  		clothes_up == other.clothes_up and
  		clothes_complete == other.clothes_complete and
  		body == other.body and
  		hair == other.hair
  	)
  
  # Apply this outfit to character sprites
  func apply_to_sprites(character_sprites: Node2D) -> void:
  	var outfit_dict = to_dictionary()
  
  	for category in outfit_dict:
  		if character_sprites.has_node(category):
  			var sprite = character_sprites.get_node(category)
  			var value = outfit_dict[category]
  
  			if value == "none":
  				sprite.visible = false
  			else:
  				sprite.visible = true
  				sprite.animation = value
  				sprite.frame = 1

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\character_customizer\customizer_controller.gd:
========================================
  class_name CustomizerController
  # UI.gd
  extends Control
  
  # Spieler-Outfit-Eigenschaften
  var body
  var player_outfit
  var selected_outfit_category = ""
  var player_animations
  var options_per_category = {}
  var has_unsaved_changes = false  # Neue Variable für ungespeicherte Änderungen
  
  # Resource-basiertes Outfit System
  var current_outfit_resource: PlayerOutfitResource = null
  
  # Signal für Debugging
  signal debug_message(message)
  
  func _ready():
  	randomize() # Initialisiere den Zufallsgenerator
  	get_node("character_sprites/masks").visible = false
  	player_outfit = get_node("character_sprites").default_outfit
  	player_animations = get_node("character_sprites").animation_frames
  
  	# Create outfit resource
  	current_outfit_resource = PlayerOutfitResource.new()
  
  	# Connect to PopupManager
  	PopupManager.dialog_confirmed.connect(_on_dialog_confirmed)
  
  	# UI-Elemente für jede Outfit-Kategorie erstellen
  	setup_outfit_categories()
  
  	# Versuche, gespeicherte Outfits zu laden
  	load_saved_outfit()
  
  	# Bei Programmstart gibt es keine ungespeicherten Änderungen
  	has_unsaved_changes = false
  
  # Erstellt UI-Elemente für alle Outfit-Kategorien
  func setup_outfit_categories():
  	for category in player_outfit:
  		var category_button = Button.new()
  		var items_container = ScrollContainer.new()
  		var item_container_grid = GridContainer.new()
  
  		# Kategorie-Button einrichten
  		category_button.text = category
  		category_button.pressed.connect(_on_category_button_pressed.bind(category))
  		$Outfit_Category_Picker/GridContainer.add_child(category_button)
  
  		# Container für Items einrichten
  		items_container.size = Vector2(620, 400)
  		items_container.position = Vector2(600, 200)
  		items_container.add_child(item_container_grid)
  		items_container.name = category
  		add_child(items_container)
  		items_container.hide()
  
  		# Grid für Items einrichten
  		item_container_grid.columns = 6
  		var current_item = 0
  		var button_size = Vector2(100, 100)
  
  		# Leeren Button für optionale Kategorien hinzufügen
  		if category != "bodies":
  			var empty_button = Button.new()
  			empty_button.custom_minimum_size = button_size
  			empty_button.pressed.connect(_on_item_button_pressed.bind("none"))
  			item_container_grid.add_child(empty_button)
  
  			var animated_sprite = get_node("character_sprites/" + category)
  			animated_sprite.visible = false
  			player_outfit[category] = "none"
  
  		# Alle verfügbaren Items für diese Kategorie hinzufügen
  		while true:
  			current_item += 1
  			var texture = get_node("character_sprites/"+category).sprite_frames.get_frame_texture(str(current_item), 1)
  			if texture == null:
  				break
  
  			var item_texture = TextureRect.new()
  			item_texture.texture = texture
  			item_texture.custom_minimum_size = button_size
  			item_texture.stretch_mode = TextureRect.STRETCH_KEEP_ASPECT_CENTERED
  
  			var item_button = Button.new()
  			item_button.custom_minimum_size = button_size
  			item_button.add_child(item_texture)
  			item_button.pressed.connect(_on_item_button_pressed.bind(str(current_item)))
  			item_container_grid.add_child(item_button)
  
  		options_per_category[category] = current_item - 1
  
  # Aktualisiert die Animations-Frames basierend auf dem gewählten Outfit
  func _process(_delta):
  	for outfit in player_outfit:
  		var animated_sprite = get_node("character_sprites/" + outfit)
  		animated_sprite.animation = player_outfit[outfit]
  		animated_sprite.frame = 1
  
  # Wird aufgerufen, wenn ein Item ausgewählt wird
  func _on_item_button_pressed(item):
  	var animated_sprite = get_node("character_sprites/" + selected_outfit_category)
  	var old_value = player_outfit[selected_outfit_category]
  	var new_value = str(item)
  
  	if new_value == "none":
  		animated_sprite.visible = false
  	else:
  		animated_sprite.visible = true
  
  	# Setze has_unsaved_changes nur, wenn sich etwas geändert hat
  	if old_value != new_value:
  		player_outfit[selected_outfit_category] = new_value
  		has_unsaved_changes = true
  
  		# Update outfit resource
  		if selected_outfit_category == "bodies":
  			current_outfit_resource.body = new_value
  		elif selected_outfit_category == "hats":
  			current_outfit_resource.hat = new_value
  		elif current_outfit_resource.get(selected_outfit_category) != null:
  			current_outfit_resource.set(selected_outfit_category, new_value)
  	else:
  		player_outfit[selected_outfit_category] = new_value
  
  # Wird aufgerufen, wenn eine Kategorie ausgewählt wird
  func _on_category_button_pressed(category):
  	if selected_outfit_category:
  		get_node(selected_outfit_category).hide()
  	get_node(category).show()
  	selected_outfit_category = category
  
  # Generiert ein zufälliges Outfit
  func _random_button_pressed():
  	current_outfit_resource.randomize_outfit()
  	var outfit_dict = current_outfit_resource.to_dictionary()
  	var had_changes = false
  
  	# Update the player_outfit from the resource
  	for category in outfit_dict:
  		if player_outfit.has(category):
  			var new_value = outfit_dict[category]
  			if player_outfit[category] != new_value:
  				player_outfit[category] = new_value
  				had_changes = true
  
  			# Update sprite visibility
  			var animated_sprite = get_node("character_sprites/" + category)
  			if new_value == "none":
  				animated_sprite.visible = false
  			else:
  				animated_sprite.visible = true
  
  	if had_changes:
  		has_unsaved_changes = true
  
  # Speichert das aktuelle Outfit
  func _save_button_pressed():
  	# Update the outfit resource
  	current_outfit_resource.from_dictionary(player_outfit)
  	current_outfit_resource.outfit_name = "Last Saved Outfit"
  
  	# Save to both the favorites and the player's current outfit
  	SaveManager.save_outfit(player_outfit, "Last Saved Outfit")
  
  	# Ensure the current save data has the outfit
  	if SaveManager.current_save_data:
  		SaveManager.current_save_data.player_outfit = player_outfit.duplicate(true)
  
  	# Save both settings and game data
  	SaveManager.save_settings()
  	SaveManager.save_game()  # Add this line to ensure full game save
  
  	has_unsaved_changes = false
  	show_message("Outfit erfolgreich gespeichert!", Color(0.3, 1, 0.3, 1))
  
  # Setzt alle optionalen Teile des Outfits zurück
  func _reset_button_pressed():
  	# Use the resource method to reset
  	current_outfit_resource.reset()
  	var outfit_dict = current_outfit_resource.to_dictionary()
  	var had_changes = false
  
  	# Apply the reset to player_outfit
  	for category in outfit_dict:
  		if player_outfit.has(category) and category != "bodies":
  			var animated_sprite = get_node("character_sprites/" + category)
  			animated_sprite.visible = false
  
  			if player_outfit[category] != "none":
  				player_outfit[category] = "none"
  				had_changes = true
  
  	if had_changes:
  		has_unsaved_changes = true
  
  	show_message("Outfit zurückgesetzt!", Color(0.3, 0.7, 1, 1))
  
  # Hilfsfunktion zum Anzeigen von Nachrichten
  func show_message(text, color = Color(1, 1, 1, 1)):
  	if has_node("save_feedback"):
  		var label = get_node("save_feedback")
  		label.text = text
  		label.modulate = color
  
  		# Timer zum Ausblenden nach 2 Sekunden
  		get_tree().create_timer(2.0).timeout.connect(func():
  			if has_node("save_feedback"):
  				get_node("save_feedback").text = ""
  		)
  
  # Lädt das gespeicherte Outfit, falls vorhanden
  func load_saved_outfit():
  	# First try to load from current save data
  	if SaveManager.current_save_data and SaveManager.current_save_data.player_outfit:
  		var saved_outfit = SaveManager.current_save_data.player_outfit
  
  		# Log for debugging
  		print("Loading outfit from save data: ", saved_outfit)
  
  		# Update the outfit resource
  		current_outfit_resource.from_dictionary(saved_outfit)
  
  		# Update the UI
  		for category in saved_outfit:
  			if player_outfit.has(category):
  				var outfit_value = str(saved_outfit[category])
  				player_outfit[category] = outfit_value
  
  				# Update visibility
  				var animated_sprite = get_node("character_sprites/" + category)
  				if outfit_value == "none":
  					animated_sprite.visible = false
  				else:
  					animated_sprite.visible = true
  
  		print("Outfit loaded successfully")
  	else:
  		print("No saved outfit found in save data")
  
  
  func _on_back_pressed() -> void:
  	if has_unsaved_changes:
  		PopupManager.confirm(
  			"Nicht gespeicherte Änderungen",
  			"Du hast nicht gespeicherte Änderungen. Möchtest du wirklich ohne Speichern zurückkehren?",
  			"Abbrechen",
  			"Zurück",
  			"back_confirmation"
  		)
  	else:
  		get_tree().change_scene_to_file("res://scenes/ui/settings/settings_menu.tscn")
  
  func _on_dialog_confirmed(dialog_id):
  	if dialog_id == "back_confirmation":
  		get_tree().change_scene_to_file("res://scenes/ui/settings/settings_menu.tscn")

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\character_customizer\outfit_showcase.gd:
========================================
  class_name OutfitShowcase
  # outfit_showcase.gd
  extends Control
  
  var current_outfits = {}
  var preview_container
  var outfit_grid
  var back_button
  var outfit_name_field
  var save_button
  var delete_button
  var preview_helper
  
  func _ready():
  	preview_helper = load("res://scripts/ui/character_customizer/preview_helper.gd").new()
  	add_child(preview_helper)
  
  	# UI erstellen
  	setup_ui()
  
  	# Gespeicherte Outfits laden
  	load_saved_outfits()
  
  func setup_ui():
  	# Container für die Vorschau
  	preview_container = ScrollContainer.new()
  	preview_container.position = Vector2(50, 50)
  	preview_container.size = Vector2(900, 400)
  	add_child(preview_container)
  
  	# Grid für Outfit-Vorschaubilder
  	outfit_grid = GridContainer.new()
  	outfit_grid.columns = 4
  	preview_container.add_child(outfit_grid)
  
  	# Textfeld für Outfit-Namen
  	var name_label = Label.new()
  	name_label.text = "Outfit-Name:"
  	name_label.position = Vector2(50, 470)
  	add_child(name_label)
  
  	outfit_name_field = LineEdit.new()
  	outfit_name_field.position = Vector2(150, 470)
  	outfit_name_field.size = Vector2(300, 30)
  	outfit_name_field.placeholder_text = "Mein cooles Outfit"
  	add_child(outfit_name_field)
  
  	# Save-Button
  	save_button = Button.new()
  	save_button.text = "Speichern"
  	save_button.position = Vector2(470, 470)
  	save_button.size = Vector2(120, 30)
  	save_button.pressed.connect(_on_save_pressed)
  	add_child(save_button)
  
  	# Delete-Button
  	delete_button = Button.new()
  	delete_button.text = "Löschen"
  	delete_button.position = Vector2(600, 470)
  	delete_button.size = Vector2(120, 30)
  	delete_button.pressed.connect(_on_delete_pressed)
  	add_child(delete_button)
  
  	# Back-Button
  	back_button = Button.new()
  	back_button.text = "Zurück"
  	back_button.position = Vector2(400, 550)
  	back_button.size = Vector2(200, 40)
  	back_button.pressed.connect(_on_back_pressed)
  	add_child(back_button)
  
  # Lädt alle gespeicherten Outfits und zeigt sie an
  func load_saved_outfits():
  	current_outfits = preview_helper.load_favorites()
  
  	# UI aktualisieren
  	update_showcase()
  
  # Aktualisiert die Anzeige der Outfits
  func update_showcase():
  	# Alle vorherigen Kinder entfernen
  	for child in outfit_grid.get_children():
  		outfit_grid.remove_child(child)
  		child.queue_free()
  
  	# Aktuelle Outfit-Liste durchgehen
  	for outfit_name in current_outfits:
  		var outfit_config = current_outfits[outfit_name]
  
  		# Container für jedes Outfit
  		var outfit_container = VBoxContainer.new()
  		outfit_grid.add_child(outfit_container)
  
  		# Vorschaubild generieren
  		var preview_image = await preview_helper.generate_outfit_preview(
  			get_node("/root/Main/character_sprites"),
  			outfit_config
  		)
  
  		# TextureRect für das Vorschaubild
  		var preview_rect = TextureRect.new()
  		var image_texture = ImageTexture.create_from_image(preview_image)
  		preview_rect.texture = image_texture
  		preview_rect.custom_minimum_size = Vector2(200, 200)
  		preview_rect.stretch_mode = TextureRect.STRETCH_KEEP_ASPECT_CENTERED
  		outfit_container.add_child(preview_rect)
  
  		# Label für den Namen
  		var name_label = Label.new()
  		name_label.text = outfit_name
  		name_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
  		outfit_container.add_child(name_label)
  
  		# Button zum Laden dieses Outfits
  		var load_button = Button.new()
  		load_button.text = "Laden"
  		load_button.pressed.connect(_on_load_outfit_pressed.bind(outfit_name))
  		outfit_container.add_child(load_button)
  
  # Event-Handler
  
  func _on_save_pressed():
  	var current_outfit = get_node("/root/Main").get_current_outfit()
  	var name = outfit_name_field.text
  
  	if name.empty():
  		name = "Outfit " + str(current_outfits.size() + 1)
  
  	# Outfit zu Favoriten hinzufügen
  	preview_helper.save_to_favorites(current_outfit, name)
  
  	# Liste aktualisieren
  	load_saved_outfits()
  
  func _on_delete_pressed():
  	var name = outfit_name_field.text
  	if current_outfits.has(name):
  		current_outfits.erase(name)
  
  		# Aktualisierte Liste speichern
  		var config = ConfigFile.new()
  		config.set_value("favorites", "outfits", current_outfits)
  		config.save("user://favorites.cfg")
  
  		# UI aktualisieren
  		update_showcase()
  
  func _on_load_outfit_pressed(outfit_name):
  	var outfit_config = current_outfits[outfit_name]
  	get_node("/root/Main").apply_outfit(outfit_config)
  
  	# Eingabefeld aktualisieren
  	outfit_name_field.text = outfit_name
  
  func _on_back_pressed():
  	get_tree().change_scene_to_file("res://scenes/ui/character_customizer/customizer.tscn")

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\character_customizer\preview_helper.gd:
========================================
  class_name PreviewHelper
  # preview_helper.gd
  # Diese Datei enthält Hilfsfunktionen für die Vorschau im Character-Customizer
  
  extends Node
  
  # Cache für Outfit-Vorschaubilder
  var preview_cache = {}
  
  # Generiert ein Vorschaubild für ein komplettes Outfit
  # Kann verwendet werden, um mehrere Outfits nebeneinander anzuzeigen
  func generate_outfit_preview(character_sprites, outfit_config):
  	var viewport = SubViewport.new()
  	viewport.size = Vector2i(128, 128)
  	viewport.transparent_bg = true
  	viewport.render_target_update_mode = SubViewport.UPDATE_ONCE
  
  	var sprites_instance = character_sprites.duplicate()
  	viewport.add_child(sprites_instance)
  
  	# Positioniere die Sprites in der Mitte des Viewports
  	sprites_instance.position = Vector2(64, 64)
  	sprites_instance.scale = Vector2(4, 4)
  
  	# Setze das Outfit gemäß der Konfiguration
  	for category in outfit_config:
  		if sprites_instance.has_node(category):
  			var sprite = sprites_instance.get_node(category)
  			if str(outfit_config[category]) == "none":
  				sprite.visible = false
  			else:
  				sprite.visible = true
  				sprite.animation = str(outfit_config[category])
  				sprite.frame = 1
  
  	# Rendern und Vorschaubild zurückgeben
  	await get_tree().process_frame
  	await get_tree().process_frame
  
  	var texture = viewport.get_texture()
  	var image = texture.get_image()
  
  	# Viewport und Duplikat aufräumen
  	viewport.remove_child(sprites_instance)
  	sprites_instance.queue_free()
  	viewport.queue_free()
  
  	return image
  
  # Speichert ein Outfit in einem gesonderten Bereich für Favoriten
  func save_to_favorites(outfit_config, name = ""):
  	var favorites = load_favorites()
  
  	if name.empty():
  		name = "Outfit " + str(favorites.size() + 1)
  
  	favorites[name] = outfit_config
  
  	var config = ConfigFile.new()
  	config.set_value("favorites", "outfits", favorites)
  	var err = config.save("user://favorites.cfg")
  
  	return err == OK
  
  # Lädt alle gespeicherten Favoriten
  func load_favorites():
  	var config = ConfigFile.new()
  	var err = config.load("user://favorites.cfg")
  
  	if err == OK:
  		return config.get_value("favorites", "outfits", {})
  	else:
  		return {}
  
  # Konvertiert ein Outfit in ein exportierbares Format (z.B. JSON)
  func export_outfit_to_json(outfit_config):
  	return JSON.stringify(outfit_config)
  
  # Importiert ein Outfit aus einem exportierten Format
  func import_outfit_from_json(json_string):
  	var json = JSON.new()
  	var error = json.parse(json_string)
  	if error == OK:
  		return json.get_data()
  	else:
  		return null

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\controls\attack_button.gd:
========================================
  class_name AttackButton
  extends Button
  
  
  @onready var attack = $"."
  
  func _ready():
  	attack.modulate = Color(2, 2, 2, 0.5)
  
  
  func _on_button_up():
  	attack.modulate = Color(2, 2, 2, 0.5)
  	Input.action_release("attack")
  
  
  func _on_button_down():
  	attack.modulate = Color(1.0, 1.0, 1.0, 0.5)
  	Input.action_press("attack")

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\controls\defend_button.gd:
========================================
  class_name DefendButton
  extends Button
  
  
  @onready var defend = $"."
  
  func _ready():
  	defend.modulate = Color(2, 2, 2, 0.5)
  
  
  func _on_button_up():
  	defend.modulate = Color(2, 2, 2, 0.5)
  	Input.action_release("defend")
  
  func _on_button_down():
  	defend.modulate = Color(1.0, 1.0, 1.0, 0.5)
  	Input.action_press("defend")
  

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\dialogs\popup_dialog.gd:
========================================
  class_name PopupDialog
  extends CanvasLayer
  
  # Signal, wenn der primäre (rechte) Button gedrückt wird
  signal confirmed
  # Signal, wenn der sekundäre (linke) Button gedrückt wird
  signal canceled
  
  # UI-Elemente
  var dimmer
  var dialog_panel
  var title_label
  var message_label
  var button_container
  var cancel_button
  var confirm_button
  
  # Standardwerte
  var _title_text = "Bestätigung"
  var _message_text = "Möchtest du fortfahren?"
  var _cancel_text = "Abbrechen"
  var _confirm_text = "Bestätigen"
  var _confirm_color = Color(0.7, 0.2, 0.2, 1)  # Rot
  var _auto_hide = true
  
  func _init():
  	# Erstelle alle UI-Elemente programmatisch
  	_create_ui()
  
  func _ready():
  	# Bei Start nicht anzeigen
  	hide()
  
  	# Verbinde Button-Signale
  	cancel_button.pressed.connect(_on_cancel_pressed)
  	confirm_button.pressed.connect(_on_confirm_pressed)
  
  # Erstellt die komplette UI-Struktur
  func _create_ui():
  	# Dimmer (Hintergrund-Verdunkelung)
  	dimmer = ColorRect.new()
  	dimmer.name = "Dimmer"
  	dimmer.color = Color(0, 0, 0, 0.6)  # Halbtransparentes Schwarz
  	add_child(dimmer)
  
  	# DialogPanel
  	dialog_panel = Panel.new()
  	dialog_panel.name = "DialogPanel"
  
  	# Panel-Design
  	var panel_style = StyleBoxFlat.new()
  	panel_style.bg_color = Color(0.12, 0.12, 0.15, 1.0)
  	panel_style.border_width_left = 2
  	panel_style.border_width_top = 2
  	panel_style.border_width_right = 2
  	panel_style.border_width_bottom = 2
  	panel_style.border_color = Color(0.6, 0.6, 1.0, 0.7)
  	panel_style.corner_radius_top_left = 15
  	panel_style.corner_radius_top_right = 15
  	panel_style.corner_radius_bottom_left = 15
  	panel_style.corner_radius_bottom_right = 15
  	panel_style.shadow_color = Color(0, 0, 0, 0.3)
  	panel_style.shadow_size = 8
  	dialog_panel.add_theme_stylebox_override("panel", panel_style)
  	dimmer.add_child(dialog_panel)
  
  	# Titel
  	title_label = Label.new()
  	title_label.name = "Title"
  	title_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
  	title_label.add_theme_font_size_override("font_size", 24)
  	title_label.add_theme_color_override("font_color", Color(1, 1, 1, 1))
  	dialog_panel.add_child(title_label)
  
  	# Nachricht
  	message_label = Label.new()
  	message_label.name = "Message"
  	message_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
  	message_label.autowrap_mode = TextServer.AUTOWRAP_WORD_SMART
  	message_label.add_theme_font_size_override("font_size", 18)
  	message_label.add_theme_color_override("font_color", Color(0.9, 0.9, 0.9, 1))
  	dialog_panel.add_child(message_label)
  
  	# Buttons-Container
  	button_container = HBoxContainer.new()
  	button_container.name = "ButtonContainer"
  	button_container.alignment = BoxContainer.ALIGNMENT_CENTER
  	button_container.add_theme_constant_override("separation", 20)
  	dialog_panel.add_child(button_container)
  
  	# Button-Style vorbereiten
  	var button_style_normal = StyleBoxFlat.new()
  	button_style_normal.bg_color = Color(0.2, 0.2, 0.25, 1)
  	button_style_normal.border_width_left = 0
  	button_style_normal.border_width_top = 0
  	button_style_normal.border_width_right = 0
  	button_style_normal.border_width_bottom = 0
  	button_style_normal.corner_radius_top_left = 8
  	button_style_normal.corner_radius_top_right = 8
  	button_style_normal.corner_radius_bottom_left = 8
  	button_style_normal.corner_radius_bottom_right = 8
  
  	var button_style_hover = StyleBoxFlat.new()
  	button_style_hover.bg_color = Color(0.25, 0.25, 0.3, 1)
  	button_style_hover.border_width_left = 0
  	button_style_hover.border_width_top = 0
  	button_style_hover.border_width_right = 0
  	button_style_hover.border_width_bottom = 0
  	button_style_hover.corner_radius_top_left = 8
  	button_style_hover.corner_radius_top_right = 8
  	button_style_hover.corner_radius_bottom_left = 8
  	button_style_hover.corner_radius_bottom_right = 8
  
  	var button_style_pressed = StyleBoxFlat.new()
  	button_style_pressed.bg_color = Color(0.15, 0.15, 0.2, 1)
  	button_style_pressed.border_width_left = 0
  	button_style_pressed.border_width_top = 0
  	button_style_pressed.border_width_right = 0
  	button_style_pressed.border_width_bottom = 0
  	button_style_pressed.corner_radius_top_left = 8
  	button_style_pressed.corner_radius_top_right = 8
  	button_style_pressed.corner_radius_bottom_left = 8
  	button_style_pressed.corner_radius_bottom_right = 8
  
  	# Abbrechen-Button
  	cancel_button = Button.new()
  	cancel_button.name = "CancelButton"
  	cancel_button.add_theme_font_size_override("font_size", 18)
  	cancel_button.add_theme_stylebox_override("normal", button_style_normal.duplicate())
  	cancel_button.add_theme_stylebox_override("hover", button_style_hover.duplicate())
  	cancel_button.add_theme_stylebox_override("pressed", button_style_pressed.duplicate())
  	button_container.add_child(cancel_button)
  
  	# Bestätigen-Button
  	confirm_button = Button.new()
  	confirm_button.name = "ConfirmButton"
  	confirm_button.add_theme_font_size_override("font_size", 18)
  
  	# Rote Button-Stile
  	var confirm_style_normal = button_style_normal.duplicate()
  	confirm_style_normal.bg_color = Color(0.7, 0.2, 0.2, 1)
  	var confirm_style_hover = button_style_hover.duplicate()
  	confirm_style_hover.bg_color = Color(0.8, 0.3, 0.3, 1)
  	var confirm_style_pressed = button_style_pressed.duplicate()
  	confirm_style_pressed.bg_color = Color(0.6, 0.15, 0.15, 1)
  
  	confirm_button.add_theme_stylebox_override("normal", confirm_style_normal)
  	confirm_button.add_theme_stylebox_override("hover", confirm_style_hover)
  	confirm_button.add_theme_stylebox_override("pressed", confirm_style_pressed)
  	button_container.add_child(confirm_button)
  
  # Setzt Text-Inhalte und Farben
  func setup(title: String = "", message: String = "",
  		   cancel_text: String = "", confirm_text: String = "",
  		   confirm_button_color: Color = Color(0.7, 0.2, 0.2, 1)):
  
  	# Setze nur nicht-leere Werte
  	if title:
  		_title_text = title
  	if message:
  		_message_text = message
  	if cancel_text:
  		_cancel_text = cancel_text
  	if confirm_text:
  		_confirm_text = confirm_text
  
  	_confirm_color = confirm_button_color
  
  	return self  # Für Methoden-Verkettung
  
  # Einstellen, ob das Popup sich automatisch schließen soll
  func set_auto_hide(value: bool):
  	_auto_hide = value
  	return self  # Für Methoden-Verkettung
  
  # Zeigt den Dialog an
  func popup():
  	# Fenstergröße aktualisieren
  	var viewport_size = get_viewport().get_visible_rect().size
  	dimmer.size = viewport_size
  
  	var dialog_width = min(500, viewport_size.x * 0.8)
  	var dialog_height = 230
  	dialog_panel.size = Vector2(dialog_width, dialog_height)
  	dialog_panel.position = (viewport_size - dialog_panel.size) / 2
  	dialog_panel.pivot_offset = dialog_panel.size / 2
  
  	# Layout aktualisieren
  	title_label.position = Vector2(0, 20)
  	title_label.size = Vector2(dialog_width, 30)
  
  	message_label.position = Vector2(20, 60)
  	message_label.size = Vector2(dialog_width - 40, 60)
  
  	button_container.position = Vector2(20, dialog_height - 80)
  	button_container.size = Vector2(dialog_width - 40, 60)
  
  	cancel_button.custom_minimum_size = Vector2(dialog_width * 0.35, 60)
  	confirm_button.custom_minimum_size = Vector2(dialog_width * 0.35, 60)
  
  	# Aktualisiere UI
  	title_label.text = _title_text
  	message_label.text = _message_text
  	cancel_button.text = _cancel_text
  	confirm_button.text = _confirm_text
  
  	# Setze Button-Farbe
  	var normal_style = confirm_button.get_theme_stylebox("normal").duplicate()
  	var hover_style = confirm_button.get_theme_stylebox("hover").duplicate()
  	var pressed_style = confirm_button.get_theme_stylebox("pressed").duplicate()
  
  	normal_style.bg_color = _confirm_color
  	hover_style.bg_color = _confirm_color.lightened(0.1)
  	pressed_style.bg_color = _confirm_color.darkened(0.1)
  
  	confirm_button.add_theme_stylebox_override("normal", normal_style)
  	confirm_button.add_theme_stylebox_override("hover", hover_style)
  	confirm_button.add_theme_stylebox_override("pressed", pressed_style)
  
  	# Dialog anzeigen mit Animation
  	show()
  	dimmer.modulate = Color(1, 1, 1, 0)
  
  	var tween = create_tween()
  	tween.tween_property(dimmer, "modulate", Color(1, 1, 1, 1), 0.3).set_ease(Tween.EASE_OUT)
  
  	# Dialog-Panel Animation (Skalierung)
  	dialog_panel.scale = Vector2(0.9, 0.9)
  	tween.parallel().tween_property(dialog_panel, "scale", Vector2(1, 1), 0.3).set_ease(Tween.EASE_OUT)
  
  	return self  # Für Methoden-Verkettung
  
  # Schließt den Dialog
  func close():
  	var tween = create_tween()
  	tween.tween_property(dimmer, "modulate", Color(1, 1, 1, 0), 0.2).set_ease(Tween.EASE_IN)
  	tween.parallel().tween_property(dialog_panel, "scale", Vector2(0.9, 0.9), 0.2).set_ease(Tween.EASE_IN)
  
  	# Warte auf das Ende der Animation
  	await tween.finished
  	hide()
  
  # Button-Handling
  func _on_cancel_pressed():
  	emit_signal("canceled")
  	if _auto_hide:
  		close()
  
  func _on_confirm_pressed():
  	emit_signal("confirmed")
  	if _auto_hide:
  		close()

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\dialogs\popup_manager.gd:
========================================
  extends Node
  
  # Signal, dass ein zuvor erstellter Dialog bestätigt wurde
  signal dialog_confirmed(dialog_id: String)
  # Signal, dass ein zuvor erstellter Dialog abgebrochen wurde
  signal dialog_canceled(dialog_id: String)
  
  # Speichert alle aktiven Popups
  var _active_popups = {}
  
  # Zeigt eine einfache Bestätigungsabfrage
  func confirm(title: String, message: String,
  			 cancel_text: String = "Abbrechen", confirm_text: String = "Bestätigen",
  			 dialog_id: String = "") -> String:
  
  	# Generiere eine eindeutige ID, falls keine angegeben wurde
  	var id = dialog_id if dialog_id else _generate_id()
  
  	# Erstelle und zeige das Popup an
  	var popup = _create_popup()
  	popup.setup(title, message, cancel_text, confirm_text)
  
  	# Verbinde Signale, um weiterzuleiten
  	popup.confirmed.connect(func():
  		emit_signal("dialog_confirmed", id)
  		_active_popups.erase(id)
  	)
  	popup.canceled.connect(func():
  		emit_signal("dialog_canceled", id)
  		_active_popups.erase(id)
  	)
  
  	# Speichere das Popup für spätere Referenz
  	_active_popups[id] = popup
  
  	# Zeige das Popup an
  	popup.popup()
  
  	return id
  
  # Zeigt einen Warnungs-Dialog
  func warning(title: String, message: String, button_text: String = "OK") -> String:
  	var id = _generate_id()
  	var popup = _create_popup()
  
  	# Stelle Warnungs-Dialog ein
  	popup.setup(
  		title,
  		message,
  		"", # Kein Abbrechen-Button
  		button_text,
  		Color(0.9, 0.6, 0.1, 1) # Orange für Warnungen
  	)
  
  	# Verbinde Signale
  	popup.confirmed.connect(func():
  		emit_signal("dialog_confirmed", id)
  		_active_popups.erase(id)
  	)
  
  	# Verstecke den Abbrechen-Button
  	popup.cancel_button.visible = false
  
  	# Speichere und zeige an
  	_active_popups[id] = popup
  	popup.popup()
  
  	return id
  
  # Zeigt einen Fehler-Dialog
  func error(title: String, message: String, button_text: String = "OK") -> String:
  	var id = _generate_id()
  	var popup = _create_popup()
  
  	# Stelle Fehler-Dialog ein
  	popup.setup(
  		title,
  		message,
  		"", # Kein Abbrechen-Button
  		button_text,
  		Color(0.8, 0.1, 0.1, 1) # Rot für Fehler
  	)
  
  	# Verbinde Signale
  	popup.confirmed.connect(func():
  		emit_signal("dialog_confirmed", id)
  		_active_popups.erase(id)
  	)
  
  	# Verstecke den Abbrechen-Button
  	popup.cancel_button.visible = false
  
  	# Speichere und zeige an
  	_active_popups[id] = popup
  	popup.popup()
  
  	return id
  
  # Zeigt eine Info-Nachricht
  func info(title: String, message: String, button_text: String = "OK") -> String:
  	var id = _generate_id()
  	var popup = _create_popup()
  
  	# Stelle Info-Dialog ein
  	popup.setup(
  		title,
  		message,
  		"", # Kein Abbrechen-Button
  		button_text,
  		Color(0.2, 0.6, 0.8, 1) # Blau für Info
  	)
  
  	# Verbinde Signale
  	popup.confirmed.connect(func():
  		emit_signal("dialog_confirmed", id)
  		_active_popups.erase(id)
  	)
  
  	# Verstecke den Abbrechen-Button
  	popup.cancel_button.visible = false
  
  	# Speichere und zeige an
  	_active_popups[id] = popup
  	popup.popup()
  
  	return id
  
  # Schließt einen bestimmten Dialog
  func close_dialog(dialog_id: String) -> bool:
  	if _active_popups.has(dialog_id):
  		_active_popups[dialog_id].close()
  		_active_popups.erase(dialog_id)
  		return true
  	return false
  
  # Schließt alle aktiven Dialoge
  func close_all_dialogs():
  	for id in _active_popups:
  		_active_popups[id].close()
  	_active_popups.clear()
  
  # Erstellt eine neue Popup-Instanz
  func _create_popup():
  	var popup_script = load("res://scripts/ui/dialogs/popup_dialog.gd")
  	# Hier ist die Korrektur: Wir erstellen einen CanvasLayer statt eines Node
  	var popup_instance = CanvasLayer.new()
  	popup_instance.set_script(popup_script)
  	add_child(popup_instance)
  	return popup_instance
  
  # Generiert eine eindeutige ID für Dialoge
  func _generate_id() -> String:
  	return "dialog_" + str(randi())

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\hud\hud_controller.gd:
========================================
  extends CanvasLayer
  
  var coins := 0
  var max_lifes := 3
  var lifes := max_lifes
  
  # Elixir fill (0.0 = empty, 1.0 = full)
  var elixir_fill_level := 0.0
  
  func _ready():
  	# Example: align hearts and coins (already in your code)
  	$HeartsFull.flip_h = true
  	$LabelCoinSum.text = str(coins)
  	load_hearts()
  
  	# Initialize the elixir with empty fill
  	set_elixir_fill(elixir_fill_level)
  
  func update_elixir_fill(fill_amount: float):
  	var new_fill_level = min(1.0, max(elixir_fill_level + fill_amount, 0))
  	set_elixir_fill(new_fill_level)
  
  func set_elixir_fill(fill_level: float):
  	elixir_fill_level = clamp(fill_level, 0.0, 1.0)
  	var elixir = $elixir
  	var bottle = $bottle
  
  	# Because we are using a scaled Sprite, region clipping is in unscaled texture coordinates.
  	elixir.region_enabled = true
  
  	# Unscaled texture size
  	var tex_size = elixir.texture.get_size()
  
  	# Fill height in unscaled pixels
  	var visible_height = tex_size.y * elixir_fill_level
  
  	# Clip from the top: region_rect starts at (0, tex_size.y - visible_height)
  	elixir.region_rect = Rect2(
  		Vector2(0, tex_size.y - visible_height),
  		Vector2(tex_size.x, visible_height)
  	)
  
  	var bottle_texture_size = bottle.texture.get_size()
  	var elixir_texture_size = elixir.texture.get_size()
  
  	var bottle_scale = bottle.scale
  	var elixir_scale = elixir.scale
  
  	var bottle_size = bottle_texture_size.y * bottle_scale.y
  	var elixir_size = visible_height * elixir_scale.y
  
  
  	elixir.position.x = bottle.position.x
  	elixir.position.y = bottle.position.y + ( (bottle_size - elixir_size) / 2)
  
  
  
  # Everything else is just your standard code for coins/life/etc.
  func coin_collected():
  	coins += 1
  	$LabelCoinSum.text = str(coins)
  	Global.collect_coin()
  	update_coin_display()
  
  func update_coin_display():
  	$LabelCoinSum.text = str(coins)
  
  func load_hearts():
  	$HeartsFull.size.x = lifes * $HeartsFull.size.x / max_lifes
  
  func change_life(amount):
  	lifes = clamp(lifes + amount, 0, max_lifes)
  	if lifes <= 0:
  		Global.player_death()
  	load_hearts()
  
  func collect_softpower():
  	update_elixir_fill(0.25)
  
  func use_softpower():
  	update_elixir_fill(-0.25)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\main_menu\camera.gd:
========================================
  class_name Camera
  extends Camera2D
  
  
  # Called when the node enters the scene tree for the first time.
  func _ready():
  	pass # Replace with function body.
  
  
  # Called every frame. 'delta' is the elapsed time since the previous frame.
  func _process(delta):
  	pass

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\main_menu\customizer_button.gd:
========================================
  class_name CustomizerButton
  extends Button
  
  
  # Called when the node enters the scene tree for the first time.
  func _ready():
  	pass # Replace with function body.
  
  
  # Called every frame. 'delta' is the elapsed time since the previous frame.
  func _process(delta):
  	pass

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\main_menu\main_menu.gd:
========================================
  class_name MainMenu
  extends Node2D
  
  
  func _on_exit_button_pressed():
  	get_tree().quit()
  
  
  func _on_settings_button_pressed():
  	get_tree().change_scene_to_file("res://scenes/ui/settings/settings_menu.tscn")
  
  
  func _on_start_button_pressed():
  	get_tree().change_scene_to_file("res://scenes/levels/adventure_mode/base_level.tscn")

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\main_menu\menu_buttons.gd:
========================================
  class_name MenuButtons
  extends Button
  
  
  # Called when the node enters the scene tree for the first time.
  func _ready():
  	pass # Replace with function body.
  
  
  # Called every frame. 'delta' is the elapsed time since the previous frame.
  func _process(_delta):
  	pass

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\main_menu\start_background.gd:
========================================
  class_name StartBackground
  extends ParallaxBackground
  
  var scrolling_speed = 50
  # Called every frame. 'delta' is the elapsed time since the previous frame.
  func _process(delta):
  	scroll_offset.x -= scrolling_speed * delta

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\settings\audio_settings.gd:
========================================
  class_name AudioSettings
  extends Node2D
  
  
  # Called when the node enters the scene tree for the first time.
  func _ready():
  	pass # Replace with function body.
  
  
  # Called every frame. 'delta' is the elapsed time since the previous frame.
  func _process(delta):
  	pass
  
  
  func _on_back_button_pressed():
  	get_tree().change_scene_to_file("res://scenes/ui/settings/settings_menu.tscn")
  
  var master_bus = AudioServer.get_bus_index("Master")
  
  
  func _on_h_slider_value_changed(value):
  	AudioServer.set_bus_volume_db(master_bus, value)
  
  	if value == -30:
  		AudioServer.set_bus_mute(master_bus, true)
  	else:
  		AudioServer.set_bus_mute(master_bus, false)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\settings\settings_menu.gd:
========================================
  class_name SettingsMenu
  extends Node2D
  
  "res://scripts/ui/settings/settings_menu.gd"
  # Called when the node enters the scene tree for the first time.
  func _ready():
  	pass # Replace with function body.
  
  
  # Called every frame. 'delta' is the elapsed time since the previous frame.
  func _process(delta):
  	pass
  
  
  func _on_back_button_pressed():
  	get_tree().change_scene_to_file("res://scenes/ui/main_menu/main_menu.tscn")
  
  
  func _on_audio_button_pressed():
  	get_tree().change_scene_to_file("res://scenes/ui/settings/audio_settings.tscn")
  
  
  func _on_customizer_button_pressed():
  	get_tree().change_scene_to_file("res://scenes/ui/character_customizer/customizer.tscn")

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\utils\killzone.gd:
========================================
  class_name Killzone
  extends Area2D
  
  @onready var timer = $Timer
  
  func _on_body_entered(body):
  	print("you died!")
  	Engine.time_scale = 0.5
  	body.get_node("CollisionShape2D").queue_free()
  	timer.start()
  
  
  
  func _on_timer_timeout():
  	Engine.time_scale = 1.0
  	get_tree().reload_current_scene()

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\utils\save_data.gd:
========================================
  class_name SaveData
  extends Resource
  
  ## Data structure for saved games in The Little Saint
  ## Stores player stats, game progress, and settings
  
  # Version for compatibility checks
  @export var save_version: int = 1
  
  # Save metadata
  @export var save_date: String = ""
  @export var playtime_seconds: int = 0
  
  # Player position and level
  @export var player_position: Vector2 = Vector2.ZERO
  @export var current_level: String = ""
  
  # Player stats
  @export var health: float = 3.0
  @export var coins: int = 0
  @export var player_speed: float = Constants.PLAYER_DEFAULT_SPEED
  @export var player_jump_velocity: float = Constants.PLAYER_DEFAULT_JUMP_VELOCITY
  @export var player_fly_velocity: float = Constants.PLAYER_DEFAULT_FLY_VELOCITY
  @export var player_gravity: float = Constants.PLAYER_DEFAULT_GRAVITY
  
  # Player state
  @export var player_mode: String = "normal"
  @export var player_passed_fly_time: float = 0.0
  @export var player_jump_counter: int = 0
  @export var player_ready_for_jump: bool = true
  @export var player_allowed_jumps: int = 1
  
  # Player appearance
  @export var player_outfit: Dictionary = {}
  
  # Game progress
  @export var collected_coins: int = 0
  @export var unlocked_levels: Array = []
  @export var completed_quests: Array = []
  
  # Initialize with default values
  func _init():
  	save_date = Time.get_datetime_string_from_system(false, true)
  
  	# Set default player outfit if none exists
  	if player_outfit.is_empty():
  		# Create a default outfit
  		player_outfit = {
  			"beard": "none",
  			"lipstick": "none",
  			"eyes": "1",
  			"shoes": "1",
  			"earrings": "none",
  			"hats": "none",
  			"glasses": "none",
  			"clothes_down": "1",
  			"clothes_up": "1",
  			"clothes_complete": "none",
  			"bodies": "1",
  			"hair": "1"
  		}
  
  # Validate the save data to ensure it's not corrupted
  func validate() -> bool:
  	# Basic validation to ensure critical fields are present
  	if player_speed <= 0 or player_gravity <= 0:
  		return false
  
  	# Check that outfit dictionary has expected keys
  	var required_outfit_keys = [
  		"beard", "lipstick", "eyes", "shoes", "earrings",
  		"hats", "glasses", "clothes_down", "clothes_up",
  		"clothes_complete", "bodies", "hair"
  	]
  
  	for key in required_outfit_keys:
  		if not player_outfit.has(key):
  			return false
  
  	return true
  
  # Create a dictionary representation of the save data for debug purposes
  func to_dict() -> Dictionary:
  	return {
  		"save_version": save_version,
  		"save_date": save_date,
  		"playtime_seconds": playtime_seconds,
  		"player_position": {"x": player_position.x, "y": player_position.y},
  		"current_level": current_level,
  		"health": health,
  		"coins": coins,
  		"player_speed": player_speed,
  		"player_jump_velocity": player_jump_velocity,
  		"player_fly_velocity": player_fly_velocity,
  		"player_gravity": player_gravity,
  		"player_mode": player_mode,
  		"player_passed_fly_time": player_passed_fly_time,
  		"player_jump_counter": player_jump_counter,
  		"player_ready_for_jump": player_ready_for_jump,
  		"player_allowed_jumps": player_allowed_jumps,
  		"player_outfit": player_outfit,
  		"collected_coins": collected_coins,
  		"unlocked_levels": unlocked_levels,
  		"completed_quests": completed_quests
  	}
  
  # Return a string representation for debugging
  func _to_string() -> String:
  	return JSON.stringify(to_dict(), "\t")
  
  # Update playtime
  func update_playtime(seconds_to_add: int) -> void:
  	playtime_seconds += seconds_to_add
  
  # Get formatted playtime as string
  func get_playtime_string() -> String:
  	var hours = playtime_seconds / 3600
  	var minutes = (playtime_seconds % 3600) / 60
  	var seconds = playtime_seconds % 60
  
  	return "%02d:%02d:%02d" % [hours, minutes, seconds]
  
  # Create a deep copy of this save data
  func duplicate_data() -> SaveData:
  	var new_data = SaveData.new()
  
  	new_data.save_version = save_version
  	new_data.save_date = save_date
  	new_data.playtime_seconds = playtime_seconds
  	new_data.player_position = player_position
  	new_data.current_level = current_level
  	new_data.health = health
  	new_data.coins = coins
  	new_data.player_speed = player_speed
  	new_data.player_jump_velocity = player_jump_velocity
  	new_data.player_fly_velocity = player_fly_velocity
  	new_data.player_gravity = player_gravity
  	new_data.player_mode = player_mode
  	new_data.player_passed_fly_time = player_passed_fly_time
  	new_data.player_jump_counter = player_jump_counter
  	new_data.player_ready_for_jump = player_ready_for_jump
  	new_data.player_allowed_jumps = player_allowed_jumps
  	new_data.player_outfit = player_outfit.duplicate(true)
  	new_data.collected_coins = collected_coins
  	new_data.unlocked_levels = unlocked_levels.duplicate()
  	new_data.completed_quests = completed_quests.duplicate()
  
  	return new_data
  
  # Create a new save with default values
  static func create_new_save() -> SaveData:
  	var save = SaveData.new()
  	save.save_date = Time.get_datetime_string_from_system(false, true)
  	return save
