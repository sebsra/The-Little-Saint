PROJECT STRUCTURE FOR: c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint
==================================================

[DIR] .git (skipped)
[DIR] .godot (skipped)
[DIR] .vscode (skipped)
[DIR] Artefakte
  - # Refactoring TODO List.md
- README.md
[DIR] addons
  [DIR] virtual_joystick
    [DIR] previews
    [DIR] test
      - player.gd
      - test.tscn
    [DIR] textures
    - virtual_joystick.gd
    - virtual_joystick_instantiator.gd
    - virtual_joystick_plugin.gd
    - virtual_joystick_scene.tscn
[DIR] assets
  [DIR] audio
    [DIR] music
      [DIR] Tracks
    [DIR] sfx
  [DIR] fonts
    [DIR] general
    [DIR] special
      [DIR] copyduck
        - More Info.txt
  [DIR] sprites
    [DIR] characters
      [DIR] acc
      [DIR] characters
      [DIR] clothes
      [DIR] eyes
      [DIR] greyscale
        [DIR] acc
          [DIR] acc
          [DIR] modular
        [DIR] character
          [DIR] without
        [DIR] clothes
          [DIR] clothes
          [DIR] modular
        [DIR] eyes
        [DIR] hair
        - info.txt
        [DIR] tools
      [DIR] hair
      - info.txt
      - list.txt
      [DIR] separate
        [DIR] axe
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
          [DIR] tool
          [DIR] without
        [DIR] block
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
          [DIR] tool
          [DIR] without
        [DIR] carry
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
        [DIR] die
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
        [DIR] fish
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
          [DIR] tool
          [DIR] without
        [DIR] hoe
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
          [DIR] tool
          [DIR] without
        [DIR] hurt
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
        [DIR] jump
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
        [DIR] pickaxe
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
          [DIR] tool
          [DIR] without
        [DIR] pickup
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
        [DIR] sword
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
          [DIR] tool
          [DIR] without
        [DIR] walk
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
        [DIR] water
          [DIR] acc
          [DIR] clothes
          [DIR] eyes
          [DIR] hair
          [DIR] tool
          [DIR] without
    [DIR] enemies
      [DIR] 1 Bat
      [DIR] 2 Goblin_Mage
      [DIR] 3 Goblin_Melee
      [DIR] 4 Goblin_Range
      [DIR] 5 Small_Mushroom
      [DIR] 6 Big_Mushroom
    [DIR] environment
      [DIR] craftpix-896753-village-pixel-art-environment-assets-pack
        - License.txt
        [DIR] PNG
          [DIR] Objects
          [DIR] Tiles
        - readme.txt
      [DIR] craftpix-net-352322-nature-pixel-art-environment-free-assets-pack
        - License.txt
        [DIR] PNG
          [DIR] Objects
          [DIR] Tiles
        - readme.txt
      [DIR] craftpix-net-481981-free-summer-pixel-art-backgrounds
        - License.txt
        [DIR] PNG
          [DIR] summer 1
          [DIR] summer 2
          [DIR] summer 3
          [DIR] summer 4
          [DIR] summer5
          [DIR] summer6
          [DIR] summer7
          [DIR] summer8
        - readme.txt
      [DIR] craftpix-net-965049-free-industrial-zone-tileset-pixel-art
        [DIR] 1 Tiles
        [DIR] 2 Background
        [DIR] 3 Objects
        [DIR] 4 Animated objects
        - Font.txt
        - license.txt
      [DIR] peasant's_house
        [DIR] Peasant's_House
          [DIR] Door_Animation
            [DIR] Door_Animation-FrameByFrame
          [DIR] House_in_the_middle
            [DIR] Door_Animation
            [DIR] Window_Animation
          [DIR] Peasant's_House-NoAnimation
          - README.txt
          [DIR] Window_Animation
            [DIR] Window_Animation-FrameByFrame
      [DIR] sunny-land-files
        [DIR] Sunny-land-files
          [DIR] Graphical Assets
            [DIR] environment
              [DIR] Background
              [DIR] Props
            [DIR] sprites
              [DIR] cherry
              [DIR] eagle
              [DIR] enemy-death
              [DIR] frog
                [DIR] idle
                [DIR] jump
              [DIR] gem
              [DIR] item-feedback
              [DIR] opossum
              [DIR] player
                [DIR] climb
                [DIR] crouch
                [DIR] hurt
                [DIR] idle
                [DIR] jump
                [DIR] run
            [DIR] spritesheets
          - public-license.txt
    [DIR] items
    [DIR] ui
    [DIR] unsorted
      [DIR] Audio
        [DIR] Tracks
      [DIR] Bushes
      [DIR] Character v.2
        [DIR] acc
        [DIR] characters
        [DIR] clothes
        [DIR] eyes
        [DIR] greyscale
          [DIR] acc
            [DIR] acc
            [DIR] modular
          [DIR] character
            [DIR] without
          [DIR] clothes
            [DIR] clothes
            [DIR] modular
          [DIR] eyes
          [DIR] hair
          [DIR] tools
        [DIR] hair
        [DIR] separate
          [DIR] axe
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
            [DIR] tool
            [DIR] without
          [DIR] block
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
            [DIR] tool
            [DIR] without
          [DIR] carry
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
          [DIR] die
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
          [DIR] fish
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
            [DIR] tool
            [DIR] without
          [DIR] hoe
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
            [DIR] tool
            [DIR] without
          [DIR] hurt
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
          [DIR] jump
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
          [DIR] pickaxe
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
            [DIR] tool
            [DIR] without
          [DIR] pickup
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
          [DIR] sword
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
            [DIR] tool
            [DIR] without
          [DIR] walk
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
          [DIR] water
            [DIR] acc
            [DIR] clothes
            [DIR] eyes
            [DIR] hair
            [DIR] tool
            [DIR] without
      [DIR] Font
      [DIR] Fonts
        [DIR] copyduck
      - License.txt
      [DIR] Monsters
        [DIR] 1 Bat
        [DIR] 2 Goblin_Mage
        [DIR] 3 Goblin_Melee
        [DIR] 4 Goblin_Range
        [DIR] 5 Small_Mushroom
        [DIR] 6 Big_Mushroom
        [DIR] PSD
      [DIR] Peasant's_House
        [DIR] Peasant's_House
          [DIR] Door_Animation
            [DIR] Door_Animation-FrameByFrame
          [DIR] House_in_the_middle
            [DIR] Door_Animation
            [DIR] Window_Animation
          [DIR] Peasant's_House-NoAnimation
          [DIR] Window_Animation
            [DIR] Window_Animation-FrameByFrame
      [DIR] Sunny-land-files
        [DIR] Sunny-land-files
          [DIR] Graphical Assets
            [DIR] Aseprite
            [DIR] GIF Previews
              [DIR] FX
              [DIR] eagle
              [DIR] frog
              [DIR] items
              [DIR] opossum
              [DIR] player
            [DIR] PSD
              [DIR] MISC
              [DIR] environment
              [DIR] sprites
                [DIR] FX
                [DIR] eagle
                [DIR] frog
                [DIR] items
                [DIR] opossum
                [DIR] player
            [DIR] environment
              [DIR] Background
              [DIR] Props
            [DIR] sprites
              [DIR] cherry
              [DIR] eagle
              [DIR] enemy-death
              [DIR] frog
                [DIR] idle
                [DIR] jump
              [DIR] gem
              [DIR] item-feedback
              [DIR] opossum
              [DIR] player
                [DIR] climb
                [DIR] crouch
                [DIR] hurt
                [DIR] idle
                [DIR] jump
                [DIR] run
            [DIR] spritesheets
      [DIR] craftpix-896753-village-pixel-art-environment-assets-pack
        [DIR] PNG
          [DIR] Objects
          [DIR] Tiles
        [DIR] Village_PixelArt_Environment.unitypackage
      [DIR] craftpix-net-352322-nature-pixel-art-environment-free-assets-pack
        [DIR] PNG
          [DIR] Objects
          [DIR] Tiles
      [DIR] craftpix-net-481981-free-summer-pixel-art-backgrounds
        [DIR] PNG
          [DIR] summer 1
          [DIR] summer 2
          [DIR] summer 3
          [DIR] summer 4
          [DIR] summer5
          [DIR] summer6
          [DIR] summer7
          [DIR] summer8
        [DIR] PSD
      [DIR] craftpix-net-965049-free-industrial-zone-tileset-pixel-art
        [DIR] 1 Tiles
        [DIR] 2 Background
        [DIR] 3 Objects
        [DIR] 4 Animated objects
        [DIR] PSD
  [DIR] tilemaps
[DIR] config
[DIR] docs
- get_structure.py
- project.godot
- project_structure.txt
[DIR] scenes
  [DIR] common
    [DIR] enemies
    [DIR] items
  [DIR] core
    [DIR] character
      - character_sprites.tscn
      - debug.gd
      - hurt.gd
      - player.tscn
    [DIR] enemies
      - ardit_enemy.tscn
      - goblin_archer.tscn
      - goblin_mage.tscn
      - goblin_melee.tscn
      - prince_enemy.tscn
    [DIR] items
      - coins.tscn
      - killzone.tscn
      - power_attack.tscn
      - power_fly.tscn
      - power_jump.tscn
    [DIR] projectiles
      - mage_ball.tscn
      - rock.tscn
  [DIR] levels
    [DIR] adventure_mode
      - adventure_level.tscn
      - base_level.tscn
    [DIR] ardit_levels
      [DIR] Egypt
      [DIR] Free
        [DIR] Background
        [DIR] Items
          [DIR] Boxes
            [DIR] Box1
            [DIR] Box2
            [DIR] Box3
          [DIR] Checkpoints
            [DIR] Checkpoint
            [DIR] End
            [DIR] Start
          [DIR] Fruits
        [DIR] Main Characters
          [DIR] Mask Dude
          [DIR] Ninja Frog
          [DIR] Pink Man
          [DIR] Virtual Guy
        [DIR] Menu
          [DIR] Buttons
          [DIR] Levels
          [DIR] Text
        [DIR] Other
        [DIR] Terrain
        [DIR] Traps
          [DIR] Arrow
          [DIR] Blocks
          [DIR] Falling Platforms
          [DIR] Fan
          [DIR] Fire
          [DIR] Platforms
          [DIR] Rock Head
          [DIR] Sand Mud Ice
          [DIR] Saw
          [DIR] Spike Head
          [DIR] Spiked Ball
          [DIR] Spikes
          [DIR] Trampoline
      [DIR] Free Version
        [DIR] Tiles
      [DIR] [Free-Version] The Lost Tomb - [24x24] Dungeon Asset pack
      - arrogance.tscn
      [DIR] egyptian-game-ui-frames-assets
      [DIR] enemy1
    [DIR] prince_levels
      [DIR] Scriptprince
      [DIR] Tiles
        [DIR] fourSeasonsPlatformer
          - - READ ME -.txt
          [DIR] background_
          [DIR] foreground_
          [DIR] midground_
          [DIR] objects_
      - game_prince.tscn
      - platform.tscn
    [DIR] sebastian_levels
      - level_1.tscn
  [DIR] managers
    - audio_manager.tscn
  [DIR] ui
    [DIR] character_customizer
      - customizer.tscn
      - outfit_showcase.tscn
    [DIR] controls
      - gui.tscn
      - joystick.tscn
    [DIR] customizer
    [DIR] dialogs
      - popup_dialog.tscn
    [DIR] hud
      - hud.tscn
    [DIR] main_menu
      - main_menu.tscn
      - start_background.tscn
    [DIR] settings
      - audio_settings.tscn
      - settings_menu.tscn
[DIR] scripts
  [DIR] autoload
    - audio_manager.gd
    - game_manager.gd
  [DIR] core
    [DIR] base_classes
      - base_enemy.gd
      - base_power_up.gd
      - base_projectile.gd
    [DIR] characters
      - character_sprites.gd
      - player.gd
      - player_camera.gd
    [DIR] enemies
      - ardit_enemy.gd
      - goblin_archer.gd
      - goblin_mage.gd
      - goblin_melee.gd
      - prince_enemy.gd
    [DIR] items
      - coins.gd
      - power_attack.gd
      - power_fly.gd
      - power_jump.gd
    [DIR] projectiles
      - mage_ball.gd
      - rock.gd
    [DIR] state_machine
      [DIR] enemy_states
        - enemy_idle_state.gd
      [DIR] player_states
        - player_attack_state.gd
        - player_base_state.gd
        - player_death_state.gd
        - player_fall_state.gd
        - player_fly_state.gd
        - player_hurt_state.gd
        - player_idle_state.gd
        - player_jump_state.gd
        - player_walk_state.gd
      - state.gd
      - state_machine.gd
  [DIR] levels
    - base_level.gd
  [DIR] ui
    [DIR] character_customizer
      - customizer_controller.gd
      - outfit_showcase.gd
      - preview_helper.gd
    [DIR] controls
      - attack_button.gd
      - defend_button.gd
    [DIR] dialogs
      - popup_dialog.gd
      - popup_manager.gd
    [DIR] hud
      - hud_controller.gd
    [DIR] main_menu
      - camera.gd
      - customizer_button.gd
      - main_menu.gd
      - menu_buttons.gd
      - start_background.gd
    [DIR] settings
      - audio_settings.gd
      - settings_menu.gd
  [DIR] utils
    - killzone.gd
- state_machineproject_structure.txt

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\Artefakte\# Refactoring TODO List.md:
========================================
  # The Little Saint - Refactoring TODO List
  
  
  ## 2. Enhanced Game Management
  
  ### 2.1 Expand Game Manager
  19. [MODIFY] `scripts/autoload/game_manager.gd` - Develop the empty manager with game state handling
  20. [NEW] `scripts/autoload/scene_manager.gd` - Create manager for scene transitions
  21. [NEW] `scripts/autoload/event_bus.gd` - Create centralized event system
  
  ### 2.2 Improve Save System
  22. [NEW] `scripts/autoload/save_manager.gd` - Create dedicated save manager
  23. [NEW] `scripts/utils/save_data.gd` - Create data structure for saved games
  24. [MODIFY] `scripts/ui/character_customizer/customizer_controller.gd` - Use SaveManager instead of ConfigFile
  25. [MODIFY] `scripts/core/characters/player.gd` - Use SaveManager instead of ConfigFile
  
  ## 3. Player System Improvements
  
  ### 3.1 Refactor Player Controller
  26. [MODIFY] `scripts/core/characters/player.gd` - Major refactoring for cleaner structure
  27. [NEW] `scripts/core/characters/player_movement.gd` - Extract movement logic
  28. [NEW] `scripts/core/characters/player_animation.gd` - Extract animation logic
  29. [NEW] `scripts/core/characters/player_outfit.gd` - Extract outfit management
  30. [NEW] `scripts/core/characters/player_input.gd` - Create input handler
  
  ### 3.2 Enhance Character Customization
  31. [NEW] `scripts/resources/player_outfit_resource.gd` - Create outfit resource type
  32. [MODIFY] `scripts/ui/character_customizer/customizer_controller.gd` - Use resource-based system
  33. [MODIFY] `scripts/ui/character_customizer/outfit_showcase.gd` - Improve UI feedback
  34. [MODIFY] `scripts/ui/character_customizer/preview_helper.gd` - Optimize preview generation
  
  ## 4. Enemy System Enhancements
  
  ### 4.1 Standardize Enemy Behavior
  35. [NEW] `scripts/core/enemies/behaviors/patrol_behavior.gd` - Create modular patrol behavior
  36. [NEW] `scripts/core/enemies/behaviors/chase_behavior.gd` - Create modular chase behavior
  37. [NEW] `scripts/core/enemies/behaviors/attack_behavior.gd` - Create modular attack behavior
  38. [NEW] `scripts/core/enemies/behaviors/ranged_attack.gd` - Create ranged attack component
  39. [NEW] `scripts/core/enemies/behaviors/melee_attack.gd` - Create melee attack component
  40. [NEW] `scripts/managers/enemy_manager.gd` - Create manager for enemy spawning and waves
  
  ### 4.2 Improve Combat System
  41. [NEW] `scripts/core/combat/damage_system.gd` - Create system for damage handling
  42. [NEW] `scripts/core/combat/hit_effect.gd` - Create visual effects for hits
  43. [NEW] `scripts/core/combat/screen_shake.gd` - Add screen shake effect
  44. [MODIFY] `scripts/ui/hud/hud_controller.gd` - Improve damage feedback
  
  ## 5. UI and User Experience
  
  ### 5.1 Enhance UI Framework
  45. [NEW] `scripts/ui/theme/ui_theme.gd` - Create consistent UI theme
  46. [NEW] `scripts/ui/components/` - Create folder for reusable UI components
  47. [NEW] `scripts/ui/components/button_with_sound.gd` - Create button with sound effects
  48. [NEW] `scripts/ui/transitions/screen_transition.gd` - Create screen transition effects
  49. [MODIFY] `scenes/ui/main_menu/main_menu.tscn` - Update with new UI components
  
  ### 5.2 Improve HUD
  50. [MODIFY] `scripts/ui/hud/hud_controller.gd` - Enhance health display and animations
  51. [NEW] `scripts/ui/hud/mini_map.gd` - Add mini-map component
  52. [NEW] `scripts/ui/hud/objective_tracker.gd` - Add objective tracking
  53. [MODIFY] `scenes/ui/hud/hud.tscn` - Update with new components
  
  ### 5.3 Dialog System
  54. [MODIFY] `scripts/ui/dialogs/popup_dialog.gd` - Enhance with animations
  55. [NEW] `scripts/ui/dialogs/conversation_system.gd` - Create NPC conversation system
  56. [NEW] `scripts/ui/dialogs/dialog_tree.gd` - Implement branching dialogs
  57. [NEW] `scripts/ui/dialogs/quest_tracker.gd` - Add quest tracking
  
  ## 6. Performance Optimization
  
  ### 6.1 Resource Management
  58. [NEW] `scripts/utils/resource_preloader.gd` - Create resource preloading manager
  59. [NEW] `scripts/utils/object_pool.gd` - Implement object pooling system
  60. [MODIFY] `scripts/core/projectiles/mage_ball.gd` - Use object pooling
  61. [MODIFY] `scripts/core/projectiles/rock.gd` - Use object pooling
  
  ### 6.2 Code Optimization
  62. [REVIEW] All scripts with _process methods - Optimize heavy processing
  63. [MODIFY] `scripts/core/characters/player.gd` - Optimize signal connections
  64. [NEW] `scripts/utils/performance_monitor.gd` - Add monitoring capabilities
  
  ## 7. Development Tooling
  
  ### 7.1 Create Debug Tools
  65. [NEW] `scripts/utils/debug_console.gd` - Implement in-game debug console
  66. [NEW] `scripts/utils/performance_display.gd` - Add FPS and memory display
  67. [NEW] `scripts/utils/cheat_system.gd` - Add cheat code functionality
  
  ### 7.2 Improve Project Structure
  68. [NEW] `scripts/utils/constants.gd` - Create global constants file
  69. [REVIEW] All scripts - Standardize class_name usage
  70. [NEW] `docs/code_standards.md` - Create coding standards document
  71. [NEW] `docs/architecture.md` - Document project architecture
  
  ## 8. Audio System Enhancements
  
  ### 8.1 Expand Audio Manager
  72. [MODIFY] `scripts/autoload/audio_manager.gd` - Expand with categories and spatial audio
  73. [NEW] `scripts/audio/adaptive_music_system.gd` - Create dynamic music system
  74. [NEW] `scripts/audio/sound_effect.gd` - Create enhanced sound effect class
  75. [MODIFY] `scenes/managers/audio_manager.tscn` - Update with new audio buses

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\README.md:
========================================
  # Godot Virtual Joystick
  
  <img src="addons/virtual_joystick/previews/icon.png" width="200">
  
  A simple virtual joystick for touchscreens, with useful options.
  
  GitHub Page: https://github.com/MarcoFazioRandom/Virtual-Joystick-Godot
  
  Godot Engine: https://godotengine.org
  
  ## PREVIEWS:
  
  <img src="addons/virtual_joystick/previews/preview1.png" width="300">    <img src="addons/virtual_joystick/previews/preview2.png" width="300">
  
  Easy to use:
  
  ```GDScript
  extends Sprite2D
  
  @export var speed : float = 100
  
  @export var joystick_left : VirtualJoystick
  
  @export var joystick_right : VirtualJoystick
  
  var move_vector := Vector2.ZERO
  
  func _process(delta: float) -> void:
  	## Movement using the joystick output:
  #	if joystick_left and joystick_left.is_pressed:
  #		position += joystick_left.output * speed * delta
  
  	## Movement using Input functions:
  	move_vector = Vector2.ZERO
  	move_vector = Input.get_vector("ui_left","ui_right","ui_up","ui_down")
  	position += move_vector * speed * delta
  
  	# Rotation:
  	if joystick_right and joystick_right.is_pressed:
  		rotation = joystick_right.output.angle()
  ```
  
  
  ## OPTIONS:
  
  - Joystick mode:
  	- Fixed: The joystick doesn't move.
  	- Dynamic: Every time the joystick area is pressed, the joystick position is set on the touched position.
  	- Following: When the finger moves outside the joystick area, the joystick will follow it.
  
  - Dead zone size: If the tip is inside this range the output is zero.
  
  - Clamp zone size: The max distance the tip can reach.
  
  - Visibility mode:
  	- always: Always visible.
  	- touchscreen only: Visible on touch screens only (will hide if the device has not a touchscreen).
  	- when_touched: Visible only when touched.
  
  - Use input actions: if true the joystick will trigger the input actions created in Project -> Project Settings -> Input Map
  
  ## HELP:
  - The Control parent of the joystick is the area in which the joystick can move in Dynamic mode.
  - For moving the joystick inside his area, select it, right click, turn on "Editable Children" and then change the position of the Base node.
  - With "Editable Children" turned on you can also edit the joystick textures and colors.
  - Create a CanvasLayer node and name it "UI", it'll contain all the UI elements, then add the Joystick scene as a child of the UI node and move it where you prefer.
  - An example scene is provided in the "Test" folder.
  
  ## FAQ
  ### Multitouch doesn't work / can't use two joystick at the same time:
  In Godot, the input events from the mouse don't support multitouch, so make sure to have this configuration:
  Project -> Project Settings -> General -> Input Devices
  "emulate touch from mouse" ON
  "emulate mouse from touch" OFF
  
  ### The joystick doesn't work when using Input.get_vector():
  ⚠ **This has been fixed in Godot Engine!**
  Unfortunately, this a bug in the Godot engine, so the only solution for now is using Input.get_axis:
  This doesn't work:
  ```gdscript
  input_vector := Input.get_vector("ui_left","ui_right","ui_up","ui_down")
  ```
  This works:
  ```gdscript
  input_vector := Vector2.ZERO
  input_vector.x = Input.get_axis("ui_left", "ui_right")
  input_vector.y = Input.get_axis("ui_up", "ui_down")
  ```

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\addons\virtual_joystick\test\player.gd:
========================================
  extends Sprite2D
  
  @export var speed : float = 100
  
  @export var joystick_left : VirtualJoystick
  
  @export var joystick_right : VirtualJoystick
  
  var move_vector := Vector2.ZERO
  
  func _process(delta: float) -> void:
  	## Movement using the joystick output:
  #	if joystick_left and joystick_left.is_pressed:
  #		position += joystick_left.output * speed * delta
  
  	## Movement using Input functions:
  	move_vector = Vector2.ZERO
  	move_vector = Input.get_vector("ui_left","ui_right","ui_up","ui_down")
  	position += move_vector * speed * delta
  
  	# Rotation:
  	if joystick_right and joystick_right.is_pressed:
  		rotation = joystick_right.output.angle()

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\addons\virtual_joystick\virtual_joystick.gd:
========================================
  class_name VirtualJoystick
  
  extends Control
  
  ## A simple virtual joystick for touchscreens, with useful options.
  ## Github: https://github.com/MarcoFazioRandom/Virtual-Joystick-Godot
  
  # EXPORTED VARIABLE
  
  ## The color of the button when the joystick is pressed.
  @export var pressed_color := Color.GRAY
  
  ## If the input is inside this range, the output is zero.
  @export_range(0, 200, 1) var deadzone_size : float = 10
  
  ## The max distance the tip can reach.
  @export_range(0, 500, 1) var clampzone_size : float = 75
  
  enum Joystick_mode {
  	FIXED, ## The joystick doesn't move.
  	DYNAMIC, ## Every time the joystick area is pressed, the joystick position is set on the touched position.
  	FOLLOWING ## When the finger moves outside the joystick area, the joystick will follow it.
  }
  
  ## If the joystick stays in the same position or appears on the touched position when touch is started
  @export var joystick_mode := Joystick_mode.FIXED
  
  enum Visibility_mode {
  	ALWAYS, ## Always visible
  	TOUCHSCREEN_ONLY, ## Visible on touch screens only
  	WHEN_TOUCHED ## Visible only when touched
  }
  
  ## If the joystick is always visible, or is shown only if there is a touchscreen
  @export var visibility_mode := Visibility_mode.ALWAYS
  
  ## If true, the joystick uses Input Actions (Project -> Project Settings -> Input Map)
  @export var use_input_actions := true
  
  @export var action_left := "ui_left"
  @export var action_right := "ui_right"
  @export var action_up := "ui_up"
  @export var action_down := "ui_down"
  
  # PUBLIC VARIABLES
  
  ## If the joystick is receiving inputs.
  var is_pressed := false
  
  # The joystick output.
  var output := Vector2.ZERO
  
  # PRIVATE VARIABLES
  
  var _touch_index : int = -1
  
  @onready var _base := $Base
  @onready var _tip := $Base/Tip
  
  @onready var _base_default_position : Vector2 = _base.position
  @onready var _tip_default_position : Vector2 = _tip.position
  
  @onready var _default_color : Color = _tip.modulate
  
  # FUNCTIONS
  
  func _ready() -> void:
  	if ProjectSettings.get_setting("input_devices/pointing/emulate_mouse_from_touch"):
  		printerr("The Project Setting 'emulate_mouse_from_touch' should be set to False")
  	if not ProjectSettings.get_setting("input_devices/pointing/emulate_touch_from_mouse"):
  		printerr("The Project Setting 'emulate_touch_from_mouse' should be set to True")
  
  	if not DisplayServer.is_touchscreen_available() and visibility_mode == Visibility_mode.TOUCHSCREEN_ONLY :
  		hide()
  
  	if visibility_mode == Visibility_mode.WHEN_TOUCHED:
  		hide()
  
  func _input(event: InputEvent) -> void:
  	if event is InputEventScreenTouch:
  		if event.pressed:
  			if _is_point_inside_joystick_area(event.position) and _touch_index == -1:
  				if joystick_mode == Joystick_mode.DYNAMIC or joystick_mode == Joystick_mode.FOLLOWING or (joystick_mode == Joystick_mode.FIXED and _is_point_inside_base(event.position)):
  					if joystick_mode == Joystick_mode.DYNAMIC or joystick_mode == Joystick_mode.FOLLOWING:
  						_move_base(event.position)
  					if visibility_mode == Visibility_mode.WHEN_TOUCHED:
  						show()
  					_touch_index = event.index
  					_tip.modulate = pressed_color
  					_update_joystick(event.position)
  					get_viewport().set_input_as_handled()
  		elif event.index == _touch_index:
  			_reset()
  			if visibility_mode == Visibility_mode.WHEN_TOUCHED:
  				hide()
  			get_viewport().set_input_as_handled()
  	elif event is InputEventScreenDrag:
  		if event.index == _touch_index:
  			_update_joystick(event.position)
  			get_viewport().set_input_as_handled()
  
  func _move_base(new_position: Vector2) -> void:
  	_base.global_position = new_position - _base.pivot_offset * get_global_transform_with_canvas().get_scale()
  
  func _move_tip(new_position: Vector2) -> void:
  	_tip.global_position = new_position - _tip.pivot_offset * _base.get_global_transform_with_canvas().get_scale()
  
  func _is_point_inside_joystick_area(point: Vector2) -> bool:
  	var x: bool = point.x >= global_position.x and point.x <= global_position.x + (size.x * get_global_transform_with_canvas().get_scale().x)
  	var y: bool = point.y >= global_position.y and point.y <= global_position.y + (size.y * get_global_transform_with_canvas().get_scale().y)
  	return x and y
  
  func _get_base_radius() -> Vector2:
  	return _base.size * _base.get_global_transform_with_canvas().get_scale() / 2
  
  func _is_point_inside_base(point: Vector2) -> bool:
  	var _base_radius = _get_base_radius()
  	var center : Vector2 = _base.global_position + _base_radius
  	var vector : Vector2 = point - center
  	if vector.length_squared() <= _base_radius.x * _base_radius.x:
  		return true
  	else:
  		return false
  
  func _update_joystick(touch_position: Vector2) -> void:
  	var _base_radius = _get_base_radius()
  	var center : Vector2 = _base.global_position + _base_radius
  	var vector : Vector2 = touch_position - center
  	vector = vector.limit_length(clampzone_size)
  
  	if joystick_mode == Joystick_mode.FOLLOWING and touch_position.distance_to(center) > clampzone_size:
  		_move_base(touch_position - vector)
  
  	_move_tip(center + vector)
  
  	if vector.length_squared() > deadzone_size * deadzone_size:
  		is_pressed = true
  		output = (vector - (vector.normalized() * deadzone_size)) / (clampzone_size - deadzone_size)
  	else:
  		is_pressed = false
  		output = Vector2.ZERO
  
  	if use_input_actions:
  		if output.x > 0:
  			Input.action_release(action_left)
  			Input.action_press(action_right, output.x)
  		else:
  			Input.action_release(action_right)
  			Input.action_press(action_left, -output.x)
  
  		if output.y > 0:
  			Input.action_release(action_up)
  			Input.action_press(action_down, output.y)
  		else:
  			Input.action_release(action_down)
  			Input.action_press(action_up, -output.y)
  
  func _reset():
  	is_pressed = false
  	output = Vector2.ZERO
  	_touch_index = -1
  	_tip.modulate = _default_color
  	_base.position = _base_default_position
  	_tip.position = _tip_default_position
  	if use_input_actions:
  		for action in [action_left, action_right, action_down, action_up]:
  			Input.action_release(action)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\addons\virtual_joystick\virtual_joystick_instantiator.gd:
========================================
  @tool
  extends Control
  
  var scene
  
  func _enter_tree():
  	scene = preload("res://addons/virtual_joystick/virtual_joystick_scene.tscn").instantiate()
  	add_child(scene)
  
  	if ProjectSettings.get_setting("input_devices/pointing/emulate_mouse_from_touch"):
  		printerr("The Project Setting 'emulate_mouse_from_touch' should be set to False")
  	if not ProjectSettings.get_setting("input_devices/pointing/emulate_touch_from_mouse"):
  		printerr("The Project Setting 'emulate_touch_from_mouse' should be set to True")
  
  
  func _exit_tree():
  	scene.free()

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\addons\virtual_joystick\virtual_joystick_plugin.gd:
========================================
  @tool
  extends EditorPlugin
  
  
  func _enter_tree():
  	add_custom_type("Virtual Joystick", "Control", preload("virtual_joystick_instantiator.gd"), preload("virtual_joystick_icon.png"))
  
  
  func _exit_tree():
  	remove_custom_type("Virtual Joystick")

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\fonts\special\copyduck\More Info.txt:
========================================
  First of All,
  
  Thank you for download my product.
  This product 100% free for personal use & commercial use
  
  File include :
  
  1. Copyduck.ttf
  2. Copyduck.otf
  
  More Info :
  khurasantype@gmail.com
  
  For Donation:
  paypal.me/khurasantype
  
  My OnlineShop:
  https://www.creativefabrica.com/ref/53/
  
  My Portofolio:
  https://www.behance.net/khurasan
  
  My web:
  www.khurasanstudio.com
  www.mbkaos.com

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\sprites\characters\greyscale\info.txt:
========================================
  
  How to use modular clothing
  
  Use basic_grey (clothes) as base and add the detail (modular) you want:
  	floral, overalls, sailor, skull, sporty, stripe
  
  "button_grey" works for clown outfit and pumpkin outfit
  
  "shoes_grey" works for all outfits besides "witch_grey"
  
  "gloves_grey" works for clown, pumpkin and spooky
  
  
  Modular hair
  
  Use "braids_tie_grey" on top of braids to adjust color of hair ties
  

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\sprites\characters\info.txt:
========================================
  
  GRID SIZE 32x32
  CELL SIZE MERGED: 256x1568
  
  WALK FR: 100
  Cell Size: 256x128
  
  JUMP FR: 100; 200; 100; 120; 100
  Cell Size: 160x128
  
  PICK UP FR: 150; 150; 100; 100; 150
  Cell Size: 160x128
  
  CARRY FR:100
  Cell Size: 256x128
  (char moved  up 1px)
  
  SWORD FR: 100; 200; 80; 100
  Cell Size: 128x128
  
  BLOCK Cell Size: 32x128
  
  HURT Cell Size: 32x128
  
  DIE FR: 500
  Cell Size: 64x32
  
  PICKAXE/ AXE FR: 100; 100; 250; 60; 100
  Cell Size: 160x128
  
  WATER FR: 300; 600
  Cell Size: 64x128
  (char moved up 5 px)
  
  HOE FR: 200; 150; 200; 200; 200
  Cell Size: 160x128
  (down: char moved up 8 px; left/right char moved up 1 px)
  
  FISHING L/R FR: 100; 100; 250; 60; 100
  FISHING U/D FR: 100; 250; 60; 100; 100
  Cell Size: 160x128
  (char moved up 4 px)
  
  LAYERS
  1. Characters
  2. Eyes ->Blush/Lipstick
  3. Clothes: Shirt -> Pants -> Shoes
  4. Hair
  5. Accessories Beard -> Glasses -> Hat
  
  
  
  
  
  
  
  
  
  

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\sprites\characters\list.txt:
========================================
  
  HAIR
  1. Black
  2. Blonde
  3. Brown
  4. Brown Light
  5. Copper
  6. Emerald
  7. Green
  8. Grey
  9. Lilac
  10. Navy
  11. Pink
  12. Purple
  13. Red
  14. Turquoise
  
  Clothes:
  1. Black
  2. Blue
  3. Blue Light
  4. Brown
  5. Green
  6. Green Light
  7. Pink
  8. Purple
  9. Red
  10. White/Grey
  
  Eyes:
  1. Black
  2. Blue
  3. Blue Light
  4. Brown
  5. Brown Dark
  6. Brown Light
  7. Green
  8. Green Dark
  9. Green Light
  10. Grey
  11. Grey Light
  12. Pink
  13. Pink Light
  14. Red
  
  Lipstick and Blush are sorted from light to dark.
  
  

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\sprites\environment\craftpix-896753-village-pixel-art-environment-assets-pack\License.txt:
========================================
  https://craftpix.net/file-licenses/

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\sprites\environment\craftpix-896753-village-pixel-art-environment-assets-pack\readme.txt:
========================================
  Font that was used for the background of the preview:
  https://www.dafont.com/pixellari.font

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\sprites\environment\craftpix-net-352322-nature-pixel-art-environment-free-assets-pack\License.txt:
========================================
  https://craftpix.net/file-licenses/

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\sprites\environment\craftpix-net-352322-nature-pixel-art-environment-free-assets-pack\readme.txt:
========================================
  Font that was used for the background of the preview:
  https://www.dafont.com/pixellari.font

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\sprites\environment\craftpix-net-481981-free-summer-pixel-art-backgrounds\License.txt:
========================================
  https://craftpix.net/file-licenses/

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\sprites\environment\craftpix-net-481981-free-summer-pixel-art-backgrounds\readme.txt:
========================================
  Font that was used for the background of the preview:
  https://www.dafont.com/digital-disco.font

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\sprites\environment\craftpix-net-965049-free-industrial-zone-tileset-pixel-art\Font.txt:
========================================
  Future Millennium
  https://www.dafont.com/futuremillennium.font

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\sprites\environment\craftpix-net-965049-free-industrial-zone-tileset-pixel-art\license.txt:
========================================
  https://craftpix.net/file-licenses/

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\sprites\environment\peasant's_house\Peasant's_House\README.txt:
========================================
  THIS MATERIAL IS COMPLETELY FREE, AND YOU CAN FIND IT ON MY PAGE "https://ericksazevedo.itch.io/". IF YOU PAID FOR THIS MATERIAL, DEMAND A REFUND!
  
  I'm glad you chose my art for your project, I hope it proves to be very useful to you.
  
  INTRODUTION
  
  My name is Ericks Azevedo. I created this artwork for study purposes and in the hope that it will be useful for other people's projects. If you're interested in more art, take a look at my page "https://ericksazevedo.itch.io/". I'll be regularly posting new art there whenever possible
  
  LICENSES
  
  * You can use the artwork in both free and commercial projects, as long as you give me credit. For that purpose, use my Instagram profile "@ericks.azevedo".
  * You can edit the images as you prefer; for this purpose, I'm providing the files in .aseprite format.
  * Selling these assets is not allowed, even if modifications have been made.
  
  INSTRUCTIONS
  
  * In each folder, you will find two ways to import your files: one using image sequences and the other with individual frames. Both methods have their own .aseprite file, in case you want to make modifications.
  * Pay attention to the "House_in_the_middle" folder. Inside it, you will find the images split in half, both for the door animation and the window animation. Both of them have the same sprite size, so you just need to overlay one onto the other. I organized it this way because the window and the door have different animation timings, and one is a loop while the other is not.
  
  If you want to support my work, please follow my page on itch.io ;)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\sprites\environment\sunny-land-files\Sunny-land-files\public-license.txt:
========================================
  Artwork created by Luis Zuno @ansimuz
  
  License for Everyone.
  
  Public domain and free to use on whatever you want, personal or commercial. Credit is not required but appreciated.
  
  Get more Free Assetslike these at: ansimuz.itch.io
  or at my patreon page: patreon.com/ansimuz
  
  

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\assets\sprites\unsorted\License.txt:
========================================
  https://craftpix.net/file-licenses/

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\project.godot:
========================================
  ; Engine configuration file.
  ; It's best edited using the editor UI and not directly,
  ; since the parameters that go here are not all obvious.
  ;
  ; Format:
  ;   [section] ; section goes between []
  ;   param=value ; assign values to parameters
  
  config_version=5
  
  [application]
  
  config/name="The Little Saint"
  run/main_scene="uid://dh7t0n4nj8w4o"
  config/features=PackedStringArray("4.4", "Mobile")
  
  [autoload]
  
  AudioManager="*res://scripts/autoload/audio_manager.gd"
  Global="*res://scripts/autoload/game_manager.gd"
  PopupManager="*res://scripts/ui/dialogs/popup_manager.gd"
  
  [display]
  
  window/size/viewport_width=1280
  window/size/viewport_height=720
  window/stretch/mode="canvas_items"
  window/stretch/aspect="expand"
  
  [input]
  
  right={
  "deadzone": 0.5,
  "events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":68,"key_label":0,"unicode":100,"location":0,"echo":false,"script":null)
  , Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194321,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
  ]
  }
  left={
  "deadzone": 0.5,
  "events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":65,"key_label":0,"unicode":97,"location":0,"echo":false,"script":null)
  , Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194319,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
  ]
  }
  up={
  "deadzone": 0.5,
  "events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":87,"key_label":0,"unicode":119,"location":0,"echo":false,"script":null)
  , Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194320,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
  ]
  }
  down={
  "deadzone": 0.5,
  "events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":83,"key_label":0,"unicode":115,"location":0,"echo":false,"script":null)
  , Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194322,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
  ]
  }
  attack={
  "deadzone": 0.5,
  "events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":85,"physical_keycode":0,"key_label":0,"unicode":117,"location":0,"echo":false,"script":null)
  ]
  }
  defend={
  "deadzone": 0.5,
  "events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":73,"physical_keycode":0,"key_label":0,"unicode":105,"location":0,"echo":false,"script":null)
  ]
  }
  Menu={
  "deadzone": 0.5,
  "events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194305,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
  ]
  }
  
  [input_devices]
  
  pointing/emulate_touch_from_mouse=true
  pointing/emulate_mouse_from_touch=false
  
  [layer_names]
  
  2d_physics/layer_1="player"
  2d_physics/layer_2="ports"
  2d_physics/layer_3="item"
  2d_physics/layer_4="enemy"
  
  [physics]
  
  2d/physics_engine="GodotPhysics2D"
  
  [rendering]
  
  textures/canvas_textures/default_texture_filter=0
  renderer/rendering_method="mobile"
  environment/defaults/default_clear_color=Color(0, 0, 0, 1)

[Skipped c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scenes\core\character\character_sprites.tscn: File too large (26535 KB)]

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scenes\core\character\debug.gd:
========================================
  # Add this as a new script called state_machine_diagnostic.gd in your project
  # Then attach it to your Player node as a child to diagnose issues
  
  extends Node
  
  var check_timer: Timer
  
  func _ready():
  	print("\n=== STATE MACHINE DIAGNOSTIC STARTED ===")
  
  	# Create timer to periodically check state
  	check_timer = Timer.new()
  	check_timer.wait_time = 1.0
  	check_timer.one_shot = false
  	check_timer.timeout.connect(_check_state_machine)
  	add_child(check_timer)
  	check_timer.start()
  
  	# Do initial check
  	_check_state_machine()
  
  	# Check input map configuration
  	_check_input_map()
  
  func _check_state_machine():
  	var player = get_parent()
  
  	# Check if player is valid
  	if !is_instance_valid(player):
  		print("ERROR: Parent node is not valid")
  		return
  
  	print("\n--- State Machine Diagnostic ---")
  	print("Player node: ", player.name)
  
  	# Check for state machine
  	var state_machine = player.get_node_or_null("StateMachine")
  	if state_machine == null:
  		print("ERROR: StateMachine node not found under player")
  		return
  
  	# Check current state
  	print("Current state: ", state_machine.get_current_state())
  
  	# Check registered states
  	var states_found = 0
  	for child in state_machine.get_children():
  		if child is State:
  			states_found += 1
  			print("- Found state: ", child.name, " (", child.get_class(), ")")
  
  	if states_found == 0:
  		print("ERROR: No state nodes found under StateMachine!")
  	else:
  		print("Total states found: ", states_found)
  
  	# Check player motion
  	print("Player velocity: ", player.velocity)
  	print("Player position: ", player.global_position)
  	print("Is on floor: ", player.is_on_floor())
  
  	# Check input state
  	print("Left input: ", Input.is_action_pressed("left"))
  	print("Right input: ", Input.is_action_pressed("right"))
  	print("Up input: ", Input.is_action_pressed("up"))
  	print("Down input: ", Input.is_action_pressed("down"))
  	print("Jump counter: ", player.jump_counter)
  	print("Player mode: ", player.mode)
  
  func _check_input_map():
  	print("\n--- Input Map Configuration ---")
  	var required_actions = ["left", "right", "up", "down", "attack", "defend", "Menu"]
  
  	for action in required_actions:
  		if InputMap.has_action(action):
  			var events = InputMap.action_get_events(action)
  			print("Action '", action, "' registered with ", events.size(), " events")
  		else:
  			print("ERROR: Action '", action, "' NOT FOUND in InputMap!")
  
  func _input(event):
  	# Log key presses for debugging
  	if event is InputEventKey and event.pressed:
  		var action_name = "None"
  
  		if Input.is_action_just_pressed("left"):
  			action_name = "left"
  		elif Input.is_action_just_pressed("right"):
  			action_name = "right"
  		elif Input.is_action_just_pressed("up"):
  			action_name = "up"
  		elif Input.is_action_just_pressed("down"):
  			action_name = "down"
  		elif Input.is_action_just_pressed("attack"):
  			action_name = "attack"
  		elif Input.is_action_just_pressed("defend"):
  			action_name = "defend"
  
  		if action_name != "None":
  			print("INPUT DETECTED: ", action_name, " (Key: ", OS.get_keycode_string(event.keycode), ")")

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scenes\core\character\hurt.gd:
========================================
  extends Node

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scenes\levels\prince_levels\Tiles\fourSeasonsPlatformer\- READ ME -.txt:
========================================
  
                                                                - READ ME -
  
  Thank you for using the fourSeasonsPlatformer_ [tileset]...part of the fourSeasonPlatformer_ series' of assets on itch.io!
  
  Stuff to know - Tilesets
  
  - Each tile is 16x16 pixels...although some objects/structures/terrain are 16x32/32x16/32x32...[e.g. trees, beehives, big terrain tile]
  - The blackout_ tileset is designed to black out the spaces between tiles [optional]
  
  Stuff to know - Animations
  
  - coin_ animation is 12 frames
  - each eventBlock_ animation is 14 frames [6 animations total]
  - each foreground animation is 8 frames
  
  If you have any questions or requests you can contact me at analogstudios.inc@gmail.com
  
  
  
  
  
  

[Skipped c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scenes\levels\prince_levels\game_prince.tscn: File too large (148 KB)]

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\autoload\audio_manager.gd:
========================================
  extends Node
  
  @export var autoplay: bool = false
  @export var default_stream: AudioStream = null
  
  var audio_player: AudioStreamPlayer
  var current_track: AudioStream = null
  
  func _ready():
  	# Initialize the AudioStreamPlayer
  	audio_player = AudioStreamPlayer.new()
  	audio_player.name = "AudioStreamPlayer"
  	add_child(audio_player)
  
  	# Connect the finished signal to handle when music ends
  	audio_player.finished.connect(_on_audio_finished)
  
  	# Autoplay if enabled
  	if autoplay and default_stream:
  		play_track(default_stream)
  
  func play_track(audio_stream: AudioStream):
  	if audio_stream != current_track:
  		audio_player.stop()
  		audio_player.stream = audio_stream
  		audio_player.play()
  		current_track = audio_stream
  	elif not audio_player.playing:
  		audio_player.play()
  
  func stop_track():
  	audio_player.stop()
  
  func is_playing() -> bool:
  	return audio_player.playing
  
  func _on_audio_finished():
  	current_track = null  # Reset track when finished

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\autoload\game_manager.gd:
========================================
  extends Node

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\base_classes\base_enemy.gd:
========================================
  class_name BaseEnemy
  extends CharacterBody2D
  
  ## Base class for all enemies in the game
  
  # Enemy properties
  @export var max_health: float = 100.0
  @export var speed: float = 80.0
  @export var chase_speed: float = 100.0
  @export var attack_damage: float = 10.0
  @export var attack_cooldown: float = 1.0
  @export var detection_radius: float = 200.0
  @export var attack_radius: float = 75.0
  
  # Current state
  var current_health: float
  var is_dead: bool = false
  var is_chasing: bool = false
  var is_attacking: bool = false
  var can_attack: bool = true
  var target = null
  
  # Nodes (to be assigned by extending classes)
  var animated_sprite: AnimatedSprite2D
  var collision_shape: CollisionShape2D
  var hud = null
  
  # Emitted when enemy dies
  signal enemy_died(enemy)
  # Emitted when enemy takes damage
  signal enemy_damaged(enemy, amount)
  
  func _ready():
  	# Initialize health
  	current_health = max_health
  
  	# Set default animation
  	if animated_sprite:
  		animated_sprite.play("idle")
  
  	# Get HUD reference (if needed)
  	hud = get_node_or_null("../../HUD")
  
  func _physics_process(delta):
  	# Apply gravity
  	if not is_on_floor():
  		velocity.y += calculate_gravity() * delta
  
  	# Core movement
  	move_and_slide()
  
  func calculate_gravity():
  	# Can be overridden by child classes
  	return ProjectSettings.get_setting("physics/2d/default_gravity")
  
  func take_damage(amount):
  	if is_dead:
  		return
  
  	current_health -= amount
  	emit_signal("enemy_damaged", self, amount)
  
  	if current_health <= 0:
  		die()
  	else:
  		play_animation("hurt")
  
  func die():
  	is_dead = true
  	is_chasing = false
  	is_attacking = false
  
  	# Disable collision
  	if collision_shape:
  		collision_shape.set_deferred("disabled", true)
  
  	# Play death animation
  	play_animation("death")
  
  	# Emit signal
  	emit_signal("enemy_died", self)
  
  	# Wait for animation to finish before removing
  	await animated_sprite.animation_finished
  	queue_free()
  
  func play_animation(anim_name: String):
  	if animated_sprite and animated_sprite.sprite_frames.has_animation(anim_name):
  		animated_sprite.play(anim_name)
  
  func chase_target(target_node):
  	if is_dead or is_attacking:
  		return
  
  	target = target_node
  	is_chasing = true
  
  	var direction = (target.global_position - global_position).normalized()
  
  	# Face the correct direction
  	if animated_sprite:
  		animated_sprite.flip_h = direction.x > 0
  
  	# Set velocity
  	velocity.x = direction.x * (chase_speed if is_chasing else speed)
  
  	# Play animation
  	play_animation("walk")
  
  func stop_chase():
  	is_chasing = false
  	velocity.x = 0
  	play_animation("idle")
  	target = null
  
  func attack():
  	if is_dead or not can_attack or not target:
  		return
  
  	is_attacking = true
  	can_attack = false
  	velocity.x = 0
  
  	play_animation("attack")
  
  	# Wait for animation to finish
  	await animated_sprite.animation_finished
  
  	is_attacking = false
  
  	# Start cooldown
  	await get_tree().create_timer(attack_cooldown).timeout
  	can_attack = true
  
  # Called when a player or other entity enters detection radius
  func _on_detection_radius_body_entered(body):
  	if body.name == "Player" and not is_dead:
  		chase_target(body)
  
  # Called when a player or other entity exits detection radius
  func _on_detection_radius_body_exited(body):
  	if body.name == "Player":
  		stop_chase()
  
  # Called when a player enters attack range
  func _on_attack_radius_body_entered(body):
  	if body.name == "Player" and not is_dead:
  		is_chasing = false
  		attack()
  
  # Called when a player exits attack range
  func _on_attack_radius_body_exited(body):
  	if body.name == "Player" and not is_dead:
  		is_chasing = true

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\base_classes\base_power_up.gd:
========================================
  class_name BasePowerUp
  extends Area2D
  
  ## Base class for all power-ups in the game
  
  # Power-up properties
  @export var power_up_name: String = "Power Up"
  @export var description: String = "A mysterious power-up"
  @export var icon_texture: Texture2D
  @export var effect_duration: float = 0.0  # 0 means permanent effect
  @export var play_animation: bool = true
  @export var destroy_on_pickup: bool = true
  
  # Animation
  @export var bounce_height: float = 5.0
  @export var bounce_speed: float = 2.0
  @export var rotation_speed: float = 0.0
  
  # Internal variables
  var original_position: Vector2
  var animation_time: float = 0.0
  var player_ref = null
  
  # Signals
  signal power_up_collected(power_up, player)
  signal power_up_effect_started(power_up, player)
  signal power_up_effect_ended(power_up, player)
  
  func _ready():
  	original_position = global_position
  
  	# Set up collision
  	if not has_node("CollisionShape2D"):
  		push_error("Power-up " + name + " has no CollisionShape2D!")
  
  	# Set up sprite/animation if enabled
  	if play_animation and has_node("Sprite2D"):
  		var sprite = get_node("Sprite2D")
  		if icon_texture:
  			sprite.texture = icon_texture
  
  	# Connect signals
  	body_entered.connect(_on_power_up_body_entered)
  
  func _process(delta):
  	if play_animation:
  		animate_power_up(delta)
  
  func animate_power_up(delta):
  	animation_time += delta
  
  	# Bouncing animation
  	if bounce_height > 0:
  		var bounce_offset = sin(animation_time * bounce_speed) * bounce_height
  		global_position.y = original_position.y + bounce_offset
  
  	# Rotation animation
  	if rotation_speed > 0 and has_node("Sprite2D"):
  		var sprite = get_node("Sprite2D")
  		sprite.rotation += rotation_speed * delta
  
  func _on_power_up_body_entered(body):
  	if body.is_in_group("Player") or body.name == "Player":
  		collect_power_up(body)
  
  func collect_power_up(player):
  	# Store reference to player
  	player_ref = player
  
  	# Disable collision
  	set_collision_mask_value(1, false)
  
  	# Emit collected signal
  	emit_signal("power_up_collected", self, player)
  
  	# Play collection animation if available
  	if has_node("AnimationPlayer"):
  		var anim_player = get_node("AnimationPlayer")
  		if anim_player.has_animation("collect"):
  			anim_player.play("collect")
  			await anim_player.animation_finished
  
  	# Apply effect
  	apply_effect(player)
  
  	# Destroy if set
  	if destroy_on_pickup:
  		queue_free()
  
  func apply_effect(player):
  	# Base implementation just emits signal
  	# Override in child classes to implement specific effects
  	emit_signal("power_up_effect_started", self, player)
  
  	# If temporary effect, setup timer to end effect
  	if effect_duration > 0:
  		await get_tree().create_timer(effect_duration).timeout
  		remove_effect(player)
  
  func remove_effect(player):
  	# Override in child classes to implement specific effect removal
  	emit_signal("power_up_effect_ended", self, player)
  
  # Optional methods for child classes to implement
  func get_effect_description() -> String:
  	return description
  
  func get_icon() -> Texture2D:
  	return icon_texture

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\base_classes\base_projectile.gd:
========================================
  class_name BaseProjectile
  extends CharacterBody2D
  
  ## Base class for all projectiles in the game
  
  # Projectile properties
  @export var speed: float = 100.0
  @export var damage: float = 10.0
  @export var lifetime: float = 5.0  # Time before auto-destruction
  @export var gravity_affected: bool = false
  @export var bounce: bool = false
  @export var bounce_factor: float = 0.5  # How much velocity is retained when bouncing
  
  # Internal variables
  var direction: Vector2 = Vector2.ZERO
  var source_node = null  # Who fired this projectile
  var spawn_position: Vector2
  var spawn_rotation: float
  var time_alive: float = 0.0
  var has_hit: bool = false
  
  # Signals
  signal projectile_hit(projectile, target)
  signal projectile_expired(projectile)
  
  func _ready():
  	# Start lifetime timer
  	if lifetime > 0:
  		get_tree().create_timer(lifetime).timeout.connect(_on_lifetime_expired)
  
  	# Set initial position and rotation
  	global_position = spawn_position
  	global_rotation = spawn_rotation
  
  	# Setup animation if available
  	if has_node("AnimatedSprite2D"):
  		var sprite = get_node("AnimatedSprite2D")
  		if sprite.sprite_frames.has_animation("flying"):
  			sprite.play("flying")
  
  func _physics_process(delta):
  	time_alive += delta
  
  	# Apply gravity if enabled
  	if gravity_affected:
  		velocity.y += ProjectSettings.get_setting("physics/2d/default_gravity") * delta
  
  	# Move the projectile
  	var collision = move_and_collide(velocity * delta)
  
  	# Handle collision
  	if collision and not has_hit:
  		_on_collision(collision)
  
  func setup(dir: Vector2, spawn_pos: Vector2, spawn_rot: float = 0.0, source = null):
  	direction = dir.normalized()
  	spawn_position = spawn_pos
  	spawn_rotation = spawn_rot
  	source_node = source
  
  	# Set initial velocity
  	velocity = direction * speed
  
  	return self  # For method chaining
  
  func _on_collision(collision):
  	var collider = collision.get_collider()
  
  	# Check if we should bounce
  	if bounce and not (collider.is_in_group("Player") or collider.is_in_group("Enemy")):
  		var reflection = collision.get_remainder().bounce(collision.get_normal())
  		velocity = velocity.bounce(collision.get_normal()) * bounce_factor
  		global_position += reflection
  		return
  
  	has_hit = true
  
  	# Handle different collision types
  	if collider.is_in_group("Player") and source_node != collider:
  		_on_hit_player(collider)
  	elif collider.is_in_group("Enemy") and source_node != collider:
  		_on_hit_enemy(collider)
  	else:
  		_on_hit_environment(collider)
  
  func _on_hit_player(player):
  	emit_signal("projectile_hit", self, player)
  
  	# Apply damage
  	if player.has_method("take_damage"):
  		player.take_damage(damage)
  
  	# Get HUD reference
  	var hud = get_node_or_null("../HUD")
  	if hud and hud.has_method("change_life"):
  		hud.change_life(-damage/100.0)  # Assuming HUD uses 0-1 scale
  
  	# Play hit effect if available
  	play_hit_effect()
  
  	queue_free()
  
  func _on_hit_enemy(enemy):
  	emit_signal("projectile_hit", self, enemy)
  
  	# Apply damage
  	if enemy.has_method("take_damage"):
  		enemy.take_damage(damage)
  
  	# Play hit effect if available
  	play_hit_effect()
  
  	queue_free()
  
  func _on_hit_environment(object):
  	emit_signal("projectile_hit", self, object)
  
  	# Play hit effect if available
  	play_hit_effect()
  
  	queue_free()
  
  func _on_lifetime_expired():
  	if not has_hit:
  		emit_signal("projectile_expired", self)
  		queue_free()
  
  func play_hit_effect():
  	# If we have an AnimatedSprite2D, try to play the hit animation
  	if has_node("AnimatedSprite2D"):
  		var sprite = get_node("AnimatedSprite2D")
  		if sprite.sprite_frames.has_animation("hit"):
  			# Disconnect from physics process
  			set_physics_process(false)
  
  			# Stop motion
  			velocity = Vector2.ZERO
  
  			# Play hit animation
  			sprite.play("hit")
  
  			# Wait for animation to finish
  			await sprite.animation_finished

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\characters\character_sprites.gd:
========================================
  class_name CharacterSprites
  extends Node2D
  
  var animation_frames = {
  	"idle": [0, 1, 2, 3, 4, 5, 6, 7],
  	"animation1": [8, 9, 10, 11, 12, 13, 14, 15],
  	"animation2": [16, 17, 18, 19, 20, 21, 22, 23],
  	"walking": [24, 25, 26, 27, 28, 29, 30, 31],
  	"animation4": [32, 33, 34, 35, 36],
  	"animation5": [40, 41, 42, 43, 44],
  	"animation6": [48, 49, 50, 51, 52],
  	"animation7": [56, 57, 58, 59, 60],
  	"animation8": [64, 65, 66, 67, 68],
  	"animation9": [72, 73, 74, 75, 76],
  	"animation10": [80, 81, 82, 83, 84],
  	"animation11": [88, 89, 90, 91, 92],
  	"animation12": [96, 97, 98, 99, 100, 101, 102, 103],
  	"animation13": [104, 105, 106, 107, 108, 109, 110, 111],
  	"animation14": [112, 113, 114, 115, 116, 117, 118, 119],
  	"animation15": [120, 121, 122, 123, 124, 125, 126, 127],
  	"animation16": [128, 129, 130, 131],
  	"animation17": [136, 137, 138, 139],
  	"animation18": [144, 145, 146, 147], #attack knife
  	"animation19": [152, 153, 154, 155],
  	"animation20": [160],
  	"animation21": [168],
  	"animation22": [176],
  	"animation23": [184],
  	"animation24": [192],
  	"animation25": [200],
  	"animation26": [208],
  	"animation27": [216],
  	"dead": [224, 225],
  	"animation29": [232, 233, 234, 235, 236],
  	"walking0": [240, 241, 242, 243, 244],
  	"walking1": [248, 249, 250, 251, 252],
  	"walking2": [256, 257, 258, 259, 260],
  	"walking3": [264, 265, 266, 267, 268],
  	"walking4": [272, 273, 274, 275, 276],
  	"walking5": [280, 281, 282, 283, 284], #attack axe right
  	"walking6": [288, 289, 290, 291, 292], #attack axe left
  	"walking7": [296, 297],
  	"walking8": [304, 305],
  	"walking9": [312, 313],
  	"animation40": [320, 321],
  	"animation41": [328, 329, 330, 331, 332],
  	"animation42": [336, 337, 338, 339, 340],
  	"animation43": [344, 345, 346, 347, 348],
  	"animation44": [352, 353, 354, 355, 356],
  	"animation45": [360, 361, 362, 363, 364],
  	"animation46": [368, 369, 370, 371, 372],
  	"animation47": [376, 377, 378, 379, 380],
  	"animation48": [384, 385, 386, 387, 388],
  	"hurt":        [25*8, 27*8],
  }
  
  var default_outfit = {
  	"beard": 1,
  	"lipstick": 1,
  	"eyes": 1,
  	"shoes": 1,
  	"earrings": 1,
  	"hats": 1,
  	"glasses": 1,
  	"clothes_down": 1,
  	"clothes_up": 1,
  	"clothes_complete": 1,
  	"bodies": 1,
  	"hair": 1
  }

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\characters\player.gd:
========================================
  # Modified player.gd - Remove direct input handling and delegate to state machine
  
  class_name Player
  extends CharacterBody2D
  
  @export var joystick_right: VirtualJoystick
  @export var debug_mode: bool = false
  
  # environment variables
  var SPEED = 200.0
  var JUMP_VELOCITY = -250.0
  var FLY_VELOCITY = -150.0
  var GRAVITY = 300
  
  # character mode variables
  var mode = "normal"
  var passed_fly_time = 0.0
  var jump_counter = 0
  var ready_for_jump = true
  var allowed_jumps = 1
  
  # character health
  var hud
  
  # character design variables
  var player_animations
  var current_animation = "idle"
  var player_outfit
  var play_attack_animation = false
  var attack_animation = "idle"
  
  # Reference to the state machine
  @onready var state_machine = $StateMachine
  
  var config = ConfigFile.new() # Create a new ConfigFile instance
  
  func _ready() -> void:
  	# Initialize your global variables here
  	hud = get_node("../../HUD")
  	player_animations = get_node("character_sprites").animation_frames
  
  	var default_player_outfit = get_node("character_sprites").default_outfit
  	get_node("character_sprites/masks").visible = false
  	player_outfit = default_player_outfit
  
  	# Load the ConfigFile if it exists
  	var err = config.load("user://settings.cfg")
  	if err == OK: # If the ConfigFile loaded successfully
  		# Get the values from the ConfigFile
  		SPEED = config.get_value("settings", "SPEED", 200.0)
  		JUMP_VELOCITY = config.get_value("settings", "JUMP_VELOCITY", -250.0)
  		FLY_VELOCITY = config.get_value("settings", "FLY_VELOCITY", -150.0)
  		GRAVITY = config.get_value("settings", "GRAVITY", 300)
  		passed_fly_time = config.get_value("settings", "passed_fly_time", 0.0)
  		jump_counter = config.get_value("settings", "jump_counter", 0)
  		ready_for_jump = config.get_value("settings", "ready_for_jump", true)
  		player_outfit = config.get_value("settings", "outfit", default_player_outfit)
  
  	if debug_mode:
  		print("Player ready, State Machine initialized")
  
  func save_settings():
  	# Set the values in the ConfigFile
  	config.set_value("settings", "SPEED", SPEED)
  	config.set_value("settings", "JUMP_VELOCITY", JUMP_VELOCITY)
  	config.set_value("settings", "FLY_VELOCITY", FLY_VELOCITY)
  	config.set_value("settings", "GRAVITY", GRAVITY)
  	config.set_value("settings", "mode", mode)
  	config.set_value("settings", "passed_fly_time", passed_fly_time)
  	config.set_value("settings", "jump_counter", jump_counter)
  	config.set_value("settings", "ready_for_jump", ready_for_jump)
  	config.set_value("settings", "allowed_jumps", allowed_jumps)
  	config.set_value("settings", "outfit", player_outfit)
  
  	# Save the ConfigFile to the disk
  	config.save("user://settings.cfg")
  
  # Helper method to play animations
  func play_animation(anim_name: String):
  	current_animation = anim_name
  
  # Return gravity as a Vector2 to avoid conflicts with PhysicsBody2D
  func calculate_gravity() -> Vector2:
  	return Vector2(0, GRAVITY)
  
  # Keep portal handlers and other methods
  func _on_test_portal_entered(_body):
  	get_tree().change_scene_to_file("res://scenes/ui/main_menu/main_menu.tscn")
  	mode = "fly"
  	save_settings()
  
  func _on_elias_portal_entered(_body):
  	print("Elias")
  	save_settings()
  
  func _on_ardit_portal_entered(_body):
  	get_tree().change_scene_to_file("res://Arrogance.tscn")
  	save_settings()
  
  func _on_sebastian_portal_entered(_body):
  	mode = "normal"
  	get_tree().change_scene_to_file("res://scenes/levels/sebastian_levels/level_1.tscn")
  	save_settings()
  
  func _on_prince_portal_entered(_body):
  	get_tree().change_scene_to_file("res://scenes/levels/prince_levels/platform.tscn")
  	save_settings()
  
  func _on_fallzone_body_entered(_body):
  	get_tree().change_scene_to_file("res://scenes/levels/ardit_levels/arrogance.tscn")
  
  func _on_life_up_body_entered(_body):
  	get_parent().get_node("HUD").change_life(0.25)
  
  func _on_life_down_body_entered(_body):
  	get_parent().get_node("HUD").change_life(-0.25)
  
  func death():
  	$CollisionShape2D.disabled = true
  	current_animation = "death"
  	self.queue_free()
  	get_tree().change_scene_to_file("res://scenes/ui/main_menu/main_menu.tscn")
  
  func _on_test_portal_body_entered(_body):
  	get_tree().change_scene_to_file("res://scenes/levels/adventure_mode/adventure_level.tscn")

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\characters\player_camera.gd:
========================================
  class_name PlayerCamera
  extends Camera2D
  
  
  # Called when the node enters the scene tree for the first time.
  func _ready():
  	pass # Replace with function body.
  
  
  # Called every frame. 'delta' is the elapsed time since the previous frame.
  func _process(delta):
  	pass

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\enemies\ardit_enemy.gd:
========================================
  class_name ArditEnemy
  extends BaseEnemy
  
  ## Simple patrol enemy that walks back and forth
  
  @export var patrol_distance: float = 100.0
  @export var direction: int = 1  # 1 = right, -1 = left
  
  @onready var ray_cast_right: RayCast2D = $RayCastRight
  @onready var ray_cast_left: RayCast2D = $RayCastLeft
  
  var start_position: Vector2
  var is_patrolling: bool = true
  
  func _ready():
  	# Set base enemy properties
  	max_health = 50.0
  	speed = 60.0
  	chase_speed = 80.0
  	attack_damage = 15.0
  	attack_cooldown = 1.0
  
  	# Set references
  	animated_sprite = $AnimatedSprite2D
  	collision_shape = $CollisionShape2D
  
  	# Store starting position for patrol
  	start_position = global_position
  
  	# Initialize raycasts if not already set
  	if not ray_cast_right:
  		ray_cast_right = $RayCastRight if has_node("RayCastRight") else null
  
  	if not ray_cast_left:
  		ray_cast_left = $RayCastLeft if has_node("RayCastLeft") else null
  
  	# Call parent ready method
  	super._ready()
  
  	# Start patrol behavior
  	play_animation("walk")
  
  func _physics_process(delta):
  	# Call parent implementation for gravity and movement
  	super._physics_process(delta)
  
  	# Handle patrol logic if not chasing or attacking
  	if is_patrolling and not is_chasing and not is_attacking and not is_dead:
  		patrol()
  
  func patrol():
  	# Check wall collisions
  	if ray_cast_right and ray_cast_right.is_colliding():
  		direction = -1
  		animated_sprite.flip_h = false
  	elif ray_cast_left and ray_cast_left.is_colliding():
  		direction = 1
  		animated_sprite.flip_h = true
  
  	# Check patrol distance limits
  	if abs(global_position.x - start_position.x) > patrol_distance:
  		direction *= -1
  		animated_sprite.flip_h = direction > 0
  
  	# Set movement velocity
  	velocity.x = direction * speed
  
  	# Play walk animation
  	play_animation("walk")
  
  func chase_target(target_node):
  	# Stop patrolling when chasing
  	is_patrolling = false
  
  	# Call parent implementation
  	super.chase_target(target_node)
  
  func stop_chase():
  	# Resume patrolling when chase ends
  	is_patrolling = true
  
  	# Call parent implementation
  	super.stop_chase()
  
  # Overridden to properly handle player jumping on enemy
  func _on_top_checker_body_entered(body):
  	if body.name == "Player" and not is_dead:
  		# Player jumped on top, take damage
  		take_damage(current_health)  # Instant kill when jumped on
  
  		# Give player an upward boost if it has the method
  		if body.has_method("bounce"):
  			body.bounce()

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\enemies\goblin_archer.gd:
========================================
  class_name GoblinArcher
  extends BaseEnemy
  
  ## Goblin Archer - Ranged enemy that attacks with arrows/rocks
  
  @export var projectile_scene: PackedScene
  @export var quiver_size: int = 5  # How many arrows before needing to reload
  @export var reload_time: float = 1.5
  @export var attack_delay: float = 0.5  # Time before arrow is fired after attack animation starts
  
  var arrows_remaining: int
  var is_reloading: bool = false
  
  func _ready():
  	# Set base enemy properties
  	max_health = 70.0
  	speed = 60.0
  	chase_speed = 80.0
  	attack_damage = 8.0
  	attack_cooldown = 0.7
  
  	# Initialize archer specific properties
  	arrows_remaining = quiver_size
  
  	# Set references
  	animated_sprite = $AnimatedSprite2D
  	collision_shape = $CollisionShape2D
  
  	# Call parent ready method
  	super._ready()
  
  func attack():
  	if is_dead or not can_attack or not target or is_reloading:
  		return
  
  	# Check if we need to reload
  	if arrows_remaining <= 0:
  		reload()
  		return
  
  	is_attacking = true
  	can_attack = false
  	velocity.x = 0
  
  	play_animation("attack")
  
  	# Wait for the right animation frame to spawn projectile
  	await get_tree().create_timer(attack_delay).timeout
  
  	# Spawn projectile if we still have a target
  	if target and not is_dead:
  		spawn_projectile()
  		arrows_remaining -= 1
  
  	# Wait for animation to finish
  	await animated_sprite.animation_finished
  
  	is_attacking = false
  
  	# Start cooldown
  	await get_tree().create_timer(attack_cooldown).timeout
  	can_attack = true
  
  func reload():
  	is_reloading = true
  
  	# Play reload animation if available, otherwise just idle
  	if animated_sprite.sprite_frames.has_animation("reload"):
  		play_animation("reload")
  	else:
  		play_animation("idle")
  
  	# Wait for reload time
  	await get_tree().create_timer(reload_time).timeout
  
  	# Refill quiver
  	arrows_remaining = quiver_size
  	is_reloading = false
  
  func spawn_projectile():
  	# Make sure we have a projectile scene
  	if not projectile_scene:
  		projectile_scene = load("res://scenes/core/projectiles/rock.tscn")
  
  	# Create projectile instance
  	var instance = projectile_scene.instantiate()
  
  	# Get direction to target
  	var direction = (target.global_position - global_position).normalized()
  
  	# Setup the projectile
  	if instance is BaseProjectile:
  		instance.setup(
  			direction,
  			global_position,
  			global_rotation,
  			self
  		)
  	else:
  		# Legacy fallback for existing implementation
  		instance.direction = direction
  		instance.spawn_position = global_position
  		instance.spawn_rotation = global_rotation
  
  	# Add projectile to the main scene
  	var main = get_node("../../")
  	main.add_child(instance)
  
  # Connection to detection radius (override parent implementation)
  func _on_detection_radius_3_body_entered(body):
  	if body.name == "Player" and not is_dead:
  		chase_target(body)
  
  func _on_detection_radius_3_body_exited(body):
  	if body.name == "Player":
  		stop_chase()
  
  # Connection to attack zone (override parent implementation)
  func _on_attack_radius_3_body_entered(body):
  	if body.name == "Player":
  		is_chasing = false
  		attack()
  
  		# Setup continuous attack if in range
  		var attack_timer = func():
  			while is_attacking == false and can_attack and not is_dead and body and is_instance_valid(body):
  				attack()
  				await get_tree().create_timer(0.1).timeout
  
  		attack_timer.call()
  
  func _on_attack_radius_3_body_exited(body):
  	if body.name == "Player":
  		is_chasing = true
  		chase_target(body)
  
  # Connection to death zone (override parent implementation)
  func _on_death_radius_3_body_entered(body):
  	if body.name == "Player":
  		take_damage(current_health)  # Instant death

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\enemies\goblin_mage.gd:
========================================
  class_name GoblinMage
  extends BaseEnemy
  
  ## Goblin Mage - Ranged magical enemy that attacks with spell projectiles
  
  @export var projectile_scene: PackedScene
  @export var mana: float = 100.0
  @export var mana_regen_rate: float = 5.0
  @export var spell_mana_cost: float = 20.0
  @export var attack_delay: float = 1.0
  
  var current_mana: float
  var can_cast: bool = true
  
  func _ready():
  	# Set base enemy properties
  	max_health = 60.0
  	speed = 40.0
  	chase_speed = 50.0
  	attack_damage = 15.0
  	attack_cooldown = 3.0
  
  	# Initialize goblin mage specific properties
  	current_mana = mana
  
  	# Set references
  	animated_sprite = $AnimatedSprite2D
  	collision_shape = $CollisionShape2D
  
  	# Call parent ready method
  	super._ready()
  
  func _process(delta):
  	# Regenerate mana
  	if current_mana < mana:
  		current_mana = min(current_mana + mana_regen_rate * delta, mana)
  
  func attack():
  	if is_dead or not can_attack or not target or current_mana < spell_mana_cost:
  		return
  
  	is_attacking = true
  	can_attack = false
  	velocity.x = 0
  
  	play_animation("attack")
  
  	# Wait for the right animation frame to spawn projectile
  	await get_tree().create_timer(attack_delay).timeout
  
  	# Spawn projectile if we still have a target
  	if target and not is_dead:
  		spawn_projectile()
  
  	# Wait for animation to finish
  	await animated_sprite.animation_finished
  
  	is_attacking = false
  
  	# Start cooldown
  	await get_tree().create_timer(attack_cooldown).timeout
  	can_attack = true
  
  func spawn_projectile():
  	# Make sure we have a projectile scene
  	if not projectile_scene:
  		projectile_scene = load("res://scenes/core/projectiles/mage_ball.tscn")
  
  	# Create projectile instance
  	var instance = projectile_scene.instantiate()
  
  	# Get direction to target
  	var direction = (target.global_position - global_position).normalized()
  
  	# Setup the projectile
  	if instance is BaseProjectile:
  		instance.setup(
  			direction,
  			global_position,
  			global_rotation,
  			self
  		)
  	else:
  		# Legacy fallback for existing implementation
  		instance.direction = direction
  		instance.spawn_position = global_position
  		instance.spawn_rotation = global_rotation
  
  	# Add projectile to the main scene
  	var main = get_node("../../")
  	main.add_child(instance)
  
  	# Consume mana
  	current_mana -= spell_mana_cost
  
  # Connection to detection radius (override parent implementation)
  func _on_detection_radius_2_body_entered(body):
  	if body.name == "Player" and not is_dead:
  		chase_target(body)
  
  func _on_detection_radius_2_body_exited(body):
  	if body.name == "Player":
  		stop_chase()
  
  # Connection to attack zone (override parent implementation)
  func _on_attackzone_2_body_entered(body):
  	if body.name == "Player":
  		is_chasing = false
  		attack()
  
  func _on_attackzone_2_body_exited(body):
  	if body.name == "Player":
  		is_chasing = true
  		chase_target(body)
  
  # Connection to death zone (override parent implementation)
  func _on_death_zone_2_body_entered(body):
  	if body.name == "Player":
  		take_damage(current_health)  # Instant death

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\enemies\goblin_melee.gd:
========================================
  class_name GoblinMelee
  extends BaseEnemy
  
  ## Goblin Melee - Close combat enemy that attacks directly
  
  @export var rage_threshold: float = 0.3  # Percentage of health that triggers rage mode
  @export var rage_speed_multiplier: float = 1.5
  @export var rage_damage_multiplier: float = 1.2
  
  var is_enraged: bool = false
  var base_speed: float
  var base_chase_speed: float
  var base_attack_damage: float
  
  func _ready():
  	# Set base enemy properties
  	max_health = 100.0
  	speed = 80.0
  	chase_speed = 100.0
  	attack_damage = 20.0
  	attack_cooldown = 1.0
  
  	# Store base values for rage mode
  	base_speed = speed
  	base_chase_speed = chase_speed
  	base_attack_damage = attack_damage
  
  	# Set references
  	animated_sprite = $AnimatedSprite2D
  	collision_shape = $CollisionShape2D
  
  	# Call parent ready method
  	super._ready()
  
  func take_damage(amount):
  	super.take_damage(amount)
  
  	# Check if we should enter rage mode
  	if not is_enraged and current_health <= max_health * rage_threshold:
  		enter_rage_mode()
  
  func enter_rage_mode():
  	is_enraged = true
  
  	# Increase stats
  	speed = base_speed * rage_speed_multiplier
  	chase_speed = base_chase_speed * rage_speed_multiplier
  	attack_damage = base_attack_damage * rage_damage_multiplier
  
  	# Visual indication of rage if available
  	if animated_sprite.sprite_frames.has_animation("rage"):
  		animated_sprite.play("rage")
  
  	# Play a sound if available
  	if has_node("AudioStreamPlayer"):
  		var audio = get_node("AudioStreamPlayer")
  		audio.play()
  
  func attack():
  	if is_dead or not can_attack or not target:
  		return
  
  	is_attacking = true
  	can_attack = false
  	velocity.x = 0
  
  	# Use rage attack animation if available and enraged
  	if is_enraged and animated_sprite.sprite_frames.has_animation("rage_attack"):
  		play_animation("rage_attack")
  	else:
  		play_animation("attack")
  
  	# Apply damage to player
  	if target.has_method("take_damage"):
  		target.take_damage(attack_damage)
  
  	# Update HUD
  	if hud and hud.has_method("change_life"):
  		hud.change_life(-attack_damage/100.0)  # Assuming health is on 0-1 scale for HUD
  
  	# Wait for animation to finish
  	await animated_sprite.animation_finished
  
  	is_attacking = false
  
  	# Start cooldown
  	await get_tree().create_timer(attack_cooldown).timeout
  	can_attack = true
  
  # Connection to detection radius (override parent implementation)
  func _on_detection_radius_body_entered(body):
  	if body.name == "Player" and not is_dead:
  		chase_target(body)
  
  func _on_detection_radius_body_exited(body):
  	if body.name == "Player":
  		stop_chase()
  
  # Connection to attack zone (override parent implementation)
  func _on_attackzone_body_entered(body):
  	if body.name == "Player":
  		is_chasing = false
  		attack()
  
  func _on_attackzone_body_exited(body):
  	if body.name == "Player":
  		is_chasing = true
  		chase_target(body)
  
  # Connection to death zone (override parent implementation)
  func _on_deathzone_body_entered(body):
  	if body.name == "Player":
  		take_damage(current_health)  # Instant death

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\enemies\prince_enemy.gd:
========================================
  class_name PrinceEnemy
  extends BaseEnemy
  
  ## Simple patrol enemy that walks back and forth (used in prince levels)
  
  @export var direction: int = 1  # 1 = right, -1 = left
  @export var damage_on_touch: float = 10.0  # Damage dealt when touching player
  
  @onready var ray_cast_right: RayCast2D = $RayCastRight
  @onready var ray_cast_left: RayCast2D = $RayCastLeft
  
  var start_position: Vector2
  var is_patrolling: bool = true
  
  func _ready():
  	# Set base enemy properties
  	max_health = 40.0
  	speed = 60.0
  	chase_speed = speed  # Same as normal speed since this enemy doesn't chase
  	attack_damage = damage_on_touch
  
  	# Set references
  	animated_sprite = $AnimatedSprite2D
  	collision_shape = $CollisionShape2D
  
  	# Store starting position
  	start_position = global_position
  
  	# Initialize raycasts if not already set
  	if not ray_cast_right:
  		ray_cast_right = $RayCastRight if has_node("RayCastRight") else null
  
  	if not ray_cast_left:
  		ray_cast_left = $RayCastLeft if has_node("RayCastLeft") else null
  
  	# Call parent ready method
  	super._ready()
  
  	# Start patrol behavior
  	play_animation("walk")
  
  func _physics_process(delta):
  	# Call parent implementation for gravity and movement
  	super._physics_process(delta)
  
  	# Handle patrol logic if not chasing or attacking
  	if is_patrolling and not is_dead:
  		patrol()
  
  func patrol():
  	# Check wall collisions
  	if ray_cast_right and ray_cast_right.is_colliding():
  		direction = -1
  		animated_sprite.flip_h = false
  	elif ray_cast_left and ray_cast_left.is_colliding():
  		direction = 1
  		animated_sprite.flip_h = true
  
  	# Set movement velocity
  	velocity.x = direction * speed
  
  	# Play walk animation
  	play_animation("walk")
  
  # Override to handle damage-on-touch behavior
  func _on_body_entered(body):
  	if body.name == "Player" and not is_dead:
  		# Deal damage to player
  		if body.has_method("take_damage"):
  			body.take_damage(damage_on_touch)
  
  		# Update HUD
  		if hud and hud.has_method("change_life"):
  			hud.change_life(-damage_on_touch/100.0)  # Assuming health is on 0-1 scale for HUD

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\items\coins.gd:
========================================
  class_name Coins
  extends Area2D
  
  signal coin_collected
  
  
  
  func _on_coins_body_entered(body):
  	get_parent().get_node("HUD").coin_collected()
  	$AnimationPlayer.play("bounce")
  	set_collision_mask_value(1,false)
  
  
  func _on_animation_player_animation_finished(anim_name):
  	queue_free()
  
  
  
  
  
  
  
  
  
  

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\items\power_attack.gd:
========================================
  class_name PowerAttack
  extends BasePowerUp
  
  ## Power-up that gives the player an axe attack ability
  
  func _ready():
  	# Set power-up properties
  	power_up_name = "Battle Axe"
  	description = "Grants the ability to attack with a powerful axe"
  	destroy_on_pickup = true
  
  	# Set animation properties
  	bounce_height = 5.0
  	bounce_speed = 2.0
  	rotation_speed = 1.0
  
  	# Call parent ready method
  	super._ready()
  
  func apply_effect(player):
  	# Call the parent implementation for signals
  	super.apply_effect(player)
  
  	# Set the player's attack animation
  	if player.has_method("set_attack_animation"):
  		player.set_attack_animation("walking6")
  	else:
  		# Fallback for current implementation
  		player.attack_animation = "walking6"
  
  	# Enable attack ability if player has the method
  	if player.has_method("enable_attack"):
  		player.enable_attack(true)
  
  	print("Player gained axe attack ability")
  
  	# Show notification to player
  	var popup_manager = get_node_or_null("/root/PopupManager")
  	if popup_manager:
  		popup_manager.info("New Ability", "You've acquired a battle axe! Press the attack button to use it.")

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\items\power_fly.gd:
========================================
  class_name PowerFly
  extends BasePowerUp
  
  ## Power-up that gives the player temporary flying ability
  
  func _ready():
  	# Set power-up properties
  	power_up_name = "Angel Wings"
  	description = "Grants temporary flying ability"
  	effect_duration = 20.0  # 20 seconds of flight
  	destroy_on_pickup = true
  
  	# Set animation properties
  	bounce_height = 8.0
  	bounce_speed = 1.5
  	rotation_speed = 0.5
  
  	# Call parent ready method
  	super._ready()
  
  func apply_effect(player):
  	# Call the parent implementation for signals
  	super.apply_effect(player)
  
  	# Set the player's movement mode
  	if player.has_method("set_movement_mode"):
  		player.set_movement_mode("fly")
  	else:
  		# Fallback for current implementation
  		player.mode = "fly"
  
  	print("Player gained flight ability")
  
  	# Show notification to player
  	var popup_manager = get_node_or_null("/root/PopupManager")
  	if popup_manager:
  		popup_manager.info("New Ability", "You've acquired angel wings! You can now fly for " + str(effect_duration) + " seconds.")
  
  	# Add a visible timer to the HUD if available
  	var hud = get_node_or_null("../../HUD")
  	if hud and hud.has_method("show_ability_timer"):
  		hud.show_ability_timer("Flight", effect_duration)
  
  func remove_effect(player):
  	# Set the player's movement mode back to normal
  	if player.has_method("set_movement_mode"):
  		player.set_movement_mode("normal")
  	else:
  		# Fallback for current implementation
  		player.mode = "normal"
  
  	# Reset player's flight timer
  	player.passed_fly_time = 0.0
  
  	# Let the player know the effect has ended
  	var popup_manager = get_node_or_null("/root/PopupManager")
  	if popup_manager:
  		popup_manager.info("Ability Expired", "Your angel wings have disappeared.")
  
  	# Call the parent implementation for signals
  	super.remove_effect(player)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\items\power_jump.gd:
========================================
  class_name PowerJump
  extends BasePowerUp
  
  ## Power-up that gives the player double jump ability
  
  @export var extra_jumps: int = 1  # How many extra jumps to grant
  
  func _ready():
  	# Set power-up properties
  	power_up_name = "Feather Boots"
  	description = "Grants the ability to double jump"
  	destroy_on_pickup = true
  
  	# Set animation properties
  	bounce_height = 10.0
  	bounce_speed = 3.0
  	rotation_speed = 0.0
  
  	# Call parent ready method
  	super._ready()
  
  func apply_effect(player):
  	# Call the parent implementation for signals
  	super.apply_effect(player)
  
  	# Increase player's allowed jumps
  	if player.has_method("add_extra_jumps"):
  		player.add_extra_jumps(extra_jumps)
  	else:
  		# Fallback for current implementation
  		player.allowed_jumps += extra_jumps
  
  	# Set the player's movement mode to normal (in case they were flying)
  	if player.has_method("set_movement_mode"):
  		player.set_movement_mode("normal")
  	else:
  		# Fallback for current implementation
  		player.mode = "normal"
  
  	print("Player gained double jump ability")
  
  	# Show notification to player
  	var popup_manager = get_node_or_null("/root/PopupManager")
  	if popup_manager:
  		if extra_jumps == 1:
  			popup_manager.info("New Ability", "You've acquired Feather Boots! You can now double jump in mid-air.")
  		else:
  			popup_manager.info("New Ability", "You've acquired Feather Boots! You can now perform " + str(extra_jumps + 1) + " jumps in a row.")

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\projectiles\mage_ball.gd:
========================================
  class_name MageBall
  extends BaseProjectile
  
  ## Magical projectile used by mage enemies
  
  @export var particle_effect: PackedScene
  @export var hit_sound: AudioStream
  
  func _ready():
  	# Set projectile properties
  	speed = 50.0
  	damage = 10.0
  	lifetime = 5.0
  	gravity_affected = false
  
  	# Call parent ready method
  	super._ready()
  
  	# Set up animation
  	if has_node("Ball"):
  		$Ball.play("flying")
  
  func _physics_process(delta):
  	# Implement base projectile physics
  	super._physics_process(delta)
  
  	# Add magical effect (optional particle trail)
  	if particle_effect and randf() < 0.3:  # 30% chance per frame
  		var particles = particle_effect.instantiate()
  		particles.global_position = global_position
  		get_tree().current_scene.add_child(particles)
  		particles.emitting = true
  
  		# Auto-remove particles after their lifetime
  		await get_tree().create_timer(particles.lifetime).timeout
  		if is_instance_valid(particles):
  			particles.queue_free()
  
  func _on_hit_player(player):
  	# Call parent implementation
  	super._on_hit_player(player)
  
  	# Add magical effect (status effect, screen shake, etc.)
  	var hud = get_node_or_null("../HUD")
  	if hud and hud.has_method("change_life"):
  		hud.change_life(-damage/100.0)  # Assuming HUD uses 0-1 scale
  
  	# Play hit sound
  	if hit_sound:
  		var audio_player = AudioStreamPlayer.new()
  		audio_player.stream = hit_sound
  		audio_player.volume_db = -10.0
  		get_tree().current_scene.add_child(audio_player)
  		audio_player.play()
  
  		# Auto-remove audio player after sound finishes
  		await audio_player.finished
  		audio_player.queue_free()
  
  # Connect the hit zone to our hit methods
  func _on_hit_zone_body_entered(body):
  	if body.name == "Player":
  		_on_hit_player(body)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\projectiles\rock.gd:
========================================
  class_name Rock
  extends BaseProjectile
  
  ## Rock projectile used by archer enemies
  
  @export var bounce_count: int = 1  # How many times the rock can bounce
  @export var hit_sound: AudioStream
  
  var bounces_remaining: int = 0
  
  func _ready():
  	# Set projectile properties
  	speed = 120.0
  	damage = 8.0
  	lifetime = 5.0
  	gravity_affected = true
  	bounce = true
  	bounce_factor = 0.6
  
  	# Set remaining bounces
  	bounces_remaining = bounce_count
  
  	# Call parent ready method
  	super._ready()
  
  	# Set up animation
  	if has_node("rock"):
  		$rock.play("flying")
  
  func _on_collision(collision):
  	var collider = collision.get_collider()
  
  	# Check if we should bounce
  	if bounce and bounces_remaining > 0 and not collider.is_in_group("Player") and not collider.is_in_group("Enemy"):
  		bounces_remaining -= 1
  
  		var reflection = collision.get_remainder().bounce(collision.get_normal())
  		velocity = velocity.bounce(collision.get_normal()) * bounce_factor
  		global_position += reflection
  
  		# Play bounce sound if available
  		if hit_sound:
  			var audio_player = AudioStreamPlayer.new()
  			audio_player.stream = hit_sound
  			audio_player.volume_db = -15.0
  			get_tree().current_scene.add_child(audio_player)
  			audio_player.play()
  
  			# Auto-remove audio player after sound finishes
  			await audio_player.finished
  			audio_player.queue_free()
  
  		return
  
  	# If no more bounces or hit player/enemy, use default behavior
  	has_hit = true
  
  	# Handle different collision types
  	if collider.is_in_group("Player") and source_node != collider:
  		_on_hit_player(collider)
  	elif collider.is_in_group("Enemy") and source_node != collider:
  		_on_hit_enemy(collider)
  	else:
  		_on_hit_environment(collider)
  
  func _on_hit_player(player):
  	# Call parent implementation
  	super._on_hit_player(player)
  
  	# Update HUD
  	var hud = get_node_or_null("../HUD")
  	if hud and hud.has_method("change_life"):
  		hud.change_life(-damage/100.0)  # Assuming HUD uses 0-1 scale
  
  # Connect the hit zone to our hit methods
  func _on_hit_zone_body_entered(body):
  	if body.name == "Player":
  		_on_hit_player(body)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\enemy_states\enemy_idle_state.gd:
========================================
  class_name EnemyIdleState
  extends State
  
  ## Enemy idle state - when the enemy is standing still
  
  @export var idle_animation: String = "idle"
  @export var idle_min_time: float = 1.0
  @export var idle_max_time: float = 3.0
  
  var idle_timer: float = 0.0
  var idle_duration: float = 0.0
  var target = null
  
  func enter():
  	# Play idle animation
  	play_animation(idle_animation)
  
  	# Reset horizontal velocity
  	var velocity = get_velocity()
  	velocity.x = 0
  	set_velocity(velocity)
  
  	# Set random idle duration
  	idle_duration = randf_range(idle_min_time, idle_max_time)
  	idle_timer = 0.0
  
  func physics_process(delta: float):
  	# Apply gravity
  	var velocity = get_velocity()
  	var gravity = owner_node.get_gravity() if owner_node.has_method("get_gravity") else 980.0
  
  	velocity.y += gravity * delta
  	set_velocity(velocity)
  
  	# Handle movement for character body
  	if owner_node.has_method("move_and_slide"):
  		owner_node.move_and_slide()
  
  	# Update idle timer
  	idle_timer += delta
  
  func get_next_state() -> String:
  	# Check if there's a player in detection range
  	target = get_owner_property("target")
  	if target != null:
  		return "Chase"
  
  	# Check if idle time has elapsed - transition to patrol
  	if idle_timer >= idle_duration:
  		return "Patrol"
  
  	# No transition, stay in idle
  	return ""
  
  # Used by enemies to find nearby player
  func check_for_player():
  	var detection_radius = get_owner_property("detection_radius")
  	if not detection_radius:
  		return null
  
  	var space_state = owner_node.get_world_2d().direct_space_state
  	var player_detection_shape = CircleShape2D.new()
  	player_detection_shape.radius = detection_radius
  
  	var query = PhysicsShapeQueryParameters2D.new()
  	query.set_shape(player_detection_shape)
  	query.transform = Transform2D(0, owner_node.global_position)
  	query.collision_mask = 1  # Player layer
  
  	var results = space_state.intersect_shape(query)
  
  	for result in results:
  		var collider = result.collider
  		if collider.name == "Player":
  			return collider
  
  	return null

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\player_states\player_attack_state.gd:
========================================
  class_name PlayerAttackState
  extends PlayerBaseState
  
  var attack_timer: float = 0.0
  var attack_duration: float = 0.5  # Duration of the attack animation
  
  func enter():
      player.current_animation = player.attack_animation
      player.play_attack_animation = true
      attack_timer = 0.0
  
      # Optionally play attack sound
      # if player.has_node("AttackSound"):
      #     player.get_node("AttackSound").play()
  
  func physics_process(delta: float):
      # Apply gravity
      var velocity = get_velocity()
      velocity.y += player.GRAVITY * delta
  
      # Reduce movement during attack (optional)
      velocity.x = move_toward(velocity.x, 0, 20)
  
      set_velocity(velocity)
  
      # Handle movement for character body
      player.move_and_slide()
  
      # Update attack timer
      attack_timer += delta
  
      # Update outfit
      update_outfit()
  
  func get_next_state() -> String:
      # Check state transitions
      var life_state = check_life()
      if life_state:
          return life_state
  
      # Return to appropriate state after attack finishes
      if attack_timer >= attack_duration:
          player.play_attack_animation = false
  
          if player.is_on_floor():
              var x_input = Input.get_axis("left", "right")
              if x_input != 0:
                  return "PlayerWalkState"
              else:
                  return "PlayerIdleState"
          else:
              return "PlayerFallState"
  
      # Stay in attack state
      return ""
  
  func handle_input(event: InputEvent):
      check_menu_input(event)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\player_states\player_base_state.gd:
========================================
  class_name PlayerBaseState
  extends State
  
  # Base functions shared by all player states
  var player: Player
  
  func _ready():
  	# Set player reference during initialization
  	player = owner_node as Player
  
  # Function to update the outfit based on the current state
  func update_outfit():
  	var player_outfit = player.player_outfit
  	var player_animations = player.player_animations
  	var current_animation = player.current_animation
  
  	for outfit in player_outfit:
  		var animated_sprite = player.get_node("character_sprites/" + outfit)
  		var selected_outfit = player_outfit[outfit]
  
  		if str(selected_outfit) == "none":
  			animated_sprite.visible = false
  		else:
  			animated_sprite.visible = true
  			animated_sprite.play(str(selected_outfit))
  			animated_sprite.speed_scale = 2.0
  
  			# Set direction based on movement
  			var x_input = Input.get_axis("left", "right")
  			if x_input != 0:
  				animated_sprite.flip_h = x_input > 0
  
  			# Frame management
  			if current_animation in player_animations:
  				if animated_sprite.frame < player_animations[current_animation][0] or animated_sprite.frame >= player_animations[current_animation][-1]:
  					animated_sprite.frame = player_animations[current_animation][0]
  
  # Function to check life and handle death
  func check_life():
  	if player.hud and player.hud.lifes <= 0:
  		return "PlayerDeathState"
  	return ""
  
  # Function to check menu input
  func check_menu_input(event):
  	if event is InputEvent and event.is_action_pressed("Menu"):
  		get_tree().change_scene_to_file("res://scenes/ui/main_menu/main_menu.tscn")
  		if player.has_method("save_settings"):
  			player.save_settings()

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\player_states\player_death_state.gd:
========================================
  class_name PlayerDeathState
  extends PlayerBaseState
  
  var death_timer: float = 0.0
  var death_duration: float = 1.5  # Duration before scene transition
  
  func enter():
      player.current_animation = "death"
      player.get_node("CollisionShape2D").disabled = true
      death_timer = 0.0
  
  func physics_process(delta: float):
      # Update death animation timer
      death_timer += delta
  
      # Update outfit
      update_outfit()
  
  func get_next_state() -> String:
      # Scene transition after death animation
      if death_timer >= death_duration:
          player.queue_free()
          get_tree().change_scene_to_file("res://scenes/ui/main_menu/main_menu.tscn")
  
      # Stay in death state
      return ""

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\player_states\player_fall_state.gd:
========================================
  class_name PlayerFallState
  extends PlayerBaseState
  
  func enter():
  	# player.current_animation = "idle"  # You may want a falling animation
  
  	# Mark as not ready for jump
  	if player.jump_counter == 0:
  		player.ready_for_jump = false
  
  func physics_process(delta: float):
  	# Apply gravity
  	var velocity = get_velocity()
  	velocity.y += player.GRAVITY * delta
  
  	# Read the input
  	var x_input = Input.get_axis("left", "right")
  	var y_input = Input.get_axis("down", "up")
  
  	# Apply horizontal movement
  	if x_input != 0:
  		velocity.x = x_input * player.SPEED
  		player.current_animation = "walking"
  	else:
  		velocity.x = move_toward(velocity.x, 0, 30)
  
  	# Check for double jump if allowed
  	if y_input > 0.4 && player.jump_counter < player.allowed_jumps && player.ready_for_jump:
  		velocity.y = player.JUMP_VELOCITY * y_input
  		player.jump_counter += 1
  		player.ready_for_jump = false
  	elif y_input < 0.4:
  		player.ready_for_jump = true
  
  	set_velocity(velocity)
  
  	# Handle movement for character body
  	player.move_and_slide()
  
  	# Update outfit
  	update_outfit()
  
  func get_next_state() -> String:
  	# Check state transitions
  	var life_state = check_life()
  	if life_state:
  		return life_state
  
  	# Check for attack input
  	if Input.is_action_just_pressed("attack"):
  		return "PlayerAttackState"
  
  	# Check for fly mode
  	if player.mode == "fly":
  		return "PlayerFlyState"
  
  	# Landing transition
  	if player.is_on_floor():
  		player.jump_counter = 0
  		player.ready_for_jump = true
  		player.passed_fly_time = 0.0
  
  		# Check if still moving
  		var x_input = Input.get_axis("left", "right")
  		if x_input != 0:
  			return "PlayerWalkState"
  		else:
  			return "PlayerIdleState"
  
  	# Double jump transition
  	var y_input = Input.get_axis("down", "up")
  	if y_input > 0.4 && player.jump_counter < player.allowed_jumps && player.ready_for_jump:
  		return "PlayerJumpState"
  
  	# Stay in fall state
  	return ""
  
  func handle_input(event: InputEvent):
  	check_menu_input(event)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\player_states\player_fly_state.gd:
========================================
  class_name PlayerFlyState
  extends PlayerBaseState
  
  func enter():
      player.current_animation = "idle"  # You may want a specific fly animation
  
  func physics_process(delta: float):
      # Apply gravity
      var velocity = get_velocity()
      velocity.y += player.GRAVITY * delta
  
      # Read inputs
      var x_input = Input.get_axis("left", "right")
      var y_input = Input.get_axis("down", "up")
  
      # Apply horizontal movement
      if x_input != 0:
          velocity.x = x_input * player.SPEED
      else:
          velocity.x = move_toward(velocity.x, 0, 30)
  
      # Update fly time counter
      if player.passed_fly_time < 4:
          player.passed_fly_time += delta
          if y_input != 0:
              velocity.y = player.FLY_VELOCITY * y_input
  
      set_velocity(velocity)
  
      # Handle movement for character body
      player.move_and_slide()
  
      # Update outfit
      update_outfit()
  
  func get_next_state() -> String:
      # Check state transitions
      var life_state = check_life()
      if life_state:
          return life_state
  
      # Check for attack input
      if Input.is_action_just_pressed("attack"):
          return "PlayerAttackState"
  
      # Landing transition
      if player.is_on_floor():
          player.jump_counter = 0
          player.ready_for_jump = true
          player.passed_fly_time = 0.0
  
          # Check movement direction after landing
          var x_input = Input.get_axis("left", "right")
          if x_input != 0:
              return "PlayerWalkState"
          else:
              return "PlayerIdleState"
  
      # Time limit check
      if player.passed_fly_time >= 4:
          return "PlayerFallState"
  
      # Stay in fly state
      return ""
  
  func handle_input(event: InputEvent):
      check_menu_input(event)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\player_states\player_hurt_state.gd:
========================================
  class_name PlayerHurtState
  extends PlayerBaseState

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\player_states\player_idle_state.gd:
========================================
  class_name PlayerIdleState
  extends PlayerBaseState
  
  func enter():
  	player.current_animation = "idle"
  	# Reset horizontal velocity
  	var velocity = get_velocity()
  	velocity.x = 0
  	set_velocity(velocity)
  
  	if player.debug_mode:
  		print("Entered Idle State")
  
  func physics_process(delta: float):
  	# Apply gravity
  	var velocity = get_velocity()
  	velocity.y += player.GRAVITY * delta
  	set_velocity(velocity)
  
  	# Handle movement for character body
  	player.move_and_slide()
  
  	# Update outfit
  	update_outfit()
  
  func get_next_state() -> String:
  	# Check for death
  	var life_state = check_life()
  	if life_state != "":
  		return life_state
  
  	# Check input for state transitions
  	var x_input = Input.get_axis("left", "right")
  	var y_input = Input.get_axis("down", "up")
  
  	# Check for attack
  	if Input.is_action_just_pressed("attack"):
  		return "PlayerAttackState"
  
  	# Check for movement
  	if x_input != 0:
  		return "PlayerWalkState"
  
  	# Check for jumping
  	if y_input > 0.4 and player.is_on_floor():
  		return "PlayerJumpState"
  
  	# Check for falling
  	if !player.is_on_floor():
  		return "PlayerFallState"
  
  	# No transition
  	return ""
  
  func handle_input(event: InputEvent):
  	check_menu_input(event)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\player_states\player_jump_state.gd:
========================================
  # Fix for player_jump_state.gd - Correct class name
  class_name PlayerJumpState
  extends PlayerBaseState
  
  func enter():
  	# player.current_animation = "idle"  # You may want to use a jump animation
  
  	# Apply initial jump velocity
  	var velocity = get_velocity()
  	var y_input = Input.get_axis("down", "up")
  	velocity.y = player.JUMP_VELOCITY * y_input
  	set_velocity(velocity)
  
  	# Update jump counter
  	player.jump_counter += 1
  	player.ready_for_jump = false
  
  	if player.debug_mode:
  		print("Entered Jump State")
  
  func physics_process(delta: float):
  	# Apply gravity
  	var velocity = get_velocity()
  	velocity.y += player.GRAVITY * delta
  
  	# Read horizontal input
  	var x_input = Input.get_axis("left", "right")
  
  	# Apply horizontal movement
  	if x_input != 0:
  		velocity.x = x_input * player.SPEED
  		player.current_animation = "walking"
  	else:
  		velocity.x = move_toward(velocity.x, 0, 30)
  
  	set_velocity(velocity)
  
  	# Handle movement for character body
  	player.move_and_slide()
  
  	# Reset jump readiness when input is released
  	var y_input = Input.get_axis("down", "up")
  	if y_input < 0.4:
  		player.ready_for_jump = true
  
  	# Update outfit
  	update_outfit()
  
  func get_next_state() -> String:
  	# Check state transitions
  	var life_state = check_life()
  	if life_state:
  		return life_state
  
  	# Check for attack input
  	if Input.is_action_just_pressed("attack"):
  		return "PlayerAttackState"
  
  	# Fly state transition
  	if player.mode == "fly":
  		return "PlayerFlyState"
  
  	# Landing transition
  	if player.is_on_floor():
  		player.jump_counter = 0
  		player.ready_for_jump = true
  
  		# Check if still moving
  		var x_input = Input.get_axis("left", "right")
  		if x_input != 0:
  			return "PlayerWalkState"
  		else:
  			return "PlayerIdleState"
  
  	# Falling transition
  	if get_velocity().y > 0:
  		return "PlayerFallState"
  
  	# Stay in jump state
  	return ""
  
  func handle_input(event: InputEvent):
  	check_menu_input(event)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\player_states\player_walk_state.gd:
========================================
  class_name PlayerWalkState
  extends PlayerBaseState
  
  func enter():
  	player.current_animation = "walking"  # Walk animation
  
  	if player.debug_mode:
  		print("Entered Walk State")
  
  func physics_process(delta: float):
  	# Apply gravity
  	var velocity = get_velocity()
  	velocity.y += player.GRAVITY * delta
  
  	# Read the input
  	var x_input = Input.get_axis("left", "right")
  
  	# Apply horizontal movement
  	if x_input != 0:
  		velocity.x = x_input * player.SPEED
  	else:
  		velocity.x = move_toward(velocity.x, 0, 30)
  
  	set_velocity(velocity)
  
  	# Handle movement for character body
  	player.move_and_slide()
  
  	# Update outfit
  	update_outfit()
  
  func get_next_state() -> String:
  	# Check for death
  	var life_state = check_life()
  	if life_state != "":
  		return life_state
  
  	# Check for attack
  	if Input.is_action_just_pressed("attack"):
  		return "PlayerAttackState"
  
  	# Read inputs
  	var x_input = Input.get_axis("left", "right")
  	var y_input = Input.get_axis("down", "up")
  
  	# Stop walking
  	if x_input == 0:
  		return "PlayerIdleState"
  
  	# Jump while moving
  	if y_input > 0.4 and player.is_on_floor():
  		return "PlayerJumpState"
  
  	# Fall transition
  	if !player.is_on_floor():
  		return "PlayerFallState"
  
  	# Stay in walk state
  	return ""
  
  func handle_input(event: InputEvent):
  	check_menu_input(event)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\state.gd:
========================================
  class_name State
  extends Node
  
  ## Base class for all states in a state machine
  
  # Reference to the state machine
  var state_machine: StateMachine = null
  
  # Reference to the owner node
  var owner_node: Node = null
  
  # State parameters (can be extended by child classes)
  var parameters: Dictionary = {}
  
  
  # Called when entering this state
  func enter():
  	pass
  
  # Called when exiting this state
  func exit():
  	pass
  
  # Called during _process
  func process(delta: float):
  	pass
  
  # Called during _physics_process
  func physics_process(delta: float):
  	pass
  
  # Called during _input
  func handle_input(event: InputEvent):
  	pass
  
  # Override this to determine the next state to transition to
  func get_next_state() -> String:
  	return ""
  
  # Utility functions that can be used by derived states
  
  # Check if a condition is true
  func condition_met(condition_name: String) -> bool:
  	if owner_node.has_method("check_condition"):
  		return owner_node.check_condition(condition_name)
  	return false
  
  # Get a value from the owner
  func get_owner_property(property_name: String):
  	if owner_node and property_name in owner_node:
  		return owner_node.get(property_name)
  	return null
  
  # Set a value on the owner
  func set_owner_property(property_name: String, value):
  	if owner_node and property_name in owner_node:
  		owner_node.set(property_name, value)
  
  # Helper to check if owner is on floor (for platformers)
  func is_on_floor() -> bool:
  	if owner_node.has_method("is_on_floor"):
  		return owner_node.is_on_floor()
  	return false
  
  # Helper to get owner velocity (for physics bodies)
  func get_velocity() -> Vector2:
  	if "velocity" in owner_node:
  		return owner_node.velocity
  	return Vector2.ZERO
  
  # Helper to set owner velocity (for physics bodies)
  func set_velocity(value: Vector2):
  	if "velocity" in owner_node:
  		owner_node.velocity = value
  
  # Helper to play animations
  func play_animation(anim_name: String):
  	if owner_node.has_method("play_animation"):
  		owner_node.play_animation(anim_name)
  	elif owner_node.has_node("AnimatedSprite2D"):
  		var sprite = owner_node.get_node("AnimatedSprite2D")
  		if sprite.sprite_frames.has_animation(anim_name):
  			sprite.play(anim_name)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\state_machine.gd:
========================================
  class_name StateMachine
  extends Node
  
  ## A finite state machine implementation for Godot 4.x
  
  # Current active state
  var current_state: State = null
  
  # Dictionary of available states
  var states: Dictionary = {}
  
  # The owner node that this state machine controls
  var owner_node: Node = null
  
  # Debug mode flag
  @export var debug_mode: bool = true
  
  # Signal emitted when state changes
  signal state_changed(from_state, to_state)
  
  func _ready():
  	owner_node = get_parent()
  
  	# Register all child states
  	for child in get_children():
  		if child is State:
  			register_state(child)
  
  	# Initialize the first state
  	if states.size() > 0:
  		var initial_state = states.values()[0]
  		change_state(initial_state.name)
  
  func _process(delta):
  	if current_state != null:
  		# Call the current state's process method
  		current_state.process(delta)
  
  		# Check for state transitions
  		var next_state = current_state.get_next_state()
  		if next_state != null and next_state != "" and states.has(next_state):
  			change_state(next_state)
  
  func _physics_process(delta):
  	if current_state != null:
  		# Call the current state's physics_process method
  		current_state.physics_process(delta)
  
  func _input(event):
  	if current_state != null:
  		# Call the current state's input method
  		current_state.handle_input(event)
  
  func register_state(state: State):
  	# Add to states dictionary
  	states[state.name] = state
  
  	# Set the state machine reference
  	state.state_machine = self
  
  	# Set the owner reference
  	state.owner_node = owner_node
  
  	# Specifically initialize player references for PlayerBaseState instances
  	if state is PlayerBaseState:
  		state.player = owner_node
  
  	if debug_mode:
  		print("Registered state: ", state.name)
  
  func change_state(new_state_name: String):
  	if not states.has(new_state_name):
  		push_error("State '" + new_state_name + "' not found in state machine!")
  		return
  
  	var from_state = current_state.name if current_state else "None"
  
  	if current_state != null:
  		if debug_mode:
  			print("Exiting state: ", current_state.name)
  		current_state.exit()
  
  	var next_state = states[new_state_name]
  	current_state = next_state
  
  	# Make sure the player reference is properly set before entering the state
  	if current_state is PlayerBaseState and current_state.player == null:
  		current_state.player = owner_node
  
  	if debug_mode:
  		print("Entering state: ", current_state.name)
  
  	current_state.enter()
  
  	# Emit state change signal
  	emit_signal("state_changed", from_state, new_state_name)
  
  func get_current_state() -> String:
  	if current_state != null:
  		return current_state.name
  	return "None"
  
  # Add a new state at runtime
  func add_state(state: State):
  	register_state(state)
  
  # Remove a state at runtime
  func remove_state(state_name: String):
  	if states.has(state_name):
  		states.erase(state_name)
  	else:
  		push_error("Tried to remove non-existent state: " + state_name)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\levels\base_level.gd:
========================================
  class_name BaseLevel
  extends Node2D
  
  var boss_music = load("res://assets/audio/music/Tracks/the-epic-2-by-rafael-krux(chosic.com).mp3")
  # Called when the node enters the scene tree for the first time.
  func _ready():
  	AudioManager.play_track(boss_music)
  
  # Called every frame. 'delta' is the elapsed time since the previous frame.
  func _process(_delta):
  	pass

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\character_customizer\customizer_controller.gd:
========================================
  class_name CustomizerController
  # UI.gd
  extends Control
  
  # Spieler-Outfit-Eigenschaften
  var body
  var player_outfit
  var selected_outfit_category = ""
  var player_animations
  var options_per_category = {}
  var config_path = "user://settings.cfg"
  var has_unsaved_changes = false  # Neue Variable für ungespeicherte Änderungen
  
  # Signal für Debugging
  signal debug_message(message)
  
  func _ready():
  	randomize() # Initialisiere den Zufallsgenerator
  	get_node("character_sprites/masks").visible = false
  	player_outfit = get_node("character_sprites").default_outfit
  	player_animations = get_node("character_sprites").animation_frames
  	PopupManager.dialog_confirmed.connect(_on_dialog_confirmed)
  
  	# UI-Elemente für jede Outfit-Kategorie erstellen
  	setup_outfit_categories()
  
  	# Versuche, gespeicherte Outfits zu laden
  	load_saved_outfit()
  
  	# Bei Programmstart gibt es keine ungespeicherten Änderungen
  	has_unsaved_changes = false
  
  # Erstellt UI-Elemente für alle Outfit-Kategorien
  func setup_outfit_categories():
  	for category in player_outfit:
  		var category_button = Button.new()
  		var items_container = ScrollContainer.new()
  		var item_container_grid = GridContainer.new()
  
  		# Kategorie-Button einrichten
  		category_button.text = category
  		category_button.pressed.connect(_on_category_button_pressed.bind(category))
  		$Outfit_Category_Picker/GridContainer.add_child(category_button)
  
  		# Container für Items einrichten
  		items_container.size = Vector2(620, 400)
  		items_container.position = Vector2(600, 200)
  		items_container.add_child(item_container_grid)
  		items_container.name = category
  		add_child(items_container)
  		items_container.hide()
  
  		# Grid für Items einrichten
  		item_container_grid.columns = 6
  		var current_item = 0
  		var button_size = Vector2(100, 100)
  
  		# Leeren Button für optionale Kategorien hinzufügen
  		if category != "bodies":
  			var empty_button = Button.new()
  			empty_button.custom_minimum_size = button_size
  			empty_button.pressed.connect(_on_item_button_pressed.bind("none"))
  			item_container_grid.add_child(empty_button)
  
  			var animated_sprite = get_node("character_sprites/" + category)
  			animated_sprite.visible = false
  			player_outfit[category] = "none"
  
  		# Alle verfügbaren Items für diese Kategorie hinzufügen
  		while true:
  			current_item += 1
  			var texture = get_node("character_sprites/"+category).sprite_frames.get_frame_texture(str(current_item), 1)
  			if texture == null:
  				break
  
  			var item_texture = TextureRect.new()
  			item_texture.texture = texture
  			item_texture.custom_minimum_size = button_size
  			item_texture.stretch_mode = TextureRect.STRETCH_KEEP_ASPECT_CENTERED
  
  			var item_button = Button.new()
  			item_button.custom_minimum_size = button_size
  			item_button.add_child(item_texture)
  			item_button.pressed.connect(_on_item_button_pressed.bind(str(current_item)))
  			item_container_grid.add_child(item_button)
  
  		options_per_category[category] = current_item - 1
  
  # Aktualisiert die Animations-Frames basierend auf dem gewählten Outfit
  func _process(_delta):
  	for outfit in player_outfit:
  		var animated_sprite = get_node("character_sprites/" + outfit)
  		animated_sprite.animation = player_outfit[outfit]
  		animated_sprite.frame = 1
  
  # Wird aufgerufen, wenn ein Item ausgewählt wird
  func _on_item_button_pressed(item):
  	var animated_sprite = get_node("character_sprites/" + selected_outfit_category)
  	var old_value = player_outfit[selected_outfit_category]
  	var new_value = str(item)
  
  	if new_value == "none":
  		animated_sprite.visible = false
  	else:
  		animated_sprite.visible = true
  
  	# Setze has_unsaved_changes nur, wenn sich etwas geändert hat
  	if old_value != new_value:
  		player_outfit[selected_outfit_category] = new_value
  		has_unsaved_changes = true
  	else:
  		player_outfit[selected_outfit_category] = new_value
  
  # Wird aufgerufen, wenn eine Kategorie ausgewählt wird
  func _on_category_button_pressed(category):
  	if selected_outfit_category:
  		get_node(selected_outfit_category).hide()
  	get_node(category).show()
  	selected_outfit_category = category
  
  # Generiert ein zufälliges Outfit
  func _random_button_pressed():
  	var old_outfit = player_outfit.duplicate()
  	var had_changes = false
  
  	for category in player_outfit:
  		if category == "bodies":
  			# Körper sollte immer sichtbar sein
  			var random_body = randi() % options_per_category[category] + 1
  			if player_outfit[category] != str(random_body):
  				player_outfit[category] = str(random_body)
  				had_changes = true
  		else:
  			# Für andere Kategorien, entscheide zufällig, ob sie sichtbar sein sollen
  			if randf() > 0.3: # 70% Chance, dass ein Item angezeigt wird
  				var random_item = randi() % options_per_category[category] + 1
  				if player_outfit[category] != str(random_item):
  					player_outfit[category] = str(random_item)
  					had_changes = true
  				get_node("character_sprites/" + category).visible = true
  			else:
  				if player_outfit[category] != "none":
  					player_outfit[category] = "none"
  					had_changes = true
  				get_node("character_sprites/" + category).visible = false
  
  	if had_changes:
  		has_unsaved_changes = true
  
  # Speichert das aktuelle Outfit
  func _save_button_pressed():
  	var config = ConfigFile.new()
  
  	# Versuche zuerst die vorhandene Konfigurationsdatei zu laden
  	var err = config.load(config_path)
  
  	# Speichere das Outfit, unabhängig davon, ob die Datei existiert
  	config.set_value("settings", "outfit", player_outfit)
  
  	err = config.save(config_path)
  	if err != OK:
  		emit_signal("debug_message", "Fehler beim Speichern der Einstellungen: " + str(err))
  		show_message("Fehler beim Speichern!", Color(1, 0.3, 0.3, 1))
  	else:
  		has_unsaved_changes = false  # Änderungen wurden gespeichert
  		show_message("Outfit erfolgreich gespeichert!", Color(0.3, 1, 0.3, 1))
  
  # Setzt alle optionalen Teile des Outfits zurück
  func _reset_button_pressed():
  	var had_changes = false
  
  	for category in player_outfit:
  		if category != "bodies":
  			var animated_sprite = get_node("character_sprites/" + category)
  			animated_sprite.visible = false
  
  			if player_outfit[category] != "none":
  				player_outfit[category] = "none"
  				had_changes = true
  
  	if had_changes:
  		has_unsaved_changes = true
  
  	show_message("Outfit zurückgesetzt!", Color(0.3, 0.7, 1, 1))
  
  # Hilfsfunktion zum Anzeigen von Nachrichten
  func show_message(text, color = Color(1, 1, 1, 1)):
  	if has_node("save_feedback"):
  		var label = get_node("save_feedback")
  		label.text = text
  		label.modulate = color
  
  		# Timer zum Ausblenden nach 2 Sekunden
  		get_tree().create_timer(2.0).timeout.connect(func():
  			if has_node("save_feedback"):
  				get_node("save_feedback").text = ""
  		)
  
  # Lädt das gespeicherte Outfit, falls vorhanden
  func load_saved_outfit():
  	var config = ConfigFile.new()
  	var err = config.load(config_path)
  
  	if err == OK:
  		var saved_outfit = config.get_value("settings", "outfit", null)
  		if saved_outfit:
  			# Aktualisiere das Outfit mit den gespeicherten Werten
  			for category in saved_outfit:
  				if player_outfit.has(category):
  					# Konvertiere den Wert zu String
  					var outfit_value = str(saved_outfit[category])
  					player_outfit[category] = outfit_value
  
  					# Aktualisiere die Sichtbarkeit
  					var animated_sprite = get_node("character_sprites/" + category)
  					if outfit_value == "none":
  						animated_sprite.visible = false
  					else:
  						animated_sprite.visible = true
  
  
  func _on_back_pressed() -> void:
  	if has_unsaved_changes:
  		PopupManager.confirm(
  			"Nicht gespeicherte Änderungen",
  			"Du hast nicht gespeicherte Änderungen. Möchtest du wirklich ohne Speichern zurückkehren?",
  			"Abbrechen",
  			"Zurück",
  			"back_confirmation"
  		)
  	else:
  		get_tree().change_scene_to_file("res://scenes/ui/settings/settings_menu.tscn")
  
  func _on_dialog_confirmed(dialog_id):
  	if dialog_id == "back_confirmation":
  		get_tree().change_scene_to_file("res://scenes/ui/settings/settings_menu.tscn")

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\character_customizer\outfit_showcase.gd:
========================================
  class_name OutfitShowcase
  # outfit_showcase.gd
  extends Control
  
  var current_outfits = {}
  var preview_container
  var outfit_grid
  var back_button
  var outfit_name_field
  var save_button
  var delete_button
  var preview_helper
  
  func _ready():
  	preview_helper = load("res://scripts/ui/character_customizer/preview_helper.gd").new()
  	add_child(preview_helper)
  
  	# UI erstellen
  	setup_ui()
  
  	# Gespeicherte Outfits laden
  	load_saved_outfits()
  
  func setup_ui():
  	# Container für die Vorschau
  	preview_container = ScrollContainer.new()
  	preview_container.position = Vector2(50, 50)
  	preview_container.size = Vector2(900, 400)
  	add_child(preview_container)
  
  	# Grid für Outfit-Vorschaubilder
  	outfit_grid = GridContainer.new()
  	outfit_grid.columns = 4
  	preview_container.add_child(outfit_grid)
  
  	# Textfeld für Outfit-Namen
  	var name_label = Label.new()
  	name_label.text = "Outfit-Name:"
  	name_label.position = Vector2(50, 470)
  	add_child(name_label)
  
  	outfit_name_field = LineEdit.new()
  	outfit_name_field.position = Vector2(150, 470)
  	outfit_name_field.size = Vector2(300, 30)
  	outfit_name_field.placeholder_text = "Mein cooles Outfit"
  	add_child(outfit_name_field)
  
  	# Save-Button
  	save_button = Button.new()
  	save_button.text = "Speichern"
  	save_button.position = Vector2(470, 470)
  	save_button.size = Vector2(120, 30)
  	save_button.pressed.connect(_on_save_pressed)
  	add_child(save_button)
  
  	# Delete-Button
  	delete_button = Button.new()
  	delete_button.text = "Löschen"
  	delete_button.position = Vector2(600, 470)
  	delete_button.size = Vector2(120, 30)
  	delete_button.pressed.connect(_on_delete_pressed)
  	add_child(delete_button)
  
  	# Back-Button
  	back_button = Button.new()
  	back_button.text = "Zurück"
  	back_button.position = Vector2(400, 550)
  	back_button.size = Vector2(200, 40)
  	back_button.pressed.connect(_on_back_pressed)
  	add_child(back_button)
  
  # Lädt alle gespeicherten Outfits und zeigt sie an
  func load_saved_outfits():
  	current_outfits = preview_helper.load_favorites()
  
  	# UI aktualisieren
  	update_showcase()
  
  # Aktualisiert die Anzeige der Outfits
  func update_showcase():
  	# Alle vorherigen Kinder entfernen
  	for child in outfit_grid.get_children():
  		outfit_grid.remove_child(child)
  		child.queue_free()
  
  	# Aktuelle Outfit-Liste durchgehen
  	for outfit_name in current_outfits:
  		var outfit_config = current_outfits[outfit_name]
  
  		# Container für jedes Outfit
  		var outfit_container = VBoxContainer.new()
  		outfit_grid.add_child(outfit_container)
  
  		# Vorschaubild generieren
  		var preview_image = await preview_helper.generate_outfit_preview(
  			get_node("/root/Main/character_sprites"),
  			outfit_config
  		)
  
  		# TextureRect für das Vorschaubild
  		var preview_rect = TextureRect.new()
  		var image_texture = ImageTexture.create_from_image(preview_image)
  		preview_rect.texture = image_texture
  		preview_rect.custom_minimum_size = Vector2(200, 200)
  		preview_rect.stretch_mode = TextureRect.STRETCH_KEEP_ASPECT_CENTERED
  		outfit_container.add_child(preview_rect)
  
  		# Label für den Namen
  		var name_label = Label.new()
  		name_label.text = outfit_name
  		name_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
  		outfit_container.add_child(name_label)
  
  		# Button zum Laden dieses Outfits
  		var load_button = Button.new()
  		load_button.text = "Laden"
  		load_button.pressed.connect(_on_load_outfit_pressed.bind(outfit_name))
  		outfit_container.add_child(load_button)
  
  # Event-Handler
  
  func _on_save_pressed():
  	var current_outfit = get_node("/root/Main").get_current_outfit()
  	var name = outfit_name_field.text
  
  	if name.empty():
  		name = "Outfit " + str(current_outfits.size() + 1)
  
  	# Outfit zu Favoriten hinzufügen
  	preview_helper.save_to_favorites(current_outfit, name)
  
  	# Liste aktualisieren
  	load_saved_outfits()
  
  func _on_delete_pressed():
  	var name = outfit_name_field.text
  	if current_outfits.has(name):
  		current_outfits.erase(name)
  
  		# Aktualisierte Liste speichern
  		var config = ConfigFile.new()
  		config.set_value("favorites", "outfits", current_outfits)
  		config.save("user://favorites.cfg")
  
  		# UI aktualisieren
  		update_showcase()
  
  func _on_load_outfit_pressed(outfit_name):
  	var outfit_config = current_outfits[outfit_name]
  	get_node("/root/Main").apply_outfit(outfit_config)
  
  	# Eingabefeld aktualisieren
  	outfit_name_field.text = outfit_name
  
  func _on_back_pressed():
  	get_tree().change_scene_to_file("res://scenes/ui/character_customizer/customizer.tscn")

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\character_customizer\preview_helper.gd:
========================================
  class_name PreviewHelper
  # preview_helper.gd
  # Diese Datei enthält Hilfsfunktionen für die Vorschau im Character-Customizer
  
  extends Node
  
  # Cache für Outfit-Vorschaubilder
  var preview_cache = {}
  
  # Generiert ein Vorschaubild für ein komplettes Outfit
  # Kann verwendet werden, um mehrere Outfits nebeneinander anzuzeigen
  func generate_outfit_preview(character_sprites, outfit_config):
  	var viewport = SubViewport.new()
  	viewport.size = Vector2i(128, 128)
  	viewport.transparent_bg = true
  	viewport.render_target_update_mode = SubViewport.UPDATE_ONCE
  
  	var sprites_instance = character_sprites.duplicate()
  	viewport.add_child(sprites_instance)
  
  	# Positioniere die Sprites in der Mitte des Viewports
  	sprites_instance.position = Vector2(64, 64)
  	sprites_instance.scale = Vector2(4, 4)
  
  	# Setze das Outfit gemäß der Konfiguration
  	for category in outfit_config:
  		if sprites_instance.has_node(category):
  			var sprite = sprites_instance.get_node(category)
  			if str(outfit_config[category]) == "none":
  				sprite.visible = false
  			else:
  				sprite.visible = true
  				sprite.animation = str(outfit_config[category])
  				sprite.frame = 1
  
  	# Rendern und Vorschaubild zurückgeben
  	await get_tree().process_frame
  	await get_tree().process_frame
  
  	var texture = viewport.get_texture()
  	var image = texture.get_image()
  
  	# Viewport und Duplikat aufräumen
  	viewport.remove_child(sprites_instance)
  	sprites_instance.queue_free()
  	viewport.queue_free()
  
  	return image
  
  # Speichert ein Outfit in einem gesonderten Bereich für Favoriten
  func save_to_favorites(outfit_config, name = ""):
  	var favorites = load_favorites()
  
  	if name.empty():
  		name = "Outfit " + str(favorites.size() + 1)
  
  	favorites[name] = outfit_config
  
  	var config = ConfigFile.new()
  	config.set_value("favorites", "outfits", favorites)
  	var err = config.save("user://favorites.cfg")
  
  	return err == OK
  
  # Lädt alle gespeicherten Favoriten
  func load_favorites():
  	var config = ConfigFile.new()
  	var err = config.load("user://favorites.cfg")
  
  	if err == OK:
  		return config.get_value("favorites", "outfits", {})
  	else:
  		return {}
  
  # Konvertiert ein Outfit in ein exportierbares Format (z.B. JSON)
  func export_outfit_to_json(outfit_config):
  	return JSON.stringify(outfit_config)
  
  # Importiert ein Outfit aus einem exportierten Format
  func import_outfit_from_json(json_string):
  	var json = JSON.new()
  	var error = json.parse(json_string)
  	if error == OK:
  		return json.get_data()
  	else:
  		return null

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\controls\attack_button.gd:
========================================
  class_name AttackButton
  extends Button
  
  
  @onready var attack = $"."
  
  func _ready():
  	attack.modulate = Color(2, 2, 2, 0.5)
  
  
  func _on_button_up():
  	attack.modulate = Color(2, 2, 2, 0.5)
  	Input.action_release("attack")
  
  
  func _on_button_down():
  	attack.modulate = Color(1.0, 1.0, 1.0, 0.5)
  	Input.action_press("attack")

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\controls\defend_button.gd:
========================================
  class_name DefendButton
  extends Button
  
  
  @onready var defend = $"."
  
  func _ready():
  	defend.modulate = Color(2, 2, 2, 0.5)
  
  
  func _on_button_up():
  	defend.modulate = Color(2, 2, 2, 0.5)
  	Input.action_release("defend")
  
  func _on_button_down():
  	defend.modulate = Color(1.0, 1.0, 1.0, 0.5)
  	Input.action_press("defend")
  

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\dialogs\popup_dialog.gd:
========================================
  class_name PopupDialog
  extends CanvasLayer
  
  # Signal, wenn der primäre (rechte) Button gedrückt wird
  signal confirmed
  # Signal, wenn der sekundäre (linke) Button gedrückt wird
  signal canceled
  
  # UI-Elemente
  var dimmer
  var dialog_panel
  var title_label
  var message_label
  var button_container
  var cancel_button
  var confirm_button
  
  # Standardwerte
  var _title_text = "Bestätigung"
  var _message_text = "Möchtest du fortfahren?"
  var _cancel_text = "Abbrechen"
  var _confirm_text = "Bestätigen"
  var _confirm_color = Color(0.7, 0.2, 0.2, 1)  # Rot
  var _auto_hide = true
  
  func _init():
  	# Erstelle alle UI-Elemente programmatisch
  	_create_ui()
  
  func _ready():
  	# Bei Start nicht anzeigen
  	hide()
  
  	# Verbinde Button-Signale
  	cancel_button.pressed.connect(_on_cancel_pressed)
  	confirm_button.pressed.connect(_on_confirm_pressed)
  
  # Erstellt die komplette UI-Struktur
  func _create_ui():
  	# Dimmer (Hintergrund-Verdunkelung)
  	dimmer = ColorRect.new()
  	dimmer.name = "Dimmer"
  	dimmer.color = Color(0, 0, 0, 0.6)  # Halbtransparentes Schwarz
  	add_child(dimmer)
  
  	# DialogPanel
  	dialog_panel = Panel.new()
  	dialog_panel.name = "DialogPanel"
  
  	# Panel-Design
  	var panel_style = StyleBoxFlat.new()
  	panel_style.bg_color = Color(0.12, 0.12, 0.15, 1.0)
  	panel_style.border_width_left = 2
  	panel_style.border_width_top = 2
  	panel_style.border_width_right = 2
  	panel_style.border_width_bottom = 2
  	panel_style.border_color = Color(0.6, 0.6, 1.0, 0.7)
  	panel_style.corner_radius_top_left = 15
  	panel_style.corner_radius_top_right = 15
  	panel_style.corner_radius_bottom_left = 15
  	panel_style.corner_radius_bottom_right = 15
  	panel_style.shadow_color = Color(0, 0, 0, 0.3)
  	panel_style.shadow_size = 8
  	dialog_panel.add_theme_stylebox_override("panel", panel_style)
  	dimmer.add_child(dialog_panel)
  
  	# Titel
  	title_label = Label.new()
  	title_label.name = "Title"
  	title_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
  	title_label.add_theme_font_size_override("font_size", 24)
  	title_label.add_theme_color_override("font_color", Color(1, 1, 1, 1))
  	dialog_panel.add_child(title_label)
  
  	# Nachricht
  	message_label = Label.new()
  	message_label.name = "Message"
  	message_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
  	message_label.autowrap_mode = TextServer.AUTOWRAP_WORD_SMART
  	message_label.add_theme_font_size_override("font_size", 18)
  	message_label.add_theme_color_override("font_color", Color(0.9, 0.9, 0.9, 1))
  	dialog_panel.add_child(message_label)
  
  	# Buttons-Container
  	button_container = HBoxContainer.new()
  	button_container.name = "ButtonContainer"
  	button_container.alignment = BoxContainer.ALIGNMENT_CENTER
  	button_container.add_theme_constant_override("separation", 20)
  	dialog_panel.add_child(button_container)
  
  	# Button-Style vorbereiten
  	var button_style_normal = StyleBoxFlat.new()
  	button_style_normal.bg_color = Color(0.2, 0.2, 0.25, 1)
  	button_style_normal.border_width_left = 0
  	button_style_normal.border_width_top = 0
  	button_style_normal.border_width_right = 0
  	button_style_normal.border_width_bottom = 0
  	button_style_normal.corner_radius_top_left = 8
  	button_style_normal.corner_radius_top_right = 8
  	button_style_normal.corner_radius_bottom_left = 8
  	button_style_normal.corner_radius_bottom_right = 8
  
  	var button_style_hover = StyleBoxFlat.new()
  	button_style_hover.bg_color = Color(0.25, 0.25, 0.3, 1)
  	button_style_hover.border_width_left = 0
  	button_style_hover.border_width_top = 0
  	button_style_hover.border_width_right = 0
  	button_style_hover.border_width_bottom = 0
  	button_style_hover.corner_radius_top_left = 8
  	button_style_hover.corner_radius_top_right = 8
  	button_style_hover.corner_radius_bottom_left = 8
  	button_style_hover.corner_radius_bottom_right = 8
  
  	var button_style_pressed = StyleBoxFlat.new()
  	button_style_pressed.bg_color = Color(0.15, 0.15, 0.2, 1)
  	button_style_pressed.border_width_left = 0
  	button_style_pressed.border_width_top = 0
  	button_style_pressed.border_width_right = 0
  	button_style_pressed.border_width_bottom = 0
  	button_style_pressed.corner_radius_top_left = 8
  	button_style_pressed.corner_radius_top_right = 8
  	button_style_pressed.corner_radius_bottom_left = 8
  	button_style_pressed.corner_radius_bottom_right = 8
  
  	# Abbrechen-Button
  	cancel_button = Button.new()
  	cancel_button.name = "CancelButton"
  	cancel_button.add_theme_font_size_override("font_size", 18)
  	cancel_button.add_theme_stylebox_override("normal", button_style_normal.duplicate())
  	cancel_button.add_theme_stylebox_override("hover", button_style_hover.duplicate())
  	cancel_button.add_theme_stylebox_override("pressed", button_style_pressed.duplicate())
  	button_container.add_child(cancel_button)
  
  	# Bestätigen-Button
  	confirm_button = Button.new()
  	confirm_button.name = "ConfirmButton"
  	confirm_button.add_theme_font_size_override("font_size", 18)
  
  	# Rote Button-Stile
  	var confirm_style_normal = button_style_normal.duplicate()
  	confirm_style_normal.bg_color = Color(0.7, 0.2, 0.2, 1)
  	var confirm_style_hover = button_style_hover.duplicate()
  	confirm_style_hover.bg_color = Color(0.8, 0.3, 0.3, 1)
  	var confirm_style_pressed = button_style_pressed.duplicate()
  	confirm_style_pressed.bg_color = Color(0.6, 0.15, 0.15, 1)
  
  	confirm_button.add_theme_stylebox_override("normal", confirm_style_normal)
  	confirm_button.add_theme_stylebox_override("hover", confirm_style_hover)
  	confirm_button.add_theme_stylebox_override("pressed", confirm_style_pressed)
  	button_container.add_child(confirm_button)
  
  # Setzt Text-Inhalte und Farben
  func setup(title: String = "", message: String = "",
  		   cancel_text: String = "", confirm_text: String = "",
  		   confirm_button_color: Color = Color(0.7, 0.2, 0.2, 1)):
  
  	# Setze nur nicht-leere Werte
  	if title:
  		_title_text = title
  	if message:
  		_message_text = message
  	if cancel_text:
  		_cancel_text = cancel_text
  	if confirm_text:
  		_confirm_text = confirm_text
  
  	_confirm_color = confirm_button_color
  
  	return self  # Für Methoden-Verkettung
  
  # Einstellen, ob das Popup sich automatisch schließen soll
  func set_auto_hide(value: bool):
  	_auto_hide = value
  	return self  # Für Methoden-Verkettung
  
  # Zeigt den Dialog an
  func popup():
  	# Fenstergröße aktualisieren
  	var viewport_size = get_viewport().get_visible_rect().size
  	dimmer.size = viewport_size
  
  	var dialog_width = min(500, viewport_size.x * 0.8)
  	var dialog_height = 230
  	dialog_panel.size = Vector2(dialog_width, dialog_height)
  	dialog_panel.position = (viewport_size - dialog_panel.size) / 2
  	dialog_panel.pivot_offset = dialog_panel.size / 2
  
  	# Layout aktualisieren
  	title_label.position = Vector2(0, 20)
  	title_label.size = Vector2(dialog_width, 30)
  
  	message_label.position = Vector2(20, 60)
  	message_label.size = Vector2(dialog_width - 40, 60)
  
  	button_container.position = Vector2(20, dialog_height - 80)
  	button_container.size = Vector2(dialog_width - 40, 60)
  
  	cancel_button.custom_minimum_size = Vector2(dialog_width * 0.35, 60)
  	confirm_button.custom_minimum_size = Vector2(dialog_width * 0.35, 60)
  
  	# Aktualisiere UI
  	title_label.text = _title_text
  	message_label.text = _message_text
  	cancel_button.text = _cancel_text
  	confirm_button.text = _confirm_text
  
  	# Setze Button-Farbe
  	var normal_style = confirm_button.get_theme_stylebox("normal").duplicate()
  	var hover_style = confirm_button.get_theme_stylebox("hover").duplicate()
  	var pressed_style = confirm_button.get_theme_stylebox("pressed").duplicate()
  
  	normal_style.bg_color = _confirm_color
  	hover_style.bg_color = _confirm_color.lightened(0.1)
  	pressed_style.bg_color = _confirm_color.darkened(0.1)
  
  	confirm_button.add_theme_stylebox_override("normal", normal_style)
  	confirm_button.add_theme_stylebox_override("hover", hover_style)
  	confirm_button.add_theme_stylebox_override("pressed", pressed_style)
  
  	# Dialog anzeigen mit Animation
  	show()
  	dimmer.modulate = Color(1, 1, 1, 0)
  
  	var tween = create_tween()
  	tween.tween_property(dimmer, "modulate", Color(1, 1, 1, 1), 0.3).set_ease(Tween.EASE_OUT)
  
  	# Dialog-Panel Animation (Skalierung)
  	dialog_panel.scale = Vector2(0.9, 0.9)
  	tween.parallel().tween_property(dialog_panel, "scale", Vector2(1, 1), 0.3).set_ease(Tween.EASE_OUT)
  
  	return self  # Für Methoden-Verkettung
  
  # Schließt den Dialog
  func close():
  	var tween = create_tween()
  	tween.tween_property(dimmer, "modulate", Color(1, 1, 1, 0), 0.2).set_ease(Tween.EASE_IN)
  	tween.parallel().tween_property(dialog_panel, "scale", Vector2(0.9, 0.9), 0.2).set_ease(Tween.EASE_IN)
  
  	# Warte auf das Ende der Animation
  	await tween.finished
  	hide()
  
  # Button-Handling
  func _on_cancel_pressed():
  	emit_signal("canceled")
  	if _auto_hide:
  		close()
  
  func _on_confirm_pressed():
  	emit_signal("confirmed")
  	if _auto_hide:
  		close()

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\dialogs\popup_manager.gd:
========================================
  extends Node
  
  # Signal, dass ein zuvor erstellter Dialog bestätigt wurde
  signal dialog_confirmed(dialog_id: String)
  # Signal, dass ein zuvor erstellter Dialog abgebrochen wurde
  signal dialog_canceled(dialog_id: String)
  
  # Speichert alle aktiven Popups
  var _active_popups = {}
  
  # Zeigt eine einfache Bestätigungsabfrage
  func confirm(title: String, message: String,
  			 cancel_text: String = "Abbrechen", confirm_text: String = "Bestätigen",
  			 dialog_id: String = "") -> String:
  
  	# Generiere eine eindeutige ID, falls keine angegeben wurde
  	var id = dialog_id if dialog_id else _generate_id()
  
  	# Erstelle und zeige das Popup an
  	var popup = _create_popup()
  	popup.setup(title, message, cancel_text, confirm_text)
  
  	# Verbinde Signale, um weiterzuleiten
  	popup.confirmed.connect(func():
  		emit_signal("dialog_confirmed", id)
  		_active_popups.erase(id)
  	)
  	popup.canceled.connect(func():
  		emit_signal("dialog_canceled", id)
  		_active_popups.erase(id)
  	)
  
  	# Speichere das Popup für spätere Referenz
  	_active_popups[id] = popup
  
  	# Zeige das Popup an
  	popup.popup()
  
  	return id
  
  # Zeigt einen Warnungs-Dialog
  func warning(title: String, message: String, button_text: String = "OK") -> String:
  	var id = _generate_id()
  	var popup = _create_popup()
  
  	# Stelle Warnungs-Dialog ein
  	popup.setup(
  		title,
  		message,
  		"", # Kein Abbrechen-Button
  		button_text,
  		Color(0.9, 0.6, 0.1, 1) # Orange für Warnungen
  	)
  
  	# Verbinde Signale
  	popup.confirmed.connect(func():
  		emit_signal("dialog_confirmed", id)
  		_active_popups.erase(id)
  	)
  
  	# Verstecke den Abbrechen-Button
  	popup.cancel_button.visible = false
  
  	# Speichere und zeige an
  	_active_popups[id] = popup
  	popup.popup()
  
  	return id
  
  # Zeigt einen Fehler-Dialog
  func error(title: String, message: String, button_text: String = "OK") -> String:
  	var id = _generate_id()
  	var popup = _create_popup()
  
  	# Stelle Fehler-Dialog ein
  	popup.setup(
  		title,
  		message,
  		"", # Kein Abbrechen-Button
  		button_text,
  		Color(0.8, 0.1, 0.1, 1) # Rot für Fehler
  	)
  
  	# Verbinde Signale
  	popup.confirmed.connect(func():
  		emit_signal("dialog_confirmed", id)
  		_active_popups.erase(id)
  	)
  
  	# Verstecke den Abbrechen-Button
  	popup.cancel_button.visible = false
  
  	# Speichere und zeige an
  	_active_popups[id] = popup
  	popup.popup()
  
  	return id
  
  # Zeigt eine Info-Nachricht
  func info(title: String, message: String, button_text: String = "OK") -> String:
  	var id = _generate_id()
  	var popup = _create_popup()
  
  	# Stelle Info-Dialog ein
  	popup.setup(
  		title,
  		message,
  		"", # Kein Abbrechen-Button
  		button_text,
  		Color(0.2, 0.6, 0.8, 1) # Blau für Info
  	)
  
  	# Verbinde Signale
  	popup.confirmed.connect(func():
  		emit_signal("dialog_confirmed", id)
  		_active_popups.erase(id)
  	)
  
  	# Verstecke den Abbrechen-Button
  	popup.cancel_button.visible = false
  
  	# Speichere und zeige an
  	_active_popups[id] = popup
  	popup.popup()
  
  	return id
  
  # Schließt einen bestimmten Dialog
  func close_dialog(dialog_id: String) -> bool:
  	if _active_popups.has(dialog_id):
  		_active_popups[dialog_id].close()
  		_active_popups.erase(dialog_id)
  		return true
  	return false
  
  # Schließt alle aktiven Dialoge
  func close_all_dialogs():
  	for id in _active_popups:
  		_active_popups[id].close()
  	_active_popups.clear()
  
  # Erstellt eine neue Popup-Instanz
  func _create_popup():
  	var popup_script = load("res://scripts/ui/dialogs/popup_dialog.gd")
  	# Hier ist die Korrektur: Wir erstellen einen CanvasLayer statt eines Node
  	var popup_instance = CanvasLayer.new()
  	popup_instance.set_script(popup_script)
  	add_child(popup_instance)
  	return popup_instance
  
  # Generiert eine eindeutige ID für Dialoge
  func _generate_id() -> String:
  	return "dialog_" + str(randi())

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\hud\hud_controller.gd:
========================================
  class_name HudController
  extends CanvasLayer
  var coins = 0
  var max_lifes = 3
  var lifes = max_lifes
  var hud
  var initial_heart_position
  var inital_heart_size
  
  func _ready():
  	$HeartsFull.flip_h = true
  	$LabelCoinSum.text = str(coins)
  	initial_heart_position = $HeartsFull.position
  	inital_heart_size = $HeartsFull.size
  	$HeartsEmpty.position = initial_heart_position - Vector2(2*inital_heart_size.x, 0)
  	$HeartsEmpty.size = inital_heart_size + Vector2(2*inital_heart_size.x, 0)
  
  	load_hearts()
  
  func coin_collected():
  	coins = coins + 1
  	$LabelCoinSum.text = str(coins)
  
  
  func load_hearts():
  	$HeartsFull.size.x = lifes * inital_heart_size.x
  	$HeartsFull.position.x= initial_heart_position.x - ((lifes-1) * inital_heart_size.x)
  
  func change_life(amount):
  	if  lifes + amount < 0:
  		lifes = 0
  
  	elif  lifes + amount > 3:
  		lifes = 3
  	else:
  		lifes = lifes + amount
  	load_hearts()

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\main_menu\camera.gd:
========================================
  class_name Camera
  extends Camera2D
  
  
  # Called when the node enters the scene tree for the first time.
  func _ready():
  	pass # Replace with function body.
  
  
  # Called every frame. 'delta' is the elapsed time since the previous frame.
  func _process(delta):
  	pass

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\main_menu\customizer_button.gd:
========================================
  class_name CustomizerButton
  extends Button
  
  
  # Called when the node enters the scene tree for the first time.
  func _ready():
  	pass # Replace with function body.
  
  
  # Called every frame. 'delta' is the elapsed time since the previous frame.
  func _process(delta):
  	pass

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\main_menu\main_menu.gd:
========================================
  class_name MainMenu
  extends Node2D
  
  
  func _on_exit_button_pressed():
  	get_tree().quit()
  
  
  func _on_settings_button_pressed():
  	get_tree().change_scene_to_file("res://scenes/ui/settings/settings_menu.tscn")
  
  
  func _on_start_button_pressed():
  	get_tree().change_scene_to_file("res://scenes/levels/adventure_mode/base_level.tscn")

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\main_menu\menu_buttons.gd:
========================================
  class_name MenuButtons
  extends Button
  
  
  # Called when the node enters the scene tree for the first time.
  func _ready():
  	pass # Replace with function body.
  
  
  # Called every frame. 'delta' is the elapsed time since the previous frame.
  func _process(_delta):
  	pass

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\main_menu\start_background.gd:
========================================
  class_name StartBackground
  extends ParallaxBackground
  
  var scrolling_speed = 50
  # Called every frame. 'delta' is the elapsed time since the previous frame.
  func _process(delta):
  	scroll_offset.x -= scrolling_speed * delta

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\settings\audio_settings.gd:
========================================
  class_name AudioSettings
  extends Node2D
  
  
  # Called when the node enters the scene tree for the first time.
  func _ready():
  	pass # Replace with function body.
  
  
  # Called every frame. 'delta' is the elapsed time since the previous frame.
  func _process(delta):
  	pass
  
  
  func _on_back_button_pressed():
  	get_tree().change_scene_to_file("res://scenes/ui/settings/settings_menu.tscn")
  
  var master_bus = AudioServer.get_bus_index("Master")
  
  
  func _on_h_slider_value_changed(value):
  	AudioServer.set_bus_volume_db(master_bus, value)
  
  	if value == -30:
  		AudioServer.set_bus_mute(master_bus, true)
  	else:
  		AudioServer.set_bus_mute(master_bus, false)

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\ui\settings\settings_menu.gd:
========================================
  class_name SettingsMenu
  extends Node2D
  
  "res://scripts/ui/settings/settings_menu.gd"
  # Called when the node enters the scene tree for the first time.
  func _ready():
  	pass # Replace with function body.
  
  
  # Called every frame. 'delta' is the elapsed time since the previous frame.
  func _process(delta):
  	pass
  
  
  func _on_back_button_pressed():
  	get_tree().change_scene_to_file("res://scenes/ui/main_menu/main_menu.tscn")
  
  
  func _on_audio_button_pressed():
  	get_tree().change_scene_to_file("res://scenes/ui/settings/audio_settings.tscn")
  
  
  func _on_customizer_button_pressed():
  	get_tree().change_scene_to_file("res://scenes/ui/character_customizer/customizer.tscn")

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\utils\killzone.gd:
========================================
  class_name Killzone
  extends Area2D
  
  @onready var timer = $Timer
  
  func _on_body_entered(body):
  	print("you died!")
  	Engine.time_scale = 0.5
  	body.get_node("CollisionShape2D").queue_free()
  	timer.start()
  
  
  
  func _on_timer_timeout():
  	Engine.time_scale = 1.0
  	get_tree().reload_current_scene()

========================================
Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\state_machineproject_structure.txt:
========================================
... (truncated, 500 lines shown of 501 total) ...
  PROJECT STRUCTURE FOR: c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine
  ==================================================
  
  [DIR] enemy_states
    - enemy_idle_state.gd
  - get_structure.py
  - player.gd
  [DIR] player_states
    - player_attack_state.gd
    - player_base_state.gd
    - player_death_state.gd
    - player_fall_state.gd
    - player_fly_state.gd
    - player_hurt_state.gd
    - player_idle_state.gd
    - player_jump_state.gd
    - player_walk_state.gd
  - project_structure.txt
  - state.gd
  - state_machine.gd
  
  ========================================
  Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\enemy_states\enemy_idle_state.gd:
  ========================================
    class_name EnemyIdleState
    extends State
  
    ## Enemy idle state - when the enemy is standing still
  
    @export var idle_animation: String = "idle"
    @export var idle_min_time: float = 1.0
    @export var idle_max_time: float = 3.0
  
    var idle_timer: float = 0.0
    var idle_duration: float = 0.0
    var target = null
  
    func enter():
    	# Play idle animation
    	play_animation(idle_animation)
  
    	# Reset horizontal velocity
    	var velocity = get_velocity()
    	velocity.x = 0
    	set_velocity(velocity)
  
    	# Set random idle duration
    	idle_duration = randf_range(idle_min_time, idle_max_time)
    	idle_timer = 0.0
  
    func physics_process(delta: float):
    	# Apply gravity
    	var velocity = get_velocity()
    	var gravity = owner_node.get_gravity() if owner_node.has_method("get_gravity") else 980.0
  
    	velocity.y += gravity * delta
    	set_velocity(velocity)
  
    	# Handle movement for character body
    	if owner_node.has_method("move_and_slide"):
    		owner_node.move_and_slide()
  
    	# Update idle timer
    	idle_timer += delta
  
    func get_next_state() -> String:
    	# Check if there's a player in detection range
    	target = get_owner_property("target")
    	if target != null:
    		return "Chase"
  
    	# Check if idle time has elapsed - transition to patrol
    	if idle_timer >= idle_duration:
    		return "Patrol"
  
    	# No transition, stay in idle
    	return ""
  
    # Used by enemies to find nearby player
    func check_for_player():
    	var detection_radius = get_owner_property("detection_radius")
    	if not detection_radius:
    		return null
  
    	var space_state = owner_node.get_world_2d().direct_space_state
    	var player_detection_shape = CircleShape2D.new()
    	player_detection_shape.radius = detection_radius
  
    	var query = PhysicsShapeQueryParameters2D.new()
    	query.set_shape(player_detection_shape)
    	query.transform = Transform2D(0, owner_node.global_position)
    	query.collision_mask = 1  # Player layer
  
    	var results = space_state.intersect_shape(query)
  
    	for result in results:
    		var collider = result.collider
    		if collider.name == "Player":
    			return collider
  
    	return null
  
  ========================================
  Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\player.gd:
  ========================================
    class_name Player
    extends CharacterBody2D
  
    @export var joystick_right: VirtualJoystick
  
    # envrionment variables
    var SPEED
    var JUMP_VELOCITY
    var FLY_VELOCITY
    var GRAVITY
  
    # character mode variables
    var mode
    var passed_fly_time
    var jump_counter
    var ready_for_jump
    var allowed_jumps
  
    # character health
    var hud
  
    #character design variables
    var player_animations
    var current_animation
    var player_outfit
    var play_attack_animation
    var attack_animation
  
    var config = ConfigFile.new() # Create a new ConfigFile instance
  
    func _ready() -> void:
    	# Initialize your global variables here
    	hud = get_node("../../HUD")
    	SPEED = 200.0
    	JUMP_VELOCITY = -250.0
    	FLY_VELOCITY = -150.0
    	GRAVITY = 300
    	mode = "normal"
    	passed_fly_time = 0.0
    	jump_counter = 0
    	ready_for_jump = true
    	player_animations = get_node("character_sprites").animation_frames
    	current_animation = "idle"
    	allowed_jumps = 1
    	play_attack_animation = false
    	attack_animation = "idle"
  
    	var default_player_outfit = get_node("character_sprites").default_outfit
    	get_node("character_sprites/masks").visible = false
    	player_outfit = default_player_outfit
  
    	# Load the ConfigFile if it exists
    	var err = config.load("user://settings.cfg")
    	if err == OK: # If the ConfigFile loaded successfully
    		# Get the values from the ConfigFile
    		SPEED = config.get_value("settings", "SPEED", 200.0)
    		JUMP_VELOCITY = config.get_value("settings", "JUMP_VELOCITY", -250.0)
    		FLY_VELOCITY = config.get_value("settings", "FLY_VELOCITY", -150.0)
    		GRAVITY = config.get_value("settings", "GRAVITY", 500)
    		# mode = config.get_value("settings", "mode", "normal")
    		passed_fly_time = config.get_value("settings", "passed_fly_time", 0.0)
    		jump_counter = config.get_value("settings", "jump_counter", 0)
    		ready_for_jump = config.get_value("settings", "ready_for_jump", true)
    		#allowed_jumps = config.get_value("settings", "allowed_jumps", 1)
    		player_outfit = config.get_value("settings", "outfit", default_player_outfit)
    		# TO-DO: load dict wheaether category is visible or not
  
    func save_settings():
    	# Set the values in the ConfigFile
    	config.set_value("settings", "SPEED", SPEED)
    	config.set_value("settings", "JUMP_VELOCITY", JUMP_VELOCITY)
    	config.set_value("settings", "FLY_VELOCITY", FLY_VELOCITY)
    	config.set_value("settings", "GRAVITY", GRAVITY)
    	config.set_value("settings", "mode", mode)
    	config.set_value("settings", "passed_fly_time", passed_fly_time)
    	config.set_value("settings", "jump_counter", jump_counter)
    	config.set_value("settings", "ready_for_jump", ready_for_jump)
    	config.set_value("settings", "allowed_jumps", allowed_jumps)
    	config.set_value("settings", "outfit", player_outfit, )
  
    	# Save the ConfigFile to the disk
    	config.save("user://settings.cfg")
  
    func _process(delta):
    	# Add the gravity.
    	Engine.physics_ticks_per_second = 240
    	# In case of Death
    	if hud.lifes == 0:
    		death()
    	# Read the joystick input
    	var x_input = Input.get_axis("left", "right")
    	var y_input = Input.get_axis("down", "up")
    	if Input.is_action_just_pressed("attack"):
    		print("attack")
    		play_attack_animation = true
    	if Input.is_action_just_pressed("defend"):
    		print("defend")
    	if Input.is_action_just_pressed("Menu"):
    		get_tree().change_scene_to_file("res://scenes/ui/main_menu/main_menu.tscn")
    	# All Modes.
    	velocity.y += GRAVITY * delta
  
    	if x_input != 0:
    		velocity.x = x_input * SPEED
    	else:
    		velocity.x = move_toward(velocity.x, 0, 30)
  
    	if is_on_floor():
    		jump_counter = 0
    		ready_for_jump = true
    		passed_fly_time = 0.0
  
    	elif jump_counter == 0	:
    		ready_for_jump = false
  
    	if y_input > 0.4 && jump_counter < allowed_jumps:
    		if ready_for_jump:
    			velocity.y = JUMP_VELOCITY * y_input
    			jump_counter += 1
    			ready_for_jump = false
    	elif y_input < 0.4:
    		ready_for_jump = true
  
  
    	# Fly mode
    	if mode == "fly":
    		allowed_jumps = 1
    		if passed_fly_time < 4:
    				passed_fly_time += delta
    				if y_input != 0:
    					velocity.y = FLY_VELOCITY * y_input
  
    	move_and_slide()
  
    	# Set Animation
    	if x_input == 0 && y_input == 0 && current_animation != "dead":
    		current_animation = "idle"
    	elif x_input != 0 && y_input <= 0.4:
    		current_animation = "walking"
    	elif y_input > 0.4 or y_input < - 0.4:
    		current_animation = "idle"
  
    	if play_attack_animation:
    		current_animation = attack_animation
  
  
    	# Set Outfit
    	for outfit in player_outfit:
    		var animated_sprite = get_node("character_sprites/"+ outfit)
    		var selected_outfit = player_outfit[outfit]
  
    		if str(selected_outfit) == "none":
    			animated_sprite.visible = false
    		else:
    			animated_sprite.play(str(selected_outfit))
    			animated_sprite.speed_scale = 2.0
    			animated_sprite.flip_h = x_input > 0
    			if animated_sprite.frame >= player_animations[current_animation][-1]:
    				play_attack_animation = false
  
    			if (animated_sprite.frame < player_animations[current_animation][0] or
    				animated_sprite.frame >= player_animations[current_animation][ - 1]):
    					animated_sprite.frame = player_animations[current_animation][0]
  
    func _on_test_portal_entered(_body):
    	get_tree().change_scene_to_file("res://scenes/ui/main_menu/main_menu.tscn")
    	mode = "fly"
    	save_settings()
  
    func _on_elias_portal_entered(_body):
    	print("Elias")
    	save_settings() # Replace with function body.
  
    func _on_ardit_portal_entered(_body):
    	get_tree().change_scene_to_file("res://Arrogance.tscn")
    	save_settings() # Replace with function body.
  
    func _on_sebastian_portal_entered(_body):
    	mode = "normal"
    	get_tree().change_scene_to_file("res://scenes/levels/sebastian_levels/level_1.tscn")
    	save_settings() # Replace with function body.
  
    func _on_prince_portal_entered(_body):
    	get_tree().change_scene_to_file("res://scenes/levels/prince_levels/platform.tscn")
    	save_settings()
  
    		#current_animation = "dead"
    		#current_animation = "hurt"
  
    func _on_fallzone_body_entered(_body):
    	get_tree().change_scene_to_file("res://scenes/levels/ardit_levels/arrogance.tscn")
  
    func _on_life_up_body_entered(_body):
    	get_parent().get_node("HUD").change_life(0.25)
  
    func _on_life_down_body_entered(_body):
    		get_parent().get_node("HUD").change_life(-0.25)
  
    func death():
    	$CollisionShape2D.disabled = true
    	current_animation = "death"
    	self.queue_free()
    	get_tree().change_scene_to_file("res://scenes/ui/main_menu/main_menu.tscn")
  
  
  
    func _on_test_portal_body_entered(_body):
    	get_tree().change_scene_to_file("res://scenes/levels/adventure_mode/adventure_level.tscn")
  
  ========================================
  Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\player_states\player_attack_state.gd:
  ========================================
    class_name PlayerAttackState
    extends PlayerBaseState
  
  ========================================
  Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\player_states\player_base_state.gd:
  ========================================
    class_name PlayerBaseState
    extends State
  
    # Grundfunktionen, die alle Player-States gemeinsam haben
  
    var player: Player
  
    func _ready():
    	# Setze Player-Referenz beim Initialisieren
    	player = owner_node as Player
  
    # Grundfunktion zum Aktualisieren des Outfits basierend auf dem aktuellen Zustand
    func update_outfit():
    	var player_outfit = player.player_outfit
    	var player_animations = player.player_animations
    	var current_animation = player.current_animation
  
    	for outfit in player_outfit:
    		var animated_sprite = player.get_node("character_sprites/" + outfit)
    		var selected_outfit = player_outfit[outfit]
  
    		if str(selected_outfit) == "none":
    			animated_sprite.visible = false
    		else:
    			animated_sprite.visible = true
    			animated_sprite.play(str(selected_outfit))
    			animated_sprite.speed_scale = 2.0
  
    			# Setze Richtung basierend auf Bewegungsrichtung
    			var x_input = Input.get_axis("left", "right")
    			if x_input != 0:
    				animated_sprite.flip_h = x_input > 0
  
    			# Frame-Management
    			if current_animation in player_animations:
    				if animated_sprite.frame < player_animations[current_animation][0] or animated_sprite.frame >= player_animations[current_animation][-1]:
    					animated_sprite.frame = player_animations[current_animation][0]
  
    # Hilfsfunktion zum Prüfen der Lebensanzeige und Tod
    func check_life():
    	if player.hud and player.hud.lifes == 0:
    		return "Death"
    	return ""
  
    # Hilfsfunktion zur Überprüfung von Menü-Input
    func check_menu_input(event):
    	if event is InputEvent and event.is_action_pressed("Menu"):
    		get_tree().change_scene_to_file("res://scenes/ui/main_menu/main_menu.tscn")
    		if player.has_method("save_settings"):
    			player.save_settings()
  
  ========================================
  Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\player_states\player_death_state.gd:
  ========================================
    class_name PlayerDeathState
    extends PlayerBaseState
  
  ========================================
  Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\player_states\player_fall_state.gd:
  ========================================
    class_name PlayerFallState
    extends PlayerBaseState
  
  ========================================
  Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\player_states\player_fly_state.gd:
  ========================================
    class_name PlayerFlyState
    extends PlayerBaseState
  
  ========================================
  Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\player_states\player_hurt_state.gd:
  ========================================
    class_name PlayerHurtState
    extends PlayerBaseState
  
  ========================================
  Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\player_states\player_idle_state.gd:
  ========================================
    class_name PlayerIdleState
    extends PlayerBaseState
  
  ========================================
  Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\player_states\player_jump_state.gd:
  ========================================
    class_name PlayerIdleState
    extends PlayerBaseState
  
  
  ========================================
  Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\player_states\player_walk_state.gd:
  ========================================
    class_name PlayerWalkState
    extends PlayerBaseState
  
  
  ========================================
  Contents of c:\Users\Stidium\Downloads\Studienarbeit\Godot\The-Little-Saint\scripts\core\state_machine\state.gd:
  ========================================
    class_name State
    extends Node
  
    ## Base class for all states in a state machine
  
    # Reference to the state machine
    var state_machine: StateMachine = null
  
    # Reference to the owner node
    var owner_node: Node = null
  
    # State parameters (can be extended by child classes)
    var parameters: Dictionary = {}
  
  
    # Called when entering this state
    func enter():
    	pass
  
    # Called when exiting this state
    func exit():
    	pass
  
    # Called during _process
    func process(delta: float):
    	pass
  
    # Called during _physics_process
    func physics_process(delta: float):
    	pass
  
    # Called during _input
    func handle_input(event: InputEvent):
    	pass
  
    # Override this to determine the next state to transition to
    func get_next_state() -> String:
    	return ""
  
    # Utility functions that can be used by derived states
  
    # Check if a condition is true
    func condition_met(condition_name: String) -> bool:
    	if owner_node.has_method("check_condition"):
    		return owner_node.check_condition(condition_name)
    	return false
  
    # Get a value from the owner
    func get_owner_property(property_name: String):
    	if owner_node and property_name in owner_node:
    		return owner_node.get(property_name)
    	return null
  
    # Set a value on the owner
    func set_owner_property(property_name: String, value):
    	if owner_node and property_name in owner_node:
    		owner_node.set(property_name, value)
  
    # Helper to check if owner is on floor (for platformers)
    func is_on_floor() -> bool:
    	if owner_node.has_method("is_on_floor"):
    		return owner_node.is_on_floor()
    	return false
  
    # Helper to get owner velocity (for physics bodies)
    func get_velocity() -> Vector2:
    	if "velocity" in owner_node:
    		return owner_node.velocity
    	return Vector2.ZERO
  
    # Helper to set owner velocity (for physics bodies)
    func set_velocity(value: Vector2):
    	if "velocity" in owner_node:
    		owner_node.velocity = value
  
    # Helper to play animations
    func play_animation(anim_name: String):
    	if owner_node.has_method("play_animation"):
    		owner_node.play_animation(anim_name)
